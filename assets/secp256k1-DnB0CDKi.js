import{au as nt,av as qt,aw as ht,ax as Kt,ay as D,az as we,aA as Mt,aB as ge,aC as ye,aD as Ut,aE as me,aF as zt,aG as be}from"./index-DAU8mbYm.js";/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Nt=BigInt(0),xt=BigInt(1);function wt(n,e=""){if(typeof n!="boolean"){const r=e&&`"${e}"`;throw new Error(r+"expected boolean, got type="+typeof n)}return n}function W(n,e,r=""){const t=qt(n),o=n?.length,s=e!==void 0;if(!t||s&&o!==e){const i=r&&`"${r}" `,u=s?` of length ${e}`:"",l=t?`length=${o}`:`type=${typeof n}`;throw new Error(i+"expected Uint8Array"+u+", got "+l)}return n}function lt(n){const e=n.toString(16);return e.length&1?"0"+e:e}function Xt(n){if(typeof n!="string")throw new Error("hex string expected, got "+typeof n);return n===""?Nt:BigInt("0x"+n)}function yt(n){return Xt(nt(n))}function Dt(n){return Kt(n),Xt(nt(Uint8Array.from(n).reverse()))}function At(n,e){return ht(n.toString(16).padStart(e*2,"0"))}function Gt(n,e){return At(n,e).reverse()}function j(n,e,r){let t;if(typeof e=="string")try{t=ht(e)}catch(o){throw new Error(n+" must be hex string or Uint8Array, cause: "+o)}else if(qt(e))t=Uint8Array.from(e);else throw new Error(n+" must be hex string or Uint8Array");return t.length,t}const mt=n=>typeof n=="bigint"&&Nt<=n;function pe(n,e,r){return mt(n)&&mt(e)&&mt(r)&&e<=n&&n<r}function Ee(n,e,r,t){if(!pe(e,r,t))throw new Error("expected valid "+n+": "+r+" <= n < "+t+", got "+e)}function Ft(n){let e;for(e=0;n>Nt;n>>=xt,e+=1);return e}const it=n=>(xt<<BigInt(n))-xt;function Be(n,e,r){if(typeof n!="number"||n<2)throw new Error("hashLen must be a number");if(typeof e!="number"||e<2)throw new Error("qByteLen must be a number");if(typeof r!="function")throw new Error("hmacFn must be a function");const t=h=>new Uint8Array(h),o=h=>Uint8Array.of(h);let s=t(n),i=t(n),u=0;const l=()=>{s.fill(1),i.fill(0),u=0},w=(...h)=>r(i,s,...h),m=(h=t(0))=>{i=w(o(0),h),s=w(),h.length!==0&&(i=w(o(1),h),s=w())},I=()=>{if(u++>=1e3)throw new Error("drbg: tried 1000 values");let h=0;const p=[];for(;h<e;){s=w();const x=s.slice();p.push(x),h+=s.length}return D(...p)};return(h,p)=>{l(),m(h);let x;for(;!(x=p(I()));)m();return l(),x}}function Ot(n,e,r={}){if(!n||typeof n!="object")throw new Error("expected valid options object");function t(o,s,i){const u=n[o];if(i&&u===void 0)return;const l=typeof u;if(l!==s||u===null)throw new Error(`param "${o}" is invalid: expected ${s}, got ${l}`)}Object.entries(e).forEach(([o,s])=>t(o,s,!1)),Object.entries(r).forEach(([o,s])=>t(o,s,!0))}function Lt(n){const e=new WeakMap;return(r,...t)=>{const o=e.get(r);if(o!==void 0)return o;const s=n(r,...t);return e.set(r,s),s}}class Wt extends we{constructor(e,r){super(),this.finished=!1,this.destroyed=!1,Mt(e);const t=ge(r);if(this.iHash=e.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const o=this.blockLen,s=new Uint8Array(o);s.set(t.length>o?e.create().update(t).digest():t);for(let i=0;i<s.length;i++)s[i]^=54;this.iHash.update(s),this.oHash=e.create();for(let i=0;i<s.length;i++)s[i]^=106;this.oHash.update(s),ye(s)}update(e){return Ut(this),this.iHash.update(e),this}digestInto(e){Ut(this),Kt(e,this.outputLen),this.finished=!0,this.iHash.digestInto(e),this.oHash.update(e),this.oHash.digestInto(e),this.destroy()}digest(){const e=new Uint8Array(this.oHash.outputLen);return this.digestInto(e),e}_cloneInto(e){e||(e=Object.create(Object.getPrototypeOf(this),{}));const{oHash:r,iHash:t,finished:o,destroyed:s,blockLen:i,outputLen:u}=this;return e=e,e.finished=o,e.destroyed=s,e.blockLen=i,e.outputLen=u,e.oHash=r._cloneInto(e.oHash),e.iHash=t._cloneInto(e.iHash),e}clone(){return this._cloneInto()}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const Pt=(n,e,r)=>new Wt(n,e).update(r).digest();Pt.create=(n,e)=>new Wt(n,e);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Y=BigInt(0),k=BigInt(1),P=BigInt(2),Qt=BigInt(3),Jt=BigInt(4),te=BigInt(5),ve=BigInt(7),ee=BigInt(8),xe=BigInt(9),ne=BigInt(16);function K(n,e){const r=n%e;return r>=Y?r:e+r}function C(n,e,r){let t=n;for(;e-- >Y;)t*=t,t%=r;return t}function Tt(n,e){if(n===Y)throw new Error("invert: expected non-zero number");if(e<=Y)throw new Error("invert: expected positive modulus, got "+e);let r=K(n,e),t=e,o=Y,s=k;for(;r!==Y;){const u=t/r,l=t%r,w=o-s*u;t=r,r=l,o=s,s=w}if(t!==k)throw new Error("invert: does not exist");return K(o,e)}function _t(n,e,r){if(!n.eql(n.sqr(e),r))throw new Error("Cannot find square root")}function re(n,e){const r=(n.ORDER+k)/Jt,t=n.pow(e,r);return _t(n,t,e),t}function Se(n,e){const r=(n.ORDER-te)/ee,t=n.mul(e,P),o=n.pow(t,r),s=n.mul(e,o),i=n.mul(n.mul(s,P),o),u=n.mul(s,n.sub(i,n.ONE));return _t(n,u,e),u}function Ie(n){const e=ct(n),r=oe(n),t=r(e,e.neg(e.ONE)),o=r(e,t),s=r(e,e.neg(t)),i=(n+ve)/ne;return(u,l)=>{let w=u.pow(l,i),m=u.mul(w,t);const I=u.mul(w,o),f=u.mul(w,s),h=u.eql(u.sqr(m),l),p=u.eql(u.sqr(I),l);w=u.cmov(w,m,h),m=u.cmov(f,I,p);const x=u.eql(u.sqr(m),l),O=u.cmov(w,m,x);return _t(u,O,l),O}}function oe(n){if(n<Qt)throw new Error("sqrt is not defined for small field");let e=n-k,r=0;for(;e%P===Y;)e/=P,r++;let t=P;const o=ct(n);for(;Vt(o,t)===1;)if(t++>1e3)throw new Error("Cannot find square root: probably non-prime P");if(r===1)return re;let s=o.pow(t,e);const i=(e+k)/P;return function(l,w){if(l.is0(w))return w;if(Vt(l,w)!==1)throw new Error("Cannot find square root");let m=r,I=l.mul(l.ONE,s),f=l.pow(w,e),h=l.pow(w,i);for(;!l.eql(f,l.ONE);){if(l.is0(f))return l.ZERO;let p=1,x=l.sqr(f);for(;!l.eql(x,l.ONE);)if(p++,x=l.sqr(x),p===m)throw new Error("Cannot find square root");const O=k<<BigInt(m-p-1),H=l.pow(I,O);m=p,I=l.sqr(H),f=l.mul(f,I),h=l.mul(h,H)}return h}}function qe(n){return n%Jt===Qt?re:n%ee===te?Se:n%ne===xe?Ie(n):oe(n)}const Ne=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function Ae(n){const e={ORDER:"bigint",MASK:"bigint",BYTES:"number",BITS:"number"},r=Ne.reduce((t,o)=>(t[o]="function",t),e);return Ot(n,r),n}function Oe(n,e,r){if(r<Y)throw new Error("invalid exponent, negatives unsupported");if(r===Y)return n.ONE;if(r===k)return e;let t=n.ONE,o=e;for(;r>Y;)r&k&&(t=n.mul(t,o)),o=n.sqr(o),r>>=k;return t}function se(n,e,r=!1){const t=new Array(e.length).fill(r?n.ZERO:void 0),o=e.reduce((i,u,l)=>n.is0(u)?i:(t[l]=i,n.mul(i,u)),n.ONE),s=n.inv(o);return e.reduceRight((i,u,l)=>n.is0(u)?i:(t[l]=n.mul(i,t[l]),n.mul(i,u)),s),t}function Vt(n,e){const r=(n.ORDER-k)/P,t=n.pow(e,r),o=n.eql(t,n.ONE),s=n.eql(t,n.ZERO),i=n.eql(t,n.neg(n.ONE));if(!o&&!s&&!i)throw new Error("invalid Legendre symbol result");return o?1:s?0:-1}function ie(n,e){e!==void 0&&me(e);const r=e!==void 0?e:n.toString(2).length,t=Math.ceil(r/8);return{nBitLength:r,nByteLength:t}}function ct(n,e,r=!1,t={}){if(n<=Y)throw new Error("invalid field: expected ORDER > 0, got "+n);let o,s,i=!1,u;if(typeof e=="object"&&e!=null){if(t.sqrt||r)throw new Error("cannot specify opts in two arguments");const f=e;f.BITS&&(o=f.BITS),f.sqrt&&(s=f.sqrt),typeof f.isLE=="boolean"&&(r=f.isLE),typeof f.modFromBytes=="boolean"&&(i=f.modFromBytes),u=f.allowedLengths}else typeof e=="number"&&(o=e),t.sqrt&&(s=t.sqrt);const{nBitLength:l,nByteLength:w}=ie(n,o);if(w>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");let m;const I=Object.freeze({ORDER:n,isLE:r,BITS:l,BYTES:w,MASK:it(l),ZERO:Y,ONE:k,allowedLengths:u,create:f=>K(f,n),isValid:f=>{if(typeof f!="bigint")throw new Error("invalid field element: expected bigint, got "+typeof f);return Y<=f&&f<n},is0:f=>f===Y,isValidNot0:f=>!I.is0(f)&&I.isValid(f),isOdd:f=>(f&k)===k,neg:f=>K(-f,n),eql:(f,h)=>f===h,sqr:f=>K(f*f,n),add:(f,h)=>K(f+h,n),sub:(f,h)=>K(f-h,n),mul:(f,h)=>K(f*h,n),pow:(f,h)=>Oe(I,f,h),div:(f,h)=>K(f*Tt(h,n),n),sqrN:f=>f*f,addN:(f,h)=>f+h,subN:(f,h)=>f-h,mulN:(f,h)=>f*h,inv:f=>Tt(f,n),sqrt:s||(f=>(m||(m=qe(n)),m(I,f))),toBytes:f=>r?Gt(f,w):At(f,w),fromBytes:(f,h=!0)=>{if(u){if(!u.includes(f.length)||f.length>w)throw new Error("Field.fromBytes: expected "+u+" bytes, got "+f.length);const x=new Uint8Array(w);x.set(f,r?0:x.length-f.length),f=x}if(f.length!==w)throw new Error("Field.fromBytes: expected "+w+" bytes, got "+f.length);let p=r?Dt(f):yt(f);if(i&&(p=K(p,n)),!h&&!I.isValid(p))throw new Error("invalid field element: outside of range 0..ORDER");return p},invertBatch:f=>se(I,f),cmov:(f,h,p)=>p?h:f});return Object.freeze(I)}function ce(n){if(typeof n!="bigint")throw new Error("field order must be bigint");const e=n.toString(2).length;return Math.ceil(e/8)}function fe(n){const e=ce(n);return e+Math.ceil(e/2)}function _e(n,e,r=!1){const t=n.length,o=ce(e),s=fe(e);if(t<16||t<s||t>1024)throw new Error("expected "+s+"-1024 bytes of input, got "+t);const i=r?Dt(n):yt(n),u=K(i,e-k)+k;return r?Gt(u,o):At(u,o)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const ot=BigInt(0),Q=BigInt(1);function gt(n,e){const r=e.negate();return n?r:e}function bt(n,e){const r=se(n.Fp,e.map(t=>t.Z));return e.map((t,o)=>n.fromAffine(t.toAffine(r[o])))}function ae(n,e){if(!Number.isSafeInteger(n)||n<=0||n>e)throw new Error("invalid window size, expected [1.."+e+"], got W="+n)}function pt(n,e){ae(n,e);const r=Math.ceil(e/n)+1,t=2**(n-1),o=2**n,s=it(n),i=BigInt(n);return{windows:r,windowSize:t,mask:s,maxNumber:o,shiftBy:i}}function kt(n,e,r){const{windowSize:t,mask:o,maxNumber:s,shiftBy:i}=r;let u=Number(n&o),l=n>>i;u>t&&(u-=s,l+=Q);const w=e*t,m=w+Math.abs(u)-1,I=u===0,f=u<0,h=e%2!==0;return{nextN:l,offset:m,isZero:I,isNeg:f,isNegF:h,offsetF:w}}function Re(n,e){if(!Array.isArray(n))throw new Error("array expected");n.forEach((r,t)=>{if(!(r instanceof e))throw new Error("invalid point at index "+t)})}function Ze(n,e){if(!Array.isArray(n))throw new Error("array of scalars expected");n.forEach((r,t)=>{if(!e.isValid(r))throw new Error("invalid scalar at index "+t)})}const Et=new WeakMap,ue=new WeakMap;function Bt(n){return ue.get(n)||1}function $t(n){if(n!==ot)throw new Error("invalid wNAF")}class He{constructor(e,r){this.BASE=e.BASE,this.ZERO=e.ZERO,this.Fn=e.Fn,this.bits=r}_unsafeLadder(e,r,t=this.ZERO){let o=e;for(;r>ot;)r&Q&&(t=t.add(o)),o=o.double(),r>>=Q;return t}precomputeWindow(e,r){const{windows:t,windowSize:o}=pt(r,this.bits),s=[];let i=e,u=i;for(let l=0;l<t;l++){u=i,s.push(u);for(let w=1;w<o;w++)u=u.add(i),s.push(u);i=u.double()}return s}wNAF(e,r,t){if(!this.Fn.isValid(t))throw new Error("invalid scalar");let o=this.ZERO,s=this.BASE;const i=pt(e,this.bits);for(let u=0;u<i.windows;u++){const{nextN:l,offset:w,isZero:m,isNeg:I,isNegF:f,offsetF:h}=kt(t,u,i);t=l,m?s=s.add(gt(f,r[h])):o=o.add(gt(I,r[w]))}return $t(t),{p:o,f:s}}wNAFUnsafe(e,r,t,o=this.ZERO){const s=pt(e,this.bits);for(let i=0;i<s.windows&&t!==ot;i++){const{nextN:u,offset:l,isZero:w,isNeg:m}=kt(t,i,s);if(t=u,!w){const I=r[l];o=o.add(m?I.negate():I)}}return $t(t),o}getPrecomputes(e,r,t){let o=Et.get(r);return o||(o=this.precomputeWindow(r,e),e!==1&&(typeof t=="function"&&(o=t(o)),Et.set(r,o))),o}cached(e,r,t){const o=Bt(e);return this.wNAF(o,this.getPrecomputes(o,e,t),r)}unsafe(e,r,t,o){const s=Bt(e);return s===1?this._unsafeLadder(e,r,o):this.wNAFUnsafe(s,this.getPrecomputes(s,e,t),r,o)}createCache(e,r){ae(r,this.bits),ue.set(e,r),Et.delete(e)}hasCache(e){return Bt(e)!==1}}function Ue(n,e,r,t){let o=e,s=n.ZERO,i=n.ZERO;for(;r>ot||t>ot;)r&Q&&(s=s.add(o)),t&Q&&(i=i.add(o)),o=o.double(),r>>=Q,t>>=Q;return{p1:s,p2:i}}function Le(n,e,r,t){Re(r,n),Ze(t,e);const o=r.length,s=t.length;if(o!==s)throw new Error("arrays of points and scalars must have equal length");const i=n.ZERO,u=Ft(BigInt(o));let l=1;u>12?l=u-3:u>4?l=u-2:u>0&&(l=2);const w=it(l),m=new Array(Number(w)+1).fill(i),I=Math.floor((e.BITS-1)/l)*l;let f=i;for(let h=I;h>=0;h-=l){m.fill(i);for(let x=0;x<s;x++){const O=t[x],H=Number(O>>BigInt(h)&w);m[H]=m[H].add(r[x])}let p=i;for(let x=m.length-1,O=i;x>0;x--)O=O.add(m[x]),p=p.add(O);if(f=f.add(p),h!==0)for(let x=0;x<l;x++)f=f.double()}return f}function jt(n,e,r){if(e){if(e.ORDER!==n)throw new Error("Field.ORDER must match order: Fp == p, Fn == n");return Ae(e),e}else return ct(n,{isLE:r})}function Te(n,e,r={},t){if(t===void 0&&(t=n==="edwards"),!e||typeof e!="object")throw new Error(`expected valid ${n} CURVE object`);for(const l of["p","n","h"]){const w=e[l];if(!(typeof w=="bigint"&&w>ot))throw new Error(`CURVE.${l} must be positive bigint`)}const o=jt(e.p,r.Fp,t),s=jt(e.n,r.Fn,t),u=["Gx","Gy","a","b"];for(const l of u)if(!o.isValid(e[l]))throw new Error(`CURVE.${l} must be valid field element of CURVE.Fp`);return e=Object.freeze(Object.assign({},e)),{CURVE:e,Fp:o,Fn:s}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Yt=(n,e)=>(n+(n>=0?e:-e)/le)/e;function Ve(n,e,r){const[[t,o],[s,i]]=e,u=Yt(i*n,r),l=Yt(-o*n,r);let w=n-u*t-l*s,m=-u*o-l*i;const I=w<z,f=m<z;I&&(w=-w),f&&(m=-m);const h=it(Math.ceil(Ft(r)/2))+rt;if(w<z||w>=h||m<z||m>=h)throw new Error("splitScalar (endomorphism): failed, k="+n);return{k1neg:I,k1:w,k2neg:f,k2:m}}function St(n){if(!["compact","recovered","der"].includes(n))throw new Error('Signature format must be "compact", "recovered", or "der"');return n}function vt(n,e){const r={};for(let t of Object.keys(e))r[t]=n[t]===void 0?e[t]:n[t];return wt(r.lowS,"lowS"),wt(r.prehash,"prehash"),r.format!==void 0&&St(r.format),r}class ke extends Error{constructor(e=""){super(e)}}const M={Err:ke,_tlv:{encode:(n,e)=>{const{Err:r}=M;if(n<0||n>256)throw new r("tlv.encode: wrong tag");if(e.length&1)throw new r("tlv.encode: unpadded data");const t=e.length/2,o=lt(t);if(o.length/2&128)throw new r("tlv.encode: long form length too big");const s=t>127?lt(o.length/2|128):"";return lt(n)+s+o+e},decode(n,e){const{Err:r}=M;let t=0;if(n<0||n>256)throw new r("tlv.encode: wrong tag");if(e.length<2||e[t++]!==n)throw new r("tlv.decode: wrong tlv");const o=e[t++],s=!!(o&128);let i=0;if(!s)i=o;else{const l=o&127;if(!l)throw new r("tlv.decode(long): indefinite length not supported");if(l>4)throw new r("tlv.decode(long): byte length is too big");const w=e.subarray(t,t+l);if(w.length!==l)throw new r("tlv.decode: length bytes not complete");if(w[0]===0)throw new r("tlv.decode(long): zero leftmost byte");for(const m of w)i=i<<8|m;if(t+=l,i<128)throw new r("tlv.decode(long): not minimal encoding")}const u=e.subarray(t,t+i);if(u.length!==i)throw new r("tlv.decode: wrong value length");return{v:u,l:e.subarray(t+i)}}},_int:{encode(n){const{Err:e}=M;if(n<z)throw new e("integer: negative integers are not allowed");let r=lt(n);if(Number.parseInt(r[0],16)&8&&(r="00"+r),r.length&1)throw new e("unexpected DER parsing assertion: unpadded hex");return r},decode(n){const{Err:e}=M;if(n[0]&128)throw new e("invalid signature integer: negative");if(n[0]===0&&!(n[1]&128))throw new e("invalid signature integer: unnecessary leading zero");return yt(n)}},toSig(n){const{Err:e,_int:r,_tlv:t}=M,o=j("signature",n),{v:s,l:i}=t.decode(48,o);if(i.length)throw new e("invalid signature: left bytes after parsing");const{v:u,l}=t.decode(2,s),{v:w,l:m}=t.decode(2,l);if(m.length)throw new e("invalid signature: left bytes after parsing");return{r:r.decode(u),s:r.decode(w)}},hexFromSig(n){const{_tlv:e,_int:r}=M,t=e.encode(2,r.encode(n.r)),o=e.encode(2,r.encode(n.s)),s=t+o;return e.encode(48,s)}},z=BigInt(0),rt=BigInt(1),le=BigInt(2),dt=BigInt(3),$e=BigInt(4);function et(n,e){const{BYTES:r}=n;let t;if(typeof e=="bigint")t=e;else{let o=j("private key",e);try{t=n.fromBytes(o)}catch{throw new Error(`invalid private key: expected ui8a of size ${r}, got ${typeof e}`)}}if(!n.isValidNot0(t))throw new Error("invalid private key: out of range [1..N-1]");return t}function je(n,e={}){const r=Te("weierstrass",n,e),{Fp:t,Fn:o}=r;let s=r.CURVE;const{h:i,n:u}=s;Ot(e,{},{allowInfinityPoint:"boolean",clearCofactor:"function",isTorsionFree:"function",fromBytes:"function",toBytes:"function",endo:"object",wrapPrivateKey:"boolean"});const{endo:l}=e;if(l&&(!t.is0(s.a)||typeof l.beta!="bigint"||!Array.isArray(l.basises)))throw new Error('invalid endo: expected "beta": bigint and "basises": array');const w=he(t,o);function m(){if(!t.isOdd)throw new Error("compression is not supported: Field does not have .isOdd()")}function I(A,d,a){const{x:c,y:g}=d.toAffine(),y=t.toBytes(c);if(wt(a,"isCompressed"),a){m();const B=!t.isOdd(g);return D(de(B),y)}else return D(Uint8Array.of(4),y,t.toBytes(g))}function f(A){W(A,void 0,"Point");const{publicKey:d,publicKeyUncompressed:a}=w,c=A.length,g=A[0],y=A.subarray(1);if(c===d&&(g===2||g===3)){const B=t.fromBytes(y);if(!t.isValid(B))throw new Error("bad point: is not on curve, wrong x");const E=x(B);let b;try{b=t.sqrt(E)}catch(L){const _=L instanceof Error?": "+L.message:"";throw new Error("bad point: is not on curve, sqrt error"+_)}m();const v=t.isOdd(b);return(g&1)===1!==v&&(b=t.neg(b)),{x:B,y:b}}else if(c===a&&g===4){const B=t.BYTES,E=t.fromBytes(y.subarray(0,B)),b=t.fromBytes(y.subarray(B,B*2));if(!O(E,b))throw new Error("bad point: is not on curve");return{x:E,y:b}}else throw new Error(`bad point: got length ${c}, expected compressed=${d} or uncompressed=${a}`)}const h=e.toBytes||I,p=e.fromBytes||f;function x(A){const d=t.sqr(A),a=t.mul(d,A);return t.add(t.add(a,t.mul(A,s.a)),s.b)}function O(A,d){const a=t.sqr(d),c=x(A);return t.eql(a,c)}if(!O(s.Gx,s.Gy))throw new Error("bad curve params: generator point");const H=t.mul(t.pow(s.a,dt),$e),st=t.mul(t.sqr(s.b),BigInt(27));if(t.is0(t.add(H,st)))throw new Error("bad curve params: a or b");function U(A,d,a=!1){if(!t.isValid(d)||a&&t.is0(d))throw new Error(`bad point coordinate ${A}`);return d}function G(A){if(!(A instanceof q))throw new Error("ProjectivePoint expected")}function X(A){if(!l||!l.basises)throw new Error("no endo");return Ve(A,l.basises,o.ORDER)}const J=Lt((A,d)=>{const{X:a,Y:c,Z:g}=A;if(t.eql(g,t.ONE))return{x:a,y:c};const y=A.is0();d==null&&(d=y?t.ONE:t.inv(g));const B=t.mul(a,d),E=t.mul(c,d),b=t.mul(g,d);if(y)return{x:t.ZERO,y:t.ZERO};if(!t.eql(b,t.ONE))throw new Error("invZ was invalid");return{x:B,y:E}}),ft=Lt(A=>{if(A.is0()){if(e.allowInfinityPoint&&!t.is0(A.Y))return;throw new Error("bad point: ZERO")}const{x:d,y:a}=A.toAffine();if(!t.isValid(d)||!t.isValid(a))throw new Error("bad point: x or y not field elements");if(!O(d,a))throw new Error("bad point: equation left != right");if(!A.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0});function tt(A,d,a,c,g){return a=new q(t.mul(a.X,A),a.Y,a.Z),d=gt(c,d),a=gt(g,a),d.add(a)}class q{constructor(d,a,c){this.X=U("x",d),this.Y=U("y",a,!0),this.Z=U("z",c),Object.freeze(this)}static CURVE(){return s}static fromAffine(d){const{x:a,y:c}=d||{};if(!d||!t.isValid(a)||!t.isValid(c))throw new Error("invalid affine point");if(d instanceof q)throw new Error("projective point not allowed");return t.is0(a)&&t.is0(c)?q.ZERO:new q(a,c,t.ONE)}static fromBytes(d){const a=q.fromAffine(p(W(d,void 0,"point")));return a.assertValidity(),a}static fromHex(d){return q.fromBytes(j("pointHex",d))}get x(){return this.toAffine().x}get y(){return this.toAffine().y}precompute(d=8,a=!0){return F.createCache(this,d),a||this.multiply(dt),this}assertValidity(){ft(this)}hasEvenY(){const{y:d}=this.toAffine();if(!t.isOdd)throw new Error("Field doesn't support isOdd");return!t.isOdd(d)}equals(d){G(d);const{X:a,Y:c,Z:g}=this,{X:y,Y:B,Z:E}=d,b=t.eql(t.mul(a,E),t.mul(y,g)),v=t.eql(t.mul(c,E),t.mul(B,g));return b&&v}negate(){return new q(this.X,t.neg(this.Y),this.Z)}double(){const{a:d,b:a}=s,c=t.mul(a,dt),{X:g,Y:y,Z:B}=this;let E=t.ZERO,b=t.ZERO,v=t.ZERO,S=t.mul(g,g),L=t.mul(y,y),_=t.mul(B,B),N=t.mul(g,y);return N=t.add(N,N),v=t.mul(g,B),v=t.add(v,v),E=t.mul(d,v),b=t.mul(c,_),b=t.add(E,b),E=t.sub(L,b),b=t.add(L,b),b=t.mul(E,b),E=t.mul(N,E),v=t.mul(c,v),_=t.mul(d,_),N=t.sub(S,_),N=t.mul(d,N),N=t.add(N,v),v=t.add(S,S),S=t.add(v,S),S=t.add(S,_),S=t.mul(S,N),b=t.add(b,S),_=t.mul(y,B),_=t.add(_,_),S=t.mul(_,N),E=t.sub(E,S),v=t.mul(_,L),v=t.add(v,v),v=t.add(v,v),new q(E,b,v)}add(d){G(d);const{X:a,Y:c,Z:g}=this,{X:y,Y:B,Z:E}=d;let b=t.ZERO,v=t.ZERO,S=t.ZERO;const L=s.a,_=t.mul(s.b,dt);let N=t.mul(a,y),R=t.mul(c,B),T=t.mul(g,E),$=t.add(a,c),Z=t.add(y,B);$=t.mul($,Z),Z=t.add(N,R),$=t.sub($,Z),Z=t.add(a,g);let V=t.add(y,E);return Z=t.mul(Z,V),V=t.add(N,T),Z=t.sub(Z,V),V=t.add(c,g),b=t.add(B,E),V=t.mul(V,b),b=t.add(R,T),V=t.sub(V,b),S=t.mul(L,Z),b=t.mul(_,T),S=t.add(b,S),b=t.sub(R,S),S=t.add(R,S),v=t.mul(b,S),R=t.add(N,N),R=t.add(R,N),T=t.mul(L,T),Z=t.mul(_,Z),R=t.add(R,T),T=t.sub(N,T),T=t.mul(L,T),Z=t.add(Z,T),N=t.mul(R,Z),v=t.add(v,N),N=t.mul(V,Z),b=t.mul($,b),b=t.sub(b,N),N=t.mul($,R),S=t.mul(V,S),S=t.add(S,N),new q(b,v,S)}subtract(d){return this.add(d.negate())}is0(){return this.equals(q.ZERO)}multiply(d){const{endo:a}=e;if(!o.isValidNot0(d))throw new Error("invalid scalar: out of range");let c,g;const y=B=>F.cached(this,B,E=>bt(q,E));if(a){const{k1neg:B,k1:E,k2neg:b,k2:v}=X(d),{p:S,f:L}=y(E),{p:_,f:N}=y(v);g=L.add(N),c=tt(a.beta,S,_,B,b)}else{const{p:B,f:E}=y(d);c=B,g=E}return bt(q,[c,g])[0]}multiplyUnsafe(d){const{endo:a}=e,c=this;if(!o.isValid(d))throw new Error("invalid scalar: out of range");if(d===z||c.is0())return q.ZERO;if(d===rt)return c;if(F.hasCache(this))return this.multiply(d);if(a){const{k1neg:g,k1:y,k2neg:B,k2:E}=X(d),{p1:b,p2:v}=Ue(q,c,y,E);return tt(a.beta,b,v,g,B)}else return F.unsafe(c,d)}multiplyAndAddUnsafe(d,a,c){const g=this.multiplyUnsafe(a).add(d.multiplyUnsafe(c));return g.is0()?void 0:g}toAffine(d){return J(this,d)}isTorsionFree(){const{isTorsionFree:d}=e;return i===rt?!0:d?d(q,this):F.unsafe(this,u).is0()}clearCofactor(){const{clearCofactor:d}=e;return i===rt?this:d?d(q,this):this.multiplyUnsafe(i)}isSmallOrder(){return this.multiplyUnsafe(i).is0()}toBytes(d=!0){return wt(d,"isCompressed"),this.assertValidity(),h(q,this,d)}toHex(d=!0){return nt(this.toBytes(d))}toString(){return`<Point ${this.is0()?"ZERO":this.toHex()}>`}get px(){return this.X}get py(){return this.X}get pz(){return this.Z}toRawBytes(d=!0){return this.toBytes(d)}_setWindowSize(d){this.precompute(d)}static normalizeZ(d){return bt(q,d)}static msm(d,a){return Le(q,o,d,a)}static fromPrivateKey(d){return q.BASE.multiply(et(o,d))}}q.BASE=new q(s.Gx,s.Gy,t.ONE),q.ZERO=new q(t.ZERO,t.ONE,t.ZERO),q.Fp=t,q.Fn=o;const at=o.BITS,F=new He(q,e.endo?Math.ceil(at/2):at);return q.BASE.precompute(8),q}function de(n){return Uint8Array.of(n?2:3)}function he(n,e){return{secretKey:e.BYTES,publicKey:1+n.BYTES,publicKeyUncompressed:1+2*n.BYTES,publicKeyHasPrefix:!0,signature:2*e.BYTES}}function Ye(n,e={}){const{Fn:r}=n,t=e.randomBytes||zt,o=Object.assign(he(n.Fp,r),{seed:fe(r.ORDER)});function s(h){try{return!!et(r,h)}catch{return!1}}function i(h,p){const{publicKey:x,publicKeyUncompressed:O}=o;try{const H=h.length;return p===!0&&H!==x||p===!1&&H!==O?!1:!!n.fromBytes(h)}catch{return!1}}function u(h=t(o.seed)){return _e(W(h,o.seed,"seed"),r.ORDER)}function l(h,p=!0){return n.BASE.multiply(et(r,h)).toBytes(p)}function w(h){const p=u(h);return{secretKey:p,publicKey:l(p)}}function m(h){if(typeof h=="bigint")return!1;if(h instanceof n)return!0;const{secretKey:p,publicKey:x,publicKeyUncompressed:O}=o;if(r.allowedLengths||p===x)return;const H=j("key",h).length;return H===x||H===O}function I(h,p,x=!0){if(m(h)===!0)throw new Error("first arg must be private key");if(m(p)===!1)throw new Error("second arg must be public key");const O=et(r,h);return n.fromHex(p).multiply(O).toBytes(x)}return Object.freeze({getPublicKey:l,getSharedSecret:I,keygen:w,Point:n,utils:{isValidSecretKey:s,isValidPublicKey:i,randomSecretKey:u,isValidPrivateKey:s,randomPrivateKey:u,normPrivateKeyToScalar:h=>et(r,h),precompute(h=8,p=n.BASE){return p.precompute(h,!1)}},lengths:o})}function Ce(n,e,r={}){Mt(e),Ot(r,{},{hmac:"function",lowS:"boolean",randomBytes:"function",bits2int:"function",bits2int_modN:"function"});const t=r.randomBytes||zt,o=r.hmac||((a,...c)=>Pt(e,a,D(...c))),{Fp:s,Fn:i}=n,{ORDER:u,BITS:l}=i,{keygen:w,getPublicKey:m,getSharedSecret:I,utils:f,lengths:h}=Ye(n,r),p={prehash:!1,lowS:typeof r.lowS=="boolean"?r.lowS:!1,format:void 0,extraEntropy:!1},x="compact";function O(a){const c=u>>rt;return a>c}function H(a,c){if(!i.isValidNot0(c))throw new Error(`invalid signature ${a}: out of range 1..Point.Fn.ORDER`);return c}function st(a,c){St(c);const g=h.signature,y=c==="compact"?g:c==="recovered"?g+1:void 0;return W(a,y,`${c} signature`)}class U{constructor(c,g,y){this.r=H("r",c),this.s=H("s",g),y!=null&&(this.recovery=y),Object.freeze(this)}static fromBytes(c,g=x){st(c,g);let y;if(g==="der"){const{r:v,s:S}=M.toSig(W(c));return new U(v,S)}g==="recovered"&&(y=c[0],g="compact",c=c.subarray(1));const B=i.BYTES,E=c.subarray(0,B),b=c.subarray(B,B*2);return new U(i.fromBytes(E),i.fromBytes(b),y)}static fromHex(c,g){return this.fromBytes(ht(c),g)}addRecoveryBit(c){return new U(this.r,this.s,c)}recoverPublicKey(c){const g=s.ORDER,{r:y,s:B,recovery:E}=this;if(E==null||![0,1,2,3].includes(E))throw new Error("recovery id invalid");if(u*le<g&&E>1)throw new Error("recovery id is ambiguous for h>1 curve");const v=E===2||E===3?y+u:y;if(!s.isValid(v))throw new Error("recovery id 2 or 3 invalid");const S=s.toBytes(v),L=n.fromBytes(D(de((E&1)===0),S)),_=i.inv(v),N=X(j("msgHash",c)),R=i.create(-N*_),T=i.create(B*_),$=n.BASE.multiplyUnsafe(R).add(L.multiplyUnsafe(T));if($.is0())throw new Error("point at infinify");return $.assertValidity(),$}hasHighS(){return O(this.s)}toBytes(c=x){if(St(c),c==="der")return ht(M.hexFromSig(this));const g=i.toBytes(this.r),y=i.toBytes(this.s);if(c==="recovered"){if(this.recovery==null)throw new Error("recovery bit must be present");return D(Uint8Array.of(this.recovery),g,y)}return D(g,y)}toHex(c){return nt(this.toBytes(c))}assertValidity(){}static fromCompact(c){return U.fromBytes(j("sig",c),"compact")}static fromDER(c){return U.fromBytes(j("sig",c),"der")}normalizeS(){return this.hasHighS()?new U(this.r,i.neg(this.s),this.recovery):this}toDERRawBytes(){return this.toBytes("der")}toDERHex(){return nt(this.toBytes("der"))}toCompactRawBytes(){return this.toBytes("compact")}toCompactHex(){return nt(this.toBytes("compact"))}}const G=r.bits2int||function(c){if(c.length>8192)throw new Error("input is too large");const g=yt(c),y=c.length*8-l;return y>0?g>>BigInt(y):g},X=r.bits2int_modN||function(c){return i.create(G(c))},J=it(l);function ft(a){return Ee("num < 2^"+l,a,z,J),i.toBytes(a)}function tt(a,c){return W(a,void 0,"message"),c?W(e(a),void 0,"prehashed message"):a}function q(a,c,g){if(["recovered","canonical"].some(R=>R in g))throw new Error("sign() legacy options not supported");const{lowS:y,prehash:B,extraEntropy:E}=vt(g,p);a=tt(a,B);const b=X(a),v=et(i,c),S=[ft(v),ft(b)];if(E!=null&&E!==!1){const R=E===!0?t(h.secretKey):E;S.push(j("extraEntropy",R))}const L=D(...S),_=b;function N(R){const T=G(R);if(!i.isValidNot0(T))return;const $=i.inv(T),Z=n.BASE.multiply(T).toAffine(),V=i.create(Z.x);if(V===z)return;const ut=i.create($*i.create(_+V*v));if(ut===z)return;let Zt=(Z.x===V?0:2)|Number(Z.y&rt),Ht=ut;return y&&O(ut)&&(Ht=i.neg(ut),Zt^=1),new U(V,Ht,Zt)}return{seed:L,k2sig:N}}function at(a,c,g={}){a=j("message",a);const{seed:y,k2sig:B}=q(a,c,g);return Be(e.outputLen,i.BYTES,o)(y,B)}function F(a){let c;const g=typeof a=="string"||qt(a),y=!g&&a!==null&&typeof a=="object"&&typeof a.r=="bigint"&&typeof a.s=="bigint";if(!g&&!y)throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");if(y)c=new U(a.r,a.s);else if(g){try{c=U.fromBytes(j("sig",a),"der")}catch(B){if(!(B instanceof M.Err))throw B}if(!c)try{c=U.fromBytes(j("sig",a),"compact")}catch{return!1}}return c||!1}function A(a,c,g,y={}){const{lowS:B,prehash:E,format:b}=vt(y,p);if(g=j("publicKey",g),c=tt(j("message",c),E),"strict"in y)throw new Error("options.strict was renamed to lowS");const v=b===void 0?F(a):U.fromBytes(j("sig",a),b);if(v===!1)return!1;try{const S=n.fromBytes(g);if(B&&v.hasHighS())return!1;const{r:L,s:_}=v,N=X(c),R=i.inv(_),T=i.create(N*R),$=i.create(L*R),Z=n.BASE.multiplyUnsafe(T).add(S.multiplyUnsafe($));return Z.is0()?!1:i.create(Z.x)===L}catch{return!1}}function d(a,c,g={}){const{prehash:y}=vt(g,p);return c=tt(c,y),U.fromBytes(a,"recovered").recoverPublicKey(c).toBytes()}return Object.freeze({keygen:w,getPublicKey:m,getSharedSecret:I,utils:f,lengths:h,Point:n,sign:at,verify:A,recoverPublicKey:d,Signature:U,hash:e})}function Ke(n){const e={a:n.a,b:n.b,p:n.Fp.ORDER,n:n.n,h:n.h,Gx:n.Gx,Gy:n.Gy},r=n.Fp;let t=n.allowedPrivateKeyLengths?Array.from(new Set(n.allowedPrivateKeyLengths.map(i=>Math.ceil(i/2)))):void 0;const o=ct(e.n,{BITS:n.nBitLength,allowedLengths:t,modFromBytes:n.wrapPrivateKey}),s={Fp:r,Fn:o,allowInfinityPoint:n.allowInfinityPoint,endo:n.endo,isTorsionFree:n.isTorsionFree,clearCofactor:n.clearCofactor,fromBytes:n.fromBytes,toBytes:n.toBytes};return{CURVE:e,curveOpts:s}}function Me(n){const{CURVE:e,curveOpts:r}=Ke(n),t={hmac:n.hmac,randomBytes:n.randomBytes,lowS:n.lowS,bits2int:n.bits2int,bits2int_modN:n.bits2int_modN};return{CURVE:e,curveOpts:r,hash:n.hash,ecdsaOpts:t}}function ze(n,e){const r=e.Point;return Object.assign({},e,{ProjectivePoint:r,CURVE:Object.assign({},n,ie(r.Fn.ORDER,r.Fn.BITS))})}function Xe(n){const{CURVE:e,curveOpts:r,hash:t,ecdsaOpts:o}=Me(n),s=je(e,r),i=Ce(s,t,o);return ze(n,i)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function De(n,e){const r=t=>Xe({...n,hash:t});return{...r(e),create:r}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Rt={p:BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),n:BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),h:BigInt(1),a:BigInt(0),b:BigInt(7),Gx:BigInt("0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),Gy:BigInt("0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8")},Ge={beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),basises:[[BigInt("0x3086d221a7d46bcde86c90e49284eb15"),-BigInt("0xe4437ed6010e88286f547fa90abfe4c3")],[BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),BigInt("0x3086d221a7d46bcde86c90e49284eb15")]]},Ct=BigInt(2);function Fe(n){const e=Rt.p,r=BigInt(3),t=BigInt(6),o=BigInt(11),s=BigInt(22),i=BigInt(23),u=BigInt(44),l=BigInt(88),w=n*n*n%e,m=w*w*n%e,I=C(m,r,e)*m%e,f=C(I,r,e)*m%e,h=C(f,Ct,e)*w%e,p=C(h,o,e)*h%e,x=C(p,s,e)*p%e,O=C(x,u,e)*x%e,H=C(O,l,e)*O%e,st=C(H,u,e)*x%e,U=C(st,r,e)*m%e,G=C(U,i,e)*p%e,X=C(G,t,e)*w%e,J=C(X,Ct,e);if(!It.eql(It.sqr(J),n))throw new Error("Cannot find square root");return J}const It=ct(Rt.p,{sqrt:Fe}),Pe=De({...Rt,Fp:It,lowS:!0,endo:Ge},be);export{Pe as secp256k1};

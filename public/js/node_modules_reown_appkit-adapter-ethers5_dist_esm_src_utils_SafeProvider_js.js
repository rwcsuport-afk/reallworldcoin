"use strict";
(self["webpackChunk"] = self["webpackChunk"] || []).push([["node_modules_reown_appkit-adapter-ethers5_dist_esm_src_utils_SafeProvider_js"],{

/***/ "./node_modules/@noble/hashes/_md.js":
/*!*******************************************!*\
  !*** ./node_modules/@noble/hashes/_md.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SHA512_IV = exports.SHA384_IV = exports.SHA224_IV = exports.SHA256_IV = exports.HashMD = void 0;
exports.setBigUint64 = setBigUint64;
exports.Chi = Chi;
exports.Maj = Maj;
/**
 * Internal Merkle-Damgard hash utils.
 * @module
 */
const utils_ts_1 = __webpack_require__(/*! ./utils.js */ "./node_modules/@noble/hashes/utils.js");
/** Polyfill for Safari 14. https://caniuse.com/mdn-javascript_builtins_dataview_setbiguint64 */
function setBigUint64(view, byteOffset, value, isLE) {
    if (typeof view.setBigUint64 === 'function')
        return view.setBigUint64(byteOffset, value, isLE);
    const _32n = BigInt(32);
    const _u32_max = BigInt(0xffffffff);
    const wh = Number((value >> _32n) & _u32_max);
    const wl = Number(value & _u32_max);
    const h = isLE ? 4 : 0;
    const l = isLE ? 0 : 4;
    view.setUint32(byteOffset + h, wh, isLE);
    view.setUint32(byteOffset + l, wl, isLE);
}
/** Choice: a ? b : c */
function Chi(a, b, c) {
    return (a & b) ^ (~a & c);
}
/** Majority function, true if any two inputs is true. */
function Maj(a, b, c) {
    return (a & b) ^ (a & c) ^ (b & c);
}
/**
 * Merkle-Damgard hash construction base class.
 * Could be used to create MD5, RIPEMD, SHA1, SHA2.
 */
class HashMD extends utils_ts_1.Hash {
    constructor(blockLen, outputLen, padOffset, isLE) {
        super();
        this.finished = false;
        this.length = 0;
        this.pos = 0;
        this.destroyed = false;
        this.blockLen = blockLen;
        this.outputLen = outputLen;
        this.padOffset = padOffset;
        this.isLE = isLE;
        this.buffer = new Uint8Array(blockLen);
        this.view = (0, utils_ts_1.createView)(this.buffer);
    }
    update(data) {
        (0, utils_ts_1.aexists)(this);
        data = (0, utils_ts_1.toBytes)(data);
        (0, utils_ts_1.abytes)(data);
        const { view, buffer, blockLen } = this;
        const len = data.length;
        for (let pos = 0; pos < len;) {
            const take = Math.min(blockLen - this.pos, len - pos);
            // Fast path: we have at least one block in input, cast it to view and process
            if (take === blockLen) {
                const dataView = (0, utils_ts_1.createView)(data);
                for (; blockLen <= len - pos; pos += blockLen)
                    this.process(dataView, pos);
                continue;
            }
            buffer.set(data.subarray(pos, pos + take), this.pos);
            this.pos += take;
            pos += take;
            if (this.pos === blockLen) {
                this.process(view, 0);
                this.pos = 0;
            }
        }
        this.length += data.length;
        this.roundClean();
        return this;
    }
    digestInto(out) {
        (0, utils_ts_1.aexists)(this);
        (0, utils_ts_1.aoutput)(out, this);
        this.finished = true;
        // Padding
        // We can avoid allocation of buffer for padding completely if it
        // was previously not allocated here. But it won't change performance.
        const { buffer, view, blockLen, isLE } = this;
        let { pos } = this;
        // append the bit '1' to the message
        buffer[pos++] = 0b10000000;
        (0, utils_ts_1.clean)(this.buffer.subarray(pos));
        // we have less than padOffset left in buffer, so we cannot put length in
        // current block, need process it and pad again
        if (this.padOffset > blockLen - pos) {
            this.process(view, 0);
            pos = 0;
        }
        // Pad until full block byte with zeros
        for (let i = pos; i < blockLen; i++)
            buffer[i] = 0;
        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that
        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.
        // So we just write lowest 64 bits of that value.
        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);
        this.process(view, 0);
        const oview = (0, utils_ts_1.createView)(out);
        const len = this.outputLen;
        // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT
        if (len % 4)
            throw new Error('_sha2: outputLen should be aligned to 32bit');
        const outLen = len / 4;
        const state = this.get();
        if (outLen > state.length)
            throw new Error('_sha2: outputLen bigger than state');
        for (let i = 0; i < outLen; i++)
            oview.setUint32(4 * i, state[i], isLE);
    }
    digest() {
        const { buffer, outputLen } = this;
        this.digestInto(buffer);
        const res = buffer.slice(0, outputLen);
        this.destroy();
        return res;
    }
    _cloneInto(to) {
        to || (to = new this.constructor());
        to.set(...this.get());
        const { blockLen, buffer, length, finished, destroyed, pos } = this;
        to.destroyed = destroyed;
        to.finished = finished;
        to.length = length;
        to.pos = pos;
        if (length % blockLen)
            to.buffer.set(buffer);
        return to;
    }
    clone() {
        return this._cloneInto();
    }
}
exports.HashMD = HashMD;
/**
 * Initial SHA-2 state: fractional parts of square roots of first 16 primes 2..53.
 * Check out `test/misc/sha2-gen-iv.js` for recomputation guide.
 */
/** Initial SHA256 state. Bits 0..32 of frac part of sqrt of primes 2..19 */
exports.SHA256_IV = Uint32Array.from([
    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19,
]);
/** Initial SHA224 state. Bits 32..64 of frac part of sqrt of primes 23..53 */
exports.SHA224_IV = Uint32Array.from([
    0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939, 0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4,
]);
/** Initial SHA384 state. Bits 0..64 of frac part of sqrt of primes 23..53 */
exports.SHA384_IV = Uint32Array.from([
    0xcbbb9d5d, 0xc1059ed8, 0x629a292a, 0x367cd507, 0x9159015a, 0x3070dd17, 0x152fecd8, 0xf70e5939,
    0x67332667, 0xffc00b31, 0x8eb44a87, 0x68581511, 0xdb0c2e0d, 0x64f98fa7, 0x47b5481d, 0xbefa4fa4,
]);
/** Initial SHA512 state. Bits 0..64 of frac part of sqrt of primes 2..19 */
exports.SHA512_IV = Uint32Array.from([
    0x6a09e667, 0xf3bcc908, 0xbb67ae85, 0x84caa73b, 0x3c6ef372, 0xfe94f82b, 0xa54ff53a, 0x5f1d36f1,
    0x510e527f, 0xade682d1, 0x9b05688c, 0x2b3e6c1f, 0x1f83d9ab, 0xfb41bd6b, 0x5be0cd19, 0x137e2179,
]);
//# sourceMappingURL=_md.js.map

/***/ }),

/***/ "./node_modules/@noble/hashes/_u64.js":
/*!********************************************!*\
  !*** ./node_modules/@noble/hashes/_u64.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.toBig = exports.shrSL = exports.shrSH = exports.rotrSL = exports.rotrSH = exports.rotrBL = exports.rotrBH = exports.rotr32L = exports.rotr32H = exports.rotlSL = exports.rotlSH = exports.rotlBL = exports.rotlBH = exports.add5L = exports.add5H = exports.add4L = exports.add4H = exports.add3L = exports.add3H = void 0;
exports.add = add;
exports.fromBig = fromBig;
exports.split = split;
/**
 * Internal helpers for u64. BigUint64Array is too slow as per 2025, so we implement it using Uint32Array.
 * @todo re-check https://issues.chromium.org/issues/42212588
 * @module
 */
const U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);
const _32n = /* @__PURE__ */ BigInt(32);
function fromBig(n, le = false) {
    if (le)
        return { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) };
    return { h: Number((n >> _32n) & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };
}
function split(lst, le = false) {
    const len = lst.length;
    let Ah = new Uint32Array(len);
    let Al = new Uint32Array(len);
    for (let i = 0; i < len; i++) {
        const { h, l } = fromBig(lst[i], le);
        [Ah[i], Al[i]] = [h, l];
    }
    return [Ah, Al];
}
const toBig = (h, l) => (BigInt(h >>> 0) << _32n) | BigInt(l >>> 0);
exports.toBig = toBig;
// for Shift in [0, 32)
const shrSH = (h, _l, s) => h >>> s;
exports.shrSH = shrSH;
const shrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);
exports.shrSL = shrSL;
// Right rotate for Shift in [1, 32)
const rotrSH = (h, l, s) => (h >>> s) | (l << (32 - s));
exports.rotrSH = rotrSH;
const rotrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);
exports.rotrSL = rotrSL;
// Right rotate for Shift in (32, 64), NOTE: 32 is special case.
const rotrBH = (h, l, s) => (h << (64 - s)) | (l >>> (s - 32));
exports.rotrBH = rotrBH;
const rotrBL = (h, l, s) => (h >>> (s - 32)) | (l << (64 - s));
exports.rotrBL = rotrBL;
// Right rotate for shift===32 (just swaps l&h)
const rotr32H = (_h, l) => l;
exports.rotr32H = rotr32H;
const rotr32L = (h, _l) => h;
exports.rotr32L = rotr32L;
// Left rotate for Shift in [1, 32)
const rotlSH = (h, l, s) => (h << s) | (l >>> (32 - s));
exports.rotlSH = rotlSH;
const rotlSL = (h, l, s) => (l << s) | (h >>> (32 - s));
exports.rotlSL = rotlSL;
// Left rotate for Shift in (32, 64), NOTE: 32 is special case.
const rotlBH = (h, l, s) => (l << (s - 32)) | (h >>> (64 - s));
exports.rotlBH = rotlBH;
const rotlBL = (h, l, s) => (h << (s - 32)) | (l >>> (64 - s));
exports.rotlBL = rotlBL;
// JS uses 32-bit signed integers for bitwise operations which means we cannot
// simple take carry out of low bit sum by shift, we need to use division.
function add(Ah, Al, Bh, Bl) {
    const l = (Al >>> 0) + (Bl >>> 0);
    return { h: (Ah + Bh + ((l / 2 ** 32) | 0)) | 0, l: l | 0 };
}
// Addition with more than 2 elements
const add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
exports.add3L = add3L;
const add3H = (low, Ah, Bh, Ch) => (Ah + Bh + Ch + ((low / 2 ** 32) | 0)) | 0;
exports.add3H = add3H;
const add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
exports.add4L = add4L;
const add4H = (low, Ah, Bh, Ch, Dh) => (Ah + Bh + Ch + Dh + ((low / 2 ** 32) | 0)) | 0;
exports.add4H = add4H;
const add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
exports.add5L = add5L;
const add5H = (low, Ah, Bh, Ch, Dh, Eh) => (Ah + Bh + Ch + Dh + Eh + ((low / 2 ** 32) | 0)) | 0;
exports.add5H = add5H;
// prettier-ignore
const u64 = {
    fromBig, split, toBig,
    shrSH, shrSL,
    rotrSH, rotrSL, rotrBH, rotrBL,
    rotr32H, rotr32L,
    rotlSH, rotlSL, rotlBH, rotlBL,
    add, add3L, add3H, add4L, add4H, add5H, add5L,
};
exports["default"] = u64;
//# sourceMappingURL=_u64.js.map

/***/ }),

/***/ "./node_modules/@noble/hashes/crypto.js":
/*!**********************************************!*\
  !*** ./node_modules/@noble/hashes/crypto.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.crypto = void 0;
exports.crypto = typeof globalThis === 'object' && 'crypto' in globalThis ? globalThis.crypto : undefined;
//# sourceMappingURL=crypto.js.map

/***/ }),

/***/ "./node_modules/@noble/hashes/hmac.js":
/*!********************************************!*\
  !*** ./node_modules/@noble/hashes/hmac.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.hmac = exports.HMAC = void 0;
/**
 * HMAC: RFC2104 message authentication code.
 * @module
 */
const utils_ts_1 = __webpack_require__(/*! ./utils.js */ "./node_modules/@noble/hashes/utils.js");
class HMAC extends utils_ts_1.Hash {
    constructor(hash, _key) {
        super();
        this.finished = false;
        this.destroyed = false;
        (0, utils_ts_1.ahash)(hash);
        const key = (0, utils_ts_1.toBytes)(_key);
        this.iHash = hash.create();
        if (typeof this.iHash.update !== 'function')
            throw new Error('Expected instance of class which extends utils.Hash');
        this.blockLen = this.iHash.blockLen;
        this.outputLen = this.iHash.outputLen;
        const blockLen = this.blockLen;
        const pad = new Uint8Array(blockLen);
        // blockLen can be bigger than outputLen
        pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);
        for (let i = 0; i < pad.length; i++)
            pad[i] ^= 0x36;
        this.iHash.update(pad);
        // By doing update (processing of first block) of outer hash here we can re-use it between multiple calls via clone
        this.oHash = hash.create();
        // Undo internal XOR && apply outer XOR
        for (let i = 0; i < pad.length; i++)
            pad[i] ^= 0x36 ^ 0x5c;
        this.oHash.update(pad);
        (0, utils_ts_1.clean)(pad);
    }
    update(buf) {
        (0, utils_ts_1.aexists)(this);
        this.iHash.update(buf);
        return this;
    }
    digestInto(out) {
        (0, utils_ts_1.aexists)(this);
        (0, utils_ts_1.abytes)(out, this.outputLen);
        this.finished = true;
        this.iHash.digestInto(out);
        this.oHash.update(out);
        this.oHash.digestInto(out);
        this.destroy();
    }
    digest() {
        const out = new Uint8Array(this.oHash.outputLen);
        this.digestInto(out);
        return out;
    }
    _cloneInto(to) {
        // Create new instance without calling constructor since key already in state and we don't know it.
        to || (to = Object.create(Object.getPrototypeOf(this), {}));
        const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
        to = to;
        to.finished = finished;
        to.destroyed = destroyed;
        to.blockLen = blockLen;
        to.outputLen = outputLen;
        to.oHash = oHash._cloneInto(to.oHash);
        to.iHash = iHash._cloneInto(to.iHash);
        return to;
    }
    clone() {
        return this._cloneInto();
    }
    destroy() {
        this.destroyed = true;
        this.oHash.destroy();
        this.iHash.destroy();
    }
}
exports.HMAC = HMAC;
/**
 * HMAC: RFC2104 message authentication code.
 * @param hash - function that would be used e.g. sha256
 * @param key - message key
 * @param message - message data
 * @example
 * import { hmac } from '@noble/hashes/hmac';
 * import { sha256 } from '@noble/hashes/sha2';
 * const mac1 = hmac(sha256, 'key', 'message');
 */
const hmac = (hash, key, message) => new HMAC(hash, key).update(message).digest();
exports.hmac = hmac;
exports.hmac.create = (hash, key) => new HMAC(hash, key);
//# sourceMappingURL=hmac.js.map

/***/ }),

/***/ "./node_modules/@noble/hashes/legacy.js":
/*!**********************************************!*\
  !*** ./node_modules/@noble/hashes/legacy.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ripemd160 = exports.RIPEMD160 = exports.md5 = exports.MD5 = exports.sha1 = exports.SHA1 = void 0;
/**

SHA1 (RFC 3174), MD5 (RFC 1321) and RIPEMD160 (RFC 2286) legacy, weak hash functions.
Don't use them in a new protocol. What "weak" means:

- Collisions can be made with 2^18 effort in MD5, 2^60 in SHA1, 2^80 in RIPEMD160.
- No practical pre-image attacks (only theoretical, 2^123.4)
- HMAC seems kinda ok: https://datatracker.ietf.org/doc/html/rfc6151
 * @module
 */
const _md_ts_1 = __webpack_require__(/*! ./_md.js */ "./node_modules/@noble/hashes/_md.js");
const utils_ts_1 = __webpack_require__(/*! ./utils.js */ "./node_modules/@noble/hashes/utils.js");
/** Initial SHA1 state */
const SHA1_IV = /* @__PURE__ */ Uint32Array.from([
    0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0,
]);
// Reusable temporary buffer
const SHA1_W = /* @__PURE__ */ new Uint32Array(80);
/** SHA1 legacy hash class. */
class SHA1 extends _md_ts_1.HashMD {
    constructor() {
        super(64, 20, 8, false);
        this.A = SHA1_IV[0] | 0;
        this.B = SHA1_IV[1] | 0;
        this.C = SHA1_IV[2] | 0;
        this.D = SHA1_IV[3] | 0;
        this.E = SHA1_IV[4] | 0;
    }
    get() {
        const { A, B, C, D, E } = this;
        return [A, B, C, D, E];
    }
    set(A, B, C, D, E) {
        this.A = A | 0;
        this.B = B | 0;
        this.C = C | 0;
        this.D = D | 0;
        this.E = E | 0;
    }
    process(view, offset) {
        for (let i = 0; i < 16; i++, offset += 4)
            SHA1_W[i] = view.getUint32(offset, false);
        for (let i = 16; i < 80; i++)
            SHA1_W[i] = (0, utils_ts_1.rotl)(SHA1_W[i - 3] ^ SHA1_W[i - 8] ^ SHA1_W[i - 14] ^ SHA1_W[i - 16], 1);
        // Compression function main loop, 80 rounds
        let { A, B, C, D, E } = this;
        for (let i = 0; i < 80; i++) {
            let F, K;
            if (i < 20) {
                F = (0, _md_ts_1.Chi)(B, C, D);
                K = 0x5a827999;
            }
            else if (i < 40) {
                F = B ^ C ^ D;
                K = 0x6ed9eba1;
            }
            else if (i < 60) {
                F = (0, _md_ts_1.Maj)(B, C, D);
                K = 0x8f1bbcdc;
            }
            else {
                F = B ^ C ^ D;
                K = 0xca62c1d6;
            }
            const T = ((0, utils_ts_1.rotl)(A, 5) + F + E + K + SHA1_W[i]) | 0;
            E = D;
            D = C;
            C = (0, utils_ts_1.rotl)(B, 30);
            B = A;
            A = T;
        }
        // Add the compressed chunk to the current hash value
        A = (A + this.A) | 0;
        B = (B + this.B) | 0;
        C = (C + this.C) | 0;
        D = (D + this.D) | 0;
        E = (E + this.E) | 0;
        this.set(A, B, C, D, E);
    }
    roundClean() {
        (0, utils_ts_1.clean)(SHA1_W);
    }
    destroy() {
        this.set(0, 0, 0, 0, 0);
        (0, utils_ts_1.clean)(this.buffer);
    }
}
exports.SHA1 = SHA1;
/** SHA1 (RFC 3174) legacy hash function. It was cryptographically broken. */
exports.sha1 = (0, utils_ts_1.createHasher)(() => new SHA1());
/** Per-round constants */
const p32 = /* @__PURE__ */ Math.pow(2, 32);
const K = /* @__PURE__ */ Array.from({ length: 64 }, (_, i) => Math.floor(p32 * Math.abs(Math.sin(i + 1))));
/** md5 initial state: same as sha1, but 4 u32 instead of 5. */
const MD5_IV = /* @__PURE__ */ SHA1_IV.slice(0, 4);
// Reusable temporary buffer
const MD5_W = /* @__PURE__ */ new Uint32Array(16);
/** MD5 legacy hash class. */
class MD5 extends _md_ts_1.HashMD {
    constructor() {
        super(64, 16, 8, true);
        this.A = MD5_IV[0] | 0;
        this.B = MD5_IV[1] | 0;
        this.C = MD5_IV[2] | 0;
        this.D = MD5_IV[3] | 0;
    }
    get() {
        const { A, B, C, D } = this;
        return [A, B, C, D];
    }
    set(A, B, C, D) {
        this.A = A | 0;
        this.B = B | 0;
        this.C = C | 0;
        this.D = D | 0;
    }
    process(view, offset) {
        for (let i = 0; i < 16; i++, offset += 4)
            MD5_W[i] = view.getUint32(offset, true);
        // Compression function main loop, 64 rounds
        let { A, B, C, D } = this;
        for (let i = 0; i < 64; i++) {
            let F, g, s;
            if (i < 16) {
                F = (0, _md_ts_1.Chi)(B, C, D);
                g = i;
                s = [7, 12, 17, 22];
            }
            else if (i < 32) {
                F = (0, _md_ts_1.Chi)(D, B, C);
                g = (5 * i + 1) % 16;
                s = [5, 9, 14, 20];
            }
            else if (i < 48) {
                F = B ^ C ^ D;
                g = (3 * i + 5) % 16;
                s = [4, 11, 16, 23];
            }
            else {
                F = C ^ (B | ~D);
                g = (7 * i) % 16;
                s = [6, 10, 15, 21];
            }
            F = F + A + K[i] + MD5_W[g];
            A = D;
            D = C;
            C = B;
            B = B + (0, utils_ts_1.rotl)(F, s[i % 4]);
        }
        // Add the compressed chunk to the current hash value
        A = (A + this.A) | 0;
        B = (B + this.B) | 0;
        C = (C + this.C) | 0;
        D = (D + this.D) | 0;
        this.set(A, B, C, D);
    }
    roundClean() {
        (0, utils_ts_1.clean)(MD5_W);
    }
    destroy() {
        this.set(0, 0, 0, 0);
        (0, utils_ts_1.clean)(this.buffer);
    }
}
exports.MD5 = MD5;
/**
 * MD5 (RFC 1321) legacy hash function. It was cryptographically broken.
 * MD5 architecture is similar to SHA1, with some differences:
 * - Reduced output length: 16 bytes (128 bit) instead of 20
 * - 64 rounds, instead of 80
 * - Little-endian: could be faster, but will require more code
 * - Non-linear index selection: huge speed-up for unroll
 * - Per round constants: more memory accesses, additional speed-up for unroll
 */
exports.md5 = (0, utils_ts_1.createHasher)(() => new MD5());
// RIPEMD-160
const Rho160 = /* @__PURE__ */ Uint8Array.from([
    7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8,
]);
const Id160 = /* @__PURE__ */ (() => Uint8Array.from(new Array(16).fill(0).map((_, i) => i)))();
const Pi160 = /* @__PURE__ */ (() => Id160.map((i) => (9 * i + 5) % 16))();
const idxLR = /* @__PURE__ */ (() => {
    const L = [Id160];
    const R = [Pi160];
    const res = [L, R];
    for (let i = 0; i < 4; i++)
        for (let j of res)
            j.push(j[i].map((k) => Rho160[k]));
    return res;
})();
const idxL = /* @__PURE__ */ (() => idxLR[0])();
const idxR = /* @__PURE__ */ (() => idxLR[1])();
// const [idxL, idxR] = idxLR;
const shifts160 = /* @__PURE__ */ [
    [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],
    [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],
    [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],
    [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],
    [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5],
].map((i) => Uint8Array.from(i));
const shiftsL160 = /* @__PURE__ */ idxL.map((idx, i) => idx.map((j) => shifts160[i][j]));
const shiftsR160 = /* @__PURE__ */ idxR.map((idx, i) => idx.map((j) => shifts160[i][j]));
const Kl160 = /* @__PURE__ */ Uint32Array.from([
    0x00000000, 0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xa953fd4e,
]);
const Kr160 = /* @__PURE__ */ Uint32Array.from([
    0x50a28be6, 0x5c4dd124, 0x6d703ef3, 0x7a6d76e9, 0x00000000,
]);
// It's called f() in spec.
function ripemd_f(group, x, y, z) {
    if (group === 0)
        return x ^ y ^ z;
    if (group === 1)
        return (x & y) | (~x & z);
    if (group === 2)
        return (x | ~y) ^ z;
    if (group === 3)
        return (x & z) | (y & ~z);
    return x ^ (y | ~z);
}
// Reusable temporary buffer
const BUF_160 = /* @__PURE__ */ new Uint32Array(16);
class RIPEMD160 extends _md_ts_1.HashMD {
    constructor() {
        super(64, 20, 8, true);
        this.h0 = 0x67452301 | 0;
        this.h1 = 0xefcdab89 | 0;
        this.h2 = 0x98badcfe | 0;
        this.h3 = 0x10325476 | 0;
        this.h4 = 0xc3d2e1f0 | 0;
    }
    get() {
        const { h0, h1, h2, h3, h4 } = this;
        return [h0, h1, h2, h3, h4];
    }
    set(h0, h1, h2, h3, h4) {
        this.h0 = h0 | 0;
        this.h1 = h1 | 0;
        this.h2 = h2 | 0;
        this.h3 = h3 | 0;
        this.h4 = h4 | 0;
    }
    process(view, offset) {
        for (let i = 0; i < 16; i++, offset += 4)
            BUF_160[i] = view.getUint32(offset, true);
        // prettier-ignore
        let al = this.h0 | 0, ar = al, bl = this.h1 | 0, br = bl, cl = this.h2 | 0, cr = cl, dl = this.h3 | 0, dr = dl, el = this.h4 | 0, er = el;
        // Instead of iterating 0 to 80, we split it into 5 groups
        // And use the groups in constants, functions, etc. Much simpler
        for (let group = 0; group < 5; group++) {
            const rGroup = 4 - group;
            const hbl = Kl160[group], hbr = Kr160[group]; // prettier-ignore
            const rl = idxL[group], rr = idxR[group]; // prettier-ignore
            const sl = shiftsL160[group], sr = shiftsR160[group]; // prettier-ignore
            for (let i = 0; i < 16; i++) {
                const tl = ((0, utils_ts_1.rotl)(al + ripemd_f(group, bl, cl, dl) + BUF_160[rl[i]] + hbl, sl[i]) + el) | 0;
                al = el, el = dl, dl = (0, utils_ts_1.rotl)(cl, 10) | 0, cl = bl, bl = tl; // prettier-ignore
            }
            // 2 loops are 10% faster
            for (let i = 0; i < 16; i++) {
                const tr = ((0, utils_ts_1.rotl)(ar + ripemd_f(rGroup, br, cr, dr) + BUF_160[rr[i]] + hbr, sr[i]) + er) | 0;
                ar = er, er = dr, dr = (0, utils_ts_1.rotl)(cr, 10) | 0, cr = br, br = tr; // prettier-ignore
            }
        }
        // Add the compressed chunk to the current hash value
        this.set((this.h1 + cl + dr) | 0, (this.h2 + dl + er) | 0, (this.h3 + el + ar) | 0, (this.h4 + al + br) | 0, (this.h0 + bl + cr) | 0);
    }
    roundClean() {
        (0, utils_ts_1.clean)(BUF_160);
    }
    destroy() {
        this.destroyed = true;
        (0, utils_ts_1.clean)(this.buffer);
        this.set(0, 0, 0, 0, 0);
    }
}
exports.RIPEMD160 = RIPEMD160;
/**
 * RIPEMD-160 - a legacy hash function from 1990s.
 * * https://homes.esat.kuleuven.be/~bosselae/ripemd160.html
 * * https://homes.esat.kuleuven.be/~bosselae/ripemd160/pdf/AB-9601/AB-9601.pdf
 */
exports.ripemd160 = (0, utils_ts_1.createHasher)(() => new RIPEMD160());
//# sourceMappingURL=legacy.js.map

/***/ }),

/***/ "./node_modules/@noble/hashes/ripemd160.js":
/*!*************************************************!*\
  !*** ./node_modules/@noble/hashes/ripemd160.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ripemd160 = exports.RIPEMD160 = void 0;
/**
 * RIPEMD-160 legacy hash function.
 * https://homes.esat.kuleuven.be/~bosselae/ripemd160.html
 * https://homes.esat.kuleuven.be/~bosselae/ripemd160/pdf/AB-9601/AB-9601.pdf
 * @module
 * @deprecated
 */
const legacy_ts_1 = __webpack_require__(/*! ./legacy.js */ "./node_modules/@noble/hashes/legacy.js");
/** @deprecated Use import from `noble/hashes/legacy` module */
exports.RIPEMD160 = legacy_ts_1.RIPEMD160;
/** @deprecated Use import from `noble/hashes/legacy` module */
exports.ripemd160 = legacy_ts_1.ripemd160;
//# sourceMappingURL=ripemd160.js.map

/***/ }),

/***/ "./node_modules/@noble/hashes/sha2.js":
/*!********************************************!*\
  !*** ./node_modules/@noble/hashes/sha2.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.sha512_224 = exports.sha512_256 = exports.sha384 = exports.sha512 = exports.sha224 = exports.sha256 = exports.SHA512_256 = exports.SHA512_224 = exports.SHA384 = exports.SHA512 = exports.SHA224 = exports.SHA256 = void 0;
/**
 * SHA2 hash function. A.k.a. sha256, sha384, sha512, sha512_224, sha512_256.
 * SHA256 is the fastest hash implementable in JS, even faster than Blake3.
 * Check out [RFC 4634](https://datatracker.ietf.org/doc/html/rfc4634) and
 * [FIPS 180-4](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf).
 * @module
 */
const _md_ts_1 = __webpack_require__(/*! ./_md.js */ "./node_modules/@noble/hashes/_md.js");
const u64 = __webpack_require__(/*! ./_u64.js */ "./node_modules/@noble/hashes/_u64.js");
const utils_ts_1 = __webpack_require__(/*! ./utils.js */ "./node_modules/@noble/hashes/utils.js");
/**
 * Round constants:
 * First 32 bits of fractional parts of the cube roots of the first 64 primes 2..311)
 */
// prettier-ignore
const SHA256_K = /* @__PURE__ */ Uint32Array.from([
    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
]);
/** Reusable temporary buffer. "W" comes straight from spec. */
const SHA256_W = /* @__PURE__ */ new Uint32Array(64);
class SHA256 extends _md_ts_1.HashMD {
    constructor(outputLen = 32) {
        super(64, outputLen, 8, false);
        // We cannot use array here since array allows indexing by variable
        // which means optimizer/compiler cannot use registers.
        this.A = _md_ts_1.SHA256_IV[0] | 0;
        this.B = _md_ts_1.SHA256_IV[1] | 0;
        this.C = _md_ts_1.SHA256_IV[2] | 0;
        this.D = _md_ts_1.SHA256_IV[3] | 0;
        this.E = _md_ts_1.SHA256_IV[4] | 0;
        this.F = _md_ts_1.SHA256_IV[5] | 0;
        this.G = _md_ts_1.SHA256_IV[6] | 0;
        this.H = _md_ts_1.SHA256_IV[7] | 0;
    }
    get() {
        const { A, B, C, D, E, F, G, H } = this;
        return [A, B, C, D, E, F, G, H];
    }
    // prettier-ignore
    set(A, B, C, D, E, F, G, H) {
        this.A = A | 0;
        this.B = B | 0;
        this.C = C | 0;
        this.D = D | 0;
        this.E = E | 0;
        this.F = F | 0;
        this.G = G | 0;
        this.H = H | 0;
    }
    process(view, offset) {
        // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array
        for (let i = 0; i < 16; i++, offset += 4)
            SHA256_W[i] = view.getUint32(offset, false);
        for (let i = 16; i < 64; i++) {
            const W15 = SHA256_W[i - 15];
            const W2 = SHA256_W[i - 2];
            const s0 = (0, utils_ts_1.rotr)(W15, 7) ^ (0, utils_ts_1.rotr)(W15, 18) ^ (W15 >>> 3);
            const s1 = (0, utils_ts_1.rotr)(W2, 17) ^ (0, utils_ts_1.rotr)(W2, 19) ^ (W2 >>> 10);
            SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;
        }
        // Compression function main loop, 64 rounds
        let { A, B, C, D, E, F, G, H } = this;
        for (let i = 0; i < 64; i++) {
            const sigma1 = (0, utils_ts_1.rotr)(E, 6) ^ (0, utils_ts_1.rotr)(E, 11) ^ (0, utils_ts_1.rotr)(E, 25);
            const T1 = (H + sigma1 + (0, _md_ts_1.Chi)(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;
            const sigma0 = (0, utils_ts_1.rotr)(A, 2) ^ (0, utils_ts_1.rotr)(A, 13) ^ (0, utils_ts_1.rotr)(A, 22);
            const T2 = (sigma0 + (0, _md_ts_1.Maj)(A, B, C)) | 0;
            H = G;
            G = F;
            F = E;
            E = (D + T1) | 0;
            D = C;
            C = B;
            B = A;
            A = (T1 + T2) | 0;
        }
        // Add the compressed chunk to the current hash value
        A = (A + this.A) | 0;
        B = (B + this.B) | 0;
        C = (C + this.C) | 0;
        D = (D + this.D) | 0;
        E = (E + this.E) | 0;
        F = (F + this.F) | 0;
        G = (G + this.G) | 0;
        H = (H + this.H) | 0;
        this.set(A, B, C, D, E, F, G, H);
    }
    roundClean() {
        (0, utils_ts_1.clean)(SHA256_W);
    }
    destroy() {
        this.set(0, 0, 0, 0, 0, 0, 0, 0);
        (0, utils_ts_1.clean)(this.buffer);
    }
}
exports.SHA256 = SHA256;
class SHA224 extends SHA256 {
    constructor() {
        super(28);
        this.A = _md_ts_1.SHA224_IV[0] | 0;
        this.B = _md_ts_1.SHA224_IV[1] | 0;
        this.C = _md_ts_1.SHA224_IV[2] | 0;
        this.D = _md_ts_1.SHA224_IV[3] | 0;
        this.E = _md_ts_1.SHA224_IV[4] | 0;
        this.F = _md_ts_1.SHA224_IV[5] | 0;
        this.G = _md_ts_1.SHA224_IV[6] | 0;
        this.H = _md_ts_1.SHA224_IV[7] | 0;
    }
}
exports.SHA224 = SHA224;
// SHA2-512 is slower than sha256 in js because u64 operations are slow.
// Round contants
// First 32 bits of the fractional parts of the cube roots of the first 80 primes 2..409
// prettier-ignore
const K512 = /* @__PURE__ */ (() => u64.split([
    '0x428a2f98d728ae22', '0x7137449123ef65cd', '0xb5c0fbcfec4d3b2f', '0xe9b5dba58189dbbc',
    '0x3956c25bf348b538', '0x59f111f1b605d019', '0x923f82a4af194f9b', '0xab1c5ed5da6d8118',
    '0xd807aa98a3030242', '0x12835b0145706fbe', '0x243185be4ee4b28c', '0x550c7dc3d5ffb4e2',
    '0x72be5d74f27b896f', '0x80deb1fe3b1696b1', '0x9bdc06a725c71235', '0xc19bf174cf692694',
    '0xe49b69c19ef14ad2', '0xefbe4786384f25e3', '0x0fc19dc68b8cd5b5', '0x240ca1cc77ac9c65',
    '0x2de92c6f592b0275', '0x4a7484aa6ea6e483', '0x5cb0a9dcbd41fbd4', '0x76f988da831153b5',
    '0x983e5152ee66dfab', '0xa831c66d2db43210', '0xb00327c898fb213f', '0xbf597fc7beef0ee4',
    '0xc6e00bf33da88fc2', '0xd5a79147930aa725', '0x06ca6351e003826f', '0x142929670a0e6e70',
    '0x27b70a8546d22ffc', '0x2e1b21385c26c926', '0x4d2c6dfc5ac42aed', '0x53380d139d95b3df',
    '0x650a73548baf63de', '0x766a0abb3c77b2a8', '0x81c2c92e47edaee6', '0x92722c851482353b',
    '0xa2bfe8a14cf10364', '0xa81a664bbc423001', '0xc24b8b70d0f89791', '0xc76c51a30654be30',
    '0xd192e819d6ef5218', '0xd69906245565a910', '0xf40e35855771202a', '0x106aa07032bbd1b8',
    '0x19a4c116b8d2d0c8', '0x1e376c085141ab53', '0x2748774cdf8eeb99', '0x34b0bcb5e19b48a8',
    '0x391c0cb3c5c95a63', '0x4ed8aa4ae3418acb', '0x5b9cca4f7763e373', '0x682e6ff3d6b2b8a3',
    '0x748f82ee5defb2fc', '0x78a5636f43172f60', '0x84c87814a1f0ab72', '0x8cc702081a6439ec',
    '0x90befffa23631e28', '0xa4506cebde82bde9', '0xbef9a3f7b2c67915', '0xc67178f2e372532b',
    '0xca273eceea26619c', '0xd186b8c721c0c207', '0xeada7dd6cde0eb1e', '0xf57d4f7fee6ed178',
    '0x06f067aa72176fba', '0x0a637dc5a2c898a6', '0x113f9804bef90dae', '0x1b710b35131c471b',
    '0x28db77f523047d84', '0x32caab7b40c72493', '0x3c9ebe0a15c9bebc', '0x431d67c49c100d4c',
    '0x4cc5d4becb3e42b6', '0x597f299cfc657e2a', '0x5fcb6fab3ad6faec', '0x6c44198c4a475817'
].map(n => BigInt(n))))();
const SHA512_Kh = /* @__PURE__ */ (() => K512[0])();
const SHA512_Kl = /* @__PURE__ */ (() => K512[1])();
// Reusable temporary buffers
const SHA512_W_H = /* @__PURE__ */ new Uint32Array(80);
const SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);
class SHA512 extends _md_ts_1.HashMD {
    constructor(outputLen = 64) {
        super(128, outputLen, 16, false);
        // We cannot use array here since array allows indexing by variable
        // which means optimizer/compiler cannot use registers.
        // h -- high 32 bits, l -- low 32 bits
        this.Ah = _md_ts_1.SHA512_IV[0] | 0;
        this.Al = _md_ts_1.SHA512_IV[1] | 0;
        this.Bh = _md_ts_1.SHA512_IV[2] | 0;
        this.Bl = _md_ts_1.SHA512_IV[3] | 0;
        this.Ch = _md_ts_1.SHA512_IV[4] | 0;
        this.Cl = _md_ts_1.SHA512_IV[5] | 0;
        this.Dh = _md_ts_1.SHA512_IV[6] | 0;
        this.Dl = _md_ts_1.SHA512_IV[7] | 0;
        this.Eh = _md_ts_1.SHA512_IV[8] | 0;
        this.El = _md_ts_1.SHA512_IV[9] | 0;
        this.Fh = _md_ts_1.SHA512_IV[10] | 0;
        this.Fl = _md_ts_1.SHA512_IV[11] | 0;
        this.Gh = _md_ts_1.SHA512_IV[12] | 0;
        this.Gl = _md_ts_1.SHA512_IV[13] | 0;
        this.Hh = _md_ts_1.SHA512_IV[14] | 0;
        this.Hl = _md_ts_1.SHA512_IV[15] | 0;
    }
    // prettier-ignore
    get() {
        const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
        return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];
    }
    // prettier-ignore
    set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {
        this.Ah = Ah | 0;
        this.Al = Al | 0;
        this.Bh = Bh | 0;
        this.Bl = Bl | 0;
        this.Ch = Ch | 0;
        this.Cl = Cl | 0;
        this.Dh = Dh | 0;
        this.Dl = Dl | 0;
        this.Eh = Eh | 0;
        this.El = El | 0;
        this.Fh = Fh | 0;
        this.Fl = Fl | 0;
        this.Gh = Gh | 0;
        this.Gl = Gl | 0;
        this.Hh = Hh | 0;
        this.Hl = Hl | 0;
    }
    process(view, offset) {
        // Extend the first 16 words into the remaining 64 words w[16..79] of the message schedule array
        for (let i = 0; i < 16; i++, offset += 4) {
            SHA512_W_H[i] = view.getUint32(offset);
            SHA512_W_L[i] = view.getUint32((offset += 4));
        }
        for (let i = 16; i < 80; i++) {
            // s0 := (w[i-15] rightrotate 1) xor (w[i-15] rightrotate 8) xor (w[i-15] rightshift 7)
            const W15h = SHA512_W_H[i - 15] | 0;
            const W15l = SHA512_W_L[i - 15] | 0;
            const s0h = u64.rotrSH(W15h, W15l, 1) ^ u64.rotrSH(W15h, W15l, 8) ^ u64.shrSH(W15h, W15l, 7);
            const s0l = u64.rotrSL(W15h, W15l, 1) ^ u64.rotrSL(W15h, W15l, 8) ^ u64.shrSL(W15h, W15l, 7);
            // s1 := (w[i-2] rightrotate 19) xor (w[i-2] rightrotate 61) xor (w[i-2] rightshift 6)
            const W2h = SHA512_W_H[i - 2] | 0;
            const W2l = SHA512_W_L[i - 2] | 0;
            const s1h = u64.rotrSH(W2h, W2l, 19) ^ u64.rotrBH(W2h, W2l, 61) ^ u64.shrSH(W2h, W2l, 6);
            const s1l = u64.rotrSL(W2h, W2l, 19) ^ u64.rotrBL(W2h, W2l, 61) ^ u64.shrSL(W2h, W2l, 6);
            // SHA256_W[i] = s0 + s1 + SHA256_W[i - 7] + SHA256_W[i - 16];
            const SUMl = u64.add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);
            const SUMh = u64.add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);
            SHA512_W_H[i] = SUMh | 0;
            SHA512_W_L[i] = SUMl | 0;
        }
        let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
        // Compression function main loop, 80 rounds
        for (let i = 0; i < 80; i++) {
            // S1 := (e rightrotate 14) xor (e rightrotate 18) xor (e rightrotate 41)
            const sigma1h = u64.rotrSH(Eh, El, 14) ^ u64.rotrSH(Eh, El, 18) ^ u64.rotrBH(Eh, El, 41);
            const sigma1l = u64.rotrSL(Eh, El, 14) ^ u64.rotrSL(Eh, El, 18) ^ u64.rotrBL(Eh, El, 41);
            //const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;
            const CHIh = (Eh & Fh) ^ (~Eh & Gh);
            const CHIl = (El & Fl) ^ (~El & Gl);
            // T1 = H + sigma1 + Chi(E, F, G) + SHA512_K[i] + SHA512_W[i]
            // prettier-ignore
            const T1ll = u64.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);
            const T1h = u64.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);
            const T1l = T1ll | 0;
            // S0 := (a rightrotate 28) xor (a rightrotate 34) xor (a rightrotate 39)
            const sigma0h = u64.rotrSH(Ah, Al, 28) ^ u64.rotrBH(Ah, Al, 34) ^ u64.rotrBH(Ah, Al, 39);
            const sigma0l = u64.rotrSL(Ah, Al, 28) ^ u64.rotrBL(Ah, Al, 34) ^ u64.rotrBL(Ah, Al, 39);
            const MAJh = (Ah & Bh) ^ (Ah & Ch) ^ (Bh & Ch);
            const MAJl = (Al & Bl) ^ (Al & Cl) ^ (Bl & Cl);
            Hh = Gh | 0;
            Hl = Gl | 0;
            Gh = Fh | 0;
            Gl = Fl | 0;
            Fh = Eh | 0;
            Fl = El | 0;
            ({ h: Eh, l: El } = u64.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));
            Dh = Ch | 0;
            Dl = Cl | 0;
            Ch = Bh | 0;
            Cl = Bl | 0;
            Bh = Ah | 0;
            Bl = Al | 0;
            const All = u64.add3L(T1l, sigma0l, MAJl);
            Ah = u64.add3H(All, T1h, sigma0h, MAJh);
            Al = All | 0;
        }
        // Add the compressed chunk to the current hash value
        ({ h: Ah, l: Al } = u64.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));
        ({ h: Bh, l: Bl } = u64.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));
        ({ h: Ch, l: Cl } = u64.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));
        ({ h: Dh, l: Dl } = u64.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));
        ({ h: Eh, l: El } = u64.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));
        ({ h: Fh, l: Fl } = u64.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));
        ({ h: Gh, l: Gl } = u64.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));
        ({ h: Hh, l: Hl } = u64.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));
        this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);
    }
    roundClean() {
        (0, utils_ts_1.clean)(SHA512_W_H, SHA512_W_L);
    }
    destroy() {
        (0, utils_ts_1.clean)(this.buffer);
        this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    }
}
exports.SHA512 = SHA512;
class SHA384 extends SHA512 {
    constructor() {
        super(48);
        this.Ah = _md_ts_1.SHA384_IV[0] | 0;
        this.Al = _md_ts_1.SHA384_IV[1] | 0;
        this.Bh = _md_ts_1.SHA384_IV[2] | 0;
        this.Bl = _md_ts_1.SHA384_IV[3] | 0;
        this.Ch = _md_ts_1.SHA384_IV[4] | 0;
        this.Cl = _md_ts_1.SHA384_IV[5] | 0;
        this.Dh = _md_ts_1.SHA384_IV[6] | 0;
        this.Dl = _md_ts_1.SHA384_IV[7] | 0;
        this.Eh = _md_ts_1.SHA384_IV[8] | 0;
        this.El = _md_ts_1.SHA384_IV[9] | 0;
        this.Fh = _md_ts_1.SHA384_IV[10] | 0;
        this.Fl = _md_ts_1.SHA384_IV[11] | 0;
        this.Gh = _md_ts_1.SHA384_IV[12] | 0;
        this.Gl = _md_ts_1.SHA384_IV[13] | 0;
        this.Hh = _md_ts_1.SHA384_IV[14] | 0;
        this.Hl = _md_ts_1.SHA384_IV[15] | 0;
    }
}
exports.SHA384 = SHA384;
/**
 * Truncated SHA512/256 and SHA512/224.
 * SHA512_IV is XORed with 0xa5a5a5a5a5a5a5a5, then used as "intermediary" IV of SHA512/t.
 * Then t hashes string to produce result IV.
 * See `test/misc/sha2-gen-iv.js`.
 */
/** SHA512/224 IV */
const T224_IV = /* @__PURE__ */ Uint32Array.from([
    0x8c3d37c8, 0x19544da2, 0x73e19966, 0x89dcd4d6, 0x1dfab7ae, 0x32ff9c82, 0x679dd514, 0x582f9fcf,
    0x0f6d2b69, 0x7bd44da8, 0x77e36f73, 0x04c48942, 0x3f9d85a8, 0x6a1d36c8, 0x1112e6ad, 0x91d692a1,
]);
/** SHA512/256 IV */
const T256_IV = /* @__PURE__ */ Uint32Array.from([
    0x22312194, 0xfc2bf72c, 0x9f555fa3, 0xc84c64c2, 0x2393b86b, 0x6f53b151, 0x96387719, 0x5940eabd,
    0x96283ee2, 0xa88effe3, 0xbe5e1e25, 0x53863992, 0x2b0199fc, 0x2c85b8aa, 0x0eb72ddc, 0x81c52ca2,
]);
class SHA512_224 extends SHA512 {
    constructor() {
        super(28);
        this.Ah = T224_IV[0] | 0;
        this.Al = T224_IV[1] | 0;
        this.Bh = T224_IV[2] | 0;
        this.Bl = T224_IV[3] | 0;
        this.Ch = T224_IV[4] | 0;
        this.Cl = T224_IV[5] | 0;
        this.Dh = T224_IV[6] | 0;
        this.Dl = T224_IV[7] | 0;
        this.Eh = T224_IV[8] | 0;
        this.El = T224_IV[9] | 0;
        this.Fh = T224_IV[10] | 0;
        this.Fl = T224_IV[11] | 0;
        this.Gh = T224_IV[12] | 0;
        this.Gl = T224_IV[13] | 0;
        this.Hh = T224_IV[14] | 0;
        this.Hl = T224_IV[15] | 0;
    }
}
exports.SHA512_224 = SHA512_224;
class SHA512_256 extends SHA512 {
    constructor() {
        super(32);
        this.Ah = T256_IV[0] | 0;
        this.Al = T256_IV[1] | 0;
        this.Bh = T256_IV[2] | 0;
        this.Bl = T256_IV[3] | 0;
        this.Ch = T256_IV[4] | 0;
        this.Cl = T256_IV[5] | 0;
        this.Dh = T256_IV[6] | 0;
        this.Dl = T256_IV[7] | 0;
        this.Eh = T256_IV[8] | 0;
        this.El = T256_IV[9] | 0;
        this.Fh = T256_IV[10] | 0;
        this.Fl = T256_IV[11] | 0;
        this.Gh = T256_IV[12] | 0;
        this.Gl = T256_IV[13] | 0;
        this.Hh = T256_IV[14] | 0;
        this.Hl = T256_IV[15] | 0;
    }
}
exports.SHA512_256 = SHA512_256;
/**
 * SHA2-256 hash function from RFC 4634.
 *
 * It is the fastest JS hash, even faster than Blake3.
 * To break sha256 using birthday attack, attackers need to try 2^128 hashes.
 * BTC network is doing 2^70 hashes/sec (2^95 hashes/year) as per 2025.
 */
exports.sha256 = (0, utils_ts_1.createHasher)(() => new SHA256());
/** SHA2-224 hash function from RFC 4634 */
exports.sha224 = (0, utils_ts_1.createHasher)(() => new SHA224());
/** SHA2-512 hash function from RFC 4634. */
exports.sha512 = (0, utils_ts_1.createHasher)(() => new SHA512());
/** SHA2-384 hash function from RFC 4634. */
exports.sha384 = (0, utils_ts_1.createHasher)(() => new SHA384());
/**
 * SHA2-512/256 "truncated" hash function, with improved resistance to length extension attacks.
 * See the paper on [truncated SHA512](https://eprint.iacr.org/2010/548.pdf).
 */
exports.sha512_256 = (0, utils_ts_1.createHasher)(() => new SHA512_256());
/**
 * SHA2-512/224 "truncated" hash function, with improved resistance to length extension attacks.
 * See the paper on [truncated SHA512](https://eprint.iacr.org/2010/548.pdf).
 */
exports.sha512_224 = (0, utils_ts_1.createHasher)(() => new SHA512_224());
//# sourceMappingURL=sha2.js.map

/***/ }),

/***/ "./node_modules/@noble/hashes/sha256.js":
/*!**********************************************!*\
  !*** ./node_modules/@noble/hashes/sha256.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.sha224 = exports.SHA224 = exports.sha256 = exports.SHA256 = void 0;
/**
 * SHA2-256 a.k.a. sha256. In JS, it is the fastest hash, even faster than Blake3.
 *
 * To break sha256 using birthday attack, attackers need to try 2^128 hashes.
 * BTC network is doing 2^70 hashes/sec (2^95 hashes/year) as per 2025.
 *
 * Check out [FIPS 180-4](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf).
 * @module
 * @deprecated
 */
const sha2_ts_1 = __webpack_require__(/*! ./sha2.js */ "./node_modules/@noble/hashes/sha2.js");
/** @deprecated Use import from `noble/hashes/sha2` module */
exports.SHA256 = sha2_ts_1.SHA256;
/** @deprecated Use import from `noble/hashes/sha2` module */
exports.sha256 = sha2_ts_1.sha256;
/** @deprecated Use import from `noble/hashes/sha2` module */
exports.SHA224 = sha2_ts_1.SHA224;
/** @deprecated Use import from `noble/hashes/sha2` module */
exports.sha224 = sha2_ts_1.sha224;
//# sourceMappingURL=sha256.js.map

/***/ }),

/***/ "./node_modules/@noble/hashes/sha3.js":
/*!********************************************!*\
  !*** ./node_modules/@noble/hashes/sha3.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.shake256 = exports.shake128 = exports.keccak_512 = exports.keccak_384 = exports.keccak_256 = exports.keccak_224 = exports.sha3_512 = exports.sha3_384 = exports.sha3_256 = exports.sha3_224 = exports.Keccak = void 0;
exports.keccakP = keccakP;
/**
 * SHA3 (keccak) hash function, based on a new "Sponge function" design.
 * Different from older hashes, the internal state is bigger than output size.
 *
 * Check out [FIPS-202](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.202.pdf),
 * [Website](https://keccak.team/keccak.html),
 * [the differences between SHA-3 and Keccak](https://crypto.stackexchange.com/questions/15727/what-are-the-key-differences-between-the-draft-sha-3-standard-and-the-keccak-sub).
 *
 * Check out `sha3-addons` module for cSHAKE, k12, and others.
 * @module
 */
const _u64_ts_1 = __webpack_require__(/*! ./_u64.js */ "./node_modules/@noble/hashes/_u64.js");
// prettier-ignore
const utils_ts_1 = __webpack_require__(/*! ./utils.js */ "./node_modules/@noble/hashes/utils.js");
// No __PURE__ annotations in sha3 header:
// EVERYTHING is in fact used on every export.
// Various per round constants calculations
const _0n = BigInt(0);
const _1n = BigInt(1);
const _2n = BigInt(2);
const _7n = BigInt(7);
const _256n = BigInt(256);
const _0x71n = BigInt(0x71);
const SHA3_PI = [];
const SHA3_ROTL = [];
const _SHA3_IOTA = [];
for (let round = 0, R = _1n, x = 1, y = 0; round < 24; round++) {
    // Pi
    [x, y] = [y, (2 * x + 3 * y) % 5];
    SHA3_PI.push(2 * (5 * y + x));
    // Rotational
    SHA3_ROTL.push((((round + 1) * (round + 2)) / 2) % 64);
    // Iota
    let t = _0n;
    for (let j = 0; j < 7; j++) {
        R = ((R << _1n) ^ ((R >> _7n) * _0x71n)) % _256n;
        if (R & _2n)
            t ^= _1n << ((_1n << /* @__PURE__ */ BigInt(j)) - _1n);
    }
    _SHA3_IOTA.push(t);
}
const IOTAS = (0, _u64_ts_1.split)(_SHA3_IOTA, true);
const SHA3_IOTA_H = IOTAS[0];
const SHA3_IOTA_L = IOTAS[1];
// Left rotation (without 0, 32, 64)
const rotlH = (h, l, s) => (s > 32 ? (0, _u64_ts_1.rotlBH)(h, l, s) : (0, _u64_ts_1.rotlSH)(h, l, s));
const rotlL = (h, l, s) => (s > 32 ? (0, _u64_ts_1.rotlBL)(h, l, s) : (0, _u64_ts_1.rotlSL)(h, l, s));
/** `keccakf1600` internal function, additionally allows to adjust round count. */
function keccakP(s, rounds = 24) {
    const B = new Uint32Array(5 * 2);
    // NOTE: all indices are x2 since we store state as u32 instead of u64 (bigints to slow in js)
    for (let round = 24 - rounds; round < 24; round++) {
        // Theta θ
        for (let x = 0; x < 10; x++)
            B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];
        for (let x = 0; x < 10; x += 2) {
            const idx1 = (x + 8) % 10;
            const idx0 = (x + 2) % 10;
            const B0 = B[idx0];
            const B1 = B[idx0 + 1];
            const Th = rotlH(B0, B1, 1) ^ B[idx1];
            const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];
            for (let y = 0; y < 50; y += 10) {
                s[x + y] ^= Th;
                s[x + y + 1] ^= Tl;
            }
        }
        // Rho (ρ) and Pi (π)
        let curH = s[2];
        let curL = s[3];
        for (let t = 0; t < 24; t++) {
            const shift = SHA3_ROTL[t];
            const Th = rotlH(curH, curL, shift);
            const Tl = rotlL(curH, curL, shift);
            const PI = SHA3_PI[t];
            curH = s[PI];
            curL = s[PI + 1];
            s[PI] = Th;
            s[PI + 1] = Tl;
        }
        // Chi (χ)
        for (let y = 0; y < 50; y += 10) {
            for (let x = 0; x < 10; x++)
                B[x] = s[y + x];
            for (let x = 0; x < 10; x++)
                s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];
        }
        // Iota (ι)
        s[0] ^= SHA3_IOTA_H[round];
        s[1] ^= SHA3_IOTA_L[round];
    }
    (0, utils_ts_1.clean)(B);
}
/** Keccak sponge function. */
class Keccak extends utils_ts_1.Hash {
    // NOTE: we accept arguments in bytes instead of bits here.
    constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {
        super();
        this.pos = 0;
        this.posOut = 0;
        this.finished = false;
        this.destroyed = false;
        this.enableXOF = false;
        this.blockLen = blockLen;
        this.suffix = suffix;
        this.outputLen = outputLen;
        this.enableXOF = enableXOF;
        this.rounds = rounds;
        // Can be passed from user as dkLen
        (0, utils_ts_1.anumber)(outputLen);
        // 1600 = 5x5 matrix of 64bit.  1600 bits === 200 bytes
        // 0 < blockLen < 200
        if (!(0 < blockLen && blockLen < 200))
            throw new Error('only keccak-f1600 function is supported');
        this.state = new Uint8Array(200);
        this.state32 = (0, utils_ts_1.u32)(this.state);
    }
    clone() {
        return this._cloneInto();
    }
    keccak() {
        (0, utils_ts_1.swap32IfBE)(this.state32);
        keccakP(this.state32, this.rounds);
        (0, utils_ts_1.swap32IfBE)(this.state32);
        this.posOut = 0;
        this.pos = 0;
    }
    update(data) {
        (0, utils_ts_1.aexists)(this);
        data = (0, utils_ts_1.toBytes)(data);
        (0, utils_ts_1.abytes)(data);
        const { blockLen, state } = this;
        const len = data.length;
        for (let pos = 0; pos < len;) {
            const take = Math.min(blockLen - this.pos, len - pos);
            for (let i = 0; i < take; i++)
                state[this.pos++] ^= data[pos++];
            if (this.pos === blockLen)
                this.keccak();
        }
        return this;
    }
    finish() {
        if (this.finished)
            return;
        this.finished = true;
        const { state, suffix, pos, blockLen } = this;
        // Do the padding
        state[pos] ^= suffix;
        if ((suffix & 0x80) !== 0 && pos === blockLen - 1)
            this.keccak();
        state[blockLen - 1] ^= 0x80;
        this.keccak();
    }
    writeInto(out) {
        (0, utils_ts_1.aexists)(this, false);
        (0, utils_ts_1.abytes)(out);
        this.finish();
        const bufferOut = this.state;
        const { blockLen } = this;
        for (let pos = 0, len = out.length; pos < len;) {
            if (this.posOut >= blockLen)
                this.keccak();
            const take = Math.min(blockLen - this.posOut, len - pos);
            out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
            this.posOut += take;
            pos += take;
        }
        return out;
    }
    xofInto(out) {
        // Sha3/Keccak usage with XOF is probably mistake, only SHAKE instances can do XOF
        if (!this.enableXOF)
            throw new Error('XOF is not possible for this instance');
        return this.writeInto(out);
    }
    xof(bytes) {
        (0, utils_ts_1.anumber)(bytes);
        return this.xofInto(new Uint8Array(bytes));
    }
    digestInto(out) {
        (0, utils_ts_1.aoutput)(out, this);
        if (this.finished)
            throw new Error('digest() was already called');
        this.writeInto(out);
        this.destroy();
        return out;
    }
    digest() {
        return this.digestInto(new Uint8Array(this.outputLen));
    }
    destroy() {
        this.destroyed = true;
        (0, utils_ts_1.clean)(this.state);
    }
    _cloneInto(to) {
        const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
        to || (to = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds));
        to.state32.set(this.state32);
        to.pos = this.pos;
        to.posOut = this.posOut;
        to.finished = this.finished;
        to.rounds = rounds;
        // Suffix can change in cSHAKE
        to.suffix = suffix;
        to.outputLen = outputLen;
        to.enableXOF = enableXOF;
        to.destroyed = this.destroyed;
        return to;
    }
}
exports.Keccak = Keccak;
const gen = (suffix, blockLen, outputLen) => (0, utils_ts_1.createHasher)(() => new Keccak(blockLen, suffix, outputLen));
/** SHA3-224 hash function. */
exports.sha3_224 = (() => gen(0x06, 144, 224 / 8))();
/** SHA3-256 hash function. Different from keccak-256. */
exports.sha3_256 = (() => gen(0x06, 136, 256 / 8))();
/** SHA3-384 hash function. */
exports.sha3_384 = (() => gen(0x06, 104, 384 / 8))();
/** SHA3-512 hash function. */
exports.sha3_512 = (() => gen(0x06, 72, 512 / 8))();
/** keccak-224 hash function. */
exports.keccak_224 = (() => gen(0x01, 144, 224 / 8))();
/** keccak-256 hash function. Different from SHA3-256. */
exports.keccak_256 = (() => gen(0x01, 136, 256 / 8))();
/** keccak-384 hash function. */
exports.keccak_384 = (() => gen(0x01, 104, 384 / 8))();
/** keccak-512 hash function. */
exports.keccak_512 = (() => gen(0x01, 72, 512 / 8))();
const genShake = (suffix, blockLen, outputLen) => (0, utils_ts_1.createXOFer)((opts = {}) => new Keccak(blockLen, suffix, opts.dkLen === undefined ? outputLen : opts.dkLen, true));
/** SHAKE128 XOF with 128-bit security. */
exports.shake128 = (() => genShake(0x1f, 168, 128 / 8))();
/** SHAKE256 XOF with 256-bit security. */
exports.shake256 = (() => genShake(0x1f, 136, 256 / 8))();
//# sourceMappingURL=sha3.js.map

/***/ }),

/***/ "./node_modules/@noble/hashes/utils.js":
/*!*********************************************!*\
  !*** ./node_modules/@noble/hashes/utils.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/**
 * Utilities for hex, bytes, CSPRNG.
 * @module
 */
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.wrapXOFConstructorWithOpts = exports.wrapConstructorWithOpts = exports.wrapConstructor = exports.Hash = exports.nextTick = exports.swap32IfBE = exports.byteSwapIfBE = exports.swap8IfBE = exports.isLE = void 0;
exports.isBytes = isBytes;
exports.anumber = anumber;
exports.abytes = abytes;
exports.ahash = ahash;
exports.aexists = aexists;
exports.aoutput = aoutput;
exports.u8 = u8;
exports.u32 = u32;
exports.clean = clean;
exports.createView = createView;
exports.rotr = rotr;
exports.rotl = rotl;
exports.byteSwap = byteSwap;
exports.byteSwap32 = byteSwap32;
exports.bytesToHex = bytesToHex;
exports.hexToBytes = hexToBytes;
exports.asyncLoop = asyncLoop;
exports.utf8ToBytes = utf8ToBytes;
exports.bytesToUtf8 = bytesToUtf8;
exports.toBytes = toBytes;
exports.kdfInputToBytes = kdfInputToBytes;
exports.concatBytes = concatBytes;
exports.checkOpts = checkOpts;
exports.createHasher = createHasher;
exports.createOptHasher = createOptHasher;
exports.createXOFer = createXOFer;
exports.randomBytes = randomBytes;
// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.
// node.js versions earlier than v19 don't declare it in global scope.
// For node.js, package.json#exports field mapping rewrites import
// from `crypto` to `cryptoNode`, which imports native module.
// Makes the utils un-importable in browsers without a bundler.
// Once node.js 18 is deprecated (2025-04-30), we can just drop the import.
const crypto_1 = __webpack_require__(/*! @noble/hashes/crypto */ "./node_modules/@noble/hashes/crypto.js");
/** Checks if something is Uint8Array. Be careful: nodejs Buffer will return true. */
function isBytes(a) {
    return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');
}
/** Asserts something is positive integer. */
function anumber(n) {
    if (!Number.isSafeInteger(n) || n < 0)
        throw new Error('positive integer expected, got ' + n);
}
/** Asserts something is Uint8Array. */
function abytes(b, ...lengths) {
    if (!isBytes(b))
        throw new Error('Uint8Array expected');
    if (lengths.length > 0 && !lengths.includes(b.length))
        throw new Error('Uint8Array expected of length ' + lengths + ', got length=' + b.length);
}
/** Asserts something is hash */
function ahash(h) {
    if (typeof h !== 'function' || typeof h.create !== 'function')
        throw new Error('Hash should be wrapped by utils.createHasher');
    anumber(h.outputLen);
    anumber(h.blockLen);
}
/** Asserts a hash instance has not been destroyed / finished */
function aexists(instance, checkFinished = true) {
    if (instance.destroyed)
        throw new Error('Hash instance has been destroyed');
    if (checkFinished && instance.finished)
        throw new Error('Hash#digest() has already been called');
}
/** Asserts output is properly-sized byte array */
function aoutput(out, instance) {
    abytes(out);
    const min = instance.outputLen;
    if (out.length < min) {
        throw new Error('digestInto() expects output buffer of length at least ' + min);
    }
}
/** Cast u8 / u16 / u32 to u8. */
function u8(arr) {
    return new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
}
/** Cast u8 / u16 / u32 to u32. */
function u32(arr) {
    return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
}
/** Zeroize a byte array. Warning: JS provides no guarantees. */
function clean(...arrays) {
    for (let i = 0; i < arrays.length; i++) {
        arrays[i].fill(0);
    }
}
/** Create DataView of an array for easy byte-level manipulation. */
function createView(arr) {
    return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
}
/** The rotate right (circular right shift) operation for uint32 */
function rotr(word, shift) {
    return (word << (32 - shift)) | (word >>> shift);
}
/** The rotate left (circular left shift) operation for uint32 */
function rotl(word, shift) {
    return (word << shift) | ((word >>> (32 - shift)) >>> 0);
}
/** Is current platform little-endian? Most are. Big-Endian platform: IBM */
exports.isLE = (() => new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44)();
/** The byte swap operation for uint32 */
function byteSwap(word) {
    return (((word << 24) & 0xff000000) |
        ((word << 8) & 0xff0000) |
        ((word >>> 8) & 0xff00) |
        ((word >>> 24) & 0xff));
}
/** Conditionally byte swap if on a big-endian platform */
exports.swap8IfBE = exports.isLE
    ? (n) => n
    : (n) => byteSwap(n);
/** @deprecated */
exports.byteSwapIfBE = exports.swap8IfBE;
/** In place byte swap for Uint32Array */
function byteSwap32(arr) {
    for (let i = 0; i < arr.length; i++) {
        arr[i] = byteSwap(arr[i]);
    }
    return arr;
}
exports.swap32IfBE = exports.isLE
    ? (u) => u
    : byteSwap32;
// Built-in hex conversion https://caniuse.com/mdn-javascript_builtins_uint8array_fromhex
const hasHexBuiltin = /* @__PURE__ */ (() => 
// @ts-ignore
typeof Uint8Array.from([]).toHex === 'function' && typeof Uint8Array.fromHex === 'function')();
// Array where index 0xf0 (240) is mapped to string 'f0'
const hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));
/**
 * Convert byte array to hex string. Uses built-in function, when available.
 * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'
 */
function bytesToHex(bytes) {
    abytes(bytes);
    // @ts-ignore
    if (hasHexBuiltin)
        return bytes.toHex();
    // pre-caching improves the speed 6x
    let hex = '';
    for (let i = 0; i < bytes.length; i++) {
        hex += hexes[bytes[i]];
    }
    return hex;
}
// We use optimized technique to convert hex string to byte array
const asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
function asciiToBase16(ch) {
    if (ch >= asciis._0 && ch <= asciis._9)
        return ch - asciis._0; // '2' => 50-48
    if (ch >= asciis.A && ch <= asciis.F)
        return ch - (asciis.A - 10); // 'B' => 66-(65-10)
    if (ch >= asciis.a && ch <= asciis.f)
        return ch - (asciis.a - 10); // 'b' => 98-(97-10)
    return;
}
/**
 * Convert hex string to byte array. Uses built-in function, when available.
 * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])
 */
function hexToBytes(hex) {
    if (typeof hex !== 'string')
        throw new Error('hex string expected, got ' + typeof hex);
    // @ts-ignore
    if (hasHexBuiltin)
        return Uint8Array.fromHex(hex);
    const hl = hex.length;
    const al = hl / 2;
    if (hl % 2)
        throw new Error('hex string expected, got unpadded hex of length ' + hl);
    const array = new Uint8Array(al);
    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
        const n1 = asciiToBase16(hex.charCodeAt(hi));
        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));
        if (n1 === undefined || n2 === undefined) {
            const char = hex[hi] + hex[hi + 1];
            throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
        }
        array[ai] = n1 * 16 + n2; // multiply first octet, e.g. 'a3' => 10*16+3 => 160 + 3 => 163
    }
    return array;
}
/**
 * There is no setImmediate in browser and setTimeout is slow.
 * Call of async fn will return Promise, which will be fullfiled only on
 * next scheduler queue processing step and this is exactly what we need.
 */
const nextTick = async () => { };
exports.nextTick = nextTick;
/** Returns control to thread each 'tick' ms to avoid blocking. */
async function asyncLoop(iters, tick, cb) {
    let ts = Date.now();
    for (let i = 0; i < iters; i++) {
        cb(i);
        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too
        const diff = Date.now() - ts;
        if (diff >= 0 && diff < tick)
            continue;
        await (0, exports.nextTick)();
        ts += diff;
    }
}
/**
 * Converts string to bytes using UTF8 encoding.
 * @example utf8ToBytes('abc') // Uint8Array.from([97, 98, 99])
 */
function utf8ToBytes(str) {
    if (typeof str !== 'string')
        throw new Error('string expected');
    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809
}
/**
 * Converts bytes to string using UTF8 encoding.
 * @example bytesToUtf8(Uint8Array.from([97, 98, 99])) // 'abc'
 */
function bytesToUtf8(bytes) {
    return new TextDecoder().decode(bytes);
}
/**
 * Normalizes (non-hex) string or Uint8Array to Uint8Array.
 * Warning: when Uint8Array is passed, it would NOT get copied.
 * Keep in mind for future mutable operations.
 */
function toBytes(data) {
    if (typeof data === 'string')
        data = utf8ToBytes(data);
    abytes(data);
    return data;
}
/**
 * Helper for KDFs: consumes uint8array or string.
 * When string is passed, does utf8 decoding, using TextDecoder.
 */
function kdfInputToBytes(data) {
    if (typeof data === 'string')
        data = utf8ToBytes(data);
    abytes(data);
    return data;
}
/** Copies several Uint8Arrays into one. */
function concatBytes(...arrays) {
    let sum = 0;
    for (let i = 0; i < arrays.length; i++) {
        const a = arrays[i];
        abytes(a);
        sum += a.length;
    }
    const res = new Uint8Array(sum);
    for (let i = 0, pad = 0; i < arrays.length; i++) {
        const a = arrays[i];
        res.set(a, pad);
        pad += a.length;
    }
    return res;
}
function checkOpts(defaults, opts) {
    if (opts !== undefined && {}.toString.call(opts) !== '[object Object]')
        throw new Error('options should be object or undefined');
    const merged = Object.assign(defaults, opts);
    return merged;
}
/** For runtime check if class implements interface */
class Hash {
}
exports.Hash = Hash;
/** Wraps hash function, creating an interface on top of it */
function createHasher(hashCons) {
    const hashC = (msg) => hashCons().update(toBytes(msg)).digest();
    const tmp = hashCons();
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = () => hashCons();
    return hashC;
}
function createOptHasher(hashCons) {
    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
    const tmp = hashCons({});
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = (opts) => hashCons(opts);
    return hashC;
}
function createXOFer(hashCons) {
    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
    const tmp = hashCons({});
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = (opts) => hashCons(opts);
    return hashC;
}
exports.wrapConstructor = createHasher;
exports.wrapConstructorWithOpts = createOptHasher;
exports.wrapXOFConstructorWithOpts = createXOFer;
/** Cryptographically secure PRNG. Uses internal OS-level `crypto.getRandomValues`. */
function randomBytes(bytesLength = 32) {
    if (crypto_1.crypto && typeof crypto_1.crypto.getRandomValues === 'function') {
        return crypto_1.crypto.getRandomValues(new Uint8Array(bytesLength));
    }
    // Legacy Node.js compatibility
    if (crypto_1.crypto && typeof crypto_1.crypto.randomBytes === 'function') {
        return Uint8Array.from(crypto_1.crypto.randomBytes(bytesLength));
    }
    throw new Error('crypto.getRandomValues must be defined');
}
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ "./node_modules/@reown/appkit-adapter-ethers5/dist/esm/src/utils/SafeProvider.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@reown/appkit-adapter-ethers5/dist/esm/src/utils/SafeProvider.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SafeProvider: () => (/* binding */ SafeProvider)
/* harmony export */ });
/* harmony import */ var _safe_global_safe_apps_provider__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @safe-global/safe-apps-provider */ "./node_modules/@safe-global/safe-apps-provider/dist/index.js");

class SafeProvider extends _safe_global_safe_apps_provider__WEBPACK_IMPORTED_MODULE_0__.SafeAppProvider {
    request(request) {
        if (request.method === 'eth_requestAccounts') {
            return this.request({
                method: 'eth_accounts',
                params: []
            });
        }
        return super.request(request);
    }
}
//# sourceMappingURL=SafeProvider.js.map

/***/ }),

/***/ "./node_modules/@safe-global/safe-apps-provider/dist/index.js":
/*!********************************************************************!*\
  !*** ./node_modules/@safe-global/safe-apps-provider/dist/index.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SafeAppProvider = void 0;
var provider_1 = __webpack_require__(/*! ./provider */ "./node_modules/@safe-global/safe-apps-provider/dist/provider.js");
Object.defineProperty(exports, "SafeAppProvider", ({ enumerable: true, get: function () { return provider_1.SafeAppProvider; } }));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@safe-global/safe-apps-provider/dist/provider.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@safe-global/safe-apps-provider/dist/provider.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SafeAppProvider = void 0;
const safe_apps_sdk_1 = __webpack_require__(/*! @safe-global/safe-apps-sdk */ "./node_modules/@safe-global/safe-apps-sdk/dist/cjs/index.js");
const events_1 = __webpack_require__(/*! events */ "./node_modules/events/events.js");
const utils_1 = __webpack_require__(/*! ./utils */ "./node_modules/@safe-global/safe-apps-provider/dist/utils.js");
// The API is based on Ethereum JavaScript API Provider Standard. Link: https://eips.ethereum.org/EIPS/eip-1193
class SafeAppProvider extends events_1.EventEmitter {
    constructor(safe, sdk) {
        super();
        this.submittedTxs = new Map();
        this.safe = safe;
        this.sdk = sdk;
    }
    async connect() {
        this.emit('connect', { chainId: this.chainId });
        return;
    }
    async disconnect() {
        return;
    }
    get chainId() {
        return this.safe.chainId;
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    async request(request) {
        const { method, params = [] } = request;
        switch (method) {
            case 'eth_accounts':
                return [this.safe.safeAddress];
            case 'net_version':
            case 'eth_chainId':
                return (0, utils_1.numberToHex)(this.chainId);
            case 'personal_sign': {
                const [message, address] = params;
                if (this.safe.safeAddress.toLowerCase() !== address.toLowerCase()) {
                    throw new Error('The address or message hash is invalid');
                }
                const response = await this.sdk.txs.signMessage(message);
                const signature = 'signature' in response ? response.signature : undefined;
                return signature || '0x';
            }
            case 'eth_sign': {
                const [address, messageHash] = params;
                if (this.safe.safeAddress.toLowerCase() !== address.toLowerCase() || !messageHash.startsWith('0x')) {
                    throw new Error('The address or message hash is invalid');
                }
                const response = await this.sdk.txs.signMessage(messageHash);
                const signature = 'signature' in response ? response.signature : undefined;
                return signature || '0x';
            }
            case 'eth_signTypedData':
            case 'eth_signTypedData_v4': {
                const [address, typedData] = params;
                const parsedTypedData = typeof typedData === 'string' ? JSON.parse(typedData) : typedData;
                if (this.safe.safeAddress.toLowerCase() !== address.toLowerCase()) {
                    throw new Error('The address is invalid');
                }
                const response = await this.sdk.txs.signTypedMessage(parsedTypedData);
                const signature = 'signature' in response ? response.signature : undefined;
                return signature || '0x';
            }
            case 'eth_sendTransaction':
                // `value` or `data` can be explicitly set as `undefined` for example in Viem. The spread will overwrite the fallback value.
                const tx = {
                    ...params[0],
                    value: params[0].value || '0',
                    data: params[0].data || '0x',
                };
                // Some ethereum libraries might pass the gas as a hex-encoded string
                // We need to convert it to a number because the SDK expects a number and our backend only supports
                // Decimal numbers
                if (typeof tx.gas === 'string' && tx.gas.startsWith('0x')) {
                    tx.gas = parseInt(tx.gas, 16);
                }
                const resp = await this.sdk.txs.send({
                    txs: [tx],
                    params: { safeTxGas: tx.gas },
                });
                // Store fake transaction
                this.submittedTxs.set(resp.safeTxHash, {
                    from: this.safe.safeAddress,
                    hash: resp.safeTxHash,
                    gas: 0,
                    gasPrice: '0x00',
                    nonce: 0,
                    input: tx.data,
                    value: tx.value,
                    to: tx.to,
                    blockHash: null,
                    blockNumber: null,
                    transactionIndex: null,
                });
                return resp.safeTxHash;
            case 'eth_blockNumber':
                const block = await this.sdk.eth.getBlockByNumber(['latest']);
                return block.number;
            case 'eth_getBalance':
                return this.sdk.eth.getBalance([(0, utils_1.getLowerCase)(params[0]), params[1]]);
            case 'eth_getCode':
                return this.sdk.eth.getCode([(0, utils_1.getLowerCase)(params[0]), params[1]]);
            case 'eth_getTransactionCount':
                return this.sdk.eth.getTransactionCount([(0, utils_1.getLowerCase)(params[0]), params[1]]);
            case 'eth_getStorageAt':
                return this.sdk.eth.getStorageAt([(0, utils_1.getLowerCase)(params[0]), params[1], params[2]]);
            case 'eth_getBlockByNumber':
                return this.sdk.eth.getBlockByNumber([params[0], params[1]]);
            case 'eth_getBlockByHash':
                return this.sdk.eth.getBlockByHash([params[0], params[1]]);
            case 'eth_getTransactionByHash':
                let txHash = params[0];
                try {
                    const resp = await this.sdk.txs.getBySafeTxHash(txHash);
                    txHash = resp.txHash || txHash;
                }
                catch (e) { }
                // Use fake transaction if we don't have a real tx hash
                if (this.submittedTxs.has(txHash)) {
                    return this.submittedTxs.get(txHash);
                }
                return this.sdk.eth.getTransactionByHash([txHash]).then((tx) => {
                    // We set the tx hash to the one requested, as some provider assert this
                    if (tx) {
                        tx.hash = params[0];
                    }
                    return tx;
                });
            case 'eth_getTransactionReceipt': {
                let txHash = params[0];
                try {
                    const resp = await this.sdk.txs.getBySafeTxHash(txHash);
                    txHash = resp.txHash || txHash;
                }
                catch (e) { }
                return this.sdk.eth.getTransactionReceipt([txHash]).then((tx) => {
                    // We set the tx hash to the one requested, as some provider assert this
                    if (tx) {
                        tx.transactionHash = params[0];
                    }
                    return tx;
                });
            }
            case 'eth_estimateGas': {
                return this.sdk.eth.getEstimateGas(params[0]);
            }
            case 'eth_call': {
                return this.sdk.eth.call([params[0], params[1]]);
            }
            case 'eth_getLogs':
                return this.sdk.eth.getPastLogs([params[0]]);
            case 'eth_gasPrice':
                return this.sdk.eth.getGasPrice();
            case 'wallet_getPermissions':
                return this.sdk.wallet.getPermissions();
            case 'wallet_requestPermissions':
                return this.sdk.wallet.requestPermissions(params[0]);
            case 'safe_setSettings':
                return this.sdk.eth.setSafeSettings([params[0]]);
            case 'wallet_sendCalls': {
                const { from, calls, chainId } = params[0];
                if (chainId !== (0, utils_1.numberToHex)(this.chainId)) {
                    throw new Error(`Safe is not on chain ${chainId}`);
                }
                if (from !== this.safe.safeAddress) {
                    throw Error('Invalid from address');
                }
                const txs = calls.map((call, i) => {
                    if (!call.to) {
                        throw new Error(`Invalid call #${i}: missing "to" field`);
                    }
                    return {
                        to: call.to,
                        data: call.data ?? '0x',
                        value: call.value ?? (0, utils_1.numberToHex)(0),
                    };
                });
                const { safeTxHash } = await this.sdk.txs.send({ txs });
                const result = {
                    id: safeTxHash,
                };
                return result;
            }
            case 'wallet_getCallsStatus': {
                const safeTxHash = params[0];
                const CallStatus = {
                    [safe_apps_sdk_1.TransactionStatus.AWAITING_CONFIRMATIONS]: 100,
                    [safe_apps_sdk_1.TransactionStatus.AWAITING_EXECUTION]: 100,
                    [safe_apps_sdk_1.TransactionStatus.SUCCESS]: 200,
                    [safe_apps_sdk_1.TransactionStatus.CANCELLED]: 400,
                    [safe_apps_sdk_1.TransactionStatus.FAILED]: 500,
                };
                const tx = await this.sdk.txs.getBySafeTxHash(safeTxHash);
                const result = {
                    version: '1.0',
                    id: safeTxHash,
                    chainId: (0, utils_1.numberToHex)(this.chainId),
                    status: CallStatus[tx.txStatus],
                };
                // Transaction is queued
                if (!tx.txHash) {
                    return result;
                }
                // If transaction is executing, receipt is null
                const receipt = await this.sdk.eth.getTransactionReceipt([tx.txHash]);
                if (!receipt) {
                    return result;
                }
                const calls = tx.txData?.dataDecoded?.method !== 'multiSend'
                    ? 1
                    : // Number of batched transactions
                        tx.txData.dataDecoded.parameters?.[0].valueDecoded?.length ?? 1;
                // Typed as number; is hex
                const blockNumber = Number(receipt.blockNumber);
                const gasUsed = Number(receipt.gasUsed);
                result.receipts = Array(calls).fill({
                    logs: receipt.logs,
                    status: (0, utils_1.numberToHex)(tx.txStatus === safe_apps_sdk_1.TransactionStatus.SUCCESS ? 1 : 0),
                    blockHash: receipt.blockHash,
                    blockNumber: (0, utils_1.numberToHex)(blockNumber),
                    gasUsed: (0, utils_1.numberToHex)(gasUsed),
                    transactionHash: tx.txHash,
                });
                return result;
            }
            case 'wallet_showCallsStatus': {
                // Cannot open transaction details page via SDK
                throw new Error(`"${request.method}" not supported`);
            }
            case 'wallet_getCapabilities': {
                return {
                    [(0, utils_1.numberToHex)(this.chainId)]: {
                        atomicBatch: {
                            supported: true,
                        },
                    },
                };
            }
            default:
                throw Error(`"${request.method}" not implemented`);
        }
    }
    // this method is needed for ethers v4
    // https://github.com/ethers-io/ethers.js/blob/427e16826eb15d52d25c4f01027f8db22b74b76c/src.ts/providers/web3-provider.ts#L41-L55
    send(request, callback) {
        if (!request)
            callback('Undefined request');
        this.request(request)
            .then((result) => callback(null, { jsonrpc: '2.0', id: request.id, result }))
            .catch((error) => callback(error, null));
    }
}
exports.SafeAppProvider = SafeAppProvider;
//# sourceMappingURL=provider.js.map

/***/ }),

/***/ "./node_modules/@safe-global/safe-apps-provider/dist/utils.js":
/*!********************************************************************!*\
  !*** ./node_modules/@safe-global/safe-apps-provider/dist/utils.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.numberToHex = exports.getLowerCase = void 0;
function getLowerCase(value) {
    if (value) {
        return value.toLowerCase();
    }
    return value;
}
exports.getLowerCase = getLowerCase;
function numberToHex(value) {
    return `0x${value.toString(16)}`;
}
exports.numberToHex = numberToHex;
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ "./node_modules/@safe-global/safe-apps-sdk/dist/cjs/communication/index.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@safe-global/safe-apps-sdk/dist/cjs/communication/index.js ***!
  \*********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const messageFormatter_js_1 = __webpack_require__(/*! ./messageFormatter.js */ "./node_modules/@safe-global/safe-apps-sdk/dist/cjs/communication/messageFormatter.js");
class PostMessageCommunicator {
    constructor(allowedOrigins = null, debugMode = false) {
        this.allowedOrigins = null;
        this.callbacks = new Map();
        this.debugMode = false;
        this.isServer = typeof window === 'undefined';
        this.isValidMessage = ({ origin, data, source }) => {
            const emptyOrMalformed = !data;
            const sentFromParentEl = !this.isServer && source === window.parent;
            const majorVersionNumber = typeof data.version !== 'undefined' && parseInt(data.version.split('.')[0]);
            const allowedSDKVersion = typeof majorVersionNumber === 'number' && majorVersionNumber >= 1;
            let validOrigin = true;
            if (Array.isArray(this.allowedOrigins)) {
                validOrigin = this.allowedOrigins.find((regExp) => regExp.test(origin)) !== undefined;
            }
            return !emptyOrMalformed && sentFromParentEl && allowedSDKVersion && validOrigin;
        };
        this.logIncomingMessage = (msg) => {
            console.info(`Safe Apps SDK v1: A message was received from origin ${msg.origin}. `, msg.data);
        };
        this.onParentMessage = (msg) => {
            if (this.isValidMessage(msg)) {
                this.debugMode && this.logIncomingMessage(msg);
                this.handleIncomingMessage(msg.data);
            }
        };
        this.handleIncomingMessage = (payload) => {
            const { id } = payload;
            const cb = this.callbacks.get(id);
            if (cb) {
                cb(payload);
                this.callbacks.delete(id);
            }
        };
        this.send = (method, params) => {
            const request = messageFormatter_js_1.MessageFormatter.makeRequest(method, params);
            if (this.isServer) {
                throw new Error("Window doesn't exist");
            }
            window.parent.postMessage(request, '*');
            return new Promise((resolve, reject) => {
                this.callbacks.set(request.id, (response) => {
                    if (!response.success) {
                        reject(new Error(response.error));
                        return;
                    }
                    resolve(response);
                });
            });
        };
        this.allowedOrigins = allowedOrigins;
        this.debugMode = debugMode;
        if (!this.isServer) {
            window.addEventListener('message', this.onParentMessage);
        }
    }
}
exports["default"] = PostMessageCommunicator;
__exportStar(__webpack_require__(/*! ./methods.js */ "./node_modules/@safe-global/safe-apps-sdk/dist/cjs/communication/methods.js"), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@safe-global/safe-apps-sdk/dist/cjs/communication/messageFormatter.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@safe-global/safe-apps-sdk/dist/cjs/communication/messageFormatter.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MessageFormatter = void 0;
const version_js_1 = __webpack_require__(/*! ../version.js */ "./node_modules/@safe-global/safe-apps-sdk/dist/cjs/version.js");
const utils_js_1 = __webpack_require__(/*! ./utils.js */ "./node_modules/@safe-global/safe-apps-sdk/dist/cjs/communication/utils.js");
class MessageFormatter {
}
exports.MessageFormatter = MessageFormatter;
MessageFormatter.makeRequest = (method, params) => {
    const id = (0, utils_js_1.generateRequestId)();
    return {
        id,
        method,
        params,
        env: {
            sdkVersion: (0, version_js_1.getSDKVersion)(),
        },
    };
};
MessageFormatter.makeResponse = (id, data, version) => ({
    id,
    success: true,
    version,
    data,
});
MessageFormatter.makeErrorResponse = (id, error, version) => ({
    id,
    success: false,
    error,
    version,
});
//# sourceMappingURL=messageFormatter.js.map

/***/ }),

/***/ "./node_modules/@safe-global/safe-apps-sdk/dist/cjs/communication/methods.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@safe-global/safe-apps-sdk/dist/cjs/communication/methods.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RestrictedMethods = exports.Methods = void 0;
var Methods;
(function (Methods) {
    Methods["sendTransactions"] = "sendTransactions";
    Methods["rpcCall"] = "rpcCall";
    Methods["getChainInfo"] = "getChainInfo";
    Methods["getSafeInfo"] = "getSafeInfo";
    Methods["getTxBySafeTxHash"] = "getTxBySafeTxHash";
    Methods["getSafeBalances"] = "getSafeBalances";
    Methods["signMessage"] = "signMessage";
    Methods["signTypedMessage"] = "signTypedMessage";
    Methods["getEnvironmentInfo"] = "getEnvironmentInfo";
    Methods["getOffChainSignature"] = "getOffChainSignature";
    Methods["requestAddressBook"] = "requestAddressBook";
    Methods["wallet_getPermissions"] = "wallet_getPermissions";
    Methods["wallet_requestPermissions"] = "wallet_requestPermissions";
})(Methods || (exports.Methods = Methods = {}));
var RestrictedMethods;
(function (RestrictedMethods) {
    RestrictedMethods["requestAddressBook"] = "requestAddressBook";
})(RestrictedMethods || (exports.RestrictedMethods = RestrictedMethods = {}));
//# sourceMappingURL=methods.js.map

/***/ }),

/***/ "./node_modules/@safe-global/safe-apps-sdk/dist/cjs/communication/utils.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@safe-global/safe-apps-sdk/dist/cjs/communication/utils.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.generateRequestId = void 0;
// i.e. 0-255 -> '00'-'ff'
const dec2hex = (dec) => dec.toString(16).padStart(2, '0');
const generateId = (len) => {
    const arr = new Uint8Array((len || 40) / 2);
    window.crypto.getRandomValues(arr);
    return Array.from(arr, dec2hex).join('');
};
const generateRequestId = () => {
    if (typeof window !== 'undefined') {
        return generateId(10);
    }
    return new Date().getTime().toString(36);
};
exports.generateRequestId = generateRequestId;
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ "./node_modules/@safe-global/safe-apps-sdk/dist/cjs/decorators/requirePermissions.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@safe-global/safe-apps-sdk/dist/cjs/decorators/requirePermissions.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
const index_js_1 = __webpack_require__(/*! ../wallet/index.js */ "./node_modules/@safe-global/safe-apps-sdk/dist/cjs/wallet/index.js");
const permissions_js_1 = __webpack_require__(/*! ../types/permissions.js */ "./node_modules/@safe-global/safe-apps-sdk/dist/cjs/types/permissions.js");
const hasPermission = (required, permissions) => permissions.some((permission) => permission.parentCapability === required);
const requirePermission = () => (_, propertyKey, descriptor) => {
    const originalMethod = descriptor.value;
    descriptor.value = async function () {
        // @ts-expect-error accessing private property from decorator. 'this' context is the class instance
        const wallet = new index_js_1.Wallet(this.communicator);
        let currentPermissions = await wallet.getPermissions();
        if (!hasPermission(propertyKey, currentPermissions)) {
            currentPermissions = await wallet.requestPermissions([{ [propertyKey]: {} }]);
        }
        if (!hasPermission(propertyKey, currentPermissions)) {
            throw new permissions_js_1.PermissionsError('Permissions rejected', permissions_js_1.PERMISSIONS_REQUEST_REJECTED);
        }
        return originalMethod.apply(this);
    };
    return descriptor;
};
exports["default"] = requirePermission;
//# sourceMappingURL=requirePermissions.js.map

/***/ }),

/***/ "./node_modules/@safe-global/safe-apps-sdk/dist/cjs/eth/constants.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@safe-global/safe-apps-sdk/dist/cjs/eth/constants.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RPC_CALLS = void 0;
exports.RPC_CALLS = {
    eth_call: 'eth_call',
    eth_gasPrice: 'eth_gasPrice',
    eth_getLogs: 'eth_getLogs',
    eth_getBalance: 'eth_getBalance',
    eth_getCode: 'eth_getCode',
    eth_getBlockByHash: 'eth_getBlockByHash',
    eth_getBlockByNumber: 'eth_getBlockByNumber',
    eth_getStorageAt: 'eth_getStorageAt',
    eth_getTransactionByHash: 'eth_getTransactionByHash',
    eth_getTransactionReceipt: 'eth_getTransactionReceipt',
    eth_getTransactionCount: 'eth_getTransactionCount',
    eth_estimateGas: 'eth_estimateGas',
    safe_setSettings: 'safe_setSettings',
};
//# sourceMappingURL=constants.js.map

/***/ }),

/***/ "./node_modules/@safe-global/safe-apps-sdk/dist/cjs/eth/index.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@safe-global/safe-apps-sdk/dist/cjs/eth/index.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Eth = void 0;
const constants_js_1 = __webpack_require__(/*! ../eth/constants.js */ "./node_modules/@safe-global/safe-apps-sdk/dist/cjs/eth/constants.js");
const methods_js_1 = __webpack_require__(/*! ../communication/methods.js */ "./node_modules/@safe-global/safe-apps-sdk/dist/cjs/communication/methods.js");
const inputFormatters = {
    defaultBlockParam: (arg = 'latest') => arg,
    returnFullTxObjectParam: (arg = false) => arg,
    blockNumberToHex: (arg) => Number.isInteger(arg) ? `0x${arg.toString(16)}` : arg,
};
class Eth {
    constructor(communicator) {
        this.communicator = communicator;
        this.call = this.buildRequest({
            call: constants_js_1.RPC_CALLS.eth_call,
            formatters: [null, inputFormatters.defaultBlockParam],
        });
        this.getBalance = this.buildRequest({
            call: constants_js_1.RPC_CALLS.eth_getBalance,
            formatters: [null, inputFormatters.defaultBlockParam],
        });
        this.getCode = this.buildRequest({
            call: constants_js_1.RPC_CALLS.eth_getCode,
            formatters: [null, inputFormatters.defaultBlockParam],
        });
        this.getStorageAt = this.buildRequest({
            call: constants_js_1.RPC_CALLS.eth_getStorageAt,
            formatters: [null, inputFormatters.blockNumberToHex, inputFormatters.defaultBlockParam],
        });
        this.getPastLogs = this.buildRequest({
            call: constants_js_1.RPC_CALLS.eth_getLogs,
        });
        this.getBlockByHash = this.buildRequest({
            call: constants_js_1.RPC_CALLS.eth_getBlockByHash,
            formatters: [null, inputFormatters.returnFullTxObjectParam],
        });
        this.getBlockByNumber = this.buildRequest({
            call: constants_js_1.RPC_CALLS.eth_getBlockByNumber,
            formatters: [inputFormatters.blockNumberToHex, inputFormatters.returnFullTxObjectParam],
        });
        this.getTransactionByHash = this.buildRequest({
            call: constants_js_1.RPC_CALLS.eth_getTransactionByHash,
        });
        this.getTransactionReceipt = this.buildRequest({
            call: constants_js_1.RPC_CALLS.eth_getTransactionReceipt,
        });
        this.getTransactionCount = this.buildRequest({
            call: constants_js_1.RPC_CALLS.eth_getTransactionCount,
            formatters: [null, inputFormatters.defaultBlockParam],
        });
        this.getGasPrice = this.buildRequest({
            call: constants_js_1.RPC_CALLS.eth_gasPrice,
        });
        this.getEstimateGas = (transaction) => this.buildRequest({
            call: constants_js_1.RPC_CALLS.eth_estimateGas,
        })([transaction]);
        this.setSafeSettings = this.buildRequest({
            call: constants_js_1.RPC_CALLS.safe_setSettings,
        });
    }
    buildRequest(args) {
        const { call, formatters } = args;
        return async (params) => {
            if (formatters && Array.isArray(params)) {
                formatters.forEach((formatter, i) => {
                    if (formatter) {
                        params[i] = formatter(params[i]);
                    }
                });
            }
            const payload = {
                call,
                params: params || [],
            };
            const response = await this.communicator.send(methods_js_1.Methods.rpcCall, payload);
            return response.data;
        };
    }
}
exports.Eth = Eth;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@safe-global/safe-apps-sdk/dist/cjs/index.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@safe-global/safe-apps-sdk/dist/cjs/index.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getSDKVersion = void 0;
const sdk_js_1 = __importDefault(__webpack_require__(/*! ./sdk.js */ "./node_modules/@safe-global/safe-apps-sdk/dist/cjs/sdk.js"));
exports["default"] = sdk_js_1.default;
__exportStar(__webpack_require__(/*! ./sdk.js */ "./node_modules/@safe-global/safe-apps-sdk/dist/cjs/sdk.js"), exports);
__exportStar(__webpack_require__(/*! ./types/index.js */ "./node_modules/@safe-global/safe-apps-sdk/dist/cjs/types/index.js"), exports);
__exportStar(__webpack_require__(/*! ./communication/methods.js */ "./node_modules/@safe-global/safe-apps-sdk/dist/cjs/communication/methods.js"), exports);
__exportStar(__webpack_require__(/*! ./communication/messageFormatter.js */ "./node_modules/@safe-global/safe-apps-sdk/dist/cjs/communication/messageFormatter.js"), exports);
var version_js_1 = __webpack_require__(/*! ./version.js */ "./node_modules/@safe-global/safe-apps-sdk/dist/cjs/version.js");
Object.defineProperty(exports, "getSDKVersion", ({ enumerable: true, get: function () { return version_js_1.getSDKVersion; } }));
__exportStar(__webpack_require__(/*! ./eth/constants.js */ "./node_modules/@safe-global/safe-apps-sdk/dist/cjs/eth/constants.js"), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@safe-global/safe-apps-sdk/dist/cjs/safe/index.js":
/*!************************************************************************!*\
  !*** ./node_modules/@safe-global/safe-apps-sdk/dist/cjs/safe/index.js ***!
  \************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Safe = void 0;
const viem_1 = __webpack_require__(/*! viem */ "./node_modules/viem/_cjs/index.js");
const signatures_js_1 = __webpack_require__(/*! ./signatures.js */ "./node_modules/@safe-global/safe-apps-sdk/dist/cjs/safe/signatures.js");
const methods_js_1 = __webpack_require__(/*! ../communication/methods.js */ "./node_modules/@safe-global/safe-apps-sdk/dist/cjs/communication/methods.js");
const constants_js_1 = __webpack_require__(/*! ../eth/constants.js */ "./node_modules/@safe-global/safe-apps-sdk/dist/cjs/eth/constants.js");
const index_js_1 = __webpack_require__(/*! ../types/index.js */ "./node_modules/@safe-global/safe-apps-sdk/dist/cjs/types/index.js");
const requirePermissions_js_1 = __importDefault(__webpack_require__(/*! ../decorators/requirePermissions.js */ "./node_modules/@safe-global/safe-apps-sdk/dist/cjs/decorators/requirePermissions.js"));
class Safe {
    constructor(communicator) {
        this.communicator = communicator;
    }
    async getChainInfo() {
        const response = await this.communicator.send(methods_js_1.Methods.getChainInfo, undefined);
        return response.data;
    }
    async getInfo() {
        const response = await this.communicator.send(methods_js_1.Methods.getSafeInfo, undefined);
        return response.data;
    }
    // There is a possibility that this method will change because we may add pagination to the endpoint
    async experimental_getBalances({ currency = 'usd' } = {}) {
        const response = await this.communicator.send(methods_js_1.Methods.getSafeBalances, {
            currency,
        });
        return response.data;
    }
    async check1271Signature(messageHash, signature = '0x') {
        const safeInfo = await this.getInfo();
        const encodedIsValidSignatureCall = (0, viem_1.encodeFunctionData)({
            abi: [
                {
                    constant: false,
                    inputs: [
                        {
                            name: '_dataHash',
                            type: 'bytes32',
                        },
                        {
                            name: '_signature',
                            type: 'bytes',
                        },
                    ],
                    name: 'isValidSignature',
                    outputs: [
                        {
                            name: '',
                            type: 'bytes4',
                        },
                    ],
                    payable: false,
                    stateMutability: 'nonpayable',
                    type: 'function',
                },
            ],
            functionName: 'isValidSignature',
            args: [messageHash, signature],
        });
        const payload = {
            call: constants_js_1.RPC_CALLS.eth_call,
            params: [
                {
                    to: safeInfo.safeAddress,
                    data: encodedIsValidSignatureCall,
                },
                'latest',
            ],
        };
        try {
            const response = await this.communicator.send(methods_js_1.Methods.rpcCall, payload);
            return response.data.slice(0, 10).toLowerCase() === signatures_js_1.MAGIC_VALUE;
        }
        catch (err) {
            return false;
        }
    }
    async check1271SignatureBytes(messageHash, signature = '0x') {
        const safeInfo = await this.getInfo();
        const encodedIsValidSignatureCall = (0, viem_1.encodeFunctionData)({
            abi: [
                {
                    constant: false,
                    inputs: [
                        {
                            name: '_data',
                            type: 'bytes',
                        },
                        {
                            name: '_signature',
                            type: 'bytes',
                        },
                    ],
                    name: 'isValidSignature',
                    outputs: [
                        {
                            name: '',
                            type: 'bytes4',
                        },
                    ],
                    payable: false,
                    stateMutability: 'nonpayable',
                    type: 'function',
                },
            ],
            functionName: 'isValidSignature',
            args: [messageHash, signature],
        });
        const payload = {
            call: constants_js_1.RPC_CALLS.eth_call,
            params: [
                {
                    to: safeInfo.safeAddress,
                    data: encodedIsValidSignatureCall,
                },
                'latest',
            ],
        };
        try {
            const response = await this.communicator.send(methods_js_1.Methods.rpcCall, payload);
            return response.data.slice(0, 10).toLowerCase() === signatures_js_1.MAGIC_VALUE_BYTES;
        }
        catch (err) {
            return false;
        }
    }
    calculateMessageHash(message) {
        return (0, viem_1.hashMessage)(message);
    }
    calculateTypedMessageHash(typedMessage) {
        const chainId = typeof typedMessage.domain.chainId === 'object'
            ? typedMessage.domain.chainId.toNumber()
            : Number(typedMessage.domain.chainId);
        let primaryType = typedMessage.primaryType;
        if (!primaryType) {
            const fields = Object.values(typedMessage.types);
            // We try to infer primaryType (simplified ether's version)
            const primaryTypes = Object.keys(typedMessage.types).filter((typeName) => fields.every((dataTypes) => dataTypes.every(({ type }) => type.replace('[', '').replace(']', '') !== typeName)));
            if (primaryTypes.length === 0 || primaryTypes.length > 1)
                throw new Error('Please specify primaryType');
            primaryType = primaryTypes[0];
        }
        return (0, viem_1.hashTypedData)({
            message: typedMessage.message,
            domain: {
                ...typedMessage.domain,
                chainId,
                verifyingContract: typedMessage.domain.verifyingContract,
                salt: typedMessage.domain.salt,
            },
            types: typedMessage.types,
            primaryType,
        });
    }
    async getOffChainSignature(messageHash) {
        const response = await this.communicator.send(methods_js_1.Methods.getOffChainSignature, messageHash);
        return response.data;
    }
    async isMessageSigned(message, signature = '0x') {
        let check;
        if (typeof message === 'string') {
            check = async () => {
                const messageHash = this.calculateMessageHash(message);
                const messageHashSigned = await this.isMessageHashSigned(messageHash, signature);
                return messageHashSigned;
            };
        }
        if ((0, index_js_1.isObjectEIP712TypedData)(message)) {
            check = async () => {
                const messageHash = this.calculateTypedMessageHash(message);
                const messageHashSigned = await this.isMessageHashSigned(messageHash, signature);
                return messageHashSigned;
            };
        }
        if (check) {
            const isValid = await check();
            return isValid;
        }
        throw new Error('Invalid message type');
    }
    async isMessageHashSigned(messageHash, signature = '0x') {
        const checks = [this.check1271Signature.bind(this), this.check1271SignatureBytes.bind(this)];
        for (const check of checks) {
            const isValid = await check(messageHash, signature);
            if (isValid) {
                return true;
            }
        }
        return false;
    }
    async getEnvironmentInfo() {
        const response = await this.communicator.send(methods_js_1.Methods.getEnvironmentInfo, undefined);
        return response.data;
    }
    async requestAddressBook() {
        const response = await this.communicator.send(methods_js_1.Methods.requestAddressBook, undefined);
        return response.data;
    }
}
exports.Safe = Safe;
__decorate([
    (0, requirePermissions_js_1.default)()
], Safe.prototype, "requestAddressBook", null);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@safe-global/safe-apps-sdk/dist/cjs/safe/signatures.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@safe-global/safe-apps-sdk/dist/cjs/safe/signatures.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MAGIC_VALUE_BYTES = exports.MAGIC_VALUE = void 0;
const MAGIC_VALUE = '0x1626ba7e';
exports.MAGIC_VALUE = MAGIC_VALUE;
const MAGIC_VALUE_BYTES = '0x20c13b0b';
exports.MAGIC_VALUE_BYTES = MAGIC_VALUE_BYTES;
//# sourceMappingURL=signatures.js.map

/***/ }),

/***/ "./node_modules/@safe-global/safe-apps-sdk/dist/cjs/sdk.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@safe-global/safe-apps-sdk/dist/cjs/sdk.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const index_js_1 = __importDefault(__webpack_require__(/*! ./communication/index.js */ "./node_modules/@safe-global/safe-apps-sdk/dist/cjs/communication/index.js"));
const index_js_2 = __webpack_require__(/*! ./txs/index.js */ "./node_modules/@safe-global/safe-apps-sdk/dist/cjs/txs/index.js");
const index_js_3 = __webpack_require__(/*! ./eth/index.js */ "./node_modules/@safe-global/safe-apps-sdk/dist/cjs/eth/index.js");
const index_js_4 = __webpack_require__(/*! ./safe/index.js */ "./node_modules/@safe-global/safe-apps-sdk/dist/cjs/safe/index.js");
const index_js_5 = __webpack_require__(/*! ./wallet/index.js */ "./node_modules/@safe-global/safe-apps-sdk/dist/cjs/wallet/index.js");
class SafeAppsSDK {
    constructor(opts = {}) {
        const { allowedDomains = null, debug = false } = opts;
        this.communicator = new index_js_1.default(allowedDomains, debug);
        this.eth = new index_js_3.Eth(this.communicator);
        this.txs = new index_js_2.TXs(this.communicator);
        this.safe = new index_js_4.Safe(this.communicator);
        this.wallet = new index_js_5.Wallet(this.communicator);
    }
}
exports["default"] = SafeAppsSDK;
//# sourceMappingURL=sdk.js.map

/***/ }),

/***/ "./node_modules/@safe-global/safe-apps-sdk/dist/cjs/txs/index.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@safe-global/safe-apps-sdk/dist/cjs/txs/index.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TXs = void 0;
const methods_js_1 = __webpack_require__(/*! ../communication/methods.js */ "./node_modules/@safe-global/safe-apps-sdk/dist/cjs/communication/methods.js");
const index_js_1 = __webpack_require__(/*! ../types/index.js */ "./node_modules/@safe-global/safe-apps-sdk/dist/cjs/types/index.js");
class TXs {
    constructor(communicator) {
        this.communicator = communicator;
    }
    async getBySafeTxHash(safeTxHash) {
        if (!safeTxHash) {
            throw new Error('Invalid safeTxHash');
        }
        const response = await this.communicator.send(methods_js_1.Methods.getTxBySafeTxHash, { safeTxHash });
        return response.data;
    }
    async signMessage(message) {
        const messagePayload = {
            message,
        };
        const response = await this.communicator.send(methods_js_1.Methods.signMessage, messagePayload);
        return response.data;
    }
    async signTypedMessage(typedData) {
        if (!(0, index_js_1.isObjectEIP712TypedData)(typedData)) {
            throw new Error('Invalid typed data');
        }
        const response = await this.communicator.send(methods_js_1.Methods.signTypedMessage, { typedData });
        return response.data;
    }
    async send({ txs, params }) {
        if (!txs || !txs.length) {
            throw new Error('No transactions were passed');
        }
        const messagePayload = {
            txs,
            params,
        };
        const response = await this.communicator.send(methods_js_1.Methods.sendTransactions, messagePayload);
        return response.data;
    }
}
exports.TXs = TXs;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@safe-global/safe-apps-sdk/dist/cjs/types/gateway.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@safe-global/safe-apps-sdk/dist/cjs/types/gateway.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TransferDirection = exports.TransactionStatus = exports.TokenType = exports.Operation = void 0;
var safe_gateway_typescript_sdk_1 = __webpack_require__(/*! @safe-global/safe-gateway-typescript-sdk */ "./node_modules/@safe-global/safe-gateway-typescript-sdk/dist/index.js");
Object.defineProperty(exports, "Operation", ({ enumerable: true, get: function () { return safe_gateway_typescript_sdk_1.Operation; } }));
Object.defineProperty(exports, "TokenType", ({ enumerable: true, get: function () { return safe_gateway_typescript_sdk_1.TokenType; } }));
Object.defineProperty(exports, "TransactionStatus", ({ enumerable: true, get: function () { return safe_gateway_typescript_sdk_1.TransactionStatus; } }));
Object.defineProperty(exports, "TransferDirection", ({ enumerable: true, get: function () { return safe_gateway_typescript_sdk_1.TransferDirection; } }));
//# sourceMappingURL=gateway.js.map

/***/ }),

/***/ "./node_modules/@safe-global/safe-apps-sdk/dist/cjs/types/index.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@safe-global/safe-apps-sdk/dist/cjs/types/index.js ***!
  \*************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(/*! ./sdk.js */ "./node_modules/@safe-global/safe-apps-sdk/dist/cjs/types/sdk.js"), exports);
__exportStar(__webpack_require__(/*! ./rpc.js */ "./node_modules/@safe-global/safe-apps-sdk/dist/cjs/types/rpc.js"), exports);
__exportStar(__webpack_require__(/*! ./gateway.js */ "./node_modules/@safe-global/safe-apps-sdk/dist/cjs/types/gateway.js"), exports);
__exportStar(__webpack_require__(/*! ./messaging.js */ "./node_modules/@safe-global/safe-apps-sdk/dist/cjs/types/messaging.js"), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@safe-global/safe-apps-sdk/dist/cjs/types/messaging.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@safe-global/safe-apps-sdk/dist/cjs/types/messaging.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
const methods_js_1 = __webpack_require__(/*! ../communication/methods.js */ "./node_modules/@safe-global/safe-apps-sdk/dist/cjs/communication/methods.js");
//# sourceMappingURL=messaging.js.map

/***/ }),

/***/ "./node_modules/@safe-global/safe-apps-sdk/dist/cjs/types/permissions.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@safe-global/safe-apps-sdk/dist/cjs/types/permissions.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PermissionsError = exports.PERMISSIONS_REQUEST_REJECTED = void 0;
exports.PERMISSIONS_REQUEST_REJECTED = 4001;
class PermissionsError extends Error {
    constructor(message, code, data) {
        super(message);
        this.code = code;
        this.data = data;
        // Should adjust prototype manually because how TS handles the type extension compilation
        // https://github.com/Microsoft/TypeScript/wiki/Breaking-Changes#extending-built-ins-like-error-array-and-map-may-no-longer-work
        Object.setPrototypeOf(this, PermissionsError.prototype);
    }
}
exports.PermissionsError = PermissionsError;
//# sourceMappingURL=permissions.js.map

/***/ }),

/***/ "./node_modules/@safe-global/safe-apps-sdk/dist/cjs/types/rpc.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@safe-global/safe-apps-sdk/dist/cjs/types/rpc.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
//# sourceMappingURL=rpc.js.map

/***/ }),

/***/ "./node_modules/@safe-global/safe-apps-sdk/dist/cjs/types/sdk.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@safe-global/safe-apps-sdk/dist/cjs/types/sdk.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isObjectEIP712TypedData = void 0;
const isObjectEIP712TypedData = (obj) => {
    return typeof obj === 'object' && obj != null && 'domain' in obj && 'types' in obj && 'message' in obj;
};
exports.isObjectEIP712TypedData = isObjectEIP712TypedData;
//# sourceMappingURL=sdk.js.map

/***/ }),

/***/ "./node_modules/@safe-global/safe-apps-sdk/dist/cjs/version.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@safe-global/safe-apps-sdk/dist/cjs/version.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getSDKVersion = void 0;
const getSDKVersion = () => '9.1.0';
exports.getSDKVersion = getSDKVersion;
//# sourceMappingURL=version.js.map

/***/ }),

/***/ "./node_modules/@safe-global/safe-apps-sdk/dist/cjs/wallet/index.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@safe-global/safe-apps-sdk/dist/cjs/wallet/index.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Wallet = void 0;
const methods_js_1 = __webpack_require__(/*! ../communication/methods.js */ "./node_modules/@safe-global/safe-apps-sdk/dist/cjs/communication/methods.js");
const permissions_js_1 = __webpack_require__(/*! ../types/permissions.js */ "./node_modules/@safe-global/safe-apps-sdk/dist/cjs/types/permissions.js");
class Wallet {
    constructor(communicator) {
        this.communicator = communicator;
    }
    async getPermissions() {
        const response = await this.communicator.send(methods_js_1.Methods.wallet_getPermissions, undefined);
        return response.data;
    }
    async requestPermissions(permissions) {
        if (!this.isPermissionRequestValid(permissions)) {
            throw new permissions_js_1.PermissionsError('Permissions request is invalid', permissions_js_1.PERMISSIONS_REQUEST_REJECTED);
        }
        try {
            const response = await this.communicator.send(methods_js_1.Methods.wallet_requestPermissions, permissions);
            return response.data;
        }
        catch {
            throw new permissions_js_1.PermissionsError('Permissions rejected', permissions_js_1.PERMISSIONS_REQUEST_REJECTED);
        }
    }
    isPermissionRequestValid(permissions) {
        return permissions.every((pr) => {
            if (typeof pr === 'object') {
                return Object.keys(pr).every((method) => {
                    if (Object.values(methods_js_1.RestrictedMethods).includes(method)) {
                        return true;
                    }
                    return false;
                });
            }
            return false;
        });
    }
}
exports.Wallet = Wallet;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@safe-global/safe-gateway-typescript-sdk/dist/config.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@safe-global/safe-gateway-typescript-sdk/dist/config.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DEFAULT_BASE_URL = void 0;
exports.DEFAULT_BASE_URL = 'https://safe-client.safe.global';
//# sourceMappingURL=config.js.map

/***/ }),

/***/ "./node_modules/@safe-global/safe-gateway-typescript-sdk/dist/endpoint.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@safe-global/safe-gateway-typescript-sdk/dist/endpoint.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.postEndpoint = postEndpoint;
exports.putEndpoint = putEndpoint;
exports.deleteEndpoint = deleteEndpoint;
exports.getEndpoint = getEndpoint;
const utils_1 = __webpack_require__(/*! ./utils */ "./node_modules/@safe-global/safe-gateway-typescript-sdk/dist/utils.js");
function makeUrl(baseUrl, path, pathParams, query) {
    const pathname = (0, utils_1.insertParams)(path, pathParams);
    const search = (0, utils_1.stringifyQuery)(query);
    return `${baseUrl}${pathname}${search}`;
}
function postEndpoint(baseUrl, path, params) {
    const url = makeUrl(baseUrl, path, params === null || params === void 0 ? void 0 : params.path, params === null || params === void 0 ? void 0 : params.query);
    return (0, utils_1.fetchData)(url, 'POST', params === null || params === void 0 ? void 0 : params.body, params === null || params === void 0 ? void 0 : params.headers, params === null || params === void 0 ? void 0 : params.credentials);
}
function putEndpoint(baseUrl, path, params) {
    const url = makeUrl(baseUrl, path, params === null || params === void 0 ? void 0 : params.path, params === null || params === void 0 ? void 0 : params.query);
    return (0, utils_1.fetchData)(url, 'PUT', params === null || params === void 0 ? void 0 : params.body, params === null || params === void 0 ? void 0 : params.headers, params === null || params === void 0 ? void 0 : params.credentials);
}
function deleteEndpoint(baseUrl, path, params) {
    const url = makeUrl(baseUrl, path, params === null || params === void 0 ? void 0 : params.path, params === null || params === void 0 ? void 0 : params.query);
    return (0, utils_1.fetchData)(url, 'DELETE', params === null || params === void 0 ? void 0 : params.body, params === null || params === void 0 ? void 0 : params.headers, params === null || params === void 0 ? void 0 : params.credentials);
}
function getEndpoint(baseUrl, path, params, rawUrl) {
    if (rawUrl) {
        return (0, utils_1.getData)(rawUrl, undefined, params === null || params === void 0 ? void 0 : params.credentials);
    }
    const url = makeUrl(baseUrl, path, params === null || params === void 0 ? void 0 : params.path, params === null || params === void 0 ? void 0 : params.query);
    return (0, utils_1.getData)(url, params === null || params === void 0 ? void 0 : params.headers, params === null || params === void 0 ? void 0 : params.credentials);
}
//# sourceMappingURL=endpoint.js.map

/***/ }),

/***/ "./node_modules/@safe-global/safe-gateway-typescript-sdk/dist/index.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@safe-global/safe-gateway-typescript-sdk/dist/index.js ***!
  \*****************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.setBaseUrl = void 0;
exports.relayTransaction = relayTransaction;
exports.getRelayCount = getRelayCount;
exports.getSafeInfo = getSafeInfo;
exports.getIncomingTransfers = getIncomingTransfers;
exports.getModuleTransactions = getModuleTransactions;
exports.getMultisigTransactions = getMultisigTransactions;
exports.getBalances = getBalances;
exports.getFiatCurrencies = getFiatCurrencies;
exports.getOwnedSafes = getOwnedSafes;
exports.getAllOwnedSafes = getAllOwnedSafes;
exports.getCollectibles = getCollectibles;
exports.getCollectiblesPage = getCollectiblesPage;
exports.getTransactionHistory = getTransactionHistory;
exports.getTransactionQueue = getTransactionQueue;
exports.getTransactionDetails = getTransactionDetails;
exports.deleteTransaction = deleteTransaction;
exports.postSafeGasEstimation = postSafeGasEstimation;
exports.getNonces = getNonces;
exports.proposeTransaction = proposeTransaction;
exports.getConfirmationView = getConfirmationView;
exports.getTxPreview = getTxPreview;
exports.getChainsConfig = getChainsConfig;
exports.getChainConfig = getChainConfig;
exports.getSafeApps = getSafeApps;
exports.getMasterCopies = getMasterCopies;
exports.getDecodedData = getDecodedData;
exports.getSafeMessages = getSafeMessages;
exports.getSafeMessage = getSafeMessage;
exports.proposeSafeMessage = proposeSafeMessage;
exports.confirmSafeMessage = confirmSafeMessage;
exports.getDelegates = getDelegates;
exports.registerDevice = registerDevice;
exports.unregisterSafe = unregisterSafe;
exports.unregisterDevice = unregisterDevice;
exports.registerEmail = registerEmail;
exports.changeEmail = changeEmail;
exports.resendEmailVerificationCode = resendEmailVerificationCode;
exports.verifyEmail = verifyEmail;
exports.getRegisteredEmail = getRegisteredEmail;
exports.deleteRegisteredEmail = deleteRegisteredEmail;
exports.registerRecoveryModule = registerRecoveryModule;
exports.unsubscribeSingle = unsubscribeSingle;
exports.unsubscribeAll = unsubscribeAll;
exports.getSafeOverviews = getSafeOverviews;
exports.getContract = getContract;
exports.getAuthNonce = getAuthNonce;
exports.verifyAuth = verifyAuth;
exports.createAccount = createAccount;
exports.getAccount = getAccount;
exports.deleteAccount = deleteAccount;
exports.getAccountDataTypes = getAccountDataTypes;
exports.getAccountDataSettings = getAccountDataSettings;
exports.putAccountDataSettings = putAccountDataSettings;
exports.getIndexingStatus = getIndexingStatus;
const endpoint_1 = __webpack_require__(/*! ./endpoint */ "./node_modules/@safe-global/safe-gateway-typescript-sdk/dist/endpoint.js");
const config_1 = __webpack_require__(/*! ./config */ "./node_modules/@safe-global/safe-gateway-typescript-sdk/dist/config.js");
__exportStar(__webpack_require__(/*! ./types/safe-info */ "./node_modules/@safe-global/safe-gateway-typescript-sdk/dist/types/safe-info.js"), exports);
__exportStar(__webpack_require__(/*! ./types/safe-apps */ "./node_modules/@safe-global/safe-gateway-typescript-sdk/dist/types/safe-apps.js"), exports);
__exportStar(__webpack_require__(/*! ./types/transactions */ "./node_modules/@safe-global/safe-gateway-typescript-sdk/dist/types/transactions.js"), exports);
__exportStar(__webpack_require__(/*! ./types/chains */ "./node_modules/@safe-global/safe-gateway-typescript-sdk/dist/types/chains.js"), exports);
__exportStar(__webpack_require__(/*! ./types/common */ "./node_modules/@safe-global/safe-gateway-typescript-sdk/dist/types/common.js"), exports);
__exportStar(__webpack_require__(/*! ./types/master-copies */ "./node_modules/@safe-global/safe-gateway-typescript-sdk/dist/types/master-copies.js"), exports);
__exportStar(__webpack_require__(/*! ./types/decoded-data */ "./node_modules/@safe-global/safe-gateway-typescript-sdk/dist/types/decoded-data.js"), exports);
__exportStar(__webpack_require__(/*! ./types/safe-messages */ "./node_modules/@safe-global/safe-gateway-typescript-sdk/dist/types/safe-messages.js"), exports);
__exportStar(__webpack_require__(/*! ./types/notifications */ "./node_modules/@safe-global/safe-gateway-typescript-sdk/dist/types/notifications.js"), exports);
__exportStar(__webpack_require__(/*! ./types/relay */ "./node_modules/@safe-global/safe-gateway-typescript-sdk/dist/types/relay.js"), exports);
// Can be set externally to a different CGW host
let baseUrl = config_1.DEFAULT_BASE_URL;
/**
 * Set the base CGW URL
 */
const setBaseUrl = (url) => {
    baseUrl = url;
};
exports.setBaseUrl = setBaseUrl;
/* eslint-disable @typescript-eslint/explicit-module-boundary-types */
/**
 * Relay a transaction from a Safe
 */
function relayTransaction(chainId, body) {
    return (0, endpoint_1.postEndpoint)(baseUrl, '/v1/chains/{chainId}/relay', { path: { chainId }, body });
}
/**
 * Get the relay limit and number of remaining relays remaining
 */
function getRelayCount(chainId, address) {
    return (0, endpoint_1.getEndpoint)(baseUrl, '/v1/chains/{chainId}/relay/{address}', { path: { chainId, address } });
}
/**
 * Get basic information about a Safe. E.g. owners, modules, version etc
 */
function getSafeInfo(chainId, address) {
    return (0, endpoint_1.getEndpoint)(baseUrl, '/v1/chains/{chainId}/safes/{address}', { path: { chainId, address } });
}
/**
 * Get filterable list of incoming transactions
 */
function getIncomingTransfers(chainId, address, query, pageUrl) {
    return (0, endpoint_1.getEndpoint)(baseUrl, '/v1/chains/{chainId}/safes/{address}/incoming-transfers/', {
        path: { chainId, address },
        query,
    }, pageUrl);
}
/**
 * Get filterable list of module transactions
 */
function getModuleTransactions(chainId, address, query, pageUrl) {
    return (0, endpoint_1.getEndpoint)(baseUrl, '/v1/chains/{chainId}/safes/{address}/module-transactions/', {
        path: { chainId, address },
        query,
    }, pageUrl);
}
/**
 * Get filterable list of multisig transactions
 */
function getMultisigTransactions(chainId, address, query, pageUrl) {
    return (0, endpoint_1.getEndpoint)(baseUrl, '/v1/chains/{chainId}/safes/{address}/multisig-transactions/', {
        path: { chainId, address },
        query,
    }, pageUrl);
}
/**
 * Get the total balance and all assets stored in a Safe
 */
function getBalances(chainId, address, currency = 'usd', query = {}) {
    return (0, endpoint_1.getEndpoint)(baseUrl, '/v1/chains/{chainId}/safes/{address}/balances/{currency}', {
        path: { chainId, address, currency },
        query,
    });
}
/**
 * Get a list of supported fiat currencies (e.g. USD, EUR etc)
 */
function getFiatCurrencies() {
    return (0, endpoint_1.getEndpoint)(baseUrl, '/v1/balances/supported-fiat-codes');
}
/**
 * Get the addresses of all Safes belonging to an owner
 */
function getOwnedSafes(chainId, address) {
    return (0, endpoint_1.getEndpoint)(baseUrl, '/v1/chains/{chainId}/owners/{address}/safes', { path: { chainId, address } });
}
/**
 * Get the addresses of all Safes belonging to an owner on all chains
 */
function getAllOwnedSafes(address) {
    return (0, endpoint_1.getEndpoint)(baseUrl, '/v1/owners/{address}/safes', { path: { address } });
}
/**
 * Get NFTs stored in a Safe
 */
function getCollectibles(chainId, address, query = {}) {
    return (0, endpoint_1.getEndpoint)(baseUrl, '/v1/chains/{chainId}/safes/{address}/collectibles', {
        path: { chainId, address },
        query,
    });
}
/**
 * Get NFTs stored in a Safe
 */
function getCollectiblesPage(chainId, address, query = {}, pageUrl) {
    return (0, endpoint_1.getEndpoint)(baseUrl, '/v2/chains/{chainId}/safes/{address}/collectibles', { path: { chainId, address }, query }, pageUrl);
}
/**
 * Get a list of past Safe transactions
 */
function getTransactionHistory(chainId, address, query = {}, pageUrl) {
    return (0, endpoint_1.getEndpoint)(baseUrl, '/v1/chains/{chainId}/safes/{safe_address}/transactions/history', { path: { chainId, safe_address: address }, query }, pageUrl);
}
/**
 * Get the list of pending transactions
 */
function getTransactionQueue(chainId, address, query = {}, pageUrl) {
    return (0, endpoint_1.getEndpoint)(baseUrl, '/v1/chains/{chainId}/safes/{safe_address}/transactions/queued', { path: { chainId, safe_address: address }, query }, pageUrl);
}
/**
 * Get the details of an individual transaction by its id
 */
function getTransactionDetails(chainId, transactionId) {
    return (0, endpoint_1.getEndpoint)(baseUrl, '/v1/chains/{chainId}/transactions/{transactionId}', {
        path: { chainId, transactionId },
    });
}
/**
 * Delete a transaction by its safeTxHash
 */
function deleteTransaction(chainId, safeTxHash, signature) {
    return (0, endpoint_1.deleteEndpoint)(baseUrl, '/v1/chains/{chainId}/transactions/{safeTxHash}', {
        path: { chainId, safeTxHash },
        body: { signature },
    });
}
/**
 * Request a gas estimate & recommmended tx nonce for a created transaction
 */
function postSafeGasEstimation(chainId, address, body) {
    return (0, endpoint_1.postEndpoint)(baseUrl, '/v2/chains/{chainId}/safes/{safe_address}/multisig-transactions/estimations', {
        path: { chainId, safe_address: address },
        body,
    });
}
function getNonces(chainId, address) {
    return (0, endpoint_1.getEndpoint)(baseUrl, '/v1/chains/{chainId}/safes/{safe_address}/nonces', {
        path: { chainId, safe_address: address },
    });
}
/**
 * Propose a new transaction for other owners to sign/execute
 */
function proposeTransaction(chainId, address, body) {
    return (0, endpoint_1.postEndpoint)(baseUrl, '/v1/chains/{chainId}/transactions/{safe_address}/propose', {
        path: { chainId, safe_address: address },
        body,
    });
}
/**
 * Returns decoded data
 */
function getConfirmationView(chainId, safeAddress, operation, data, to, value) {
    return (0, endpoint_1.postEndpoint)(baseUrl, '/v1/chains/{chainId}/safes/{safe_address}/views/transaction-confirmation', {
        path: { chainId, safe_address: safeAddress },
        body: { operation, data, to, value },
    });
}
/**
 * Get a tx preview
 */
function getTxPreview(chainId, safeAddress, operation, data, to, value) {
    return (0, endpoint_1.postEndpoint)(baseUrl, '/v1/chains/{chainId}/transactions/{safe_address}/preview', {
        path: { chainId, safe_address: safeAddress },
        body: { operation, data, to, value },
    });
}
/**
 * Returns all defined chain configs
 */
function getChainsConfig(query) {
    return (0, endpoint_1.getEndpoint)(baseUrl, '/v1/chains', {
        query,
    });
}
/**
 * Returns a chain config
 */
function getChainConfig(chainId) {
    return (0, endpoint_1.getEndpoint)(baseUrl, '/v1/chains/{chainId}', {
        path: { chainId: chainId },
    });
}
/**
 * Returns Safe Apps List
 */
function getSafeApps(chainId, query = {}) {
    return (0, endpoint_1.getEndpoint)(baseUrl, '/v1/chains/{chainId}/safe-apps', {
        path: { chainId: chainId },
        query,
    });
}
/**
 * Returns list of Master Copies
 */
function getMasterCopies(chainId) {
    return (0, endpoint_1.getEndpoint)(baseUrl, '/v1/chains/{chainId}/about/master-copies', {
        path: { chainId: chainId },
    });
}
/**
 * Returns decoded data
 */
function getDecodedData(chainId, operation, encodedData, to) {
    return (0, endpoint_1.postEndpoint)(baseUrl, '/v1/chains/{chainId}/data-decoder', {
        path: { chainId: chainId },
        body: { operation, data: encodedData, to },
    });
}
/**
 * Returns list of `SafeMessage`s
 */
function getSafeMessages(chainId, address, pageUrl) {
    return (0, endpoint_1.getEndpoint)(baseUrl, '/v1/chains/{chainId}/safes/{safe_address}/messages', { path: { chainId, safe_address: address }, query: {} }, pageUrl);
}
/**
 * Returns a `SafeMessage`
 */
function getSafeMessage(chainId, messageHash) {
    return (0, endpoint_1.getEndpoint)(baseUrl, '/v1/chains/{chainId}/messages/{message_hash}', {
        path: { chainId, message_hash: messageHash },
    });
}
/**
 * Propose a new `SafeMessage` for other owners to sign
 */
function proposeSafeMessage(chainId, address, body) {
    return (0, endpoint_1.postEndpoint)(baseUrl, '/v1/chains/{chainId}/safes/{safe_address}/messages', {
        path: { chainId, safe_address: address },
        body,
    });
}
/**
 * Add a confirmation to a `SafeMessage`
 */
function confirmSafeMessage(chainId, messageHash, body) {
    return (0, endpoint_1.postEndpoint)(baseUrl, '/v1/chains/{chainId}/messages/{message_hash}/signatures', {
        path: { chainId, message_hash: messageHash },
        body,
    });
}
/**
 * Returns a list of delegates
 */
function getDelegates(chainId, query = {}) {
    return (0, endpoint_1.getEndpoint)(baseUrl, '/v2/chains/{chainId}/delegates', {
        path: { chainId },
        query,
    });
}
/**
 * Registers a device/Safe for notifications
 */
function registerDevice(body) {
    return (0, endpoint_1.postEndpoint)(baseUrl, '/v1/register/notifications', {
        body,
    });
}
/**
 * Unregisters a Safe from notifications
 */
function unregisterSafe(chainId, address, uuid) {
    return (0, endpoint_1.deleteEndpoint)(baseUrl, '/v1/chains/{chainId}/notifications/devices/{uuid}/safes/{safe_address}', {
        path: { chainId, safe_address: address, uuid },
    });
}
/**
 * Unregisters a device from notifications
 */
function unregisterDevice(chainId, uuid) {
    return (0, endpoint_1.deleteEndpoint)(baseUrl, '/v1/chains/{chainId}/notifications/devices/{uuid}', {
        path: { chainId, uuid },
    });
}
/**
 * Registers a email address for a safe signer.
 *
 * The signer wallet has to sign a message of format: `email-register-{chainId}-{safeAddress}-{emailAddress}-{signer}-{timestamp}`
 * The signature is valid for 5 minutes.
 *
 * @param chainId
 * @param safeAddress
 * @param body Signer address and email address
 * @param headers Signature and Signature timestamp
 * @returns 200 if signature matches the data
 */
function registerEmail(chainId, safeAddress, body, headers) {
    return (0, endpoint_1.postEndpoint)(baseUrl, '/v1/chains/{chainId}/safes/{safe_address}/emails', {
        path: { chainId, safe_address: safeAddress },
        body,
        headers,
    });
}
/**
 * Changes an already registered email address for a safe signer. The new email address still needs to be verified.
 *
 * The signer wallet has to sign a message of format: `email-edit-{chainId}-{safeAddress}-{emailAddress}-{signer}-{timestamp}`
 * The signature is valid for 5 minutes.
 *
 * @param chainId
 * @param safeAddress
 * @param signerAddress
 * @param body New email address
 * @param headers Signature and Signature timestamp
 * @returns 202 if signature matches the data
 */
function changeEmail(chainId, safeAddress, signerAddress, body, headers) {
    return (0, endpoint_1.putEndpoint)(baseUrl, '/v1/chains/{chainId}/safes/{safe_address}/emails/{signer}', {
        path: { chainId, safe_address: safeAddress, signer: signerAddress },
        body,
        headers,
    });
}
/**
 * Resends an email verification code.
 */
function resendEmailVerificationCode(chainId, safeAddress, signerAddress) {
    return (0, endpoint_1.postEndpoint)(baseUrl, '/v1/chains/{chainId}/safes/{safe_address}/emails/{signer}/verify-resend', {
        path: { chainId, safe_address: safeAddress, signer: signerAddress },
        body: '',
    });
}
/**
 * Verifies a pending email address registration.
 *
 * @param chainId
 * @param safeAddress
 * @param signerAddress address who signed the email registration
 * @param body Verification code
 */
function verifyEmail(chainId, safeAddress, signerAddress, body) {
    return (0, endpoint_1.putEndpoint)(baseUrl, '/v1/chains/{chainId}/safes/{safe_address}/emails/{signer}/verify', {
        path: { chainId, safe_address: safeAddress, signer: signerAddress },
        body,
    });
}
/**
 * Gets the registered email address of the signer
 *
 * The signer wallet will have to sign a message of format: `email-retrieval-{chainId}-{safe}-{signer}-{timestamp}`
 * The signature is valid for 5 minutes.
 *
 * @param chainId
 * @param safeAddress
 * @param signerAddress address of the owner of the Safe
 *
 * @returns email address and verified flag
 */
function getRegisteredEmail(chainId, safeAddress, signerAddress, headers) {
    return (0, endpoint_1.getEndpoint)(baseUrl, '/v1/chains/{chainId}/safes/{safe_address}/emails/{signer}', {
        path: { chainId, safe_address: safeAddress, signer: signerAddress },
        headers,
    });
}
/**
 * Delete a registered email address for the signer
 *
 * The signer wallet will have to sign a message of format: `email-delete-{chainId}-{safe}-{signer}-{timestamp}`
 * The signature is valid for 5 minutes.
 *
 * @param chainId
 * @param safeAddress
 * @param signerAddress
 * @param headers
 */
function deleteRegisteredEmail(chainId, safeAddress, signerAddress, headers) {
    return (0, endpoint_1.deleteEndpoint)(baseUrl, '/v1/chains/{chainId}/safes/{safe_address}/emails/{signer}', {
        path: { chainId, safe_address: safeAddress, signer: signerAddress },
        headers,
    });
}
/**
 * Register a recovery module for receiving alerts
 * @param chainId
 * @param safeAddress
 * @param body - { moduleAddress: string }
 */
function registerRecoveryModule(chainId, safeAddress, body) {
    return (0, endpoint_1.postEndpoint)(baseUrl, '/v1/chains/{chainId}/safes/{safe_address}/recovery', {
        path: { chainId, safe_address: safeAddress },
        body,
    });
}
/**
 * Delete email subscription for a single category
 * @param query
 */
function unsubscribeSingle(query) {
    return (0, endpoint_1.deleteEndpoint)(baseUrl, '/v1/subscriptions', { query });
}
/**
 * Delete email subscription for all categories
 * @param query
 */
function unsubscribeAll(query) {
    return (0, endpoint_1.deleteEndpoint)(baseUrl, '/v1/subscriptions/all', { query });
}
/**
 * Get Safe overviews per address
 */
function getSafeOverviews(safes, query) {
    return (0, endpoint_1.getEndpoint)(baseUrl, '/v1/safes', {
        query: Object.assign(Object.assign({}, query), { safes: safes.join(',') }),
    });
}
function getContract(chainId, contractAddress) {
    return (0, endpoint_1.getEndpoint)(baseUrl, '/v1/chains/{chainId}/contracts/{contractAddress}', {
        path: {
            chainId: chainId,
            contractAddress: contractAddress,
        },
    });
}
function getAuthNonce() {
    return (0, endpoint_1.getEndpoint)(baseUrl, '/v1/auth/nonce', { credentials: 'include' });
}
function verifyAuth(body) {
    return (0, endpoint_1.postEndpoint)(baseUrl, '/v1/auth/verify', {
        body,
        credentials: 'include',
    });
}
function createAccount(body) {
    return (0, endpoint_1.postEndpoint)(baseUrl, '/v1/accounts', {
        body,
        credentials: 'include',
    });
}
function getAccount(address) {
    return (0, endpoint_1.getEndpoint)(baseUrl, '/v1/accounts/{address}', {
        path: { address },
        credentials: 'include',
    });
}
function deleteAccount(address) {
    return (0, endpoint_1.deleteEndpoint)(baseUrl, '/v1/accounts/{address}', {
        path: { address },
        credentials: 'include',
    });
}
function getAccountDataTypes() {
    return (0, endpoint_1.getEndpoint)(baseUrl, '/v1/accounts/data-types');
}
function getAccountDataSettings(address) {
    return (0, endpoint_1.getEndpoint)(baseUrl, '/v1/accounts/{address}/data-settings', {
        path: { address },
        credentials: 'include',
    });
}
function putAccountDataSettings(address, body) {
    return (0, endpoint_1.putEndpoint)(baseUrl, '/v1/accounts/{address}/data-settings', {
        path: { address },
        body,
        credentials: 'include',
    });
}
function getIndexingStatus(chainId) {
    return (0, endpoint_1.getEndpoint)(baseUrl, '/v1/chains/{chainId}/about/indexing', {
        path: { chainId },
    });
}
/* eslint-enable @typescript-eslint/explicit-module-boundary-types */
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@safe-global/safe-gateway-typescript-sdk/dist/types/chains.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@safe-global/safe-gateway-typescript-sdk/dist/types/chains.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FEATURES = exports.GAS_PRICE_TYPE = exports.RPC_AUTHENTICATION = void 0;
var RPC_AUTHENTICATION;
(function (RPC_AUTHENTICATION) {
    RPC_AUTHENTICATION["API_KEY_PATH"] = "API_KEY_PATH";
    RPC_AUTHENTICATION["NO_AUTHENTICATION"] = "NO_AUTHENTICATION";
    RPC_AUTHENTICATION["UNKNOWN"] = "UNKNOWN";
})(RPC_AUTHENTICATION || (exports.RPC_AUTHENTICATION = RPC_AUTHENTICATION = {}));
var GAS_PRICE_TYPE;
(function (GAS_PRICE_TYPE) {
    GAS_PRICE_TYPE["ORACLE"] = "ORACLE";
    GAS_PRICE_TYPE["FIXED"] = "FIXED";
    GAS_PRICE_TYPE["FIXED_1559"] = "FIXED1559";
    GAS_PRICE_TYPE["UNKNOWN"] = "UNKNOWN";
})(GAS_PRICE_TYPE || (exports.GAS_PRICE_TYPE = GAS_PRICE_TYPE = {}));
var FEATURES;
(function (FEATURES) {
    FEATURES["ERC721"] = "ERC721";
    FEATURES["SAFE_APPS"] = "SAFE_APPS";
    FEATURES["CONTRACT_INTERACTION"] = "CONTRACT_INTERACTION";
    FEATURES["DOMAIN_LOOKUP"] = "DOMAIN_LOOKUP";
    FEATURES["SPENDING_LIMIT"] = "SPENDING_LIMIT";
    FEATURES["EIP1559"] = "EIP1559";
    FEATURES["SAFE_TX_GAS_OPTIONAL"] = "SAFE_TX_GAS_OPTIONAL";
    FEATURES["TX_SIMULATION"] = "TX_SIMULATION";
    FEATURES["EIP1271"] = "EIP1271";
})(FEATURES || (exports.FEATURES = FEATURES = {}));
//# sourceMappingURL=chains.js.map

/***/ }),

/***/ "./node_modules/@safe-global/safe-gateway-typescript-sdk/dist/types/common.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@safe-global/safe-gateway-typescript-sdk/dist/types/common.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TokenType = void 0;
var TokenType;
(function (TokenType) {
    TokenType["ERC20"] = "ERC20";
    TokenType["ERC721"] = "ERC721";
    TokenType["NATIVE_TOKEN"] = "NATIVE_TOKEN";
    TokenType["UNKNOWN"] = "UNKNOWN";
})(TokenType || (exports.TokenType = TokenType = {}));
//# sourceMappingURL=common.js.map

/***/ }),

/***/ "./node_modules/@safe-global/safe-gateway-typescript-sdk/dist/types/decoded-data.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@safe-global/safe-gateway-typescript-sdk/dist/types/decoded-data.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NativeStakingStatus = exports.ConfirmationViewTypes = void 0;
var ConfirmationViewTypes;
(function (ConfirmationViewTypes) {
    ConfirmationViewTypes["GENERIC"] = "GENERIC";
    ConfirmationViewTypes["COW_SWAP_ORDER"] = "COW_SWAP_ORDER";
    ConfirmationViewTypes["COW_SWAP_TWAP_ORDER"] = "COW_SWAP_TWAP_ORDER";
    ConfirmationViewTypes["KILN_NATIVE_STAKING_DEPOSIT"] = "KILN_NATIVE_STAKING_DEPOSIT";
    ConfirmationViewTypes["KILN_NATIVE_STAKING_VALIDATORS_EXIT"] = "KILN_NATIVE_STAKING_VALIDATORS_EXIT";
    ConfirmationViewTypes["KILN_NATIVE_STAKING_WITHDRAW"] = "KILN_NATIVE_STAKING_WITHDRAW";
})(ConfirmationViewTypes || (exports.ConfirmationViewTypes = ConfirmationViewTypes = {}));
var NativeStakingStatus;
(function (NativeStakingStatus) {
    NativeStakingStatus["NOT_STAKED"] = "NOT_STAKED";
    NativeStakingStatus["ACTIVATING"] = "ACTIVATING";
    NativeStakingStatus["DEPOSIT_IN_PROGRESS"] = "DEPOSIT_IN_PROGRESS";
    NativeStakingStatus["ACTIVE"] = "ACTIVE";
    NativeStakingStatus["EXIT_REQUESTED"] = "EXIT_REQUESTED";
    NativeStakingStatus["EXITING"] = "EXITING";
    NativeStakingStatus["EXITED"] = "EXITED";
    NativeStakingStatus["SLASHED"] = "SLASHED";
})(NativeStakingStatus || (exports.NativeStakingStatus = NativeStakingStatus = {}));
//# sourceMappingURL=decoded-data.js.map

/***/ }),

/***/ "./node_modules/@safe-global/safe-gateway-typescript-sdk/dist/types/master-copies.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@safe-global/safe-gateway-typescript-sdk/dist/types/master-copies.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
//# sourceMappingURL=master-copies.js.map

/***/ }),

/***/ "./node_modules/@safe-global/safe-gateway-typescript-sdk/dist/types/notifications.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@safe-global/safe-gateway-typescript-sdk/dist/types/notifications.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DeviceType = void 0;
var DeviceType;
(function (DeviceType) {
    DeviceType["ANDROID"] = "ANDROID";
    DeviceType["IOS"] = "IOS";
    DeviceType["WEB"] = "WEB";
})(DeviceType || (exports.DeviceType = DeviceType = {}));
//# sourceMappingURL=notifications.js.map

/***/ }),

/***/ "./node_modules/@safe-global/safe-gateway-typescript-sdk/dist/types/relay.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@safe-global/safe-gateway-typescript-sdk/dist/types/relay.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
//# sourceMappingURL=relay.js.map

/***/ }),

/***/ "./node_modules/@safe-global/safe-gateway-typescript-sdk/dist/types/safe-apps.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@safe-global/safe-gateway-typescript-sdk/dist/types/safe-apps.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SafeAppSocialPlatforms = exports.SafeAppFeatures = exports.SafeAppAccessPolicyTypes = void 0;
var SafeAppAccessPolicyTypes;
(function (SafeAppAccessPolicyTypes) {
    SafeAppAccessPolicyTypes["NoRestrictions"] = "NO_RESTRICTIONS";
    SafeAppAccessPolicyTypes["DomainAllowlist"] = "DOMAIN_ALLOWLIST";
})(SafeAppAccessPolicyTypes || (exports.SafeAppAccessPolicyTypes = SafeAppAccessPolicyTypes = {}));
var SafeAppFeatures;
(function (SafeAppFeatures) {
    SafeAppFeatures["BATCHED_TRANSACTIONS"] = "BATCHED_TRANSACTIONS";
})(SafeAppFeatures || (exports.SafeAppFeatures = SafeAppFeatures = {}));
var SafeAppSocialPlatforms;
(function (SafeAppSocialPlatforms) {
    SafeAppSocialPlatforms["TWITTER"] = "TWITTER";
    SafeAppSocialPlatforms["GITHUB"] = "GITHUB";
    SafeAppSocialPlatforms["DISCORD"] = "DISCORD";
    SafeAppSocialPlatforms["TELEGRAM"] = "TELEGRAM";
})(SafeAppSocialPlatforms || (exports.SafeAppSocialPlatforms = SafeAppSocialPlatforms = {}));
//# sourceMappingURL=safe-apps.js.map

/***/ }),

/***/ "./node_modules/@safe-global/safe-gateway-typescript-sdk/dist/types/safe-info.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@safe-global/safe-gateway-typescript-sdk/dist/types/safe-info.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ImplementationVersionState = void 0;
var ImplementationVersionState;
(function (ImplementationVersionState) {
    ImplementationVersionState["UP_TO_DATE"] = "UP_TO_DATE";
    ImplementationVersionState["OUTDATED"] = "OUTDATED";
    ImplementationVersionState["UNKNOWN"] = "UNKNOWN";
})(ImplementationVersionState || (exports.ImplementationVersionState = ImplementationVersionState = {}));
//# sourceMappingURL=safe-info.js.map

/***/ }),

/***/ "./node_modules/@safe-global/safe-gateway-typescript-sdk/dist/types/safe-messages.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@safe-global/safe-gateway-typescript-sdk/dist/types/safe-messages.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SafeMessageStatus = exports.SafeMessageListItemType = void 0;
var SafeMessageListItemType;
(function (SafeMessageListItemType) {
    SafeMessageListItemType["DATE_LABEL"] = "DATE_LABEL";
    SafeMessageListItemType["MESSAGE"] = "MESSAGE";
})(SafeMessageListItemType || (exports.SafeMessageListItemType = SafeMessageListItemType = {}));
var SafeMessageStatus;
(function (SafeMessageStatus) {
    SafeMessageStatus["NEEDS_CONFIRMATION"] = "NEEDS_CONFIRMATION";
    SafeMessageStatus["CONFIRMED"] = "CONFIRMED";
})(SafeMessageStatus || (exports.SafeMessageStatus = SafeMessageStatus = {}));
//# sourceMappingURL=safe-messages.js.map

/***/ }),

/***/ "./node_modules/@safe-global/safe-gateway-typescript-sdk/dist/types/transactions.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@safe-global/safe-gateway-typescript-sdk/dist/types/transactions.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LabelValue = exports.StartTimeValue = exports.DurationType = exports.DetailedExecutionInfoType = exports.TransactionListItemType = exports.ConflictType = exports.TransactionInfoType = exports.SettingsInfoType = exports.TransactionTokenType = exports.TransferDirection = exports.TransactionStatus = exports.Operation = void 0;
var Operation;
(function (Operation) {
    Operation[Operation["CALL"] = 0] = "CALL";
    Operation[Operation["DELEGATE"] = 1] = "DELEGATE";
})(Operation || (exports.Operation = Operation = {}));
var TransactionStatus;
(function (TransactionStatus) {
    TransactionStatus["AWAITING_CONFIRMATIONS"] = "AWAITING_CONFIRMATIONS";
    TransactionStatus["AWAITING_EXECUTION"] = "AWAITING_EXECUTION";
    TransactionStatus["CANCELLED"] = "CANCELLED";
    TransactionStatus["FAILED"] = "FAILED";
    TransactionStatus["SUCCESS"] = "SUCCESS";
})(TransactionStatus || (exports.TransactionStatus = TransactionStatus = {}));
var TransferDirection;
(function (TransferDirection) {
    TransferDirection["INCOMING"] = "INCOMING";
    TransferDirection["OUTGOING"] = "OUTGOING";
    TransferDirection["UNKNOWN"] = "UNKNOWN";
})(TransferDirection || (exports.TransferDirection = TransferDirection = {}));
var TransactionTokenType;
(function (TransactionTokenType) {
    TransactionTokenType["ERC20"] = "ERC20";
    TransactionTokenType["ERC721"] = "ERC721";
    TransactionTokenType["NATIVE_COIN"] = "NATIVE_COIN";
})(TransactionTokenType || (exports.TransactionTokenType = TransactionTokenType = {}));
var SettingsInfoType;
(function (SettingsInfoType) {
    SettingsInfoType["SET_FALLBACK_HANDLER"] = "SET_FALLBACK_HANDLER";
    SettingsInfoType["ADD_OWNER"] = "ADD_OWNER";
    SettingsInfoType["REMOVE_OWNER"] = "REMOVE_OWNER";
    SettingsInfoType["SWAP_OWNER"] = "SWAP_OWNER";
    SettingsInfoType["CHANGE_THRESHOLD"] = "CHANGE_THRESHOLD";
    SettingsInfoType["CHANGE_IMPLEMENTATION"] = "CHANGE_IMPLEMENTATION";
    SettingsInfoType["ENABLE_MODULE"] = "ENABLE_MODULE";
    SettingsInfoType["DISABLE_MODULE"] = "DISABLE_MODULE";
    SettingsInfoType["SET_GUARD"] = "SET_GUARD";
    SettingsInfoType["DELETE_GUARD"] = "DELETE_GUARD";
})(SettingsInfoType || (exports.SettingsInfoType = SettingsInfoType = {}));
var TransactionInfoType;
(function (TransactionInfoType) {
    TransactionInfoType["TRANSFER"] = "Transfer";
    TransactionInfoType["SETTINGS_CHANGE"] = "SettingsChange";
    TransactionInfoType["CUSTOM"] = "Custom";
    TransactionInfoType["CREATION"] = "Creation";
    TransactionInfoType["SWAP_ORDER"] = "SwapOrder";
    TransactionInfoType["TWAP_ORDER"] = "TwapOrder";
    TransactionInfoType["SWAP_TRANSFER"] = "SwapTransfer";
    TransactionInfoType["NATIVE_STAKING_DEPOSIT"] = "NativeStakingDeposit";
    TransactionInfoType["NATIVE_STAKING_VALIDATORS_EXIT"] = "NativeStakingValidatorsExit";
    TransactionInfoType["NATIVE_STAKING_WITHDRAW"] = "NativeStakingWithdraw";
})(TransactionInfoType || (exports.TransactionInfoType = TransactionInfoType = {}));
var ConflictType;
(function (ConflictType) {
    ConflictType["NONE"] = "None";
    ConflictType["HAS_NEXT"] = "HasNext";
    ConflictType["END"] = "End";
})(ConflictType || (exports.ConflictType = ConflictType = {}));
var TransactionListItemType;
(function (TransactionListItemType) {
    TransactionListItemType["TRANSACTION"] = "TRANSACTION";
    TransactionListItemType["LABEL"] = "LABEL";
    TransactionListItemType["CONFLICT_HEADER"] = "CONFLICT_HEADER";
    TransactionListItemType["DATE_LABEL"] = "DATE_LABEL";
})(TransactionListItemType || (exports.TransactionListItemType = TransactionListItemType = {}));
var DetailedExecutionInfoType;
(function (DetailedExecutionInfoType) {
    DetailedExecutionInfoType["MULTISIG"] = "MULTISIG";
    DetailedExecutionInfoType["MODULE"] = "MODULE";
})(DetailedExecutionInfoType || (exports.DetailedExecutionInfoType = DetailedExecutionInfoType = {}));
var DurationType;
(function (DurationType) {
    DurationType["AUTO"] = "AUTO";
    DurationType["LIMIT_DURATION"] = "LIMIT_DURATION";
})(DurationType || (exports.DurationType = DurationType = {}));
var StartTimeValue;
(function (StartTimeValue) {
    StartTimeValue["AT_MINING_TIME"] = "AT_MINING_TIME";
    StartTimeValue["AT_EPOCH"] = "AT_EPOCH";
})(StartTimeValue || (exports.StartTimeValue = StartTimeValue = {}));
var LabelValue;
(function (LabelValue) {
    LabelValue["Queued"] = "Queued";
    LabelValue["Next"] = "Next";
})(LabelValue || (exports.LabelValue = LabelValue = {}));
//# sourceMappingURL=transactions.js.map

/***/ }),

/***/ "./node_modules/@safe-global/safe-gateway-typescript-sdk/dist/utils.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@safe-global/safe-gateway-typescript-sdk/dist/utils.js ***!
  \*****************************************************************************/
/***/ (function(__unused_webpack_module, exports) {


var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.insertParams = insertParams;
exports.stringifyQuery = stringifyQuery;
exports.fetchData = fetchData;
exports.getData = getData;
const isErrorResponse = (data) => {
    const isObject = typeof data === 'object' && data !== null;
    return isObject && ('code' in data || 'statusCode' in data) && 'message' in data;
};
function replaceParam(str, key, value) {
    return str.replace(new RegExp(`\\{${key}\\}`, 'g'), value);
}
function insertParams(template, params) {
    return params
        ? Object.keys(params).reduce((result, key) => {
            return replaceParam(result, key, String(params[key]));
        }, template)
        : template;
}
function stringifyQuery(query) {
    if (!query) {
        return '';
    }
    const searchParams = new URLSearchParams();
    Object.keys(query).forEach((key) => {
        if (query[key] != null) {
            searchParams.append(key, String(query[key]));
        }
    });
    const searchString = searchParams.toString();
    return searchString ? `?${searchString}` : '';
}
function parseResponse(resp) {
    return __awaiter(this, void 0, void 0, function* () {
        var _a;
        let json;
        try {
            json = yield resp.json();
        }
        catch (_b) {
            json = {};
        }
        if (!resp.ok) {
            const errTxt = isErrorResponse(json)
                ? `CGW error - ${(_a = json.code) !== null && _a !== void 0 ? _a : json.statusCode}: ${json.message}`
                : `CGW error - status ${resp.statusText}`;
            throw new Error(errTxt);
        }
        return json;
    });
}
function fetchData(url, method, body, headers, credentials) {
    return __awaiter(this, void 0, void 0, function* () {
        const requestHeaders = Object.assign({ 'Content-Type': 'application/json' }, headers);
        const options = {
            method: method !== null && method !== void 0 ? method : 'POST',
            headers: requestHeaders,
        };
        if (credentials) {
            options['credentials'] = credentials;
        }
        if (body != null) {
            options.body = typeof body === 'string' ? body : JSON.stringify(body);
        }
        const resp = yield fetch(url, options);
        return parseResponse(resp);
    });
}
function getData(url, headers, credentials) {
    return __awaiter(this, void 0, void 0, function* () {
        const options = {
            method: 'GET',
        };
        if (headers) {
            options['headers'] = Object.assign(Object.assign({}, headers), { 'Content-Type': 'application/json' });
        }
        if (credentials) {
            options['credentials'] = credentials;
        }
        const resp = yield fetch(url, options);
        return parseResponse(resp);
    });
}
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ "./node_modules/abitype/dist/cjs/errors.js":
/*!*************************************************!*\
  !*** ./node_modules/abitype/dist/cjs/errors.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BaseError = void 0;
const version_js_1 = __webpack_require__(/*! ./version.js */ "./node_modules/abitype/dist/cjs/version.js");
class BaseError extends Error {
    constructor(shortMessage, args = {}) {
        const details = args.cause instanceof BaseError
            ? args.cause.details
            : args.cause?.message
                ? args.cause.message
                : args.details;
        const docsPath = args.cause instanceof BaseError
            ? args.cause.docsPath || args.docsPath
            : args.docsPath;
        const message = [
            shortMessage || 'An error occurred.',
            '',
            ...(args.metaMessages ? [...args.metaMessages, ''] : []),
            ...(docsPath ? [`Docs: https://abitype.dev${docsPath}`] : []),
            ...(details ? [`Details: ${details}`] : []),
            `Version: abitype@${version_js_1.version}`,
        ].join('\n');
        super(message);
        Object.defineProperty(this, "details", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "docsPath", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "metaMessages", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "shortMessage", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'AbiTypeError'
        });
        if (args.cause)
            this.cause = args.cause;
        this.details = details;
        this.docsPath = docsPath;
        this.metaMessages = args.metaMessages;
        this.shortMessage = shortMessage;
    }
}
exports.BaseError = BaseError;
//# sourceMappingURL=errors.js.map

/***/ }),

/***/ "./node_modules/abitype/dist/cjs/exports/index.js":
/*!********************************************************!*\
  !*** ./node_modules/abitype/dist/cjs/exports/index.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CircularReferenceError = exports.InvalidParenthesisError = exports.UnknownSignatureError = exports.InvalidSignatureError = exports.InvalidStructSignatureError = exports.InvalidAbiParameterError = exports.InvalidAbiParametersError = exports.InvalidParameterError = exports.SolidityProtectedKeywordError = exports.InvalidModifierError = exports.InvalidFunctionModifierError = exports.InvalidAbiTypeParameterError = exports.UnknownSolidityTypeError = exports.InvalidAbiItemError = exports.UnknownTypeError = exports.parseAbiParameters = exports.parseAbiParameter = exports.parseAbiItem = exports.parseAbi = exports.formatAbiParameters = exports.formatAbiParameter = exports.formatAbiItem = exports.formatAbi = exports.narrow = exports.BaseError = void 0;
var errors_js_1 = __webpack_require__(/*! ../errors.js */ "./node_modules/abitype/dist/cjs/errors.js");
Object.defineProperty(exports, "BaseError", ({ enumerable: true, get: function () { return errors_js_1.BaseError; } }));
var narrow_js_1 = __webpack_require__(/*! ../narrow.js */ "./node_modules/abitype/dist/cjs/narrow.js");
Object.defineProperty(exports, "narrow", ({ enumerable: true, get: function () { return narrow_js_1.narrow; } }));
var formatAbi_js_1 = __webpack_require__(/*! ../human-readable/formatAbi.js */ "./node_modules/abitype/dist/cjs/human-readable/formatAbi.js");
Object.defineProperty(exports, "formatAbi", ({ enumerable: true, get: function () { return formatAbi_js_1.formatAbi; } }));
var formatAbiItem_js_1 = __webpack_require__(/*! ../human-readable/formatAbiItem.js */ "./node_modules/abitype/dist/cjs/human-readable/formatAbiItem.js");
Object.defineProperty(exports, "formatAbiItem", ({ enumerable: true, get: function () { return formatAbiItem_js_1.formatAbiItem; } }));
var formatAbiParameter_js_1 = __webpack_require__(/*! ../human-readable/formatAbiParameter.js */ "./node_modules/abitype/dist/cjs/human-readable/formatAbiParameter.js");
Object.defineProperty(exports, "formatAbiParameter", ({ enumerable: true, get: function () { return formatAbiParameter_js_1.formatAbiParameter; } }));
var formatAbiParameters_js_1 = __webpack_require__(/*! ../human-readable/formatAbiParameters.js */ "./node_modules/abitype/dist/cjs/human-readable/formatAbiParameters.js");
Object.defineProperty(exports, "formatAbiParameters", ({ enumerable: true, get: function () { return formatAbiParameters_js_1.formatAbiParameters; } }));
var parseAbi_js_1 = __webpack_require__(/*! ../human-readable/parseAbi.js */ "./node_modules/abitype/dist/cjs/human-readable/parseAbi.js");
Object.defineProperty(exports, "parseAbi", ({ enumerable: true, get: function () { return parseAbi_js_1.parseAbi; } }));
var parseAbiItem_js_1 = __webpack_require__(/*! ../human-readable/parseAbiItem.js */ "./node_modules/abitype/dist/cjs/human-readable/parseAbiItem.js");
Object.defineProperty(exports, "parseAbiItem", ({ enumerable: true, get: function () { return parseAbiItem_js_1.parseAbiItem; } }));
var parseAbiParameter_js_1 = __webpack_require__(/*! ../human-readable/parseAbiParameter.js */ "./node_modules/abitype/dist/cjs/human-readable/parseAbiParameter.js");
Object.defineProperty(exports, "parseAbiParameter", ({ enumerable: true, get: function () { return parseAbiParameter_js_1.parseAbiParameter; } }));
var parseAbiParameters_js_1 = __webpack_require__(/*! ../human-readable/parseAbiParameters.js */ "./node_modules/abitype/dist/cjs/human-readable/parseAbiParameters.js");
Object.defineProperty(exports, "parseAbiParameters", ({ enumerable: true, get: function () { return parseAbiParameters_js_1.parseAbiParameters; } }));
var abiItem_js_1 = __webpack_require__(/*! ../human-readable/errors/abiItem.js */ "./node_modules/abitype/dist/cjs/human-readable/errors/abiItem.js");
Object.defineProperty(exports, "UnknownTypeError", ({ enumerable: true, get: function () { return abiItem_js_1.UnknownTypeError; } }));
Object.defineProperty(exports, "InvalidAbiItemError", ({ enumerable: true, get: function () { return abiItem_js_1.InvalidAbiItemError; } }));
Object.defineProperty(exports, "UnknownSolidityTypeError", ({ enumerable: true, get: function () { return abiItem_js_1.UnknownSolidityTypeError; } }));
var abiParameter_js_1 = __webpack_require__(/*! ../human-readable/errors/abiParameter.js */ "./node_modules/abitype/dist/cjs/human-readable/errors/abiParameter.js");
Object.defineProperty(exports, "InvalidAbiTypeParameterError", ({ enumerable: true, get: function () { return abiParameter_js_1.InvalidAbiTypeParameterError; } }));
Object.defineProperty(exports, "InvalidFunctionModifierError", ({ enumerable: true, get: function () { return abiParameter_js_1.InvalidFunctionModifierError; } }));
Object.defineProperty(exports, "InvalidModifierError", ({ enumerable: true, get: function () { return abiParameter_js_1.InvalidModifierError; } }));
Object.defineProperty(exports, "SolidityProtectedKeywordError", ({ enumerable: true, get: function () { return abiParameter_js_1.SolidityProtectedKeywordError; } }));
Object.defineProperty(exports, "InvalidParameterError", ({ enumerable: true, get: function () { return abiParameter_js_1.InvalidParameterError; } }));
Object.defineProperty(exports, "InvalidAbiParametersError", ({ enumerable: true, get: function () { return abiParameter_js_1.InvalidAbiParametersError; } }));
Object.defineProperty(exports, "InvalidAbiParameterError", ({ enumerable: true, get: function () { return abiParameter_js_1.InvalidAbiParameterError; } }));
var signature_js_1 = __webpack_require__(/*! ../human-readable/errors/signature.js */ "./node_modules/abitype/dist/cjs/human-readable/errors/signature.js");
Object.defineProperty(exports, "InvalidStructSignatureError", ({ enumerable: true, get: function () { return signature_js_1.InvalidStructSignatureError; } }));
Object.defineProperty(exports, "InvalidSignatureError", ({ enumerable: true, get: function () { return signature_js_1.InvalidSignatureError; } }));
Object.defineProperty(exports, "UnknownSignatureError", ({ enumerable: true, get: function () { return signature_js_1.UnknownSignatureError; } }));
var splitParameters_js_1 = __webpack_require__(/*! ../human-readable/errors/splitParameters.js */ "./node_modules/abitype/dist/cjs/human-readable/errors/splitParameters.js");
Object.defineProperty(exports, "InvalidParenthesisError", ({ enumerable: true, get: function () { return splitParameters_js_1.InvalidParenthesisError; } }));
var struct_js_1 = __webpack_require__(/*! ../human-readable/errors/struct.js */ "./node_modules/abitype/dist/cjs/human-readable/errors/struct.js");
Object.defineProperty(exports, "CircularReferenceError", ({ enumerable: true, get: function () { return struct_js_1.CircularReferenceError; } }));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/abitype/dist/cjs/human-readable/errors/abiItem.js":
/*!************************************************************************!*\
  !*** ./node_modules/abitype/dist/cjs/human-readable/errors/abiItem.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UnknownSolidityTypeError = exports.UnknownTypeError = exports.InvalidAbiItemError = void 0;
const errors_js_1 = __webpack_require__(/*! ../../errors.js */ "./node_modules/abitype/dist/cjs/errors.js");
class InvalidAbiItemError extends errors_js_1.BaseError {
    constructor({ signature }) {
        super('Failed to parse ABI item.', {
            details: `parseAbiItem(${JSON.stringify(signature, null, 2)})`,
            docsPath: '/api/human#parseabiitem-1',
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'InvalidAbiItemError'
        });
    }
}
exports.InvalidAbiItemError = InvalidAbiItemError;
class UnknownTypeError extends errors_js_1.BaseError {
    constructor({ type }) {
        super('Unknown type.', {
            metaMessages: [
                `Type "${type}" is not a valid ABI type. Perhaps you forgot to include a struct signature?`,
            ],
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'UnknownTypeError'
        });
    }
}
exports.UnknownTypeError = UnknownTypeError;
class UnknownSolidityTypeError extends errors_js_1.BaseError {
    constructor({ type }) {
        super('Unknown type.', {
            metaMessages: [`Type "${type}" is not a valid ABI type.`],
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'UnknownSolidityTypeError'
        });
    }
}
exports.UnknownSolidityTypeError = UnknownSolidityTypeError;
//# sourceMappingURL=abiItem.js.map

/***/ }),

/***/ "./node_modules/abitype/dist/cjs/human-readable/errors/abiParameter.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/abitype/dist/cjs/human-readable/errors/abiParameter.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.InvalidAbiTypeParameterError = exports.InvalidFunctionModifierError = exports.InvalidModifierError = exports.SolidityProtectedKeywordError = exports.InvalidParameterError = exports.InvalidAbiParametersError = exports.InvalidAbiParameterError = void 0;
const errors_js_1 = __webpack_require__(/*! ../../errors.js */ "./node_modules/abitype/dist/cjs/errors.js");
class InvalidAbiParameterError extends errors_js_1.BaseError {
    constructor({ param }) {
        super('Failed to parse ABI parameter.', {
            details: `parseAbiParameter(${JSON.stringify(param, null, 2)})`,
            docsPath: '/api/human#parseabiparameter-1',
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'InvalidAbiParameterError'
        });
    }
}
exports.InvalidAbiParameterError = InvalidAbiParameterError;
class InvalidAbiParametersError extends errors_js_1.BaseError {
    constructor({ params }) {
        super('Failed to parse ABI parameters.', {
            details: `parseAbiParameters(${JSON.stringify(params, null, 2)})`,
            docsPath: '/api/human#parseabiparameters-1',
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'InvalidAbiParametersError'
        });
    }
}
exports.InvalidAbiParametersError = InvalidAbiParametersError;
class InvalidParameterError extends errors_js_1.BaseError {
    constructor({ param }) {
        super('Invalid ABI parameter.', {
            details: param,
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'InvalidParameterError'
        });
    }
}
exports.InvalidParameterError = InvalidParameterError;
class SolidityProtectedKeywordError extends errors_js_1.BaseError {
    constructor({ param, name }) {
        super('Invalid ABI parameter.', {
            details: param,
            metaMessages: [
                `"${name}" is a protected Solidity keyword. More info: https://docs.soliditylang.org/en/latest/cheatsheet.html`,
            ],
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'SolidityProtectedKeywordError'
        });
    }
}
exports.SolidityProtectedKeywordError = SolidityProtectedKeywordError;
class InvalidModifierError extends errors_js_1.BaseError {
    constructor({ param, type, modifier, }) {
        super('Invalid ABI parameter.', {
            details: param,
            metaMessages: [
                `Modifier "${modifier}" not allowed${type ? ` in "${type}" type` : ''}.`,
            ],
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'InvalidModifierError'
        });
    }
}
exports.InvalidModifierError = InvalidModifierError;
class InvalidFunctionModifierError extends errors_js_1.BaseError {
    constructor({ param, type, modifier, }) {
        super('Invalid ABI parameter.', {
            details: param,
            metaMessages: [
                `Modifier "${modifier}" not allowed${type ? ` in "${type}" type` : ''}.`,
                `Data location can only be specified for array, struct, or mapping types, but "${modifier}" was given.`,
            ],
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'InvalidFunctionModifierError'
        });
    }
}
exports.InvalidFunctionModifierError = InvalidFunctionModifierError;
class InvalidAbiTypeParameterError extends errors_js_1.BaseError {
    constructor({ abiParameter, }) {
        super('Invalid ABI parameter.', {
            details: JSON.stringify(abiParameter, null, 2),
            metaMessages: ['ABI parameter type is invalid.'],
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'InvalidAbiTypeParameterError'
        });
    }
}
exports.InvalidAbiTypeParameterError = InvalidAbiTypeParameterError;
//# sourceMappingURL=abiParameter.js.map

/***/ }),

/***/ "./node_modules/abitype/dist/cjs/human-readable/errors/signature.js":
/*!**************************************************************************!*\
  !*** ./node_modules/abitype/dist/cjs/human-readable/errors/signature.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.InvalidStructSignatureError = exports.UnknownSignatureError = exports.InvalidSignatureError = void 0;
const errors_js_1 = __webpack_require__(/*! ../../errors.js */ "./node_modules/abitype/dist/cjs/errors.js");
class InvalidSignatureError extends errors_js_1.BaseError {
    constructor({ signature, type, }) {
        super(`Invalid ${type} signature.`, {
            details: signature,
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'InvalidSignatureError'
        });
    }
}
exports.InvalidSignatureError = InvalidSignatureError;
class UnknownSignatureError extends errors_js_1.BaseError {
    constructor({ signature }) {
        super('Unknown signature.', {
            details: signature,
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'UnknownSignatureError'
        });
    }
}
exports.UnknownSignatureError = UnknownSignatureError;
class InvalidStructSignatureError extends errors_js_1.BaseError {
    constructor({ signature }) {
        super('Invalid struct signature.', {
            details: signature,
            metaMessages: ['No properties exist.'],
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'InvalidStructSignatureError'
        });
    }
}
exports.InvalidStructSignatureError = InvalidStructSignatureError;
//# sourceMappingURL=signature.js.map

/***/ }),

/***/ "./node_modules/abitype/dist/cjs/human-readable/errors/splitParameters.js":
/*!********************************************************************************!*\
  !*** ./node_modules/abitype/dist/cjs/human-readable/errors/splitParameters.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.InvalidParenthesisError = void 0;
const errors_js_1 = __webpack_require__(/*! ../../errors.js */ "./node_modules/abitype/dist/cjs/errors.js");
class InvalidParenthesisError extends errors_js_1.BaseError {
    constructor({ current, depth }) {
        super('Unbalanced parentheses.', {
            metaMessages: [
                `"${current.trim()}" has too many ${depth > 0 ? 'opening' : 'closing'} parentheses.`,
            ],
            details: `Depth "${depth}"`,
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'InvalidParenthesisError'
        });
    }
}
exports.InvalidParenthesisError = InvalidParenthesisError;
//# sourceMappingURL=splitParameters.js.map

/***/ }),

/***/ "./node_modules/abitype/dist/cjs/human-readable/errors/struct.js":
/*!***********************************************************************!*\
  !*** ./node_modules/abitype/dist/cjs/human-readable/errors/struct.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CircularReferenceError = void 0;
const errors_js_1 = __webpack_require__(/*! ../../errors.js */ "./node_modules/abitype/dist/cjs/errors.js");
class CircularReferenceError extends errors_js_1.BaseError {
    constructor({ type }) {
        super('Circular reference detected.', {
            metaMessages: [`Struct "${type}" is a circular reference.`],
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'CircularReferenceError'
        });
    }
}
exports.CircularReferenceError = CircularReferenceError;
//# sourceMappingURL=struct.js.map

/***/ }),

/***/ "./node_modules/abitype/dist/cjs/human-readable/formatAbi.js":
/*!*******************************************************************!*\
  !*** ./node_modules/abitype/dist/cjs/human-readable/formatAbi.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.formatAbi = formatAbi;
const formatAbiItem_js_1 = __webpack_require__(/*! ./formatAbiItem.js */ "./node_modules/abitype/dist/cjs/human-readable/formatAbiItem.js");
function formatAbi(abi) {
    const signatures = [];
    const length = abi.length;
    for (let i = 0; i < length; i++) {
        const abiItem = abi[i];
        const signature = (0, formatAbiItem_js_1.formatAbiItem)(abiItem);
        signatures.push(signature);
    }
    return signatures;
}
//# sourceMappingURL=formatAbi.js.map

/***/ }),

/***/ "./node_modules/abitype/dist/cjs/human-readable/formatAbiItem.js":
/*!***********************************************************************!*\
  !*** ./node_modules/abitype/dist/cjs/human-readable/formatAbiItem.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.formatAbiItem = formatAbiItem;
const formatAbiParameters_js_1 = __webpack_require__(/*! ./formatAbiParameters.js */ "./node_modules/abitype/dist/cjs/human-readable/formatAbiParameters.js");
function formatAbiItem(abiItem) {
    if (abiItem.type === 'function')
        return `function ${abiItem.name}(${(0, formatAbiParameters_js_1.formatAbiParameters)(abiItem.inputs)})${abiItem.stateMutability && abiItem.stateMutability !== 'nonpayable'
            ? ` ${abiItem.stateMutability}`
            : ''}${abiItem.outputs?.length
            ? ` returns (${(0, formatAbiParameters_js_1.formatAbiParameters)(abiItem.outputs)})`
            : ''}`;
    if (abiItem.type === 'event')
        return `event ${abiItem.name}(${(0, formatAbiParameters_js_1.formatAbiParameters)(abiItem.inputs)})`;
    if (abiItem.type === 'error')
        return `error ${abiItem.name}(${(0, formatAbiParameters_js_1.formatAbiParameters)(abiItem.inputs)})`;
    if (abiItem.type === 'constructor')
        return `constructor(${(0, formatAbiParameters_js_1.formatAbiParameters)(abiItem.inputs)})${abiItem.stateMutability === 'payable' ? ' payable' : ''}`;
    if (abiItem.type === 'fallback')
        return `fallback() external${abiItem.stateMutability === 'payable' ? ' payable' : ''}`;
    return 'receive() external payable';
}
//# sourceMappingURL=formatAbiItem.js.map

/***/ }),

/***/ "./node_modules/abitype/dist/cjs/human-readable/formatAbiParameter.js":
/*!****************************************************************************!*\
  !*** ./node_modules/abitype/dist/cjs/human-readable/formatAbiParameter.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.formatAbiParameter = formatAbiParameter;
const regex_js_1 = __webpack_require__(/*! ../regex.js */ "./node_modules/abitype/dist/cjs/regex.js");
const tupleRegex = /^tuple(?<array>(\[(\d*)\])*)$/;
function formatAbiParameter(abiParameter) {
    let type = abiParameter.type;
    if (tupleRegex.test(abiParameter.type) && 'components' in abiParameter) {
        type = '(';
        const length = abiParameter.components.length;
        for (let i = 0; i < length; i++) {
            const component = abiParameter.components[i];
            type += formatAbiParameter(component);
            if (i < length - 1)
                type += ', ';
        }
        const result = (0, regex_js_1.execTyped)(tupleRegex, abiParameter.type);
        type += `)${result?.array ?? ''}`;
        return formatAbiParameter({
            ...abiParameter,
            type,
        });
    }
    if ('indexed' in abiParameter && abiParameter.indexed)
        type = `${type} indexed`;
    if (abiParameter.name)
        return `${type} ${abiParameter.name}`;
    return type;
}
//# sourceMappingURL=formatAbiParameter.js.map

/***/ }),

/***/ "./node_modules/abitype/dist/cjs/human-readable/formatAbiParameters.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/abitype/dist/cjs/human-readable/formatAbiParameters.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.formatAbiParameters = formatAbiParameters;
const formatAbiParameter_js_1 = __webpack_require__(/*! ./formatAbiParameter.js */ "./node_modules/abitype/dist/cjs/human-readable/formatAbiParameter.js");
function formatAbiParameters(abiParameters) {
    let params = '';
    const length = abiParameters.length;
    for (let i = 0; i < length; i++) {
        const abiParameter = abiParameters[i];
        params += (0, formatAbiParameter_js_1.formatAbiParameter)(abiParameter);
        if (i !== length - 1)
            params += ', ';
    }
    return params;
}
//# sourceMappingURL=formatAbiParameters.js.map

/***/ }),

/***/ "./node_modules/abitype/dist/cjs/human-readable/parseAbi.js":
/*!******************************************************************!*\
  !*** ./node_modules/abitype/dist/cjs/human-readable/parseAbi.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.parseAbi = parseAbi;
const signatures_js_1 = __webpack_require__(/*! ./runtime/signatures.js */ "./node_modules/abitype/dist/cjs/human-readable/runtime/signatures.js");
const structs_js_1 = __webpack_require__(/*! ./runtime/structs.js */ "./node_modules/abitype/dist/cjs/human-readable/runtime/structs.js");
const utils_js_1 = __webpack_require__(/*! ./runtime/utils.js */ "./node_modules/abitype/dist/cjs/human-readable/runtime/utils.js");
function parseAbi(signatures) {
    const structs = (0, structs_js_1.parseStructs)(signatures);
    const abi = [];
    const length = signatures.length;
    for (let i = 0; i < length; i++) {
        const signature = signatures[i];
        if ((0, signatures_js_1.isStructSignature)(signature))
            continue;
        abi.push((0, utils_js_1.parseSignature)(signature, structs));
    }
    return abi;
}
//# sourceMappingURL=parseAbi.js.map

/***/ }),

/***/ "./node_modules/abitype/dist/cjs/human-readable/parseAbiItem.js":
/*!**********************************************************************!*\
  !*** ./node_modules/abitype/dist/cjs/human-readable/parseAbiItem.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.parseAbiItem = parseAbiItem;
const abiItem_js_1 = __webpack_require__(/*! ./errors/abiItem.js */ "./node_modules/abitype/dist/cjs/human-readable/errors/abiItem.js");
const signatures_js_1 = __webpack_require__(/*! ./runtime/signatures.js */ "./node_modules/abitype/dist/cjs/human-readable/runtime/signatures.js");
const structs_js_1 = __webpack_require__(/*! ./runtime/structs.js */ "./node_modules/abitype/dist/cjs/human-readable/runtime/structs.js");
const utils_js_1 = __webpack_require__(/*! ./runtime/utils.js */ "./node_modules/abitype/dist/cjs/human-readable/runtime/utils.js");
function parseAbiItem(signature) {
    let abiItem;
    if (typeof signature === 'string')
        abiItem = (0, utils_js_1.parseSignature)(signature);
    else {
        const structs = (0, structs_js_1.parseStructs)(signature);
        const length = signature.length;
        for (let i = 0; i < length; i++) {
            const signature_ = signature[i];
            if ((0, signatures_js_1.isStructSignature)(signature_))
                continue;
            abiItem = (0, utils_js_1.parseSignature)(signature_, structs);
            break;
        }
    }
    if (!abiItem)
        throw new abiItem_js_1.InvalidAbiItemError({ signature });
    return abiItem;
}
//# sourceMappingURL=parseAbiItem.js.map

/***/ }),

/***/ "./node_modules/abitype/dist/cjs/human-readable/parseAbiParameter.js":
/*!***************************************************************************!*\
  !*** ./node_modules/abitype/dist/cjs/human-readable/parseAbiParameter.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.parseAbiParameter = parseAbiParameter;
const abiParameter_js_1 = __webpack_require__(/*! ./errors/abiParameter.js */ "./node_modules/abitype/dist/cjs/human-readable/errors/abiParameter.js");
const signatures_js_1 = __webpack_require__(/*! ./runtime/signatures.js */ "./node_modules/abitype/dist/cjs/human-readable/runtime/signatures.js");
const structs_js_1 = __webpack_require__(/*! ./runtime/structs.js */ "./node_modules/abitype/dist/cjs/human-readable/runtime/structs.js");
const utils_js_1 = __webpack_require__(/*! ./runtime/utils.js */ "./node_modules/abitype/dist/cjs/human-readable/runtime/utils.js");
function parseAbiParameter(param) {
    let abiParameter;
    if (typeof param === 'string')
        abiParameter = (0, utils_js_1.parseAbiParameter)(param, {
            modifiers: signatures_js_1.modifiers,
        });
    else {
        const structs = (0, structs_js_1.parseStructs)(param);
        const length = param.length;
        for (let i = 0; i < length; i++) {
            const signature = param[i];
            if ((0, signatures_js_1.isStructSignature)(signature))
                continue;
            abiParameter = (0, utils_js_1.parseAbiParameter)(signature, { modifiers: signatures_js_1.modifiers, structs });
            break;
        }
    }
    if (!abiParameter)
        throw new abiParameter_js_1.InvalidAbiParameterError({ param });
    return abiParameter;
}
//# sourceMappingURL=parseAbiParameter.js.map

/***/ }),

/***/ "./node_modules/abitype/dist/cjs/human-readable/parseAbiParameters.js":
/*!****************************************************************************!*\
  !*** ./node_modules/abitype/dist/cjs/human-readable/parseAbiParameters.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.parseAbiParameters = parseAbiParameters;
const abiParameter_js_1 = __webpack_require__(/*! ./errors/abiParameter.js */ "./node_modules/abitype/dist/cjs/human-readable/errors/abiParameter.js");
const signatures_js_1 = __webpack_require__(/*! ./runtime/signatures.js */ "./node_modules/abitype/dist/cjs/human-readable/runtime/signatures.js");
const structs_js_1 = __webpack_require__(/*! ./runtime/structs.js */ "./node_modules/abitype/dist/cjs/human-readable/runtime/structs.js");
const utils_js_1 = __webpack_require__(/*! ./runtime/utils.js */ "./node_modules/abitype/dist/cjs/human-readable/runtime/utils.js");
const utils_js_2 = __webpack_require__(/*! ./runtime/utils.js */ "./node_modules/abitype/dist/cjs/human-readable/runtime/utils.js");
function parseAbiParameters(params) {
    const abiParameters = [];
    if (typeof params === 'string') {
        const parameters = (0, utils_js_1.splitParameters)(params);
        const length = parameters.length;
        for (let i = 0; i < length; i++) {
            abiParameters.push((0, utils_js_2.parseAbiParameter)(parameters[i], { modifiers: signatures_js_1.modifiers }));
        }
    }
    else {
        const structs = (0, structs_js_1.parseStructs)(params);
        const length = params.length;
        for (let i = 0; i < length; i++) {
            const signature = params[i];
            if ((0, signatures_js_1.isStructSignature)(signature))
                continue;
            const parameters = (0, utils_js_1.splitParameters)(signature);
            const length = parameters.length;
            for (let k = 0; k < length; k++) {
                abiParameters.push((0, utils_js_2.parseAbiParameter)(parameters[k], { modifiers: signatures_js_1.modifiers, structs }));
            }
        }
    }
    if (abiParameters.length === 0)
        throw new abiParameter_js_1.InvalidAbiParametersError({ params });
    return abiParameters;
}
//# sourceMappingURL=parseAbiParameters.js.map

/***/ }),

/***/ "./node_modules/abitype/dist/cjs/human-readable/runtime/cache.js":
/*!***********************************************************************!*\
  !*** ./node_modules/abitype/dist/cjs/human-readable/runtime/cache.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.parameterCache = void 0;
exports.getParameterCacheKey = getParameterCacheKey;
function getParameterCacheKey(param, type, structs) {
    let structKey = '';
    if (structs)
        for (const struct of Object.entries(structs)) {
            if (!struct)
                continue;
            let propertyKey = '';
            for (const property of struct[1]) {
                propertyKey += `[${property.type}${property.name ? `:${property.name}` : ''}]`;
            }
            structKey += `(${struct[0]}{${propertyKey}})`;
        }
    if (type)
        return `${type}:${param}${structKey}`;
    return param;
}
exports.parameterCache = new Map([
    ['address', { type: 'address' }],
    ['bool', { type: 'bool' }],
    ['bytes', { type: 'bytes' }],
    ['bytes32', { type: 'bytes32' }],
    ['int', { type: 'int256' }],
    ['int256', { type: 'int256' }],
    ['string', { type: 'string' }],
    ['uint', { type: 'uint256' }],
    ['uint8', { type: 'uint8' }],
    ['uint16', { type: 'uint16' }],
    ['uint24', { type: 'uint24' }],
    ['uint32', { type: 'uint32' }],
    ['uint64', { type: 'uint64' }],
    ['uint96', { type: 'uint96' }],
    ['uint112', { type: 'uint112' }],
    ['uint160', { type: 'uint160' }],
    ['uint192', { type: 'uint192' }],
    ['uint256', { type: 'uint256' }],
    ['address owner', { type: 'address', name: 'owner' }],
    ['address to', { type: 'address', name: 'to' }],
    ['bool approved', { type: 'bool', name: 'approved' }],
    ['bytes _data', { type: 'bytes', name: '_data' }],
    ['bytes data', { type: 'bytes', name: 'data' }],
    ['bytes signature', { type: 'bytes', name: 'signature' }],
    ['bytes32 hash', { type: 'bytes32', name: 'hash' }],
    ['bytes32 r', { type: 'bytes32', name: 'r' }],
    ['bytes32 root', { type: 'bytes32', name: 'root' }],
    ['bytes32 s', { type: 'bytes32', name: 's' }],
    ['string name', { type: 'string', name: 'name' }],
    ['string symbol', { type: 'string', name: 'symbol' }],
    ['string tokenURI', { type: 'string', name: 'tokenURI' }],
    ['uint tokenId', { type: 'uint256', name: 'tokenId' }],
    ['uint8 v', { type: 'uint8', name: 'v' }],
    ['uint256 balance', { type: 'uint256', name: 'balance' }],
    ['uint256 tokenId', { type: 'uint256', name: 'tokenId' }],
    ['uint256 value', { type: 'uint256', name: 'value' }],
    [
        'event:address indexed from',
        { type: 'address', name: 'from', indexed: true },
    ],
    ['event:address indexed to', { type: 'address', name: 'to', indexed: true }],
    [
        'event:uint indexed tokenId',
        { type: 'uint256', name: 'tokenId', indexed: true },
    ],
    [
        'event:uint256 indexed tokenId',
        { type: 'uint256', name: 'tokenId', indexed: true },
    ],
]);
//# sourceMappingURL=cache.js.map

/***/ }),

/***/ "./node_modules/abitype/dist/cjs/human-readable/runtime/signatures.js":
/*!****************************************************************************!*\
  !*** ./node_modules/abitype/dist/cjs/human-readable/runtime/signatures.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.functionModifiers = exports.eventModifiers = exports.modifiers = void 0;
exports.isErrorSignature = isErrorSignature;
exports.execErrorSignature = execErrorSignature;
exports.isEventSignature = isEventSignature;
exports.execEventSignature = execEventSignature;
exports.isFunctionSignature = isFunctionSignature;
exports.execFunctionSignature = execFunctionSignature;
exports.isStructSignature = isStructSignature;
exports.execStructSignature = execStructSignature;
exports.isConstructorSignature = isConstructorSignature;
exports.execConstructorSignature = execConstructorSignature;
exports.isFallbackSignature = isFallbackSignature;
exports.execFallbackSignature = execFallbackSignature;
exports.isReceiveSignature = isReceiveSignature;
const regex_js_1 = __webpack_require__(/*! ../../regex.js */ "./node_modules/abitype/dist/cjs/regex.js");
const errorSignatureRegex = /^error (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\((?<parameters>.*?)\)$/;
function isErrorSignature(signature) {
    return errorSignatureRegex.test(signature);
}
function execErrorSignature(signature) {
    return (0, regex_js_1.execTyped)(errorSignatureRegex, signature);
}
const eventSignatureRegex = /^event (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\((?<parameters>.*?)\)$/;
function isEventSignature(signature) {
    return eventSignatureRegex.test(signature);
}
function execEventSignature(signature) {
    return (0, regex_js_1.execTyped)(eventSignatureRegex, signature);
}
const functionSignatureRegex = /^function (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\((?<parameters>.*?)\)(?: (?<scope>external|public{1}))?(?: (?<stateMutability>pure|view|nonpayable|payable{1}))?(?: returns\s?\((?<returns>.*?)\))?$/;
function isFunctionSignature(signature) {
    return functionSignatureRegex.test(signature);
}
function execFunctionSignature(signature) {
    return (0, regex_js_1.execTyped)(functionSignatureRegex, signature);
}
const structSignatureRegex = /^struct (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*) \{(?<properties>.*?)\}$/;
function isStructSignature(signature) {
    return structSignatureRegex.test(signature);
}
function execStructSignature(signature) {
    return (0, regex_js_1.execTyped)(structSignatureRegex, signature);
}
const constructorSignatureRegex = /^constructor\((?<parameters>.*?)\)(?:\s(?<stateMutability>payable{1}))?$/;
function isConstructorSignature(signature) {
    return constructorSignatureRegex.test(signature);
}
function execConstructorSignature(signature) {
    return (0, regex_js_1.execTyped)(constructorSignatureRegex, signature);
}
const fallbackSignatureRegex = /^fallback\(\) external(?:\s(?<stateMutability>payable{1}))?$/;
function isFallbackSignature(signature) {
    return fallbackSignatureRegex.test(signature);
}
function execFallbackSignature(signature) {
    return (0, regex_js_1.execTyped)(fallbackSignatureRegex, signature);
}
const receiveSignatureRegex = /^receive\(\) external payable$/;
function isReceiveSignature(signature) {
    return receiveSignatureRegex.test(signature);
}
exports.modifiers = new Set([
    'memory',
    'indexed',
    'storage',
    'calldata',
]);
exports.eventModifiers = new Set(['indexed']);
exports.functionModifiers = new Set([
    'calldata',
    'memory',
    'storage',
]);
//# sourceMappingURL=signatures.js.map

/***/ }),

/***/ "./node_modules/abitype/dist/cjs/human-readable/runtime/structs.js":
/*!*************************************************************************!*\
  !*** ./node_modules/abitype/dist/cjs/human-readable/runtime/structs.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.parseStructs = parseStructs;
const regex_js_1 = __webpack_require__(/*! ../../regex.js */ "./node_modules/abitype/dist/cjs/regex.js");
const abiItem_js_1 = __webpack_require__(/*! ../errors/abiItem.js */ "./node_modules/abitype/dist/cjs/human-readable/errors/abiItem.js");
const abiParameter_js_1 = __webpack_require__(/*! ../errors/abiParameter.js */ "./node_modules/abitype/dist/cjs/human-readable/errors/abiParameter.js");
const signature_js_1 = __webpack_require__(/*! ../errors/signature.js */ "./node_modules/abitype/dist/cjs/human-readable/errors/signature.js");
const struct_js_1 = __webpack_require__(/*! ../errors/struct.js */ "./node_modules/abitype/dist/cjs/human-readable/errors/struct.js");
const signatures_js_1 = __webpack_require__(/*! ./signatures.js */ "./node_modules/abitype/dist/cjs/human-readable/runtime/signatures.js");
const utils_js_1 = __webpack_require__(/*! ./utils.js */ "./node_modules/abitype/dist/cjs/human-readable/runtime/utils.js");
function parseStructs(signatures) {
    const shallowStructs = {};
    const signaturesLength = signatures.length;
    for (let i = 0; i < signaturesLength; i++) {
        const signature = signatures[i];
        if (!(0, signatures_js_1.isStructSignature)(signature))
            continue;
        const match = (0, signatures_js_1.execStructSignature)(signature);
        if (!match)
            throw new signature_js_1.InvalidSignatureError({ signature, type: 'struct' });
        const properties = match.properties.split(';');
        const components = [];
        const propertiesLength = properties.length;
        for (let k = 0; k < propertiesLength; k++) {
            const property = properties[k];
            const trimmed = property.trim();
            if (!trimmed)
                continue;
            const abiParameter = (0, utils_js_1.parseAbiParameter)(trimmed, {
                type: 'struct',
            });
            components.push(abiParameter);
        }
        if (!components.length)
            throw new signature_js_1.InvalidStructSignatureError({ signature });
        shallowStructs[match.name] = components;
    }
    const resolvedStructs = {};
    const entries = Object.entries(shallowStructs);
    const entriesLength = entries.length;
    for (let i = 0; i < entriesLength; i++) {
        const [name, parameters] = entries[i];
        resolvedStructs[name] = resolveStructs(parameters, shallowStructs);
    }
    return resolvedStructs;
}
const typeWithoutTupleRegex = /^(?<type>[a-zA-Z$_][a-zA-Z0-9$_]*)(?<array>(?:\[\d*?\])+?)?$/;
function resolveStructs(abiParameters, structs, ancestors = new Set()) {
    const components = [];
    const length = abiParameters.length;
    for (let i = 0; i < length; i++) {
        const abiParameter = abiParameters[i];
        const isTuple = regex_js_1.isTupleRegex.test(abiParameter.type);
        if (isTuple)
            components.push(abiParameter);
        else {
            const match = (0, regex_js_1.execTyped)(typeWithoutTupleRegex, abiParameter.type);
            if (!match?.type)
                throw new abiParameter_js_1.InvalidAbiTypeParameterError({ abiParameter });
            const { array, type } = match;
            if (type in structs) {
                if (ancestors.has(type))
                    throw new struct_js_1.CircularReferenceError({ type });
                components.push({
                    ...abiParameter,
                    type: `tuple${array ?? ''}`,
                    components: resolveStructs(structs[type] ?? [], structs, new Set([...ancestors, type])),
                });
            }
            else {
                if ((0, utils_js_1.isSolidityType)(type))
                    components.push(abiParameter);
                else
                    throw new abiItem_js_1.UnknownTypeError({ type });
            }
        }
    }
    return components;
}
//# sourceMappingURL=structs.js.map

/***/ }),

/***/ "./node_modules/abitype/dist/cjs/human-readable/runtime/utils.js":
/*!***********************************************************************!*\
  !*** ./node_modules/abitype/dist/cjs/human-readable/runtime/utils.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.parseSignature = parseSignature;
exports.parseFunctionSignature = parseFunctionSignature;
exports.parseEventSignature = parseEventSignature;
exports.parseErrorSignature = parseErrorSignature;
exports.parseConstructorSignature = parseConstructorSignature;
exports.parseFallbackSignature = parseFallbackSignature;
exports.parseAbiParameter = parseAbiParameter;
exports.splitParameters = splitParameters;
exports.isSolidityType = isSolidityType;
exports.isSolidityKeyword = isSolidityKeyword;
exports.isValidDataLocation = isValidDataLocation;
const regex_js_1 = __webpack_require__(/*! ../../regex.js */ "./node_modules/abitype/dist/cjs/regex.js");
const abiItem_js_1 = __webpack_require__(/*! ../errors/abiItem.js */ "./node_modules/abitype/dist/cjs/human-readable/errors/abiItem.js");
const abiParameter_js_1 = __webpack_require__(/*! ../errors/abiParameter.js */ "./node_modules/abitype/dist/cjs/human-readable/errors/abiParameter.js");
const signature_js_1 = __webpack_require__(/*! ../errors/signature.js */ "./node_modules/abitype/dist/cjs/human-readable/errors/signature.js");
const splitParameters_js_1 = __webpack_require__(/*! ../errors/splitParameters.js */ "./node_modules/abitype/dist/cjs/human-readable/errors/splitParameters.js");
const cache_js_1 = __webpack_require__(/*! ./cache.js */ "./node_modules/abitype/dist/cjs/human-readable/runtime/cache.js");
const signatures_js_1 = __webpack_require__(/*! ./signatures.js */ "./node_modules/abitype/dist/cjs/human-readable/runtime/signatures.js");
function parseSignature(signature, structs = {}) {
    if ((0, signatures_js_1.isFunctionSignature)(signature))
        return parseFunctionSignature(signature, structs);
    if ((0, signatures_js_1.isEventSignature)(signature))
        return parseEventSignature(signature, structs);
    if ((0, signatures_js_1.isErrorSignature)(signature))
        return parseErrorSignature(signature, structs);
    if ((0, signatures_js_1.isConstructorSignature)(signature))
        return parseConstructorSignature(signature, structs);
    if ((0, signatures_js_1.isFallbackSignature)(signature))
        return parseFallbackSignature(signature);
    if ((0, signatures_js_1.isReceiveSignature)(signature))
        return {
            type: 'receive',
            stateMutability: 'payable',
        };
    throw new signature_js_1.UnknownSignatureError({ signature });
}
function parseFunctionSignature(signature, structs = {}) {
    const match = (0, signatures_js_1.execFunctionSignature)(signature);
    if (!match)
        throw new signature_js_1.InvalidSignatureError({ signature, type: 'function' });
    const inputParams = splitParameters(match.parameters);
    const inputs = [];
    const inputLength = inputParams.length;
    for (let i = 0; i < inputLength; i++) {
        inputs.push(parseAbiParameter(inputParams[i], {
            modifiers: signatures_js_1.functionModifiers,
            structs,
            type: 'function',
        }));
    }
    const outputs = [];
    if (match.returns) {
        const outputParams = splitParameters(match.returns);
        const outputLength = outputParams.length;
        for (let i = 0; i < outputLength; i++) {
            outputs.push(parseAbiParameter(outputParams[i], {
                modifiers: signatures_js_1.functionModifiers,
                structs,
                type: 'function',
            }));
        }
    }
    return {
        name: match.name,
        type: 'function',
        stateMutability: match.stateMutability ?? 'nonpayable',
        inputs,
        outputs,
    };
}
function parseEventSignature(signature, structs = {}) {
    const match = (0, signatures_js_1.execEventSignature)(signature);
    if (!match)
        throw new signature_js_1.InvalidSignatureError({ signature, type: 'event' });
    const params = splitParameters(match.parameters);
    const abiParameters = [];
    const length = params.length;
    for (let i = 0; i < length; i++)
        abiParameters.push(parseAbiParameter(params[i], {
            modifiers: signatures_js_1.eventModifiers,
            structs,
            type: 'event',
        }));
    return { name: match.name, type: 'event', inputs: abiParameters };
}
function parseErrorSignature(signature, structs = {}) {
    const match = (0, signatures_js_1.execErrorSignature)(signature);
    if (!match)
        throw new signature_js_1.InvalidSignatureError({ signature, type: 'error' });
    const params = splitParameters(match.parameters);
    const abiParameters = [];
    const length = params.length;
    for (let i = 0; i < length; i++)
        abiParameters.push(parseAbiParameter(params[i], { structs, type: 'error' }));
    return { name: match.name, type: 'error', inputs: abiParameters };
}
function parseConstructorSignature(signature, structs = {}) {
    const match = (0, signatures_js_1.execConstructorSignature)(signature);
    if (!match)
        throw new signature_js_1.InvalidSignatureError({ signature, type: 'constructor' });
    const params = splitParameters(match.parameters);
    const abiParameters = [];
    const length = params.length;
    for (let i = 0; i < length; i++)
        abiParameters.push(parseAbiParameter(params[i], { structs, type: 'constructor' }));
    return {
        type: 'constructor',
        stateMutability: match.stateMutability ?? 'nonpayable',
        inputs: abiParameters,
    };
}
function parseFallbackSignature(signature) {
    const match = (0, signatures_js_1.execFallbackSignature)(signature);
    if (!match)
        throw new signature_js_1.InvalidSignatureError({ signature, type: 'fallback' });
    return {
        type: 'fallback',
        stateMutability: match.stateMutability ?? 'nonpayable',
    };
}
const abiParameterWithoutTupleRegex = /^(?<type>[a-zA-Z$_][a-zA-Z0-9$_]*)(?<array>(?:\[\d*?\])+?)?(?:\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\s(?<name>[a-zA-Z$_][a-zA-Z0-9$_]*))?$/;
const abiParameterWithTupleRegex = /^\((?<type>.+?)\)(?<array>(?:\[\d*?\])+?)?(?:\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\s(?<name>[a-zA-Z$_][a-zA-Z0-9$_]*))?$/;
const dynamicIntegerRegex = /^u?int$/;
function parseAbiParameter(param, options) {
    const parameterCacheKey = (0, cache_js_1.getParameterCacheKey)(param, options?.type, options?.structs);
    if (cache_js_1.parameterCache.has(parameterCacheKey))
        return cache_js_1.parameterCache.get(parameterCacheKey);
    const isTuple = regex_js_1.isTupleRegex.test(param);
    const match = (0, regex_js_1.execTyped)(isTuple ? abiParameterWithTupleRegex : abiParameterWithoutTupleRegex, param);
    if (!match)
        throw new abiParameter_js_1.InvalidParameterError({ param });
    if (match.name && isSolidityKeyword(match.name))
        throw new abiParameter_js_1.SolidityProtectedKeywordError({ param, name: match.name });
    const name = match.name ? { name: match.name } : {};
    const indexed = match.modifier === 'indexed' ? { indexed: true } : {};
    const structs = options?.structs ?? {};
    let type;
    let components = {};
    if (isTuple) {
        type = 'tuple';
        const params = splitParameters(match.type);
        const components_ = [];
        const length = params.length;
        for (let i = 0; i < length; i++) {
            components_.push(parseAbiParameter(params[i], { structs }));
        }
        components = { components: components_ };
    }
    else if (match.type in structs) {
        type = 'tuple';
        components = { components: structs[match.type] };
    }
    else if (dynamicIntegerRegex.test(match.type)) {
        type = `${match.type}256`;
    }
    else {
        type = match.type;
        if (!(options?.type === 'struct') && !isSolidityType(type))
            throw new abiItem_js_1.UnknownSolidityTypeError({ type });
    }
    if (match.modifier) {
        if (!options?.modifiers?.has?.(match.modifier))
            throw new abiParameter_js_1.InvalidModifierError({
                param,
                type: options?.type,
                modifier: match.modifier,
            });
        if (signatures_js_1.functionModifiers.has(match.modifier) &&
            !isValidDataLocation(type, !!match.array))
            throw new abiParameter_js_1.InvalidFunctionModifierError({
                param,
                type: options?.type,
                modifier: match.modifier,
            });
    }
    const abiParameter = {
        type: `${type}${match.array ?? ''}`,
        ...name,
        ...indexed,
        ...components,
    };
    cache_js_1.parameterCache.set(parameterCacheKey, abiParameter);
    return abiParameter;
}
function splitParameters(params, result = [], current = '', depth = 0) {
    const length = params.trim().length;
    for (let i = 0; i < length; i++) {
        const char = params[i];
        const tail = params.slice(i + 1);
        switch (char) {
            case ',':
                return depth === 0
                    ? splitParameters(tail, [...result, current.trim()])
                    : splitParameters(tail, result, `${current}${char}`, depth);
            case '(':
                return splitParameters(tail, result, `${current}${char}`, depth + 1);
            case ')':
                return splitParameters(tail, result, `${current}${char}`, depth - 1);
            default:
                return splitParameters(tail, result, `${current}${char}`, depth);
        }
    }
    if (current === '')
        return result;
    if (depth !== 0)
        throw new splitParameters_js_1.InvalidParenthesisError({ current, depth });
    result.push(current.trim());
    return result;
}
function isSolidityType(type) {
    return (type === 'address' ||
        type === 'bool' ||
        type === 'function' ||
        type === 'string' ||
        regex_js_1.bytesRegex.test(type) ||
        regex_js_1.integerRegex.test(type));
}
const protectedKeywordsRegex = /^(?:after|alias|anonymous|apply|auto|byte|calldata|case|catch|constant|copyof|default|defined|error|event|external|false|final|function|immutable|implements|in|indexed|inline|internal|let|mapping|match|memory|mutable|null|of|override|partial|private|promise|public|pure|reference|relocatable|return|returns|sizeof|static|storage|struct|super|supports|switch|this|true|try|typedef|typeof|var|view|virtual)$/;
function isSolidityKeyword(name) {
    return (name === 'address' ||
        name === 'bool' ||
        name === 'function' ||
        name === 'string' ||
        name === 'tuple' ||
        regex_js_1.bytesRegex.test(name) ||
        regex_js_1.integerRegex.test(name) ||
        protectedKeywordsRegex.test(name));
}
function isValidDataLocation(type, isArray) {
    return isArray || type === 'bytes' || type === 'string' || type === 'tuple';
}
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ "./node_modules/abitype/dist/cjs/narrow.js":
/*!*************************************************!*\
  !*** ./node_modules/abitype/dist/cjs/narrow.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.narrow = narrow;
function narrow(value) {
    return value;
}
//# sourceMappingURL=narrow.js.map

/***/ }),

/***/ "./node_modules/abitype/dist/cjs/regex.js":
/*!************************************************!*\
  !*** ./node_modules/abitype/dist/cjs/regex.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isTupleRegex = exports.integerRegex = exports.bytesRegex = void 0;
exports.execTyped = execTyped;
function execTyped(regex, string) {
    const match = regex.exec(string);
    return match?.groups;
}
exports.bytesRegex = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/;
exports.integerRegex = /^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/;
exports.isTupleRegex = /^\(.+?\).*?$/;
//# sourceMappingURL=regex.js.map

/***/ }),

/***/ "./node_modules/abitype/dist/cjs/version.js":
/*!**************************************************!*\
  !*** ./node_modules/abitype/dist/cjs/version.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.version = void 0;
exports.version = '1.0.8';
//# sourceMappingURL=version.js.map

/***/ }),

/***/ "./node_modules/isows/_esm/native.js":
/*!*******************************************!*\
  !*** ./node_modules/isows/_esm/native.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   WebSocket: () => (/* binding */ WebSocket)
/* harmony export */ });
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ "./node_modules/isows/_esm/utils.js");

const WebSocket = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.getNativeWebSocket)();
//# sourceMappingURL=native.js.map

/***/ }),

/***/ "./node_modules/isows/_esm/utils.js":
/*!******************************************!*\
  !*** ./node_modules/isows/_esm/utils.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getNativeWebSocket: () => (/* binding */ getNativeWebSocket)
/* harmony export */ });
function getNativeWebSocket() {
    if (typeof WebSocket !== "undefined")
        return WebSocket;
    if (typeof global.WebSocket !== "undefined")
        return global.WebSocket;
    if (typeof window.WebSocket !== "undefined")
        return window.WebSocket;
    if (typeof self.WebSocket !== "undefined")
        return self.WebSocket;
    throw new Error("`WebSocket` is not supported in this environment");
}
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ "./node_modules/ox/_cjs/core/AbiConstructor.js":
/*!*****************************************************!*\
  !*** ./node_modules/ox/_cjs/core/AbiConstructor.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.decode = decode;
exports.encode = encode;
exports.format = format;
exports.from = from;
exports.fromAbi = fromAbi;
const abitype = __webpack_require__(/*! abitype */ "./node_modules/abitype/dist/cjs/exports/index.js");
const AbiItem = __webpack_require__(/*! ./AbiItem.js */ "./node_modules/ox/_cjs/core/AbiItem.js");
const AbiParameters = __webpack_require__(/*! ./AbiParameters.js */ "./node_modules/ox/_cjs/core/AbiParameters.js");
const Hex = __webpack_require__(/*! ./Hex.js */ "./node_modules/ox/_cjs/core/Hex.js");
function decode(abiConstructor, options) {
    const { bytecode } = options;
    if (abiConstructor.inputs.length === 0)
        return undefined;
    const data = options.data.replace(bytecode, '0x');
    return AbiParameters.decode(abiConstructor.inputs, data);
}
function encode(abiConstructor, options) {
    const { bytecode, args } = options;
    return Hex.concat(bytecode, abiConstructor.inputs?.length && args?.length
        ? AbiParameters.encode(abiConstructor.inputs, args)
        : '0x');
}
function format(abiConstructor) {
    return abitype.formatAbiItem(abiConstructor);
}
function from(abiConstructor) {
    return AbiItem.from(abiConstructor);
}
function fromAbi(abi) {
    const item = abi.find((item) => item.type === 'constructor');
    if (!item)
        throw new AbiItem.NotFoundError({ name: 'constructor' });
    return item;
}
//# sourceMappingURL=AbiConstructor.js.map

/***/ }),

/***/ "./node_modules/ox/_cjs/core/AbiFunction.js":
/*!**************************************************!*\
  !*** ./node_modules/ox/_cjs/core/AbiFunction.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.decodeData = decodeData;
exports.decodeResult = decodeResult;
exports.encodeData = encodeData;
exports.encodeResult = encodeResult;
exports.format = format;
exports.from = from;
exports.fromAbi = fromAbi;
exports.getSelector = getSelector;
const abitype = __webpack_require__(/*! abitype */ "./node_modules/abitype/dist/cjs/exports/index.js");
const AbiItem = __webpack_require__(/*! ./AbiItem.js */ "./node_modules/ox/_cjs/core/AbiItem.js");
const AbiParameters = __webpack_require__(/*! ./AbiParameters.js */ "./node_modules/ox/_cjs/core/AbiParameters.js");
const Hex = __webpack_require__(/*! ./Hex.js */ "./node_modules/ox/_cjs/core/Hex.js");
function decodeData(abiFunction, data) {
    const { overloads } = abiFunction;
    if (Hex.size(data) < 4)
        throw new AbiItem.InvalidSelectorSizeError({ data });
    if (abiFunction.inputs.length === 0)
        return undefined;
    const item = overloads
        ? fromAbi([abiFunction, ...overloads], data)
        : abiFunction;
    if (Hex.size(data) <= 4)
        return undefined;
    return AbiParameters.decode(item.inputs, Hex.slice(data, 4));
}
function decodeResult(abiFunction, data, options = {}) {
    const values = AbiParameters.decode(abiFunction.outputs, data, options);
    if (values && Object.keys(values).length === 0)
        return undefined;
    if (values && Object.keys(values).length === 1) {
        if (Array.isArray(values))
            return values[0];
        return Object.values(values)[0];
    }
    return values;
}
function encodeData(abiFunction, ...args) {
    const { overloads } = abiFunction;
    const item = overloads
        ? fromAbi([abiFunction, ...overloads], abiFunction.name, {
            args: args[0],
        })
        : abiFunction;
    const selector = getSelector(item);
    const data = args.length > 0
        ? AbiParameters.encode(item.inputs, args[0])
        : undefined;
    return data ? Hex.concat(selector, data) : selector;
}
function encodeResult(abiFunction, output, options = {}) {
    const { as = 'Array' } = options;
    const values = (() => {
        if (abiFunction.outputs.length === 1)
            return [output];
        if (Array.isArray(output))
            return output;
        if (as === 'Object')
            return Object.values(output);
        return [output];
    })();
    return AbiParameters.encode(abiFunction.outputs, values);
}
function format(abiFunction) {
    return abitype.formatAbiItem(abiFunction);
}
function from(abiFunction, options = {}) {
    return AbiItem.from(abiFunction, options);
}
function fromAbi(abi, name, options) {
    const item = AbiItem.fromAbi(abi, name, options);
    if (item.type !== 'function')
        throw new AbiItem.NotFoundError({ name, type: 'function' });
    return item;
}
function getSelector(abiItem) {
    return AbiItem.getSelector(abiItem);
}
//# sourceMappingURL=AbiFunction.js.map

/***/ }),

/***/ "./node_modules/ox/_cjs/core/AbiItem.js":
/*!**********************************************!*\
  !*** ./node_modules/ox/_cjs/core/AbiItem.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.InvalidSelectorSizeError = exports.NotFoundError = exports.AmbiguityError = void 0;
exports.format = format;
exports.from = from;
exports.fromAbi = fromAbi;
exports.getSelector = getSelector;
exports.getSignature = getSignature;
exports.getSignatureHash = getSignatureHash;
const abitype = __webpack_require__(/*! abitype */ "./node_modules/abitype/dist/cjs/exports/index.js");
const Errors = __webpack_require__(/*! ./Errors.js */ "./node_modules/ox/_cjs/core/Errors.js");
const Hash = __webpack_require__(/*! ./Hash.js */ "./node_modules/ox/_cjs/core/Hash.js");
const Hex = __webpack_require__(/*! ./Hex.js */ "./node_modules/ox/_cjs/core/Hex.js");
const internal = __webpack_require__(/*! ./internal/abiItem.js */ "./node_modules/ox/_cjs/core/internal/abiItem.js");
function format(abiItem) {
    return abitype.formatAbiItem(abiItem);
}
function from(abiItem, options = {}) {
    const { prepare = true } = options;
    const item = (() => {
        if (Array.isArray(abiItem))
            return abitype.parseAbiItem(abiItem);
        if (typeof abiItem === 'string')
            return abitype.parseAbiItem(abiItem);
        return abiItem;
    })();
    return {
        ...item,
        ...(prepare ? { hash: getSignatureHash(item) } : {}),
    };
}
function fromAbi(abi, name, options) {
    const { args = [], prepare = true } = (options ??
        {});
    const isSelector = Hex.validate(name, { strict: false });
    const abiItems = abi.filter((abiItem) => {
        if (isSelector) {
            if (abiItem.type === 'function' || abiItem.type === 'error')
                return getSelector(abiItem) === Hex.slice(name, 0, 4);
            if (abiItem.type === 'event')
                return getSignatureHash(abiItem) === name;
            return false;
        }
        return 'name' in abiItem && abiItem.name === name;
    });
    if (abiItems.length === 0)
        throw new NotFoundError({ name: name });
    if (abiItems.length === 1)
        return {
            ...abiItems[0],
            ...(prepare ? { hash: getSignatureHash(abiItems[0]) } : {}),
        };
    let matchedAbiItem;
    for (const abiItem of abiItems) {
        if (!('inputs' in abiItem))
            continue;
        if (!args || args.length === 0) {
            if (!abiItem.inputs || abiItem.inputs.length === 0)
                return {
                    ...abiItem,
                    ...(prepare ? { hash: getSignatureHash(abiItem) } : {}),
                };
            continue;
        }
        if (!abiItem.inputs)
            continue;
        if (abiItem.inputs.length === 0)
            continue;
        if (abiItem.inputs.length !== args.length)
            continue;
        const matched = args.every((arg, index) => {
            const abiParameter = 'inputs' in abiItem && abiItem.inputs[index];
            if (!abiParameter)
                return false;
            return internal.isArgOfType(arg, abiParameter);
        });
        if (matched) {
            if (matchedAbiItem &&
                'inputs' in matchedAbiItem &&
                matchedAbiItem.inputs) {
                const ambiguousTypes = internal.getAmbiguousTypes(abiItem.inputs, matchedAbiItem.inputs, args);
                if (ambiguousTypes)
                    throw new AmbiguityError({
                        abiItem,
                        type: ambiguousTypes[0],
                    }, {
                        abiItem: matchedAbiItem,
                        type: ambiguousTypes[1],
                    });
            }
            matchedAbiItem = abiItem;
        }
    }
    const abiItem = (() => {
        if (matchedAbiItem)
            return matchedAbiItem;
        const [abiItem, ...overloads] = abiItems;
        return { ...abiItem, overloads };
    })();
    if (!abiItem)
        throw new NotFoundError({ name: name });
    return {
        ...abiItem,
        ...(prepare ? { hash: getSignatureHash(abiItem) } : {}),
    };
}
function getSelector(abiItem) {
    return Hex.slice(getSignatureHash(abiItem), 0, 4);
}
function getSignature(abiItem) {
    const signature = (() => {
        if (typeof abiItem === 'string')
            return abiItem;
        return abitype.formatAbiItem(abiItem);
    })();
    return internal.normalizeSignature(signature);
}
function getSignatureHash(abiItem) {
    if (typeof abiItem !== 'string' && 'hash' in abiItem && abiItem.hash)
        return abiItem.hash;
    return Hash.keccak256(Hex.fromString(getSignature(abiItem)));
}
class AmbiguityError extends Errors.BaseError {
    constructor(x, y) {
        super('Found ambiguous types in overloaded ABI Items.', {
            metaMessages: [
                `\`${x.type}\` in \`${internal.normalizeSignature(abitype.formatAbiItem(x.abiItem))}\`, and`,
                `\`${y.type}\` in \`${internal.normalizeSignature(abitype.formatAbiItem(y.abiItem))}\``,
                '',
                'These types encode differently and cannot be distinguished at runtime.',
                'Remove one of the ambiguous items in the ABI.',
            ],
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'AbiItem.AmbiguityError'
        });
    }
}
exports.AmbiguityError = AmbiguityError;
class NotFoundError extends Errors.BaseError {
    constructor({ name, data, type = 'item', }) {
        const selector = (() => {
            if (name)
                return ` with name "${name}"`;
            if (data)
                return ` with data "${data}"`;
            return '';
        })();
        super(`ABI ${type}${selector} not found.`);
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'AbiItem.NotFoundError'
        });
    }
}
exports.NotFoundError = NotFoundError;
class InvalidSelectorSizeError extends Errors.BaseError {
    constructor({ data }) {
        super(`Selector size is invalid. Expected 4 bytes. Received ${Hex.size(data)} bytes ("${data}").`);
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'AbiItem.InvalidSelectorSizeError'
        });
    }
}
exports.InvalidSelectorSizeError = InvalidSelectorSizeError;
//# sourceMappingURL=AbiItem.js.map

/***/ }),

/***/ "./node_modules/ox/_cjs/core/AbiParameters.js":
/*!****************************************************!*\
  !*** ./node_modules/ox/_cjs/core/AbiParameters.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.InvalidTypeError = exports.InvalidArrayError = exports.LengthMismatchError = exports.BytesSizeMismatchError = exports.ArrayLengthMismatchError = exports.ZeroDataError = exports.DataSizeTooSmallError = void 0;
exports.decode = decode;
exports.encode = encode;
exports.encodePacked = encodePacked;
exports.format = format;
exports.from = from;
const abitype = __webpack_require__(/*! abitype */ "./node_modules/abitype/dist/cjs/exports/index.js");
const Address = __webpack_require__(/*! ./Address.js */ "./node_modules/ox/_cjs/core/Address.js");
const Bytes = __webpack_require__(/*! ./Bytes.js */ "./node_modules/ox/_cjs/core/Bytes.js");
const Errors = __webpack_require__(/*! ./Errors.js */ "./node_modules/ox/_cjs/core/Errors.js");
const Hex = __webpack_require__(/*! ./Hex.js */ "./node_modules/ox/_cjs/core/Hex.js");
const internal = __webpack_require__(/*! ./internal/abiParameters.js */ "./node_modules/ox/_cjs/core/internal/abiParameters.js");
const Cursor = __webpack_require__(/*! ./internal/cursor.js */ "./node_modules/ox/_cjs/core/internal/cursor.js");
const Solidity = __webpack_require__(/*! ./Solidity.js */ "./node_modules/ox/_cjs/core/Solidity.js");
function decode(parameters, data, options = {}) {
    const { as = 'Array', checksumAddress = false } = options;
    const bytes = typeof data === 'string' ? Bytes.fromHex(data) : data;
    const cursor = Cursor.create(bytes);
    if (Bytes.size(bytes) === 0 && parameters.length > 0)
        throw new ZeroDataError();
    if (Bytes.size(bytes) && Bytes.size(bytes) < 32)
        throw new DataSizeTooSmallError({
            data: typeof data === 'string' ? data : Hex.fromBytes(data),
            parameters: parameters,
            size: Bytes.size(bytes),
        });
    let consumed = 0;
    const values = as === 'Array' ? [] : {};
    for (let i = 0; i < parameters.length; ++i) {
        const param = parameters[i];
        cursor.setPosition(consumed);
        const [data, consumed_] = internal.decodeParameter(cursor, param, {
            checksumAddress,
            staticPosition: 0,
        });
        consumed += consumed_;
        if (as === 'Array')
            values.push(data);
        else
            values[param.name ?? i] = data;
    }
    return values;
}
function encode(parameters, values, options) {
    const { checksumAddress = false } = options ?? {};
    if (parameters.length !== values.length)
        throw new LengthMismatchError({
            expectedLength: parameters.length,
            givenLength: values.length,
        });
    const preparedParameters = internal.prepareParameters({
        checksumAddress,
        parameters: parameters,
        values: values,
    });
    const data = internal.encode(preparedParameters);
    if (data.length === 0)
        return '0x';
    return data;
}
function encodePacked(types, values) {
    if (types.length !== values.length)
        throw new LengthMismatchError({
            expectedLength: types.length,
            givenLength: values.length,
        });
    const data = [];
    for (let i = 0; i < types.length; i++) {
        const type = types[i];
        const value = values[i];
        data.push(encodePacked.encode(type, value));
    }
    return Hex.concat(...data);
}
(function (encodePacked) {
    function encode(type, value, isArray = false) {
        if (type === 'address') {
            const address = value;
            Address.assert(address);
            return Hex.padLeft(address.toLowerCase(), isArray ? 32 : 0);
        }
        if (type === 'string')
            return Hex.fromString(value);
        if (type === 'bytes')
            return value;
        if (type === 'bool')
            return Hex.padLeft(Hex.fromBoolean(value), isArray ? 32 : 1);
        const intMatch = type.match(Solidity.integerRegex);
        if (intMatch) {
            const [_type, baseType, bits = '256'] = intMatch;
            const size = Number.parseInt(bits, 10) / 8;
            return Hex.fromNumber(value, {
                size: isArray ? 32 : size,
                signed: baseType === 'int',
            });
        }
        const bytesMatch = type.match(Solidity.bytesRegex);
        if (bytesMatch) {
            const [_type, size] = bytesMatch;
            if (Number.parseInt(size, 10) !== (value.length - 2) / 2)
                throw new BytesSizeMismatchError({
                    expectedSize: Number.parseInt(size, 10),
                    value: value,
                });
            return Hex.padRight(value, isArray ? 32 : 0);
        }
        const arrayMatch = type.match(Solidity.arrayRegex);
        if (arrayMatch && Array.isArray(value)) {
            const [_type, childType] = arrayMatch;
            const data = [];
            for (let i = 0; i < value.length; i++) {
                data.push(encode(childType, value[i], true));
            }
            if (data.length === 0)
                return '0x';
            return Hex.concat(...data);
        }
        throw new InvalidTypeError(type);
    }
    encodePacked.encode = encode;
})(encodePacked || (exports.encodePacked = encodePacked = {}));
function format(parameters) {
    return abitype.formatAbiParameters(parameters);
}
function from(parameters) {
    if (Array.isArray(parameters) && typeof parameters[0] === 'string')
        return abitype.parseAbiParameters(parameters);
    if (typeof parameters === 'string')
        return abitype.parseAbiParameters(parameters);
    return parameters;
}
class DataSizeTooSmallError extends Errors.BaseError {
    constructor({ data, parameters, size, }) {
        super(`Data size of ${size} bytes is too small for given parameters.`, {
            metaMessages: [
                `Params: (${abitype.formatAbiParameters(parameters)})`,
                `Data:   ${data} (${size} bytes)`,
            ],
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'AbiParameters.DataSizeTooSmallError'
        });
    }
}
exports.DataSizeTooSmallError = DataSizeTooSmallError;
class ZeroDataError extends Errors.BaseError {
    constructor() {
        super('Cannot decode zero data ("0x") with ABI parameters.');
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'AbiParameters.ZeroDataError'
        });
    }
}
exports.ZeroDataError = ZeroDataError;
class ArrayLengthMismatchError extends Errors.BaseError {
    constructor({ expectedLength, givenLength, type, }) {
        super(`Array length mismatch for type \`${type}\`. Expected: \`${expectedLength}\`. Given: \`${givenLength}\`.`);
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'AbiParameters.ArrayLengthMismatchError'
        });
    }
}
exports.ArrayLengthMismatchError = ArrayLengthMismatchError;
class BytesSizeMismatchError extends Errors.BaseError {
    constructor({ expectedSize, value, }) {
        super(`Size of bytes "${value}" (bytes${Hex.size(value)}) does not match expected size (bytes${expectedSize}).`);
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'AbiParameters.BytesSizeMismatchError'
        });
    }
}
exports.BytesSizeMismatchError = BytesSizeMismatchError;
class LengthMismatchError extends Errors.BaseError {
    constructor({ expectedLength, givenLength, }) {
        super([
            'ABI encoding parameters/values length mismatch.',
            `Expected length (parameters): ${expectedLength}`,
            `Given length (values): ${givenLength}`,
        ].join('\n'));
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'AbiParameters.LengthMismatchError'
        });
    }
}
exports.LengthMismatchError = LengthMismatchError;
class InvalidArrayError extends Errors.BaseError {
    constructor(value) {
        super(`Value \`${value}\` is not a valid array.`);
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'AbiParameters.InvalidArrayError'
        });
    }
}
exports.InvalidArrayError = InvalidArrayError;
class InvalidTypeError extends Errors.BaseError {
    constructor(type) {
        super(`Type \`${type}\` is not a valid ABI Type.`);
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'AbiParameters.InvalidTypeError'
        });
    }
}
exports.InvalidTypeError = InvalidTypeError;
//# sourceMappingURL=AbiParameters.js.map

/***/ }),

/***/ "./node_modules/ox/_cjs/core/Address.js":
/*!**********************************************!*\
  !*** ./node_modules/ox/_cjs/core/Address.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.InvalidChecksumError = exports.InvalidInputError = exports.InvalidAddressError = void 0;
exports.assert = assert;
exports.checksum = checksum;
exports.from = from;
exports.fromPublicKey = fromPublicKey;
exports.isEqual = isEqual;
exports.validate = validate;
const Bytes = __webpack_require__(/*! ./Bytes.js */ "./node_modules/ox/_cjs/core/Bytes.js");
const Caches = __webpack_require__(/*! ./Caches.js */ "./node_modules/ox/_cjs/core/Caches.js");
const Errors = __webpack_require__(/*! ./Errors.js */ "./node_modules/ox/_cjs/core/Errors.js");
const Hash = __webpack_require__(/*! ./Hash.js */ "./node_modules/ox/_cjs/core/Hash.js");
const PublicKey = __webpack_require__(/*! ./PublicKey.js */ "./node_modules/ox/_cjs/core/PublicKey.js");
const addressRegex = /^0x[a-fA-F0-9]{40}$/;
function assert(value, options = {}) {
    const { strict = true } = options;
    if (!addressRegex.test(value))
        throw new InvalidAddressError({
            address: value,
            cause: new InvalidInputError(),
        });
    if (strict) {
        if (value.toLowerCase() === value)
            return;
        if (checksum(value) !== value)
            throw new InvalidAddressError({
                address: value,
                cause: new InvalidChecksumError(),
            });
    }
}
function checksum(address) {
    if (Caches.checksum.has(address))
        return Caches.checksum.get(address);
    assert(address, { strict: false });
    const hexAddress = address.substring(2).toLowerCase();
    const hash = Hash.keccak256(Bytes.fromString(hexAddress), { as: 'Bytes' });
    const characters = hexAddress.split('');
    for (let i = 0; i < 40; i += 2) {
        if (hash[i >> 1] >> 4 >= 8 && characters[i]) {
            characters[i] = characters[i].toUpperCase();
        }
        if ((hash[i >> 1] & 0x0f) >= 8 && characters[i + 1]) {
            characters[i + 1] = characters[i + 1].toUpperCase();
        }
    }
    const result = `0x${characters.join('')}`;
    Caches.checksum.set(address, result);
    return result;
}
function from(address, options = {}) {
    const { checksum: checksumVal = false } = options;
    assert(address);
    if (checksumVal)
        return checksum(address);
    return address;
}
function fromPublicKey(publicKey, options = {}) {
    const address = Hash.keccak256(`0x${PublicKey.toHex(publicKey).slice(4)}`).substring(26);
    return from(`0x${address}`, options);
}
function isEqual(addressA, addressB) {
    assert(addressA, { strict: false });
    assert(addressB, { strict: false });
    return addressA.toLowerCase() === addressB.toLowerCase();
}
function validate(address, options = {}) {
    const { strict = true } = options ?? {};
    try {
        assert(address, { strict });
        return true;
    }
    catch {
        return false;
    }
}
class InvalidAddressError extends Errors.BaseError {
    constructor({ address, cause }) {
        super(`Address "${address}" is invalid.`, {
            cause,
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'Address.InvalidAddressError'
        });
    }
}
exports.InvalidAddressError = InvalidAddressError;
class InvalidInputError extends Errors.BaseError {
    constructor() {
        super('Address is not a 20 byte (40 hexadecimal character) value.');
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'Address.InvalidInputError'
        });
    }
}
exports.InvalidInputError = InvalidInputError;
class InvalidChecksumError extends Errors.BaseError {
    constructor() {
        super('Address does not match its checksum counterpart.');
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'Address.InvalidChecksumError'
        });
    }
}
exports.InvalidChecksumError = InvalidChecksumError;
//# sourceMappingURL=Address.js.map

/***/ }),

/***/ "./node_modules/ox/_cjs/core/BlockOverrides.js":
/*!*****************************************************!*\
  !*** ./node_modules/ox/_cjs/core/BlockOverrides.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.fromRpc = fromRpc;
exports.toRpc = toRpc;
const Hex = __webpack_require__(/*! ./Hex.js */ "./node_modules/ox/_cjs/core/Hex.js");
const Withdrawal = __webpack_require__(/*! ./Withdrawal.js */ "./node_modules/ox/_cjs/core/Withdrawal.js");
function fromRpc(rpcBlockOverrides) {
    return {
        ...(rpcBlockOverrides.baseFeePerGas && {
            baseFeePerGas: BigInt(rpcBlockOverrides.baseFeePerGas),
        }),
        ...(rpcBlockOverrides.blobBaseFee && {
            blobBaseFee: BigInt(rpcBlockOverrides.blobBaseFee),
        }),
        ...(rpcBlockOverrides.feeRecipient && {
            feeRecipient: rpcBlockOverrides.feeRecipient,
        }),
        ...(rpcBlockOverrides.gasLimit && {
            gasLimit: BigInt(rpcBlockOverrides.gasLimit),
        }),
        ...(rpcBlockOverrides.number && {
            number: BigInt(rpcBlockOverrides.number),
        }),
        ...(rpcBlockOverrides.prevRandao && {
            prevRandao: BigInt(rpcBlockOverrides.prevRandao),
        }),
        ...(rpcBlockOverrides.time && {
            time: BigInt(rpcBlockOverrides.time),
        }),
        ...(rpcBlockOverrides.withdrawals && {
            withdrawals: rpcBlockOverrides.withdrawals.map(Withdrawal.fromRpc),
        }),
    };
}
function toRpc(blockOverrides) {
    return {
        ...(typeof blockOverrides.baseFeePerGas === 'bigint' && {
            baseFeePerGas: Hex.fromNumber(blockOverrides.baseFeePerGas),
        }),
        ...(typeof blockOverrides.blobBaseFee === 'bigint' && {
            blobBaseFee: Hex.fromNumber(blockOverrides.blobBaseFee),
        }),
        ...(typeof blockOverrides.feeRecipient === 'string' && {
            feeRecipient: blockOverrides.feeRecipient,
        }),
        ...(typeof blockOverrides.gasLimit === 'bigint' && {
            gasLimit: Hex.fromNumber(blockOverrides.gasLimit),
        }),
        ...(typeof blockOverrides.number === 'bigint' && {
            number: Hex.fromNumber(blockOverrides.number),
        }),
        ...(typeof blockOverrides.prevRandao === 'bigint' && {
            prevRandao: Hex.fromNumber(blockOverrides.prevRandao),
        }),
        ...(typeof blockOverrides.time === 'bigint' && {
            time: Hex.fromNumber(blockOverrides.time),
        }),
        ...(blockOverrides.withdrawals && {
            withdrawals: blockOverrides.withdrawals.map(Withdrawal.toRpc),
        }),
    };
}
//# sourceMappingURL=BlockOverrides.js.map

/***/ }),

/***/ "./node_modules/ox/_cjs/core/Bytes.js":
/*!********************************************!*\
  !*** ./node_modules/ox/_cjs/core/Bytes.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SizeExceedsPaddingSizeError = exports.SliceOffsetOutOfBoundsError = exports.SizeOverflowError = exports.InvalidBytesTypeError = exports.InvalidBytesBooleanError = void 0;
exports.assert = assert;
exports.concat = concat;
exports.from = from;
exports.fromArray = fromArray;
exports.fromBoolean = fromBoolean;
exports.fromHex = fromHex;
exports.fromNumber = fromNumber;
exports.fromString = fromString;
exports.isEqual = isEqual;
exports.padLeft = padLeft;
exports.padRight = padRight;
exports.random = random;
exports.size = size;
exports.slice = slice;
exports.toBigInt = toBigInt;
exports.toBoolean = toBoolean;
exports.toHex = toHex;
exports.toNumber = toNumber;
exports.toString = toString;
exports.trimLeft = trimLeft;
exports.trimRight = trimRight;
exports.validate = validate;
const utils_1 = __webpack_require__(/*! @noble/curves/abstract/utils */ "./node_modules/ox/node_modules/@noble/curves/abstract/utils.js");
const Errors = __webpack_require__(/*! ./Errors.js */ "./node_modules/ox/_cjs/core/Errors.js");
const Hex = __webpack_require__(/*! ./Hex.js */ "./node_modules/ox/_cjs/core/Hex.js");
const internal = __webpack_require__(/*! ./internal/bytes.js */ "./node_modules/ox/_cjs/core/internal/bytes.js");
const internal_hex = __webpack_require__(/*! ./internal/hex.js */ "./node_modules/ox/_cjs/core/internal/hex.js");
const Json = __webpack_require__(/*! ./Json.js */ "./node_modules/ox/_cjs/core/Json.js");
const decoder = new TextDecoder();
const encoder = new TextEncoder();
function assert(value) {
    if (value instanceof Uint8Array)
        return;
    if (!value)
        throw new InvalidBytesTypeError(value);
    if (typeof value !== 'object')
        throw new InvalidBytesTypeError(value);
    if (!('BYTES_PER_ELEMENT' in value))
        throw new InvalidBytesTypeError(value);
    if (value.BYTES_PER_ELEMENT !== 1 || value.constructor.name !== 'Uint8Array')
        throw new InvalidBytesTypeError(value);
}
function concat(...values) {
    let length = 0;
    for (const arr of values) {
        length += arr.length;
    }
    const result = new Uint8Array(length);
    for (let i = 0, index = 0; i < values.length; i++) {
        const arr = values[i];
        result.set(arr, index);
        index += arr.length;
    }
    return result;
}
function from(value) {
    if (value instanceof Uint8Array)
        return value;
    if (typeof value === 'string')
        return fromHex(value);
    return fromArray(value);
}
function fromArray(value) {
    return value instanceof Uint8Array ? value : new Uint8Array(value);
}
function fromBoolean(value, options = {}) {
    const { size } = options;
    const bytes = new Uint8Array(1);
    bytes[0] = Number(value);
    if (typeof size === 'number') {
        internal.assertSize(bytes, size);
        return padLeft(bytes, size);
    }
    return bytes;
}
function fromHex(value, options = {}) {
    const { size } = options;
    let hex = value;
    if (size) {
        internal_hex.assertSize(value, size);
        hex = Hex.padRight(value, size);
    }
    let hexString = hex.slice(2);
    if (hexString.length % 2)
        hexString = `0${hexString}`;
    const length = hexString.length / 2;
    const bytes = new Uint8Array(length);
    for (let index = 0, j = 0; index < length; index++) {
        const nibbleLeft = internal.charCodeToBase16(hexString.charCodeAt(j++));
        const nibbleRight = internal.charCodeToBase16(hexString.charCodeAt(j++));
        if (nibbleLeft === undefined || nibbleRight === undefined) {
            throw new Errors.BaseError(`Invalid byte sequence ("${hexString[j - 2]}${hexString[j - 1]}" in "${hexString}").`);
        }
        bytes[index] = nibbleLeft * 16 + nibbleRight;
    }
    return bytes;
}
function fromNumber(value, options) {
    const hex = Hex.fromNumber(value, options);
    return fromHex(hex);
}
function fromString(value, options = {}) {
    const { size } = options;
    const bytes = encoder.encode(value);
    if (typeof size === 'number') {
        internal.assertSize(bytes, size);
        return padRight(bytes, size);
    }
    return bytes;
}
function isEqual(bytesA, bytesB) {
    return (0, utils_1.equalBytes)(bytesA, bytesB);
}
function padLeft(value, size) {
    return internal.pad(value, { dir: 'left', size });
}
function padRight(value, size) {
    return internal.pad(value, { dir: 'right', size });
}
function random(length) {
    return crypto.getRandomValues(new Uint8Array(length));
}
function size(value) {
    return value.length;
}
function slice(value, start, end, options = {}) {
    const { strict } = options;
    internal.assertStartOffset(value, start);
    const value_ = value.slice(start, end);
    if (strict)
        internal.assertEndOffset(value_, start, end);
    return value_;
}
function toBigInt(bytes, options = {}) {
    const { size } = options;
    if (typeof size !== 'undefined')
        internal.assertSize(bytes, size);
    const hex = Hex.fromBytes(bytes, options);
    return Hex.toBigInt(hex, options);
}
function toBoolean(bytes, options = {}) {
    const { size } = options;
    let bytes_ = bytes;
    if (typeof size !== 'undefined') {
        internal.assertSize(bytes_, size);
        bytes_ = trimLeft(bytes_);
    }
    if (bytes_.length > 1 || bytes_[0] > 1)
        throw new InvalidBytesBooleanError(bytes_);
    return Boolean(bytes_[0]);
}
function toHex(value, options = {}) {
    return Hex.fromBytes(value, options);
}
function toNumber(bytes, options = {}) {
    const { size } = options;
    if (typeof size !== 'undefined')
        internal.assertSize(bytes, size);
    const hex = Hex.fromBytes(bytes, options);
    return Hex.toNumber(hex, options);
}
function toString(bytes, options = {}) {
    const { size } = options;
    let bytes_ = bytes;
    if (typeof size !== 'undefined') {
        internal.assertSize(bytes_, size);
        bytes_ = trimRight(bytes_);
    }
    return decoder.decode(bytes_);
}
function trimLeft(value) {
    return internal.trim(value, { dir: 'left' });
}
function trimRight(value) {
    return internal.trim(value, { dir: 'right' });
}
function validate(value) {
    try {
        assert(value);
        return true;
    }
    catch {
        return false;
    }
}
class InvalidBytesBooleanError extends Errors.BaseError {
    constructor(bytes) {
        super(`Bytes value \`${bytes}\` is not a valid boolean.`, {
            metaMessages: [
                'The bytes array must contain a single byte of either a `0` or `1` value.',
            ],
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'Bytes.InvalidBytesBooleanError'
        });
    }
}
exports.InvalidBytesBooleanError = InvalidBytesBooleanError;
class InvalidBytesTypeError extends Errors.BaseError {
    constructor(value) {
        super(`Value \`${typeof value === 'object' ? Json.stringify(value) : value}\` of type \`${typeof value}\` is an invalid Bytes value.`, {
            metaMessages: ['Bytes values must be of type `Bytes`.'],
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'Bytes.InvalidBytesTypeError'
        });
    }
}
exports.InvalidBytesTypeError = InvalidBytesTypeError;
class SizeOverflowError extends Errors.BaseError {
    constructor({ givenSize, maxSize }) {
        super(`Size cannot exceed \`${maxSize}\` bytes. Given size: \`${givenSize}\` bytes.`);
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'Bytes.SizeOverflowError'
        });
    }
}
exports.SizeOverflowError = SizeOverflowError;
class SliceOffsetOutOfBoundsError extends Errors.BaseError {
    constructor({ offset, position, size, }) {
        super(`Slice ${position === 'start' ? 'starting' : 'ending'} at offset \`${offset}\` is out-of-bounds (size: \`${size}\`).`);
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'Bytes.SliceOffsetOutOfBoundsError'
        });
    }
}
exports.SliceOffsetOutOfBoundsError = SliceOffsetOutOfBoundsError;
class SizeExceedsPaddingSizeError extends Errors.BaseError {
    constructor({ size, targetSize, type, }) {
        super(`${type.charAt(0).toUpperCase()}${type
            .slice(1)
            .toLowerCase()} size (\`${size}\`) exceeds padding size (\`${targetSize}\`).`);
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'Bytes.SizeExceedsPaddingSizeError'
        });
    }
}
exports.SizeExceedsPaddingSizeError = SizeExceedsPaddingSizeError;
//# sourceMappingURL=Bytes.js.map

/***/ }),

/***/ "./node_modules/ox/_cjs/core/Caches.js":
/*!*********************************************!*\
  !*** ./node_modules/ox/_cjs/core/Caches.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.checksum = void 0;
exports.clear = clear;
const lru_js_1 = __webpack_require__(/*! ./internal/lru.js */ "./node_modules/ox/_cjs/core/internal/lru.js");
const caches = {
    checksum: new lru_js_1.LruMap(8192),
};
exports.checksum = caches.checksum;
function clear() {
    for (const cache of Object.values(caches))
        cache.clear();
}
//# sourceMappingURL=Caches.js.map

/***/ }),

/***/ "./node_modules/ox/_cjs/core/Errors.js":
/*!*********************************************!*\
  !*** ./node_modules/ox/_cjs/core/Errors.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BaseError = void 0;
const errors_js_1 = __webpack_require__(/*! ./internal/errors.js */ "./node_modules/ox/_cjs/core/internal/errors.js");
class BaseError extends Error {
    constructor(shortMessage, options = {}) {
        const details = (() => {
            if (options.cause instanceof BaseError) {
                if (options.cause.details)
                    return options.cause.details;
                if (options.cause.shortMessage)
                    return options.cause.shortMessage;
            }
            if (options.cause &&
                'details' in options.cause &&
                typeof options.cause.details === 'string')
                return options.cause.details;
            if (options.cause?.message)
                return options.cause.message;
            return options.details;
        })();
        const docsPath = (() => {
            if (options.cause instanceof BaseError)
                return options.cause.docsPath || options.docsPath;
            return options.docsPath;
        })();
        const docsBaseUrl = 'https://oxlib.sh';
        const docs = `${docsBaseUrl}${docsPath ?? ''}`;
        const message = [
            shortMessage || 'An error occurred.',
            ...(options.metaMessages ? ['', ...options.metaMessages] : []),
            ...(details || docsPath
                ? [
                    '',
                    details ? `Details: ${details}` : undefined,
                    docsPath ? `See: ${docs}` : undefined,
                ]
                : []),
        ]
            .filter((x) => typeof x === 'string')
            .join('\n');
        super(message, options.cause ? { cause: options.cause } : undefined);
        Object.defineProperty(this, "details", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "docs", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "docsPath", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "shortMessage", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "cause", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'BaseError'
        });
        Object.defineProperty(this, "version", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: `ox@${(0, errors_js_1.getVersion)()}`
        });
        this.cause = options.cause;
        this.details = details;
        this.docs = docs;
        this.docsPath = docsPath;
        this.shortMessage = shortMessage;
    }
    walk(fn) {
        return walk(this, fn);
    }
}
exports.BaseError = BaseError;
function walk(err, fn) {
    if (fn?.(err))
        return err;
    if (err && typeof err === 'object' && 'cause' in err && err.cause)
        return walk(err.cause, fn);
    return fn ? null : err;
}
//# sourceMappingURL=Errors.js.map

/***/ }),

/***/ "./node_modules/ox/_cjs/core/Hash.js":
/*!*******************************************!*\
  !*** ./node_modules/ox/_cjs/core/Hash.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.keccak256 = keccak256;
exports.ripemd160 = ripemd160;
exports.sha256 = sha256;
exports.validate = validate;
const ripemd160_1 = __webpack_require__(/*! @noble/hashes/ripemd160 */ "./node_modules/@noble/hashes/ripemd160.js");
const sha3_1 = __webpack_require__(/*! @noble/hashes/sha3 */ "./node_modules/@noble/hashes/sha3.js");
const sha256_1 = __webpack_require__(/*! @noble/hashes/sha256 */ "./node_modules/@noble/hashes/sha256.js");
const Bytes = __webpack_require__(/*! ./Bytes.js */ "./node_modules/ox/_cjs/core/Bytes.js");
const Hex = __webpack_require__(/*! ./Hex.js */ "./node_modules/ox/_cjs/core/Hex.js");
function keccak256(value, options = {}) {
    const { as = typeof value === 'string' ? 'Hex' : 'Bytes' } = options;
    const bytes = (0, sha3_1.keccak_256)(Bytes.from(value));
    if (as === 'Bytes')
        return bytes;
    return Hex.fromBytes(bytes);
}
function ripemd160(value, options = {}) {
    const { as = typeof value === 'string' ? 'Hex' : 'Bytes' } = options;
    const bytes = (0, ripemd160_1.ripemd160)(Bytes.from(value));
    if (as === 'Bytes')
        return bytes;
    return Hex.fromBytes(bytes);
}
function sha256(value, options = {}) {
    const { as = typeof value === 'string' ? 'Hex' : 'Bytes' } = options;
    const bytes = (0, sha256_1.sha256)(Bytes.from(value));
    if (as === 'Bytes')
        return bytes;
    return Hex.fromBytes(bytes);
}
function validate(value) {
    return Hex.validate(value) && Hex.size(value) === 32;
}
//# sourceMappingURL=Hash.js.map

/***/ }),

/***/ "./node_modules/ox/_cjs/core/Hex.js":
/*!******************************************!*\
  !*** ./node_modules/ox/_cjs/core/Hex.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SizeExceedsPaddingSizeError = exports.SliceOffsetOutOfBoundsError = exports.SizeOverflowError = exports.InvalidLengthError = exports.InvalidHexValueError = exports.InvalidHexTypeError = exports.InvalidHexBooleanError = exports.IntegerOutOfRangeError = void 0;
exports.assert = assert;
exports.concat = concat;
exports.from = from;
exports.fromBoolean = fromBoolean;
exports.fromBytes = fromBytes;
exports.fromNumber = fromNumber;
exports.fromString = fromString;
exports.isEqual = isEqual;
exports.padLeft = padLeft;
exports.padRight = padRight;
exports.random = random;
exports.slice = slice;
exports.size = size;
exports.trimLeft = trimLeft;
exports.trimRight = trimRight;
exports.toBigInt = toBigInt;
exports.toBoolean = toBoolean;
exports.toBytes = toBytes;
exports.toNumber = toNumber;
exports.toString = toString;
exports.validate = validate;
const utils_1 = __webpack_require__(/*! @noble/curves/abstract/utils */ "./node_modules/ox/node_modules/@noble/curves/abstract/utils.js");
const Bytes = __webpack_require__(/*! ./Bytes.js */ "./node_modules/ox/_cjs/core/Bytes.js");
const Errors = __webpack_require__(/*! ./Errors.js */ "./node_modules/ox/_cjs/core/Errors.js");
const internal_bytes = __webpack_require__(/*! ./internal/bytes.js */ "./node_modules/ox/_cjs/core/internal/bytes.js");
const internal = __webpack_require__(/*! ./internal/hex.js */ "./node_modules/ox/_cjs/core/internal/hex.js");
const Json = __webpack_require__(/*! ./Json.js */ "./node_modules/ox/_cjs/core/Json.js");
const encoder = new TextEncoder();
const hexes = Array.from({ length: 256 }, (_v, i) => i.toString(16).padStart(2, '0'));
function assert(value, options = {}) {
    const { strict = false } = options;
    if (!value)
        throw new InvalidHexTypeError(value);
    if (typeof value !== 'string')
        throw new InvalidHexTypeError(value);
    if (strict) {
        if (!/^0x[0-9a-fA-F]*$/.test(value))
            throw new InvalidHexValueError(value);
    }
    if (!value.startsWith('0x'))
        throw new InvalidHexValueError(value);
}
function concat(...values) {
    return `0x${values.reduce((acc, x) => acc + x.replace('0x', ''), '')}`;
}
function from(value) {
    if (value instanceof Uint8Array)
        return fromBytes(value);
    if (Array.isArray(value))
        return fromBytes(new Uint8Array(value));
    return value;
}
function fromBoolean(value, options = {}) {
    const hex = `0x${Number(value)}`;
    if (typeof options.size === 'number') {
        internal.assertSize(hex, options.size);
        return padLeft(hex, options.size);
    }
    return hex;
}
function fromBytes(value, options = {}) {
    let string = '';
    for (let i = 0; i < value.length; i++)
        string += hexes[value[i]];
    const hex = `0x${string}`;
    if (typeof options.size === 'number') {
        internal.assertSize(hex, options.size);
        return padRight(hex, options.size);
    }
    return hex;
}
function fromNumber(value, options = {}) {
    const { signed, size } = options;
    const value_ = BigInt(value);
    let maxValue;
    if (size) {
        if (signed)
            maxValue = (1n << (BigInt(size) * 8n - 1n)) - 1n;
        else
            maxValue = 2n ** (BigInt(size) * 8n) - 1n;
    }
    else if (typeof value === 'number') {
        maxValue = BigInt(Number.MAX_SAFE_INTEGER);
    }
    const minValue = typeof maxValue === 'bigint' && signed ? -maxValue - 1n : 0;
    if ((maxValue && value_ > maxValue) || value_ < minValue) {
        const suffix = typeof value === 'bigint' ? 'n' : '';
        throw new IntegerOutOfRangeError({
            max: maxValue ? `${maxValue}${suffix}` : undefined,
            min: `${minValue}${suffix}`,
            signed,
            size,
            value: `${value}${suffix}`,
        });
    }
    const stringValue = (signed && value_ < 0 ? (1n << BigInt(size * 8)) + BigInt(value_) : value_).toString(16);
    const hex = `0x${stringValue}`;
    if (size)
        return padLeft(hex, size);
    return hex;
}
function fromString(value, options = {}) {
    return fromBytes(encoder.encode(value), options);
}
function isEqual(hexA, hexB) {
    return (0, utils_1.equalBytes)(Bytes.fromHex(hexA), Bytes.fromHex(hexB));
}
function padLeft(value, size) {
    return internal.pad(value, { dir: 'left', size });
}
function padRight(value, size) {
    return internal.pad(value, { dir: 'right', size });
}
function random(length) {
    return fromBytes(Bytes.random(length));
}
function slice(value, start, end, options = {}) {
    const { strict } = options;
    internal.assertStartOffset(value, start);
    const value_ = `0x${value
        .replace('0x', '')
        .slice((start ?? 0) * 2, (end ?? value.length) * 2)}`;
    if (strict)
        internal.assertEndOffset(value_, start, end);
    return value_;
}
function size(value) {
    return Math.ceil((value.length - 2) / 2);
}
function trimLeft(value) {
    return internal.trim(value, { dir: 'left' });
}
function trimRight(value) {
    return internal.trim(value, { dir: 'right' });
}
function toBigInt(hex, options = {}) {
    const { signed } = options;
    if (options.size)
        internal.assertSize(hex, options.size);
    const value = BigInt(hex);
    if (!signed)
        return value;
    const size = (hex.length - 2) / 2;
    const max_unsigned = (1n << (BigInt(size) * 8n)) - 1n;
    const max_signed = max_unsigned >> 1n;
    if (value <= max_signed)
        return value;
    return value - max_unsigned - 1n;
}
function toBoolean(hex, options = {}) {
    if (options.size)
        internal.assertSize(hex, options.size);
    const hex_ = trimLeft(hex);
    if (hex_ === '0x')
        return false;
    if (hex_ === '0x1')
        return true;
    throw new InvalidHexBooleanError(hex);
}
function toBytes(hex, options = {}) {
    return Bytes.fromHex(hex, options);
}
function toNumber(hex, options = {}) {
    const { signed, size } = options;
    if (!signed && !size)
        return Number(hex);
    return Number(toBigInt(hex, options));
}
function toString(hex, options = {}) {
    const { size } = options;
    let bytes = Bytes.fromHex(hex);
    if (size) {
        internal_bytes.assertSize(bytes, size);
        bytes = Bytes.trimRight(bytes);
    }
    return new TextDecoder().decode(bytes);
}
function validate(value, options = {}) {
    const { strict = false } = options;
    try {
        assert(value, { strict });
        return true;
    }
    catch {
        return false;
    }
}
class IntegerOutOfRangeError extends Errors.BaseError {
    constructor({ max, min, signed, size, value, }) {
        super(`Number \`${value}\` is not in safe${size ? ` ${size * 8}-bit` : ''}${signed ? ' signed' : ' unsigned'} integer range ${max ? `(\`${min}\` to \`${max}\`)` : `(above \`${min}\`)`}`);
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'Hex.IntegerOutOfRangeError'
        });
    }
}
exports.IntegerOutOfRangeError = IntegerOutOfRangeError;
class InvalidHexBooleanError extends Errors.BaseError {
    constructor(hex) {
        super(`Hex value \`"${hex}"\` is not a valid boolean.`, {
            metaMessages: [
                'The hex value must be `"0x0"` (false) or `"0x1"` (true).',
            ],
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'Hex.InvalidHexBooleanError'
        });
    }
}
exports.InvalidHexBooleanError = InvalidHexBooleanError;
class InvalidHexTypeError extends Errors.BaseError {
    constructor(value) {
        super(`Value \`${typeof value === 'object' ? Json.stringify(value) : value}\` of type \`${typeof value}\` is an invalid hex type.`, {
            metaMessages: ['Hex types must be represented as `"0x${string}"`.'],
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'Hex.InvalidHexTypeError'
        });
    }
}
exports.InvalidHexTypeError = InvalidHexTypeError;
class InvalidHexValueError extends Errors.BaseError {
    constructor(value) {
        super(`Value \`${value}\` is an invalid hex value.`, {
            metaMessages: [
                'Hex values must start with `"0x"` and contain only hexadecimal characters (0-9, a-f, A-F).',
            ],
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'Hex.InvalidHexValueError'
        });
    }
}
exports.InvalidHexValueError = InvalidHexValueError;
class InvalidLengthError extends Errors.BaseError {
    constructor(value) {
        super(`Hex value \`"${value}"\` is an odd length (${value.length - 2} nibbles).`, {
            metaMessages: ['It must be an even length.'],
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'Hex.InvalidLengthError'
        });
    }
}
exports.InvalidLengthError = InvalidLengthError;
class SizeOverflowError extends Errors.BaseError {
    constructor({ givenSize, maxSize }) {
        super(`Size cannot exceed \`${maxSize}\` bytes. Given size: \`${givenSize}\` bytes.`);
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'Hex.SizeOverflowError'
        });
    }
}
exports.SizeOverflowError = SizeOverflowError;
class SliceOffsetOutOfBoundsError extends Errors.BaseError {
    constructor({ offset, position, size, }) {
        super(`Slice ${position === 'start' ? 'starting' : 'ending'} at offset \`${offset}\` is out-of-bounds (size: \`${size}\`).`);
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'Hex.SliceOffsetOutOfBoundsError'
        });
    }
}
exports.SliceOffsetOutOfBoundsError = SliceOffsetOutOfBoundsError;
class SizeExceedsPaddingSizeError extends Errors.BaseError {
    constructor({ size, targetSize, type, }) {
        super(`${type.charAt(0).toUpperCase()}${type
            .slice(1)
            .toLowerCase()} size (\`${size}\`) exceeds padding size (\`${targetSize}\`).`);
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'Hex.SizeExceedsPaddingSizeError'
        });
    }
}
exports.SizeExceedsPaddingSizeError = SizeExceedsPaddingSizeError;
//# sourceMappingURL=Hex.js.map

/***/ }),

/***/ "./node_modules/ox/_cjs/core/Json.js":
/*!*******************************************!*\
  !*** ./node_modules/ox/_cjs/core/Json.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.parse = parse;
exports.stringify = stringify;
const bigIntSuffix = '#__bigint';
function parse(string, reviver) {
    return JSON.parse(string, (key, value_) => {
        const value = value_;
        if (typeof value === 'string' && value.endsWith(bigIntSuffix))
            return BigInt(value.slice(0, -bigIntSuffix.length));
        return typeof reviver === 'function' ? reviver(key, value) : value;
    });
}
function stringify(value, replacer, space) {
    return JSON.stringify(value, (key, value) => {
        if (typeof replacer === 'function')
            return replacer(key, value);
        if (typeof value === 'bigint')
            return value.toString() + bigIntSuffix;
        return value;
    }, space);
}
//# sourceMappingURL=Json.js.map

/***/ }),

/***/ "./node_modules/ox/_cjs/core/PublicKey.js":
/*!************************************************!*\
  !*** ./node_modules/ox/_cjs/core/PublicKey.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.InvalidSerializedSizeError = exports.InvalidUncompressedPrefixError = exports.InvalidCompressedPrefixError = exports.InvalidPrefixError = exports.InvalidError = void 0;
exports.assert = assert;
exports.compress = compress;
exports.from = from;
exports.fromBytes = fromBytes;
exports.fromHex = fromHex;
exports.toBytes = toBytes;
exports.toHex = toHex;
exports.validate = validate;
const Bytes = __webpack_require__(/*! ./Bytes.js */ "./node_modules/ox/_cjs/core/Bytes.js");
const Errors = __webpack_require__(/*! ./Errors.js */ "./node_modules/ox/_cjs/core/Errors.js");
const Hex = __webpack_require__(/*! ./Hex.js */ "./node_modules/ox/_cjs/core/Hex.js");
const Json = __webpack_require__(/*! ./Json.js */ "./node_modules/ox/_cjs/core/Json.js");
function assert(publicKey, options = {}) {
    const { compressed } = options;
    const { prefix, x, y } = publicKey;
    if (compressed === false ||
        (typeof x === 'bigint' && typeof y === 'bigint')) {
        if (prefix !== 4)
            throw new InvalidPrefixError({
                prefix,
                cause: new InvalidUncompressedPrefixError(),
            });
        return;
    }
    if (compressed === true ||
        (typeof x === 'bigint' && typeof y === 'undefined')) {
        if (prefix !== 3 && prefix !== 2)
            throw new InvalidPrefixError({
                prefix,
                cause: new InvalidCompressedPrefixError(),
            });
        return;
    }
    throw new InvalidError({ publicKey });
}
function compress(publicKey) {
    const { x, y } = publicKey;
    return {
        prefix: y % 2n === 0n ? 2 : 3,
        x,
    };
}
function from(value) {
    const publicKey = (() => {
        if (Hex.validate(value))
            return fromHex(value);
        if (Bytes.validate(value))
            return fromBytes(value);
        const { prefix, x, y } = value;
        if (typeof x === 'bigint' && typeof y === 'bigint')
            return { prefix: prefix ?? 0x04, x, y };
        return { prefix, x };
    })();
    assert(publicKey);
    return publicKey;
}
function fromBytes(publicKey) {
    return fromHex(Hex.fromBytes(publicKey));
}
function fromHex(publicKey) {
    if (publicKey.length !== 132 &&
        publicKey.length !== 130 &&
        publicKey.length !== 68)
        throw new InvalidSerializedSizeError({ publicKey });
    if (publicKey.length === 130) {
        const x = BigInt(Hex.slice(publicKey, 0, 32));
        const y = BigInt(Hex.slice(publicKey, 32, 64));
        return {
            prefix: 4,
            x,
            y,
        };
    }
    if (publicKey.length === 132) {
        const prefix = Number(Hex.slice(publicKey, 0, 1));
        const x = BigInt(Hex.slice(publicKey, 1, 33));
        const y = BigInt(Hex.slice(publicKey, 33, 65));
        return {
            prefix,
            x,
            y,
        };
    }
    const prefix = Number(Hex.slice(publicKey, 0, 1));
    const x = BigInt(Hex.slice(publicKey, 1, 33));
    return {
        prefix,
        x,
    };
}
function toBytes(publicKey, options = {}) {
    return Bytes.fromHex(toHex(publicKey, options));
}
function toHex(publicKey, options = {}) {
    assert(publicKey);
    const { prefix, x, y } = publicKey;
    const { includePrefix = true } = options;
    const publicKey_ = Hex.concat(includePrefix ? Hex.fromNumber(prefix, { size: 1 }) : '0x', Hex.fromNumber(x, { size: 32 }), typeof y === 'bigint' ? Hex.fromNumber(y, { size: 32 }) : '0x');
    return publicKey_;
}
function validate(publicKey, options = {}) {
    try {
        assert(publicKey, options);
        return true;
    }
    catch (_error) {
        return false;
    }
}
class InvalidError extends Errors.BaseError {
    constructor({ publicKey }) {
        super(`Value \`${Json.stringify(publicKey)}\` is not a valid public key.`, {
            metaMessages: [
                'Public key must contain:',
                '- an `x` and `prefix` value (compressed)',
                '- an `x`, `y`, and `prefix` value (uncompressed)',
            ],
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'PublicKey.InvalidError'
        });
    }
}
exports.InvalidError = InvalidError;
class InvalidPrefixError extends Errors.BaseError {
    constructor({ prefix, cause }) {
        super(`Prefix "${prefix}" is invalid.`, {
            cause,
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'PublicKey.InvalidPrefixError'
        });
    }
}
exports.InvalidPrefixError = InvalidPrefixError;
class InvalidCompressedPrefixError extends Errors.BaseError {
    constructor() {
        super('Prefix must be 2 or 3 for compressed public keys.');
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'PublicKey.InvalidCompressedPrefixError'
        });
    }
}
exports.InvalidCompressedPrefixError = InvalidCompressedPrefixError;
class InvalidUncompressedPrefixError extends Errors.BaseError {
    constructor() {
        super('Prefix must be 4 for uncompressed public keys.');
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'PublicKey.InvalidUncompressedPrefixError'
        });
    }
}
exports.InvalidUncompressedPrefixError = InvalidUncompressedPrefixError;
class InvalidSerializedSizeError extends Errors.BaseError {
    constructor({ publicKey }) {
        super(`Value \`${publicKey}\` is an invalid public key size.`, {
            metaMessages: [
                'Expected: 33 bytes (compressed + prefix), 64 bytes (uncompressed) or 65 bytes (uncompressed + prefix).',
                `Received ${Hex.size(Hex.from(publicKey))} bytes.`,
            ],
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'PublicKey.InvalidSerializedSizeError'
        });
    }
}
exports.InvalidSerializedSizeError = InvalidSerializedSizeError;
//# sourceMappingURL=PublicKey.js.map

/***/ }),

/***/ "./node_modules/ox/_cjs/core/Solidity.js":
/*!***********************************************!*\
  !*** ./node_modules/ox/_cjs/core/Solidity.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.minInt120 = exports.minInt112 = exports.minInt104 = exports.minInt96 = exports.minInt88 = exports.minInt80 = exports.minInt72 = exports.minInt64 = exports.minInt56 = exports.minInt48 = exports.minInt40 = exports.minInt32 = exports.minInt24 = exports.minInt16 = exports.minInt8 = exports.maxInt256 = exports.maxInt248 = exports.maxInt240 = exports.maxInt232 = exports.maxInt224 = exports.maxInt216 = exports.maxInt208 = exports.maxInt200 = exports.maxInt192 = exports.maxInt184 = exports.maxInt176 = exports.maxInt168 = exports.maxInt160 = exports.maxInt152 = exports.maxInt144 = exports.maxInt136 = exports.maxInt128 = exports.maxInt120 = exports.maxInt112 = exports.maxInt104 = exports.maxInt96 = exports.maxInt88 = exports.maxInt80 = exports.maxInt72 = exports.maxInt64 = exports.maxInt56 = exports.maxInt48 = exports.maxInt40 = exports.maxInt32 = exports.maxInt24 = exports.maxInt16 = exports.maxInt8 = exports.integerRegex = exports.bytesRegex = exports.arrayRegex = void 0;
exports.maxUint256 = exports.maxUint248 = exports.maxUint240 = exports.maxUint232 = exports.maxUint224 = exports.maxUint216 = exports.maxUint208 = exports.maxUint200 = exports.maxUint192 = exports.maxUint184 = exports.maxUint176 = exports.maxUint168 = exports.maxUint160 = exports.maxUint152 = exports.maxUint144 = exports.maxUint136 = exports.maxUint128 = exports.maxUint120 = exports.maxUint112 = exports.maxUint104 = exports.maxUint96 = exports.maxUint88 = exports.maxUint80 = exports.maxUint72 = exports.maxUint64 = exports.maxUint56 = exports.maxUint48 = exports.maxUint40 = exports.maxUint32 = exports.maxUint24 = exports.maxUint16 = exports.maxUint8 = exports.minInt256 = exports.minInt248 = exports.minInt240 = exports.minInt232 = exports.minInt224 = exports.minInt216 = exports.minInt208 = exports.minInt200 = exports.minInt192 = exports.minInt184 = exports.minInt176 = exports.minInt168 = exports.minInt160 = exports.minInt152 = exports.minInt144 = exports.minInt136 = exports.minInt128 = void 0;
exports.arrayRegex = /^(.*)\[([0-9]*)\]$/;
exports.bytesRegex = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/;
exports.integerRegex = /^(u?int)(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/;
exports.maxInt8 = 2n ** (8n - 1n) - 1n;
exports.maxInt16 = 2n ** (16n - 1n) - 1n;
exports.maxInt24 = 2n ** (24n - 1n) - 1n;
exports.maxInt32 = 2n ** (32n - 1n) - 1n;
exports.maxInt40 = 2n ** (40n - 1n) - 1n;
exports.maxInt48 = 2n ** (48n - 1n) - 1n;
exports.maxInt56 = 2n ** (56n - 1n) - 1n;
exports.maxInt64 = 2n ** (64n - 1n) - 1n;
exports.maxInt72 = 2n ** (72n - 1n) - 1n;
exports.maxInt80 = 2n ** (80n - 1n) - 1n;
exports.maxInt88 = 2n ** (88n - 1n) - 1n;
exports.maxInt96 = 2n ** (96n - 1n) - 1n;
exports.maxInt104 = 2n ** (104n - 1n) - 1n;
exports.maxInt112 = 2n ** (112n - 1n) - 1n;
exports.maxInt120 = 2n ** (120n - 1n) - 1n;
exports.maxInt128 = 2n ** (128n - 1n) - 1n;
exports.maxInt136 = 2n ** (136n - 1n) - 1n;
exports.maxInt144 = 2n ** (144n - 1n) - 1n;
exports.maxInt152 = 2n ** (152n - 1n) - 1n;
exports.maxInt160 = 2n ** (160n - 1n) - 1n;
exports.maxInt168 = 2n ** (168n - 1n) - 1n;
exports.maxInt176 = 2n ** (176n - 1n) - 1n;
exports.maxInt184 = 2n ** (184n - 1n) - 1n;
exports.maxInt192 = 2n ** (192n - 1n) - 1n;
exports.maxInt200 = 2n ** (200n - 1n) - 1n;
exports.maxInt208 = 2n ** (208n - 1n) - 1n;
exports.maxInt216 = 2n ** (216n - 1n) - 1n;
exports.maxInt224 = 2n ** (224n - 1n) - 1n;
exports.maxInt232 = 2n ** (232n - 1n) - 1n;
exports.maxInt240 = 2n ** (240n - 1n) - 1n;
exports.maxInt248 = 2n ** (248n - 1n) - 1n;
exports.maxInt256 = 2n ** (256n - 1n) - 1n;
exports.minInt8 = -(2n ** (8n - 1n));
exports.minInt16 = -(2n ** (16n - 1n));
exports.minInt24 = -(2n ** (24n - 1n));
exports.minInt32 = -(2n ** (32n - 1n));
exports.minInt40 = -(2n ** (40n - 1n));
exports.minInt48 = -(2n ** (48n - 1n));
exports.minInt56 = -(2n ** (56n - 1n));
exports.minInt64 = -(2n ** (64n - 1n));
exports.minInt72 = -(2n ** (72n - 1n));
exports.minInt80 = -(2n ** (80n - 1n));
exports.minInt88 = -(2n ** (88n - 1n));
exports.minInt96 = -(2n ** (96n - 1n));
exports.minInt104 = -(2n ** (104n - 1n));
exports.minInt112 = -(2n ** (112n - 1n));
exports.minInt120 = -(2n ** (120n - 1n));
exports.minInt128 = -(2n ** (128n - 1n));
exports.minInt136 = -(2n ** (136n - 1n));
exports.minInt144 = -(2n ** (144n - 1n));
exports.minInt152 = -(2n ** (152n - 1n));
exports.minInt160 = -(2n ** (160n - 1n));
exports.minInt168 = -(2n ** (168n - 1n));
exports.minInt176 = -(2n ** (176n - 1n));
exports.minInt184 = -(2n ** (184n - 1n));
exports.minInt192 = -(2n ** (192n - 1n));
exports.minInt200 = -(2n ** (200n - 1n));
exports.minInt208 = -(2n ** (208n - 1n));
exports.minInt216 = -(2n ** (216n - 1n));
exports.minInt224 = -(2n ** (224n - 1n));
exports.minInt232 = -(2n ** (232n - 1n));
exports.minInt240 = -(2n ** (240n - 1n));
exports.minInt248 = -(2n ** (248n - 1n));
exports.minInt256 = -(2n ** (256n - 1n));
exports.maxUint8 = 2n ** 8n - 1n;
exports.maxUint16 = 2n ** 16n - 1n;
exports.maxUint24 = 2n ** 24n - 1n;
exports.maxUint32 = 2n ** 32n - 1n;
exports.maxUint40 = 2n ** 40n - 1n;
exports.maxUint48 = 2n ** 48n - 1n;
exports.maxUint56 = 2n ** 56n - 1n;
exports.maxUint64 = 2n ** 64n - 1n;
exports.maxUint72 = 2n ** 72n - 1n;
exports.maxUint80 = 2n ** 80n - 1n;
exports.maxUint88 = 2n ** 88n - 1n;
exports.maxUint96 = 2n ** 96n - 1n;
exports.maxUint104 = 2n ** 104n - 1n;
exports.maxUint112 = 2n ** 112n - 1n;
exports.maxUint120 = 2n ** 120n - 1n;
exports.maxUint128 = 2n ** 128n - 1n;
exports.maxUint136 = 2n ** 136n - 1n;
exports.maxUint144 = 2n ** 144n - 1n;
exports.maxUint152 = 2n ** 152n - 1n;
exports.maxUint160 = 2n ** 160n - 1n;
exports.maxUint168 = 2n ** 168n - 1n;
exports.maxUint176 = 2n ** 176n - 1n;
exports.maxUint184 = 2n ** 184n - 1n;
exports.maxUint192 = 2n ** 192n - 1n;
exports.maxUint200 = 2n ** 200n - 1n;
exports.maxUint208 = 2n ** 208n - 1n;
exports.maxUint216 = 2n ** 216n - 1n;
exports.maxUint224 = 2n ** 224n - 1n;
exports.maxUint232 = 2n ** 232n - 1n;
exports.maxUint240 = 2n ** 240n - 1n;
exports.maxUint248 = 2n ** 248n - 1n;
exports.maxUint256 = 2n ** 256n - 1n;
//# sourceMappingURL=Solidity.js.map

/***/ }),

/***/ "./node_modules/ox/_cjs/core/Withdrawal.js":
/*!*************************************************!*\
  !*** ./node_modules/ox/_cjs/core/Withdrawal.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.fromRpc = fromRpc;
exports.toRpc = toRpc;
const Hex = __webpack_require__(/*! ./Hex.js */ "./node_modules/ox/_cjs/core/Hex.js");
function fromRpc(withdrawal) {
    return {
        ...withdrawal,
        amount: BigInt(withdrawal.amount),
        index: Number(withdrawal.index),
        validatorIndex: Number(withdrawal.validatorIndex),
    };
}
function toRpc(withdrawal) {
    return {
        address: withdrawal.address,
        amount: Hex.fromNumber(withdrawal.amount),
        index: Hex.fromNumber(withdrawal.index),
        validatorIndex: Hex.fromNumber(withdrawal.validatorIndex),
    };
}
//# sourceMappingURL=Withdrawal.js.map

/***/ }),

/***/ "./node_modules/ox/_cjs/core/internal/abiItem.js":
/*!*******************************************************!*\
  !*** ./node_modules/ox/_cjs/core/internal/abiItem.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.normalizeSignature = normalizeSignature;
exports.isArgOfType = isArgOfType;
exports.getAmbiguousTypes = getAmbiguousTypes;
const Address = __webpack_require__(/*! ../Address.js */ "./node_modules/ox/_cjs/core/Address.js");
const Errors = __webpack_require__(/*! ../Errors.js */ "./node_modules/ox/_cjs/core/Errors.js");
function normalizeSignature(signature) {
    let active = true;
    let current = '';
    let level = 0;
    let result = '';
    let valid = false;
    for (let i = 0; i < signature.length; i++) {
        const char = signature[i];
        if (['(', ')', ','].includes(char))
            active = true;
        if (char === '(')
            level++;
        if (char === ')')
            level--;
        if (!active)
            continue;
        if (level === 0) {
            if (char === ' ' && ['event', 'function', 'error', ''].includes(result))
                result = '';
            else {
                result += char;
                if (char === ')') {
                    valid = true;
                    break;
                }
            }
            continue;
        }
        if (char === ' ') {
            if (signature[i - 1] !== ',' && current !== ',' && current !== ',(') {
                current = '';
                active = false;
            }
            continue;
        }
        result += char;
        current += char;
    }
    if (!valid)
        throw new Errors.BaseError('Unable to normalize signature.');
    return result;
}
function isArgOfType(arg, abiParameter) {
    const argType = typeof arg;
    const abiParameterType = abiParameter.type;
    switch (abiParameterType) {
        case 'address':
            return Address.validate(arg, { strict: false });
        case 'bool':
            return argType === 'boolean';
        case 'function':
            return argType === 'string';
        case 'string':
            return argType === 'string';
        default: {
            if (abiParameterType === 'tuple' && 'components' in abiParameter)
                return Object.values(abiParameter.components).every((component, index) => {
                    return isArgOfType(Object.values(arg)[index], component);
                });
            if (/^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/.test(abiParameterType))
                return argType === 'number' || argType === 'bigint';
            if (/^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/.test(abiParameterType))
                return argType === 'string' || arg instanceof Uint8Array;
            if (/[a-z]+[1-9]{0,3}(\[[0-9]{0,}\])+$/.test(abiParameterType)) {
                return (Array.isArray(arg) &&
                    arg.every((x) => isArgOfType(x, {
                        ...abiParameter,
                        type: abiParameterType.replace(/(\[[0-9]{0,}\])$/, ''),
                    })));
            }
            return false;
        }
    }
}
function getAmbiguousTypes(sourceParameters, targetParameters, args) {
    for (const parameterIndex in sourceParameters) {
        const sourceParameter = sourceParameters[parameterIndex];
        const targetParameter = targetParameters[parameterIndex];
        if (sourceParameter.type === 'tuple' &&
            targetParameter.type === 'tuple' &&
            'components' in sourceParameter &&
            'components' in targetParameter)
            return getAmbiguousTypes(sourceParameter.components, targetParameter.components, args[parameterIndex]);
        const types = [sourceParameter.type, targetParameter.type];
        const ambiguous = (() => {
            if (types.includes('address') && types.includes('bytes20'))
                return true;
            if (types.includes('address') && types.includes('string'))
                return Address.validate(args[parameterIndex], {
                    strict: false,
                });
            if (types.includes('address') && types.includes('bytes'))
                return Address.validate(args[parameterIndex], {
                    strict: false,
                });
            return false;
        })();
        if (ambiguous)
            return types;
    }
    return;
}
//# sourceMappingURL=abiItem.js.map

/***/ }),

/***/ "./node_modules/ox/_cjs/core/internal/abiParameters.js":
/*!*************************************************************!*\
  !*** ./node_modules/ox/_cjs/core/internal/abiParameters.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.decodeParameter = decodeParameter;
exports.decodeAddress = decodeAddress;
exports.decodeArray = decodeArray;
exports.decodeBool = decodeBool;
exports.decodeBytes = decodeBytes;
exports.decodeNumber = decodeNumber;
exports.decodeTuple = decodeTuple;
exports.decodeString = decodeString;
exports.prepareParameters = prepareParameters;
exports.prepareParameter = prepareParameter;
exports.encode = encode;
exports.encodeAddress = encodeAddress;
exports.encodeArray = encodeArray;
exports.encodeBytes = encodeBytes;
exports.encodeBoolean = encodeBoolean;
exports.encodeNumber = encodeNumber;
exports.encodeString = encodeString;
exports.encodeTuple = encodeTuple;
exports.getArrayComponents = getArrayComponents;
exports.hasDynamicChild = hasDynamicChild;
const AbiParameters = __webpack_require__(/*! ../AbiParameters.js */ "./node_modules/ox/_cjs/core/AbiParameters.js");
const Address = __webpack_require__(/*! ../Address.js */ "./node_modules/ox/_cjs/core/Address.js");
const Bytes = __webpack_require__(/*! ../Bytes.js */ "./node_modules/ox/_cjs/core/Bytes.js");
const Errors = __webpack_require__(/*! ../Errors.js */ "./node_modules/ox/_cjs/core/Errors.js");
const Hex = __webpack_require__(/*! ../Hex.js */ "./node_modules/ox/_cjs/core/Hex.js");
const Solidity_js_1 = __webpack_require__(/*! ../Solidity.js */ "./node_modules/ox/_cjs/core/Solidity.js");
function decodeParameter(cursor, param, options) {
    const { checksumAddress, staticPosition } = options;
    const arrayComponents = getArrayComponents(param.type);
    if (arrayComponents) {
        const [length, type] = arrayComponents;
        return decodeArray(cursor, { ...param, type }, { checksumAddress, length, staticPosition });
    }
    if (param.type === 'tuple')
        return decodeTuple(cursor, param, {
            checksumAddress,
            staticPosition,
        });
    if (param.type === 'address')
        return decodeAddress(cursor, { checksum: checksumAddress });
    if (param.type === 'bool')
        return decodeBool(cursor);
    if (param.type.startsWith('bytes'))
        return decodeBytes(cursor, param, { staticPosition });
    if (param.type.startsWith('uint') || param.type.startsWith('int'))
        return decodeNumber(cursor, param);
    if (param.type === 'string')
        return decodeString(cursor, { staticPosition });
    throw new AbiParameters.InvalidTypeError(param.type);
}
const sizeOfLength = 32;
const sizeOfOffset = 32;
function decodeAddress(cursor, options = {}) {
    const { checksum = false } = options;
    const value = cursor.readBytes(32);
    const wrap = (address) => checksum ? Address.checksum(address) : address;
    return [wrap(Hex.fromBytes(Bytes.slice(value, -20))), 32];
}
function decodeArray(cursor, param, options) {
    const { checksumAddress, length, staticPosition } = options;
    if (!length) {
        const offset = Bytes.toNumber(cursor.readBytes(sizeOfOffset));
        const start = staticPosition + offset;
        const startOfData = start + sizeOfLength;
        cursor.setPosition(start);
        const length = Bytes.toNumber(cursor.readBytes(sizeOfLength));
        const dynamicChild = hasDynamicChild(param);
        let consumed = 0;
        const value = [];
        for (let i = 0; i < length; ++i) {
            cursor.setPosition(startOfData + (dynamicChild ? i * 32 : consumed));
            const [data, consumed_] = decodeParameter(cursor, param, {
                checksumAddress,
                staticPosition: startOfData,
            });
            consumed += consumed_;
            value.push(data);
        }
        cursor.setPosition(staticPosition + 32);
        return [value, 32];
    }
    if (hasDynamicChild(param)) {
        const offset = Bytes.toNumber(cursor.readBytes(sizeOfOffset));
        const start = staticPosition + offset;
        const value = [];
        for (let i = 0; i < length; ++i) {
            cursor.setPosition(start + i * 32);
            const [data] = decodeParameter(cursor, param, {
                checksumAddress,
                staticPosition: start,
            });
            value.push(data);
        }
        cursor.setPosition(staticPosition + 32);
        return [value, 32];
    }
    let consumed = 0;
    const value = [];
    for (let i = 0; i < length; ++i) {
        const [data, consumed_] = decodeParameter(cursor, param, {
            checksumAddress,
            staticPosition: staticPosition + consumed,
        });
        consumed += consumed_;
        value.push(data);
    }
    return [value, consumed];
}
function decodeBool(cursor) {
    return [Bytes.toBoolean(cursor.readBytes(32), { size: 32 }), 32];
}
function decodeBytes(cursor, param, { staticPosition }) {
    const [_, size] = param.type.split('bytes');
    if (!size) {
        const offset = Bytes.toNumber(cursor.readBytes(32));
        cursor.setPosition(staticPosition + offset);
        const length = Bytes.toNumber(cursor.readBytes(32));
        if (length === 0) {
            cursor.setPosition(staticPosition + 32);
            return ['0x', 32];
        }
        const data = cursor.readBytes(length);
        cursor.setPosition(staticPosition + 32);
        return [Hex.fromBytes(data), 32];
    }
    const value = Hex.fromBytes(cursor.readBytes(Number.parseInt(size, 10), 32));
    return [value, 32];
}
function decodeNumber(cursor, param) {
    const signed = param.type.startsWith('int');
    const size = Number.parseInt(param.type.split('int')[1] || '256', 10);
    const value = cursor.readBytes(32);
    return [
        size > 48
            ? Bytes.toBigInt(value, { signed })
            : Bytes.toNumber(value, { signed }),
        32,
    ];
}
function decodeTuple(cursor, param, options) {
    const { checksumAddress, staticPosition } = options;
    const hasUnnamedChild = param.components.length === 0 || param.components.some(({ name }) => !name);
    const value = hasUnnamedChild ? [] : {};
    let consumed = 0;
    if (hasDynamicChild(param)) {
        const offset = Bytes.toNumber(cursor.readBytes(sizeOfOffset));
        const start = staticPosition + offset;
        for (let i = 0; i < param.components.length; ++i) {
            const component = param.components[i];
            cursor.setPosition(start + consumed);
            const [data, consumed_] = decodeParameter(cursor, component, {
                checksumAddress,
                staticPosition: start,
            });
            consumed += consumed_;
            value[hasUnnamedChild ? i : component?.name] = data;
        }
        cursor.setPosition(staticPosition + 32);
        return [value, 32];
    }
    for (let i = 0; i < param.components.length; ++i) {
        const component = param.components[i];
        const [data, consumed_] = decodeParameter(cursor, component, {
            checksumAddress,
            staticPosition,
        });
        value[hasUnnamedChild ? i : component?.name] = data;
        consumed += consumed_;
    }
    return [value, consumed];
}
function decodeString(cursor, { staticPosition }) {
    const offset = Bytes.toNumber(cursor.readBytes(32));
    const start = staticPosition + offset;
    cursor.setPosition(start);
    const length = Bytes.toNumber(cursor.readBytes(32));
    if (length === 0) {
        cursor.setPosition(staticPosition + 32);
        return ['', 32];
    }
    const data = cursor.readBytes(length, 32);
    const value = Bytes.toString(Bytes.trimLeft(data));
    cursor.setPosition(staticPosition + 32);
    return [value, 32];
}
function prepareParameters({ checksumAddress, parameters, values, }) {
    const preparedParameters = [];
    for (let i = 0; i < parameters.length; i++) {
        preparedParameters.push(prepareParameter({
            checksumAddress,
            parameter: parameters[i],
            value: values[i],
        }));
    }
    return preparedParameters;
}
function prepareParameter({ checksumAddress = false, parameter: parameter_, value, }) {
    const parameter = parameter_;
    const arrayComponents = getArrayComponents(parameter.type);
    if (arrayComponents) {
        const [length, type] = arrayComponents;
        return encodeArray(value, {
            checksumAddress,
            length,
            parameter: {
                ...parameter,
                type,
            },
        });
    }
    if (parameter.type === 'tuple') {
        return encodeTuple(value, {
            checksumAddress,
            parameter: parameter,
        });
    }
    if (parameter.type === 'address') {
        return encodeAddress(value, {
            checksum: checksumAddress,
        });
    }
    if (parameter.type === 'bool') {
        return encodeBoolean(value);
    }
    if (parameter.type.startsWith('uint') || parameter.type.startsWith('int')) {
        const signed = parameter.type.startsWith('int');
        const [, , size = '256'] = Solidity_js_1.integerRegex.exec(parameter.type) ?? [];
        return encodeNumber(value, {
            signed,
            size: Number(size),
        });
    }
    if (parameter.type.startsWith('bytes')) {
        return encodeBytes(value, { type: parameter.type });
    }
    if (parameter.type === 'string') {
        return encodeString(value);
    }
    throw new AbiParameters.InvalidTypeError(parameter.type);
}
function encode(preparedParameters) {
    let staticSize = 0;
    for (let i = 0; i < preparedParameters.length; i++) {
        const { dynamic, encoded } = preparedParameters[i];
        if (dynamic)
            staticSize += 32;
        else
            staticSize += Hex.size(encoded);
    }
    const staticParameters = [];
    const dynamicParameters = [];
    let dynamicSize = 0;
    for (let i = 0; i < preparedParameters.length; i++) {
        const { dynamic, encoded } = preparedParameters[i];
        if (dynamic) {
            staticParameters.push(Hex.fromNumber(staticSize + dynamicSize, { size: 32 }));
            dynamicParameters.push(encoded);
            dynamicSize += Hex.size(encoded);
        }
        else {
            staticParameters.push(encoded);
        }
    }
    return Hex.concat(...staticParameters, ...dynamicParameters);
}
function encodeAddress(value, options) {
    const { checksum = false } = options;
    Address.assert(value, { strict: checksum });
    return {
        dynamic: false,
        encoded: Hex.padLeft(value.toLowerCase()),
    };
}
function encodeArray(value, options) {
    const { checksumAddress, length, parameter } = options;
    const dynamic = length === null;
    if (!Array.isArray(value))
        throw new AbiParameters.InvalidArrayError(value);
    if (!dynamic && value.length !== length)
        throw new AbiParameters.ArrayLengthMismatchError({
            expectedLength: length,
            givenLength: value.length,
            type: `${parameter.type}[${length}]`,
        });
    let dynamicChild = false;
    const preparedParameters = [];
    for (let i = 0; i < value.length; i++) {
        const preparedParam = prepareParameter({
            checksumAddress,
            parameter,
            value: value[i],
        });
        if (preparedParam.dynamic)
            dynamicChild = true;
        preparedParameters.push(preparedParam);
    }
    if (dynamic || dynamicChild) {
        const data = encode(preparedParameters);
        if (dynamic) {
            const length = Hex.fromNumber(preparedParameters.length, { size: 32 });
            return {
                dynamic: true,
                encoded: preparedParameters.length > 0 ? Hex.concat(length, data) : length,
            };
        }
        if (dynamicChild)
            return { dynamic: true, encoded: data };
    }
    return {
        dynamic: false,
        encoded: Hex.concat(...preparedParameters.map(({ encoded }) => encoded)),
    };
}
function encodeBytes(value, { type }) {
    const [, parametersize] = type.split('bytes');
    const bytesSize = Hex.size(value);
    if (!parametersize) {
        let value_ = value;
        if (bytesSize % 32 !== 0)
            value_ = Hex.padRight(value_, Math.ceil((value.length - 2) / 2 / 32) * 32);
        return {
            dynamic: true,
            encoded: Hex.concat(Hex.padLeft(Hex.fromNumber(bytesSize, { size: 32 })), value_),
        };
    }
    if (bytesSize !== Number.parseInt(parametersize, 10))
        throw new AbiParameters.BytesSizeMismatchError({
            expectedSize: Number.parseInt(parametersize, 10),
            value,
        });
    return { dynamic: false, encoded: Hex.padRight(value) };
}
function encodeBoolean(value) {
    if (typeof value !== 'boolean')
        throw new Errors.BaseError(`Invalid boolean value: "${value}" (type: ${typeof value}). Expected: \`true\` or \`false\`.`);
    return { dynamic: false, encoded: Hex.padLeft(Hex.fromBoolean(value)) };
}
function encodeNumber(value, { signed, size }) {
    if (typeof size === 'number') {
        const max = 2n ** (BigInt(size) - (signed ? 1n : 0n)) - 1n;
        const min = signed ? -max - 1n : 0n;
        if (value > max || value < min)
            throw new Hex.IntegerOutOfRangeError({
                max: max.toString(),
                min: min.toString(),
                signed,
                size: size / 8,
                value: value.toString(),
            });
    }
    return {
        dynamic: false,
        encoded: Hex.fromNumber(value, {
            size: 32,
            signed,
        }),
    };
}
function encodeString(value) {
    const hexValue = Hex.fromString(value);
    const partsLength = Math.ceil(Hex.size(hexValue) / 32);
    const parts = [];
    for (let i = 0; i < partsLength; i++) {
        parts.push(Hex.padRight(Hex.slice(hexValue, i * 32, (i + 1) * 32)));
    }
    return {
        dynamic: true,
        encoded: Hex.concat(Hex.padRight(Hex.fromNumber(Hex.size(hexValue), { size: 32 })), ...parts),
    };
}
function encodeTuple(value, options) {
    const { checksumAddress, parameter } = options;
    let dynamic = false;
    const preparedParameters = [];
    for (let i = 0; i < parameter.components.length; i++) {
        const param_ = parameter.components[i];
        const index = Array.isArray(value) ? i : param_.name;
        const preparedParam = prepareParameter({
            checksumAddress,
            parameter: param_,
            value: value[index],
        });
        preparedParameters.push(preparedParam);
        if (preparedParam.dynamic)
            dynamic = true;
    }
    return {
        dynamic,
        encoded: dynamic
            ? encode(preparedParameters)
            : Hex.concat(...preparedParameters.map(({ encoded }) => encoded)),
    };
}
function getArrayComponents(type) {
    const matches = type.match(/^(.*)\[(\d+)?\]$/);
    return matches
        ?
            [matches[2] ? Number(matches[2]) : null, matches[1]]
        : undefined;
}
function hasDynamicChild(param) {
    const { type } = param;
    if (type === 'string')
        return true;
    if (type === 'bytes')
        return true;
    if (type.endsWith('[]'))
        return true;
    if (type === 'tuple')
        return param.components?.some(hasDynamicChild);
    const arrayComponents = getArrayComponents(param.type);
    if (arrayComponents &&
        hasDynamicChild({
            ...param,
            type: arrayComponents[1],
        }))
        return true;
    return false;
}
//# sourceMappingURL=abiParameters.js.map

/***/ }),

/***/ "./node_modules/ox/_cjs/core/internal/bytes.js":
/*!*****************************************************!*\
  !*** ./node_modules/ox/_cjs/core/internal/bytes.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.charCodeMap = void 0;
exports.assertSize = assertSize;
exports.assertStartOffset = assertStartOffset;
exports.assertEndOffset = assertEndOffset;
exports.charCodeToBase16 = charCodeToBase16;
exports.pad = pad;
exports.trim = trim;
const Bytes = __webpack_require__(/*! ../Bytes.js */ "./node_modules/ox/_cjs/core/Bytes.js");
function assertSize(bytes, size_) {
    if (Bytes.size(bytes) > size_)
        throw new Bytes.SizeOverflowError({
            givenSize: Bytes.size(bytes),
            maxSize: size_,
        });
}
function assertStartOffset(value, start) {
    if (typeof start === 'number' && start > 0 && start > Bytes.size(value) - 1)
        throw new Bytes.SliceOffsetOutOfBoundsError({
            offset: start,
            position: 'start',
            size: Bytes.size(value),
        });
}
function assertEndOffset(value, start, end) {
    if (typeof start === 'number' &&
        typeof end === 'number' &&
        Bytes.size(value) !== end - start) {
        throw new Bytes.SliceOffsetOutOfBoundsError({
            offset: end,
            position: 'end',
            size: Bytes.size(value),
        });
    }
}
exports.charCodeMap = {
    zero: 48,
    nine: 57,
    A: 65,
    F: 70,
    a: 97,
    f: 102,
};
function charCodeToBase16(char) {
    if (char >= exports.charCodeMap.zero && char <= exports.charCodeMap.nine)
        return char - exports.charCodeMap.zero;
    if (char >= exports.charCodeMap.A && char <= exports.charCodeMap.F)
        return char - (exports.charCodeMap.A - 10);
    if (char >= exports.charCodeMap.a && char <= exports.charCodeMap.f)
        return char - (exports.charCodeMap.a - 10);
    return undefined;
}
function pad(bytes, options = {}) {
    const { dir, size = 32 } = options;
    if (size === 0)
        return bytes;
    if (bytes.length > size)
        throw new Bytes.SizeExceedsPaddingSizeError({
            size: bytes.length,
            targetSize: size,
            type: 'Bytes',
        });
    const paddedBytes = new Uint8Array(size);
    for (let i = 0; i < size; i++) {
        const padEnd = dir === 'right';
        paddedBytes[padEnd ? i : size - i - 1] =
            bytes[padEnd ? i : bytes.length - i - 1];
    }
    return paddedBytes;
}
function trim(value, options = {}) {
    const { dir = 'left' } = options;
    let data = value;
    let sliceLength = 0;
    for (let i = 0; i < data.length - 1; i++) {
        if (data[dir === 'left' ? i : data.length - i - 1].toString() === '0')
            sliceLength++;
        else
            break;
    }
    data =
        dir === 'left'
            ? data.slice(sliceLength)
            : data.slice(0, data.length - sliceLength);
    return data;
}
//# sourceMappingURL=bytes.js.map

/***/ }),

/***/ "./node_modules/ox/_cjs/core/internal/cursor.js":
/*!******************************************************!*\
  !*** ./node_modules/ox/_cjs/core/internal/cursor.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RecursiveReadLimitExceededError = exports.PositionOutOfBoundsError = exports.NegativeOffsetError = void 0;
exports.create = create;
const Errors = __webpack_require__(/*! ../Errors.js */ "./node_modules/ox/_cjs/core/Errors.js");
const staticCursor = {
    bytes: new Uint8Array(),
    dataView: new DataView(new ArrayBuffer(0)),
    position: 0,
    positionReadCount: new Map(),
    recursiveReadCount: 0,
    recursiveReadLimit: Number.POSITIVE_INFINITY,
    assertReadLimit() {
        if (this.recursiveReadCount >= this.recursiveReadLimit)
            throw new RecursiveReadLimitExceededError({
                count: this.recursiveReadCount + 1,
                limit: this.recursiveReadLimit,
            });
    },
    assertPosition(position) {
        if (position < 0 || position > this.bytes.length - 1)
            throw new PositionOutOfBoundsError({
                length: this.bytes.length,
                position,
            });
    },
    decrementPosition(offset) {
        if (offset < 0)
            throw new NegativeOffsetError({ offset });
        const position = this.position - offset;
        this.assertPosition(position);
        this.position = position;
    },
    getReadCount(position) {
        return this.positionReadCount.get(position || this.position) || 0;
    },
    incrementPosition(offset) {
        if (offset < 0)
            throw new NegativeOffsetError({ offset });
        const position = this.position + offset;
        this.assertPosition(position);
        this.position = position;
    },
    inspectByte(position_) {
        const position = position_ ?? this.position;
        this.assertPosition(position);
        return this.bytes[position];
    },
    inspectBytes(length, position_) {
        const position = position_ ?? this.position;
        this.assertPosition(position + length - 1);
        return this.bytes.subarray(position, position + length);
    },
    inspectUint8(position_) {
        const position = position_ ?? this.position;
        this.assertPosition(position);
        return this.bytes[position];
    },
    inspectUint16(position_) {
        const position = position_ ?? this.position;
        this.assertPosition(position + 1);
        return this.dataView.getUint16(position);
    },
    inspectUint24(position_) {
        const position = position_ ?? this.position;
        this.assertPosition(position + 2);
        return ((this.dataView.getUint16(position) << 8) +
            this.dataView.getUint8(position + 2));
    },
    inspectUint32(position_) {
        const position = position_ ?? this.position;
        this.assertPosition(position + 3);
        return this.dataView.getUint32(position);
    },
    pushByte(byte) {
        this.assertPosition(this.position);
        this.bytes[this.position] = byte;
        this.position++;
    },
    pushBytes(bytes) {
        this.assertPosition(this.position + bytes.length - 1);
        this.bytes.set(bytes, this.position);
        this.position += bytes.length;
    },
    pushUint8(value) {
        this.assertPosition(this.position);
        this.bytes[this.position] = value;
        this.position++;
    },
    pushUint16(value) {
        this.assertPosition(this.position + 1);
        this.dataView.setUint16(this.position, value);
        this.position += 2;
    },
    pushUint24(value) {
        this.assertPosition(this.position + 2);
        this.dataView.setUint16(this.position, value >> 8);
        this.dataView.setUint8(this.position + 2, value & ~4294967040);
        this.position += 3;
    },
    pushUint32(value) {
        this.assertPosition(this.position + 3);
        this.dataView.setUint32(this.position, value);
        this.position += 4;
    },
    readByte() {
        this.assertReadLimit();
        this._touch();
        const value = this.inspectByte();
        this.position++;
        return value;
    },
    readBytes(length, size) {
        this.assertReadLimit();
        this._touch();
        const value = this.inspectBytes(length);
        this.position += size ?? length;
        return value;
    },
    readUint8() {
        this.assertReadLimit();
        this._touch();
        const value = this.inspectUint8();
        this.position += 1;
        return value;
    },
    readUint16() {
        this.assertReadLimit();
        this._touch();
        const value = this.inspectUint16();
        this.position += 2;
        return value;
    },
    readUint24() {
        this.assertReadLimit();
        this._touch();
        const value = this.inspectUint24();
        this.position += 3;
        return value;
    },
    readUint32() {
        this.assertReadLimit();
        this._touch();
        const value = this.inspectUint32();
        this.position += 4;
        return value;
    },
    get remaining() {
        return this.bytes.length - this.position;
    },
    setPosition(position) {
        const oldPosition = this.position;
        this.assertPosition(position);
        this.position = position;
        return () => (this.position = oldPosition);
    },
    _touch() {
        if (this.recursiveReadLimit === Number.POSITIVE_INFINITY)
            return;
        const count = this.getReadCount();
        this.positionReadCount.set(this.position, count + 1);
        if (count > 0)
            this.recursiveReadCount++;
    },
};
function create(bytes, { recursiveReadLimit = 8_192 } = {}) {
    const cursor = Object.create(staticCursor);
    cursor.bytes = bytes;
    cursor.dataView = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);
    cursor.positionReadCount = new Map();
    cursor.recursiveReadLimit = recursiveReadLimit;
    return cursor;
}
class NegativeOffsetError extends Errors.BaseError {
    constructor({ offset }) {
        super(`Offset \`${offset}\` cannot be negative.`);
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'Cursor.NegativeOffsetError'
        });
    }
}
exports.NegativeOffsetError = NegativeOffsetError;
class PositionOutOfBoundsError extends Errors.BaseError {
    constructor({ length, position }) {
        super(`Position \`${position}\` is out of bounds (\`0 < position < ${length}\`).`);
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'Cursor.PositionOutOfBoundsError'
        });
    }
}
exports.PositionOutOfBoundsError = PositionOutOfBoundsError;
class RecursiveReadLimitExceededError extends Errors.BaseError {
    constructor({ count, limit }) {
        super(`Recursive read limit of \`${limit}\` exceeded (recursive read count: \`${count}\`).`);
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'Cursor.RecursiveReadLimitExceededError'
        });
    }
}
exports.RecursiveReadLimitExceededError = RecursiveReadLimitExceededError;
//# sourceMappingURL=cursor.js.map

/***/ }),

/***/ "./node_modules/ox/_cjs/core/internal/errors.js":
/*!******************************************************!*\
  !*** ./node_modules/ox/_cjs/core/internal/errors.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getUrl = getUrl;
exports.getVersion = getVersion;
exports.prettyPrint = prettyPrint;
const version_js_1 = __webpack_require__(/*! ../version.js */ "./node_modules/ox/_cjs/core/version.js");
function getUrl(url) {
    return url;
}
function getVersion() {
    return version_js_1.version;
}
function prettyPrint(args) {
    if (!args)
        return '';
    const entries = Object.entries(args)
        .map(([key, value]) => {
        if (value === undefined || value === false)
            return null;
        return [key, value];
    })
        .filter(Boolean);
    const maxLength = entries.reduce((acc, [key]) => Math.max(acc, key.length), 0);
    return entries
        .map(([key, value]) => `  ${`${key}:`.padEnd(maxLength + 1)}  ${value}`)
        .join('\n');
}
//# sourceMappingURL=errors.js.map

/***/ }),

/***/ "./node_modules/ox/_cjs/core/internal/hex.js":
/*!***************************************************!*\
  !*** ./node_modules/ox/_cjs/core/internal/hex.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.assertSize = assertSize;
exports.assertStartOffset = assertStartOffset;
exports.assertEndOffset = assertEndOffset;
exports.pad = pad;
exports.trim = trim;
const Hex = __webpack_require__(/*! ../Hex.js */ "./node_modules/ox/_cjs/core/Hex.js");
function assertSize(hex, size_) {
    if (Hex.size(hex) > size_)
        throw new Hex.SizeOverflowError({
            givenSize: Hex.size(hex),
            maxSize: size_,
        });
}
function assertStartOffset(value, start) {
    if (typeof start === 'number' && start > 0 && start > Hex.size(value) - 1)
        throw new Hex.SliceOffsetOutOfBoundsError({
            offset: start,
            position: 'start',
            size: Hex.size(value),
        });
}
function assertEndOffset(value, start, end) {
    if (typeof start === 'number' &&
        typeof end === 'number' &&
        Hex.size(value) !== end - start) {
        throw new Hex.SliceOffsetOutOfBoundsError({
            offset: end,
            position: 'end',
            size: Hex.size(value),
        });
    }
}
function pad(hex_, options = {}) {
    const { dir, size = 32 } = options;
    if (size === 0)
        return hex_;
    const hex = hex_.replace('0x', '');
    if (hex.length > size * 2)
        throw new Hex.SizeExceedsPaddingSizeError({
            size: Math.ceil(hex.length / 2),
            targetSize: size,
            type: 'Hex',
        });
    return `0x${hex[dir === 'right' ? 'padEnd' : 'padStart'](size * 2, '0')}`;
}
function trim(value, options = {}) {
    const { dir = 'left' } = options;
    let data = value.replace('0x', '');
    let sliceLength = 0;
    for (let i = 0; i < data.length - 1; i++) {
        if (data[dir === 'left' ? i : data.length - i - 1].toString() === '0')
            sliceLength++;
        else
            break;
    }
    data =
        dir === 'left'
            ? data.slice(sliceLength)
            : data.slice(0, data.length - sliceLength);
    if (data === '0')
        return '0x';
    if (dir === 'right' && data.length % 2 === 1)
        return `0x${data}0`;
    return `0x${data}`;
}
//# sourceMappingURL=hex.js.map

/***/ }),

/***/ "./node_modules/ox/_cjs/core/internal/lru.js":
/*!***************************************************!*\
  !*** ./node_modules/ox/_cjs/core/internal/lru.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LruMap = void 0;
class LruMap extends Map {
    constructor(size) {
        super();
        Object.defineProperty(this, "maxSize", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.maxSize = size;
    }
    get(key) {
        const value = super.get(key);
        if (super.has(key) && value !== undefined) {
            this.delete(key);
            super.set(key, value);
        }
        return value;
    }
    set(key, value) {
        super.set(key, value);
        if (this.maxSize && this.size > this.maxSize) {
            const firstKey = this.keys().next().value;
            if (firstKey)
                this.delete(firstKey);
        }
        return this;
    }
}
exports.LruMap = LruMap;
//# sourceMappingURL=lru.js.map

/***/ }),

/***/ "./node_modules/ox/_cjs/core/version.js":
/*!**********************************************!*\
  !*** ./node_modules/ox/_cjs/core/version.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.version = void 0;
exports.version = '0.1.1';
//# sourceMappingURL=version.js.map

/***/ }),

/***/ "./node_modules/ox/node_modules/@noble/curves/abstract/utils.js":
/*!**********************************************************************!*\
  !*** ./node_modules/ox/node_modules/@noble/curves/abstract/utils.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isHash = exports.validateObject = exports.memoized = exports.notImplemented = exports.createHmacDrbg = exports.bitMask = exports.bitSet = exports.bitGet = exports.bitLen = exports.aInRange = exports.inRange = exports.asciiToBytes = exports.copyBytes = exports.equalBytes = exports.ensureBytes = exports.numberToVarBytesBE = exports.numberToBytesLE = exports.numberToBytesBE = exports.bytesToNumberLE = exports.bytesToNumberBE = exports.hexToNumber = exports.numberToHexUnpadded = exports.abool = exports.utf8ToBytes = exports.randomBytes = exports.isBytes = exports.hexToBytes = exports.concatBytes = exports.bytesToUtf8 = exports.bytesToHex = exports.anumber = exports.abytes = void 0;
/**
 * Deprecated module: moved from curves/abstract/utils.js to curves/utils.js
 * @module
 */
const u = __webpack_require__(/*! ../utils.js */ "./node_modules/ox/node_modules/@noble/curves/utils.js");
/** @deprecated moved to `@noble/curves/utils.js` */
exports.abytes = u.abytes;
/** @deprecated moved to `@noble/curves/utils.js` */
exports.anumber = u.anumber;
/** @deprecated moved to `@noble/curves/utils.js` */
exports.bytesToHex = u.bytesToHex;
/** @deprecated moved to `@noble/curves/utils.js` */
exports.bytesToUtf8 = u.bytesToUtf8;
/** @deprecated moved to `@noble/curves/utils.js` */
exports.concatBytes = u.concatBytes;
/** @deprecated moved to `@noble/curves/utils.js` */
exports.hexToBytes = u.hexToBytes;
/** @deprecated moved to `@noble/curves/utils.js` */
exports.isBytes = u.isBytes;
/** @deprecated moved to `@noble/curves/utils.js` */
exports.randomBytes = u.randomBytes;
/** @deprecated moved to `@noble/curves/utils.js` */
exports.utf8ToBytes = u.utf8ToBytes;
/** @deprecated moved to `@noble/curves/utils.js` */
exports.abool = u.abool;
/** @deprecated moved to `@noble/curves/utils.js` */
exports.numberToHexUnpadded = u.numberToHexUnpadded;
/** @deprecated moved to `@noble/curves/utils.js` */
exports.hexToNumber = u.hexToNumber;
/** @deprecated moved to `@noble/curves/utils.js` */
exports.bytesToNumberBE = u.bytesToNumberBE;
/** @deprecated moved to `@noble/curves/utils.js` */
exports.bytesToNumberLE = u.bytesToNumberLE;
/** @deprecated moved to `@noble/curves/utils.js` */
exports.numberToBytesBE = u.numberToBytesBE;
/** @deprecated moved to `@noble/curves/utils.js` */
exports.numberToBytesLE = u.numberToBytesLE;
/** @deprecated moved to `@noble/curves/utils.js` */
exports.numberToVarBytesBE = u.numberToVarBytesBE;
/** @deprecated moved to `@noble/curves/utils.js` */
exports.ensureBytes = u.ensureBytes;
/** @deprecated moved to `@noble/curves/utils.js` */
exports.equalBytes = u.equalBytes;
/** @deprecated moved to `@noble/curves/utils.js` */
exports.copyBytes = u.copyBytes;
/** @deprecated moved to `@noble/curves/utils.js` */
exports.asciiToBytes = u.asciiToBytes;
/** @deprecated moved to `@noble/curves/utils.js` */
exports.inRange = u.inRange;
/** @deprecated moved to `@noble/curves/utils.js` */
exports.aInRange = u.aInRange;
/** @deprecated moved to `@noble/curves/utils.js` */
exports.bitLen = u.bitLen;
/** @deprecated moved to `@noble/curves/utils.js` */
exports.bitGet = u.bitGet;
/** @deprecated moved to `@noble/curves/utils.js` */
exports.bitSet = u.bitSet;
/** @deprecated moved to `@noble/curves/utils.js` */
exports.bitMask = u.bitMask;
/** @deprecated moved to `@noble/curves/utils.js` */
exports.createHmacDrbg = u.createHmacDrbg;
/** @deprecated moved to `@noble/curves/utils.js` */
exports.notImplemented = u.notImplemented;
/** @deprecated moved to `@noble/curves/utils.js` */
exports.memoized = u.memoized;
/** @deprecated moved to `@noble/curves/utils.js` */
exports.validateObject = u.validateObject;
/** @deprecated moved to `@noble/curves/utils.js` */
exports.isHash = u.isHash;
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ "./node_modules/ox/node_modules/@noble/curves/utils.js":
/*!*************************************************************!*\
  !*** ./node_modules/ox/node_modules/@noble/curves/utils.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.notImplemented = exports.bitMask = exports.utf8ToBytes = exports.randomBytes = exports.isBytes = exports.hexToBytes = exports.concatBytes = exports.bytesToUtf8 = exports.bytesToHex = exports.anumber = exports.abytes = void 0;
exports.abool = abool;
exports._abool2 = _abool2;
exports._abytes2 = _abytes2;
exports.numberToHexUnpadded = numberToHexUnpadded;
exports.hexToNumber = hexToNumber;
exports.bytesToNumberBE = bytesToNumberBE;
exports.bytesToNumberLE = bytesToNumberLE;
exports.numberToBytesBE = numberToBytesBE;
exports.numberToBytesLE = numberToBytesLE;
exports.numberToVarBytesBE = numberToVarBytesBE;
exports.ensureBytes = ensureBytes;
exports.equalBytes = equalBytes;
exports.copyBytes = copyBytes;
exports.asciiToBytes = asciiToBytes;
exports.inRange = inRange;
exports.aInRange = aInRange;
exports.bitLen = bitLen;
exports.bitGet = bitGet;
exports.bitSet = bitSet;
exports.createHmacDrbg = createHmacDrbg;
exports.validateObject = validateObject;
exports.isHash = isHash;
exports._validateObject = _validateObject;
exports.memoized = memoized;
/**
 * Hex, bytes and number utilities.
 * @module
 */
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const utils_js_1 = __webpack_require__(/*! @noble/hashes/utils.js */ "./node_modules/@noble/hashes/utils.js");
var utils_js_2 = __webpack_require__(/*! @noble/hashes/utils.js */ "./node_modules/@noble/hashes/utils.js");
Object.defineProperty(exports, "abytes", ({ enumerable: true, get: function () { return utils_js_2.abytes; } }));
Object.defineProperty(exports, "anumber", ({ enumerable: true, get: function () { return utils_js_2.anumber; } }));
Object.defineProperty(exports, "bytesToHex", ({ enumerable: true, get: function () { return utils_js_2.bytesToHex; } }));
Object.defineProperty(exports, "bytesToUtf8", ({ enumerable: true, get: function () { return utils_js_2.bytesToUtf8; } }));
Object.defineProperty(exports, "concatBytes", ({ enumerable: true, get: function () { return utils_js_2.concatBytes; } }));
Object.defineProperty(exports, "hexToBytes", ({ enumerable: true, get: function () { return utils_js_2.hexToBytes; } }));
Object.defineProperty(exports, "isBytes", ({ enumerable: true, get: function () { return utils_js_2.isBytes; } }));
Object.defineProperty(exports, "randomBytes", ({ enumerable: true, get: function () { return utils_js_2.randomBytes; } }));
Object.defineProperty(exports, "utf8ToBytes", ({ enumerable: true, get: function () { return utils_js_2.utf8ToBytes; } }));
const _0n = /* @__PURE__ */ BigInt(0);
const _1n = /* @__PURE__ */ BigInt(1);
function abool(title, value) {
    if (typeof value !== 'boolean')
        throw new Error(title + ' boolean expected, got ' + value);
}
// tmp name until v2
function _abool2(value, title = '') {
    if (typeof value !== 'boolean') {
        const prefix = title && `"${title}"`;
        throw new Error(prefix + 'expected boolean, got type=' + typeof value);
    }
    return value;
}
// tmp name until v2
/** Asserts something is Uint8Array. */
function _abytes2(value, length, title = '') {
    const bytes = (0, utils_js_1.isBytes)(value);
    const len = value?.length;
    const needsLen = length !== undefined;
    if (!bytes || (needsLen && len !== length)) {
        const prefix = title && `"${title}" `;
        const ofLen = needsLen ? ` of length ${length}` : '';
        const got = bytes ? `length=${len}` : `type=${typeof value}`;
        throw new Error(prefix + 'expected Uint8Array' + ofLen + ', got ' + got);
    }
    return value;
}
// Used in weierstrass, der
function numberToHexUnpadded(num) {
    const hex = num.toString(16);
    return hex.length & 1 ? '0' + hex : hex;
}
function hexToNumber(hex) {
    if (typeof hex !== 'string')
        throw new Error('hex string expected, got ' + typeof hex);
    return hex === '' ? _0n : BigInt('0x' + hex); // Big Endian
}
// BE: Big Endian, LE: Little Endian
function bytesToNumberBE(bytes) {
    return hexToNumber((0, utils_js_1.bytesToHex)(bytes));
}
function bytesToNumberLE(bytes) {
    (0, utils_js_1.abytes)(bytes);
    return hexToNumber((0, utils_js_1.bytesToHex)(Uint8Array.from(bytes).reverse()));
}
function numberToBytesBE(n, len) {
    return (0, utils_js_1.hexToBytes)(n.toString(16).padStart(len * 2, '0'));
}
function numberToBytesLE(n, len) {
    return numberToBytesBE(n, len).reverse();
}
// Unpadded, rarely used
function numberToVarBytesBE(n) {
    return (0, utils_js_1.hexToBytes)(numberToHexUnpadded(n));
}
/**
 * Takes hex string or Uint8Array, converts to Uint8Array.
 * Validates output length.
 * Will throw error for other types.
 * @param title descriptive title for an error e.g. 'secret key'
 * @param hex hex string or Uint8Array
 * @param expectedLength optional, will compare to result array's length
 * @returns
 */
function ensureBytes(title, hex, expectedLength) {
    let res;
    if (typeof hex === 'string') {
        try {
            res = (0, utils_js_1.hexToBytes)(hex);
        }
        catch (e) {
            throw new Error(title + ' must be hex string or Uint8Array, cause: ' + e);
        }
    }
    else if ((0, utils_js_1.isBytes)(hex)) {
        // Uint8Array.from() instead of hash.slice() because node.js Buffer
        // is instance of Uint8Array, and its slice() creates **mutable** copy
        res = Uint8Array.from(hex);
    }
    else {
        throw new Error(title + ' must be hex string or Uint8Array');
    }
    const len = res.length;
    if (typeof expectedLength === 'number' && len !== expectedLength)
        throw new Error(title + ' of length ' + expectedLength + ' expected, got ' + len);
    return res;
}
// Compares 2 u8a-s in kinda constant time
function equalBytes(a, b) {
    if (a.length !== b.length)
        return false;
    let diff = 0;
    for (let i = 0; i < a.length; i++)
        diff |= a[i] ^ b[i];
    return diff === 0;
}
/**
 * Copies Uint8Array. We can't use u8a.slice(), because u8a can be Buffer,
 * and Buffer#slice creates mutable copy. Never use Buffers!
 */
function copyBytes(bytes) {
    return Uint8Array.from(bytes);
}
/**
 * Decodes 7-bit ASCII string to Uint8Array, throws on non-ascii symbols
 * Should be safe to use for things expected to be ASCII.
 * Returns exact same result as utf8ToBytes for ASCII or throws.
 */
function asciiToBytes(ascii) {
    return Uint8Array.from(ascii, (c, i) => {
        const charCode = c.charCodeAt(0);
        if (c.length !== 1 || charCode > 127) {
            throw new Error(`string contains non-ASCII character "${ascii[i]}" with code ${charCode} at position ${i}`);
        }
        return charCode;
    });
}
/**
 * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])
 */
// export const utf8ToBytes: typeof utf8ToBytes_ = utf8ToBytes_;
/**
 * Converts bytes to string using UTF8 encoding.
 * @example bytesToUtf8(Uint8Array.from([97, 98, 99])) // 'abc'
 */
// export const bytesToUtf8: typeof bytesToUtf8_ = bytesToUtf8_;
// Is positive bigint
const isPosBig = (n) => typeof n === 'bigint' && _0n <= n;
function inRange(n, min, max) {
    return isPosBig(n) && isPosBig(min) && isPosBig(max) && min <= n && n < max;
}
/**
 * Asserts min <= n < max. NOTE: It's < max and not <= max.
 * @example
 * aInRange('x', x, 1n, 256n); // would assume x is in (1n..255n)
 */
function aInRange(title, n, min, max) {
    // Why min <= n < max and not a (min < n < max) OR b (min <= n <= max)?
    // consider P=256n, min=0n, max=P
    // - a for min=0 would require -1:          `inRange('x', x, -1n, P)`
    // - b would commonly require subtraction:  `inRange('x', x, 0n, P - 1n)`
    // - our way is the cleanest:               `inRange('x', x, 0n, P)
    if (!inRange(n, min, max))
        throw new Error('expected valid ' + title + ': ' + min + ' <= n < ' + max + ', got ' + n);
}
// Bit operations
/**
 * Calculates amount of bits in a bigint.
 * Same as `n.toString(2).length`
 * TODO: merge with nLength in modular
 */
function bitLen(n) {
    let len;
    for (len = 0; n > _0n; n >>= _1n, len += 1)
        ;
    return len;
}
/**
 * Gets single bit at position.
 * NOTE: first bit position is 0 (same as arrays)
 * Same as `!!+Array.from(n.toString(2)).reverse()[pos]`
 */
function bitGet(n, pos) {
    return (n >> BigInt(pos)) & _1n;
}
/**
 * Sets single bit at position.
 */
function bitSet(n, pos, value) {
    return n | ((value ? _1n : _0n) << BigInt(pos));
}
/**
 * Calculate mask for N bits. Not using ** operator with bigints because of old engines.
 * Same as BigInt(`0b${Array(i).fill('1').join('')}`)
 */
const bitMask = (n) => (_1n << BigInt(n)) - _1n;
exports.bitMask = bitMask;
/**
 * Minimal HMAC-DRBG from NIST 800-90 for RFC6979 sigs.
 * @returns function that will call DRBG until 2nd arg returns something meaningful
 * @example
 *   const drbg = createHmacDRBG<Key>(32, 32, hmac);
 *   drbg(seed, bytesToKey); // bytesToKey must return Key or undefined
 */
function createHmacDrbg(hashLen, qByteLen, hmacFn) {
    if (typeof hashLen !== 'number' || hashLen < 2)
        throw new Error('hashLen must be a number');
    if (typeof qByteLen !== 'number' || qByteLen < 2)
        throw new Error('qByteLen must be a number');
    if (typeof hmacFn !== 'function')
        throw new Error('hmacFn must be a function');
    // Step B, Step C: set hashLen to 8*ceil(hlen/8)
    const u8n = (len) => new Uint8Array(len); // creates Uint8Array
    const u8of = (byte) => Uint8Array.of(byte); // another shortcut
    let v = u8n(hashLen); // Minimal non-full-spec HMAC-DRBG from NIST 800-90 for RFC6979 sigs.
    let k = u8n(hashLen); // Steps B and C of RFC6979 3.2: set hashLen, in our case always same
    let i = 0; // Iterations counter, will throw when over 1000
    const reset = () => {
        v.fill(1);
        k.fill(0);
        i = 0;
    };
    const h = (...b) => hmacFn(k, v, ...b); // hmac(k)(v, ...values)
    const reseed = (seed = u8n(0)) => {
        // HMAC-DRBG reseed() function. Steps D-G
        k = h(u8of(0x00), seed); // k = hmac(k || v || 0x00 || seed)
        v = h(); // v = hmac(k || v)
        if (seed.length === 0)
            return;
        k = h(u8of(0x01), seed); // k = hmac(k || v || 0x01 || seed)
        v = h(); // v = hmac(k || v)
    };
    const gen = () => {
        // HMAC-DRBG generate() function
        if (i++ >= 1000)
            throw new Error('drbg: tried 1000 values');
        let len = 0;
        const out = [];
        while (len < qByteLen) {
            v = h();
            const sl = v.slice();
            out.push(sl);
            len += v.length;
        }
        return (0, utils_js_1.concatBytes)(...out);
    };
    const genUntil = (seed, pred) => {
        reset();
        reseed(seed); // Steps D-G
        let res = undefined; // Step H: grind until k is in [1..n-1]
        while (!(res = pred(gen())))
            reseed();
        reset();
        return res;
    };
    return genUntil;
}
// Validating curves and fields
const validatorFns = {
    bigint: (val) => typeof val === 'bigint',
    function: (val) => typeof val === 'function',
    boolean: (val) => typeof val === 'boolean',
    string: (val) => typeof val === 'string',
    stringOrUint8Array: (val) => typeof val === 'string' || (0, utils_js_1.isBytes)(val),
    isSafeInteger: (val) => Number.isSafeInteger(val),
    array: (val) => Array.isArray(val),
    field: (val, object) => object.Fp.isValid(val),
    hash: (val) => typeof val === 'function' && Number.isSafeInteger(val.outputLen),
};
// type Record<K extends string | number | symbol, T> = { [P in K]: T; }
function validateObject(object, validators, optValidators = {}) {
    const checkField = (fieldName, type, isOptional) => {
        const checkVal = validatorFns[type];
        if (typeof checkVal !== 'function')
            throw new Error('invalid validator function');
        const val = object[fieldName];
        if (isOptional && val === undefined)
            return;
        if (!checkVal(val, object)) {
            throw new Error('param ' + String(fieldName) + ' is invalid. Expected ' + type + ', got ' + val);
        }
    };
    for (const [fieldName, type] of Object.entries(validators))
        checkField(fieldName, type, false);
    for (const [fieldName, type] of Object.entries(optValidators))
        checkField(fieldName, type, true);
    return object;
}
// validate type tests
// const o: { a: number; b: number; c: number } = { a: 1, b: 5, c: 6 };
// const z0 = validateObject(o, { a: 'isSafeInteger' }, { c: 'bigint' }); // Ok!
// // Should fail type-check
// const z1 = validateObject(o, { a: 'tmp' }, { c: 'zz' });
// const z2 = validateObject(o, { a: 'isSafeInteger' }, { c: 'zz' });
// const z3 = validateObject(o, { test: 'boolean', z: 'bug' });
// const z4 = validateObject(o, { a: 'boolean', z: 'bug' });
function isHash(val) {
    return typeof val === 'function' && Number.isSafeInteger(val.outputLen);
}
function _validateObject(object, fields, optFields = {}) {
    if (!object || typeof object !== 'object')
        throw new Error('expected valid options object');
    function checkField(fieldName, expectedType, isOpt) {
        const val = object[fieldName];
        if (isOpt && val === undefined)
            return;
        const current = typeof val;
        if (current !== expectedType || val === null)
            throw new Error(`param "${fieldName}" is invalid: expected ${expectedType}, got ${current}`);
    }
    Object.entries(fields).forEach(([k, v]) => checkField(k, v, false));
    Object.entries(optFields).forEach(([k, v]) => checkField(k, v, true));
}
/**
 * throws not implemented error
 */
const notImplemented = () => {
    throw new Error('not implemented');
};
exports.notImplemented = notImplemented;
/**
 * Memoizes (caches) computation result.
 * Uses WeakMap: the value is going auto-cleaned by GC after last reference is removed.
 */
function memoized(fn) {
    const map = new WeakMap();
    return (arg, ...args) => {
        const val = map.get(arg);
        if (val !== undefined)
            return val;
        const computed = fn(arg, ...args);
        map.set(arg, computed);
        return computed;
    };
}
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/accounts/utils/parseAccount.js":
/*!***************************************************************!*\
  !*** ./node_modules/viem/_cjs/accounts/utils/parseAccount.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.parseAccount = parseAccount;
function parseAccount(account) {
    if (typeof account === 'string')
        return { address: account, type: 'json-rpc' };
    return account;
}
//# sourceMappingURL=parseAccount.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/accounts/utils/publicKeyToAddress.js":
/*!*********************************************************************!*\
  !*** ./node_modules/viem/_cjs/accounts/utils/publicKeyToAddress.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.publicKeyToAddress = publicKeyToAddress;
const getAddress_js_1 = __webpack_require__(/*! ../../utils/address/getAddress.js */ "./node_modules/viem/_cjs/utils/address/getAddress.js");
const keccak256_js_1 = __webpack_require__(/*! ../../utils/hash/keccak256.js */ "./node_modules/viem/_cjs/utils/hash/keccak256.js");
function publicKeyToAddress(publicKey) {
    const address = (0, keccak256_js_1.keccak256)(`0x${publicKey.substring(4)}`).substring(26);
    return (0, getAddress_js_1.checksumAddress)(`0x${address}`);
}
//# sourceMappingURL=publicKeyToAddress.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/actions/ens/getEnsAddress.js":
/*!*************************************************************!*\
  !*** ./node_modules/viem/_cjs/actions/ens/getEnsAddress.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getEnsAddress = getEnsAddress;
const abis_js_1 = __webpack_require__(/*! ../../constants/abis.js */ "./node_modules/viem/_cjs/constants/abis.js");
const decodeFunctionResult_js_1 = __webpack_require__(/*! ../../utils/abi/decodeFunctionResult.js */ "./node_modules/viem/_cjs/utils/abi/decodeFunctionResult.js");
const encodeFunctionData_js_1 = __webpack_require__(/*! ../../utils/abi/encodeFunctionData.js */ "./node_modules/viem/_cjs/utils/abi/encodeFunctionData.js");
const getChainContractAddress_js_1 = __webpack_require__(/*! ../../utils/chain/getChainContractAddress.js */ "./node_modules/viem/_cjs/utils/chain/getChainContractAddress.js");
const trim_js_1 = __webpack_require__(/*! ../../utils/data/trim.js */ "./node_modules/viem/_cjs/utils/data/trim.js");
const toHex_js_1 = __webpack_require__(/*! ../../utils/encoding/toHex.js */ "./node_modules/viem/_cjs/utils/encoding/toHex.js");
const errors_js_1 = __webpack_require__(/*! ../../utils/ens/errors.js */ "./node_modules/viem/_cjs/utils/ens/errors.js");
const localBatchGatewayRequest_js_1 = __webpack_require__(/*! ../../utils/ens/localBatchGatewayRequest.js */ "./node_modules/viem/_cjs/utils/ens/localBatchGatewayRequest.js");
const namehash_js_1 = __webpack_require__(/*! ../../utils/ens/namehash.js */ "./node_modules/viem/_cjs/utils/ens/namehash.js");
const packetToBytes_js_1 = __webpack_require__(/*! ../../utils/ens/packetToBytes.js */ "./node_modules/viem/_cjs/utils/ens/packetToBytes.js");
const getAction_js_1 = __webpack_require__(/*! ../../utils/getAction.js */ "./node_modules/viem/_cjs/utils/getAction.js");
const readContract_js_1 = __webpack_require__(/*! ../public/readContract.js */ "./node_modules/viem/_cjs/actions/public/readContract.js");
async function getEnsAddress(client, parameters) {
    const { blockNumber, blockTag, coinType, name, gatewayUrls, strict } = parameters;
    const { chain } = client;
    const universalResolverAddress = (() => {
        if (parameters.universalResolverAddress)
            return parameters.universalResolverAddress;
        if (!chain)
            throw new Error('client chain not configured. universalResolverAddress is required.');
        return (0, getChainContractAddress_js_1.getChainContractAddress)({
            blockNumber,
            chain,
            contract: 'ensUniversalResolver',
        });
    })();
    const tlds = chain?.ensTlds;
    if (tlds && !tlds.some((tld) => name.endsWith(tld)))
        return null;
    const args = (() => {
        if (coinType != null)
            return [(0, namehash_js_1.namehash)(name), BigInt(coinType)];
        return [(0, namehash_js_1.namehash)(name)];
    })();
    try {
        const functionData = (0, encodeFunctionData_js_1.encodeFunctionData)({
            abi: abis_js_1.addressResolverAbi,
            functionName: 'addr',
            args,
        });
        const readContractParameters = {
            address: universalResolverAddress,
            abi: abis_js_1.universalResolverResolveAbi,
            functionName: 'resolveWithGateways',
            args: [
                (0, toHex_js_1.toHex)((0, packetToBytes_js_1.packetToBytes)(name)),
                functionData,
                gatewayUrls ?? [localBatchGatewayRequest_js_1.localBatchGatewayUrl],
            ],
            blockNumber,
            blockTag,
        };
        const readContractAction = (0, getAction_js_1.getAction)(client, readContract_js_1.readContract, 'readContract');
        const res = await readContractAction(readContractParameters);
        if (res[0] === '0x')
            return null;
        const address = (0, decodeFunctionResult_js_1.decodeFunctionResult)({
            abi: abis_js_1.addressResolverAbi,
            args,
            functionName: 'addr',
            data: res[0],
        });
        if (address === '0x')
            return null;
        if ((0, trim_js_1.trim)(address) === '0x00')
            return null;
        return address;
    }
    catch (err) {
        if (strict)
            throw err;
        if ((0, errors_js_1.isNullUniversalResolverError)(err))
            return null;
        throw err;
    }
}
//# sourceMappingURL=getEnsAddress.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/actions/ens/getEnsAvatar.js":
/*!************************************************************!*\
  !*** ./node_modules/viem/_cjs/actions/ens/getEnsAvatar.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getEnsAvatar = getEnsAvatar;
const parseAvatarRecord_js_1 = __webpack_require__(/*! ../../utils/ens/avatar/parseAvatarRecord.js */ "./node_modules/viem/_cjs/utils/ens/avatar/parseAvatarRecord.js");
const getAction_js_1 = __webpack_require__(/*! ../../utils/getAction.js */ "./node_modules/viem/_cjs/utils/getAction.js");
const getEnsText_js_1 = __webpack_require__(/*! ./getEnsText.js */ "./node_modules/viem/_cjs/actions/ens/getEnsText.js");
async function getEnsAvatar(client, { blockNumber, blockTag, assetGatewayUrls, name, gatewayUrls, strict, universalResolverAddress, }) {
    const record = await (0, getAction_js_1.getAction)(client, getEnsText_js_1.getEnsText, 'getEnsText')({
        blockNumber,
        blockTag,
        key: 'avatar',
        name,
        universalResolverAddress,
        gatewayUrls,
        strict,
    });
    if (!record)
        return null;
    try {
        return await (0, parseAvatarRecord_js_1.parseAvatarRecord)(client, {
            record,
            gatewayUrls: assetGatewayUrls,
        });
    }
    catch {
        return null;
    }
}
//# sourceMappingURL=getEnsAvatar.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/actions/ens/getEnsName.js":
/*!**********************************************************!*\
  !*** ./node_modules/viem/_cjs/actions/ens/getEnsName.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getEnsName = getEnsName;
const abis_js_1 = __webpack_require__(/*! ../../constants/abis.js */ "./node_modules/viem/_cjs/constants/abis.js");
const getChainContractAddress_js_1 = __webpack_require__(/*! ../../utils/chain/getChainContractAddress.js */ "./node_modules/viem/_cjs/utils/chain/getChainContractAddress.js");
const errors_js_1 = __webpack_require__(/*! ../../utils/ens/errors.js */ "./node_modules/viem/_cjs/utils/ens/errors.js");
const localBatchGatewayRequest_js_1 = __webpack_require__(/*! ../../utils/ens/localBatchGatewayRequest.js */ "./node_modules/viem/_cjs/utils/ens/localBatchGatewayRequest.js");
const getAction_js_1 = __webpack_require__(/*! ../../utils/getAction.js */ "./node_modules/viem/_cjs/utils/getAction.js");
const readContract_js_1 = __webpack_require__(/*! ../public/readContract.js */ "./node_modules/viem/_cjs/actions/public/readContract.js");
async function getEnsName(client, parameters) {
    const { address, blockNumber, blockTag, coinType = 60n, gatewayUrls, strict, } = parameters;
    const { chain } = client;
    const universalResolverAddress = (() => {
        if (parameters.universalResolverAddress)
            return parameters.universalResolverAddress;
        if (!chain)
            throw new Error('client chain not configured. universalResolverAddress is required.');
        return (0, getChainContractAddress_js_1.getChainContractAddress)({
            blockNumber,
            chain,
            contract: 'ensUniversalResolver',
        });
    })();
    try {
        const readContractParameters = {
            address: universalResolverAddress,
            abi: abis_js_1.universalResolverReverseAbi,
            args: [address, coinType, gatewayUrls ?? [localBatchGatewayRequest_js_1.localBatchGatewayUrl]],
            functionName: 'reverseWithGateways',
            blockNumber,
            blockTag,
        };
        const readContractAction = (0, getAction_js_1.getAction)(client, readContract_js_1.readContract, 'readContract');
        const [name] = await readContractAction(readContractParameters);
        return name || null;
    }
    catch (err) {
        if (strict)
            throw err;
        if ((0, errors_js_1.isNullUniversalResolverError)(err))
            return null;
        throw err;
    }
}
//# sourceMappingURL=getEnsName.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/actions/ens/getEnsResolver.js":
/*!**************************************************************!*\
  !*** ./node_modules/viem/_cjs/actions/ens/getEnsResolver.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getEnsResolver = getEnsResolver;
const getChainContractAddress_js_1 = __webpack_require__(/*! ../../utils/chain/getChainContractAddress.js */ "./node_modules/viem/_cjs/utils/chain/getChainContractAddress.js");
const toHex_js_1 = __webpack_require__(/*! ../../utils/encoding/toHex.js */ "./node_modules/viem/_cjs/utils/encoding/toHex.js");
const packetToBytes_js_1 = __webpack_require__(/*! ../../utils/ens/packetToBytes.js */ "./node_modules/viem/_cjs/utils/ens/packetToBytes.js");
const getAction_js_1 = __webpack_require__(/*! ../../utils/getAction.js */ "./node_modules/viem/_cjs/utils/getAction.js");
const readContract_js_1 = __webpack_require__(/*! ../public/readContract.js */ "./node_modules/viem/_cjs/actions/public/readContract.js");
async function getEnsResolver(client, parameters) {
    const { blockNumber, blockTag, name } = parameters;
    const { chain } = client;
    const universalResolverAddress = (() => {
        if (parameters.universalResolverAddress)
            return parameters.universalResolverAddress;
        if (!chain)
            throw new Error('client chain not configured. universalResolverAddress is required.');
        return (0, getChainContractAddress_js_1.getChainContractAddress)({
            blockNumber,
            chain,
            contract: 'ensUniversalResolver',
        });
    })();
    const tlds = chain?.ensTlds;
    if (tlds && !tlds.some((tld) => name.endsWith(tld)))
        throw new Error(`${name} is not a valid ENS TLD (${tlds?.join(', ')}) for chain "${chain.name}" (id: ${chain.id}).`);
    const [resolverAddress] = await (0, getAction_js_1.getAction)(client, readContract_js_1.readContract, 'readContract')({
        address: universalResolverAddress,
        abi: [
            {
                inputs: [{ type: 'bytes' }],
                name: 'findResolver',
                outputs: [
                    { type: 'address' },
                    { type: 'bytes32' },
                    { type: 'uint256' },
                ],
                stateMutability: 'view',
                type: 'function',
            },
        ],
        functionName: 'findResolver',
        args: [(0, toHex_js_1.toHex)((0, packetToBytes_js_1.packetToBytes)(name))],
        blockNumber,
        blockTag,
    });
    return resolverAddress;
}
//# sourceMappingURL=getEnsResolver.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/actions/ens/getEnsText.js":
/*!**********************************************************!*\
  !*** ./node_modules/viem/_cjs/actions/ens/getEnsText.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getEnsText = getEnsText;
const abis_js_1 = __webpack_require__(/*! ../../constants/abis.js */ "./node_modules/viem/_cjs/constants/abis.js");
const decodeFunctionResult_js_1 = __webpack_require__(/*! ../../utils/abi/decodeFunctionResult.js */ "./node_modules/viem/_cjs/utils/abi/decodeFunctionResult.js");
const encodeFunctionData_js_1 = __webpack_require__(/*! ../../utils/abi/encodeFunctionData.js */ "./node_modules/viem/_cjs/utils/abi/encodeFunctionData.js");
const getChainContractAddress_js_1 = __webpack_require__(/*! ../../utils/chain/getChainContractAddress.js */ "./node_modules/viem/_cjs/utils/chain/getChainContractAddress.js");
const toHex_js_1 = __webpack_require__(/*! ../../utils/encoding/toHex.js */ "./node_modules/viem/_cjs/utils/encoding/toHex.js");
const errors_js_1 = __webpack_require__(/*! ../../utils/ens/errors.js */ "./node_modules/viem/_cjs/utils/ens/errors.js");
const localBatchGatewayRequest_js_1 = __webpack_require__(/*! ../../utils/ens/localBatchGatewayRequest.js */ "./node_modules/viem/_cjs/utils/ens/localBatchGatewayRequest.js");
const namehash_js_1 = __webpack_require__(/*! ../../utils/ens/namehash.js */ "./node_modules/viem/_cjs/utils/ens/namehash.js");
const packetToBytes_js_1 = __webpack_require__(/*! ../../utils/ens/packetToBytes.js */ "./node_modules/viem/_cjs/utils/ens/packetToBytes.js");
const getAction_js_1 = __webpack_require__(/*! ../../utils/getAction.js */ "./node_modules/viem/_cjs/utils/getAction.js");
const readContract_js_1 = __webpack_require__(/*! ../public/readContract.js */ "./node_modules/viem/_cjs/actions/public/readContract.js");
async function getEnsText(client, parameters) {
    const { blockNumber, blockTag, key, name, gatewayUrls, strict } = parameters;
    const { chain } = client;
    const universalResolverAddress = (() => {
        if (parameters.universalResolverAddress)
            return parameters.universalResolverAddress;
        if (!chain)
            throw new Error('client chain not configured. universalResolverAddress is required.');
        return (0, getChainContractAddress_js_1.getChainContractAddress)({
            blockNumber,
            chain,
            contract: 'ensUniversalResolver',
        });
    })();
    const tlds = chain?.ensTlds;
    if (tlds && !tlds.some((tld) => name.endsWith(tld)))
        return null;
    try {
        const readContractParameters = {
            address: universalResolverAddress,
            abi: abis_js_1.universalResolverResolveAbi,
            args: [
                (0, toHex_js_1.toHex)((0, packetToBytes_js_1.packetToBytes)(name)),
                (0, encodeFunctionData_js_1.encodeFunctionData)({
                    abi: abis_js_1.textResolverAbi,
                    functionName: 'text',
                    args: [(0, namehash_js_1.namehash)(name), key],
                }),
                gatewayUrls ?? [localBatchGatewayRequest_js_1.localBatchGatewayUrl],
            ],
            functionName: 'resolveWithGateways',
            blockNumber,
            blockTag,
        };
        const readContractAction = (0, getAction_js_1.getAction)(client, readContract_js_1.readContract, 'readContract');
        const res = await readContractAction(readContractParameters);
        if (res[0] === '0x')
            return null;
        const record = (0, decodeFunctionResult_js_1.decodeFunctionResult)({
            abi: abis_js_1.textResolverAbi,
            functionName: 'text',
            data: res[0],
        });
        return record === '' ? null : record;
    }
    catch (err) {
        if (strict)
            throw err;
        if ((0, errors_js_1.isNullUniversalResolverError)(err))
            return null;
        throw err;
    }
}
//# sourceMappingURL=getEnsText.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/actions/getContract.js":
/*!*******************************************************!*\
  !*** ./node_modules/viem/_cjs/actions/getContract.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getContract = getContract;
exports.getFunctionParameters = getFunctionParameters;
exports.getEventParameters = getEventParameters;
const getAction_js_1 = __webpack_require__(/*! ../utils/getAction.js */ "./node_modules/viem/_cjs/utils/getAction.js");
const createContractEventFilter_js_1 = __webpack_require__(/*! ./public/createContractEventFilter.js */ "./node_modules/viem/_cjs/actions/public/createContractEventFilter.js");
const estimateContractGas_js_1 = __webpack_require__(/*! ./public/estimateContractGas.js */ "./node_modules/viem/_cjs/actions/public/estimateContractGas.js");
const getContractEvents_js_1 = __webpack_require__(/*! ./public/getContractEvents.js */ "./node_modules/viem/_cjs/actions/public/getContractEvents.js");
const readContract_js_1 = __webpack_require__(/*! ./public/readContract.js */ "./node_modules/viem/_cjs/actions/public/readContract.js");
const simulateContract_js_1 = __webpack_require__(/*! ./public/simulateContract.js */ "./node_modules/viem/_cjs/actions/public/simulateContract.js");
const watchContractEvent_js_1 = __webpack_require__(/*! ./public/watchContractEvent.js */ "./node_modules/viem/_cjs/actions/public/watchContractEvent.js");
const writeContract_js_1 = __webpack_require__(/*! ./wallet/writeContract.js */ "./node_modules/viem/_cjs/actions/wallet/writeContract.js");
function getContract({ abi, address, client: client_, }) {
    const client = client_;
    const [publicClient, walletClient] = (() => {
        if (!client)
            return [undefined, undefined];
        if ('public' in client && 'wallet' in client)
            return [client.public, client.wallet];
        if ('public' in client)
            return [client.public, undefined];
        if ('wallet' in client)
            return [undefined, client.wallet];
        return [client, client];
    })();
    const hasPublicClient = publicClient !== undefined && publicClient !== null;
    const hasWalletClient = walletClient !== undefined && walletClient !== null;
    const contract = {};
    let hasReadFunction = false;
    let hasWriteFunction = false;
    let hasEvent = false;
    for (const item of abi) {
        if (item.type === 'function')
            if (item.stateMutability === 'view' || item.stateMutability === 'pure')
                hasReadFunction = true;
            else
                hasWriteFunction = true;
        else if (item.type === 'event')
            hasEvent = true;
        if (hasReadFunction && hasWriteFunction && hasEvent)
            break;
    }
    if (hasPublicClient) {
        if (hasReadFunction)
            contract.read = new Proxy({}, {
                get(_, functionName) {
                    return (...parameters) => {
                        const { args, options } = getFunctionParameters(parameters);
                        return (0, getAction_js_1.getAction)(publicClient, readContract_js_1.readContract, 'readContract')({
                            abi,
                            address,
                            functionName,
                            args,
                            ...options,
                        });
                    };
                },
            });
        if (hasWriteFunction)
            contract.simulate = new Proxy({}, {
                get(_, functionName) {
                    return (...parameters) => {
                        const { args, options } = getFunctionParameters(parameters);
                        return (0, getAction_js_1.getAction)(publicClient, simulateContract_js_1.simulateContract, 'simulateContract')({
                            abi,
                            address,
                            functionName,
                            args,
                            ...options,
                        });
                    };
                },
            });
        if (hasEvent) {
            contract.createEventFilter = new Proxy({}, {
                get(_, eventName) {
                    return (...parameters) => {
                        const abiEvent = abi.find((x) => x.type === 'event' && x.name === eventName);
                        const { args, options } = getEventParameters(parameters, abiEvent);
                        return (0, getAction_js_1.getAction)(publicClient, createContractEventFilter_js_1.createContractEventFilter, 'createContractEventFilter')({
                            abi,
                            address,
                            eventName,
                            args,
                            ...options,
                        });
                    };
                },
            });
            contract.getEvents = new Proxy({}, {
                get(_, eventName) {
                    return (...parameters) => {
                        const abiEvent = abi.find((x) => x.type === 'event' && x.name === eventName);
                        const { args, options } = getEventParameters(parameters, abiEvent);
                        return (0, getAction_js_1.getAction)(publicClient, getContractEvents_js_1.getContractEvents, 'getContractEvents')({
                            abi,
                            address,
                            eventName,
                            args,
                            ...options,
                        });
                    };
                },
            });
            contract.watchEvent = new Proxy({}, {
                get(_, eventName) {
                    return (...parameters) => {
                        const abiEvent = abi.find((x) => x.type === 'event' && x.name === eventName);
                        const { args, options } = getEventParameters(parameters, abiEvent);
                        return (0, getAction_js_1.getAction)(publicClient, watchContractEvent_js_1.watchContractEvent, 'watchContractEvent')({
                            abi,
                            address,
                            eventName,
                            args,
                            ...options,
                        });
                    };
                },
            });
        }
    }
    if (hasWalletClient) {
        if (hasWriteFunction)
            contract.write = new Proxy({}, {
                get(_, functionName) {
                    return (...parameters) => {
                        const { args, options } = getFunctionParameters(parameters);
                        return (0, getAction_js_1.getAction)(walletClient, writeContract_js_1.writeContract, 'writeContract')({
                            abi,
                            address,
                            functionName,
                            args,
                            ...options,
                        });
                    };
                },
            });
    }
    if (hasPublicClient || hasWalletClient)
        if (hasWriteFunction)
            contract.estimateGas = new Proxy({}, {
                get(_, functionName) {
                    return (...parameters) => {
                        const { args, options } = getFunctionParameters(parameters);
                        const client = (publicClient ?? walletClient);
                        return (0, getAction_js_1.getAction)(client, estimateContractGas_js_1.estimateContractGas, 'estimateContractGas')({
                            abi,
                            address,
                            functionName,
                            args,
                            ...options,
                            account: options.account ??
                                walletClient.account,
                        });
                    };
                },
            });
    contract.address = address;
    contract.abi = abi;
    return contract;
}
function getFunctionParameters(values) {
    const hasArgs = values.length && Array.isArray(values[0]);
    const args = hasArgs ? values[0] : [];
    const options = (hasArgs ? values[1] : values[0]) ?? {};
    return { args, options };
}
function getEventParameters(values, abiEvent) {
    let hasArgs = false;
    if (Array.isArray(values[0]))
        hasArgs = true;
    else if (values.length === 1) {
        hasArgs = abiEvent.inputs.some((x) => x.indexed);
    }
    else if (values.length === 2) {
        hasArgs = true;
    }
    const args = hasArgs ? values[0] : undefined;
    const options = (hasArgs ? values[1] : values[0]) ?? {};
    return { args, options };
}
//# sourceMappingURL=getContract.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/actions/public/call.js":
/*!*******************************************************!*\
  !*** ./node_modules/viem/_cjs/actions/public/call.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.call = call;
exports.getRevertErrorData = getRevertErrorData;
const abitype_1 = __webpack_require__(/*! abitype */ "./node_modules/abitype/dist/cjs/exports/index.js");
const BlockOverrides = __webpack_require__(/*! ox/BlockOverrides */ "./node_modules/ox/_cjs/core/BlockOverrides.js");
const parseAccount_js_1 = __webpack_require__(/*! ../../accounts/utils/parseAccount.js */ "./node_modules/viem/_cjs/accounts/utils/parseAccount.js");
const abis_js_1 = __webpack_require__(/*! ../../constants/abis.js */ "./node_modules/viem/_cjs/constants/abis.js");
const contract_js_1 = __webpack_require__(/*! ../../constants/contract.js */ "./node_modules/viem/_cjs/constants/contract.js");
const contracts_js_1 = __webpack_require__(/*! ../../constants/contracts.js */ "./node_modules/viem/_cjs/constants/contracts.js");
const base_js_1 = __webpack_require__(/*! ../../errors/base.js */ "./node_modules/viem/_cjs/errors/base.js");
const chain_js_1 = __webpack_require__(/*! ../../errors/chain.js */ "./node_modules/viem/_cjs/errors/chain.js");
const contract_js_2 = __webpack_require__(/*! ../../errors/contract.js */ "./node_modules/viem/_cjs/errors/contract.js");
const decodeFunctionResult_js_1 = __webpack_require__(/*! ../../utils/abi/decodeFunctionResult.js */ "./node_modules/viem/_cjs/utils/abi/decodeFunctionResult.js");
const encodeDeployData_js_1 = __webpack_require__(/*! ../../utils/abi/encodeDeployData.js */ "./node_modules/viem/_cjs/utils/abi/encodeDeployData.js");
const encodeFunctionData_js_1 = __webpack_require__(/*! ../../utils/abi/encodeFunctionData.js */ "./node_modules/viem/_cjs/utils/abi/encodeFunctionData.js");
const getChainContractAddress_js_1 = __webpack_require__(/*! ../../utils/chain/getChainContractAddress.js */ "./node_modules/viem/_cjs/utils/chain/getChainContractAddress.js");
const toHex_js_1 = __webpack_require__(/*! ../../utils/encoding/toHex.js */ "./node_modules/viem/_cjs/utils/encoding/toHex.js");
const getCallError_js_1 = __webpack_require__(/*! ../../utils/errors/getCallError.js */ "./node_modules/viem/_cjs/utils/errors/getCallError.js");
const extract_js_1 = __webpack_require__(/*! ../../utils/formatters/extract.js */ "./node_modules/viem/_cjs/utils/formatters/extract.js");
const transactionRequest_js_1 = __webpack_require__(/*! ../../utils/formatters/transactionRequest.js */ "./node_modules/viem/_cjs/utils/formatters/transactionRequest.js");
const createBatchScheduler_js_1 = __webpack_require__(/*! ../../utils/promise/createBatchScheduler.js */ "./node_modules/viem/_cjs/utils/promise/createBatchScheduler.js");
const stateOverride_js_1 = __webpack_require__(/*! ../../utils/stateOverride.js */ "./node_modules/viem/_cjs/utils/stateOverride.js");
const assertRequest_js_1 = __webpack_require__(/*! ../../utils/transaction/assertRequest.js */ "./node_modules/viem/_cjs/utils/transaction/assertRequest.js");
async function call(client, args) {
    const { account: account_ = client.account, authorizationList, batch = Boolean(client.batch?.multicall), blockNumber, blockTag = client.experimental_blockTag ?? 'latest', accessList, blobs, blockOverrides, code, data: data_, factory, factoryData, gas, gasPrice, maxFeePerBlobGas, maxFeePerGas, maxPriorityFeePerGas, nonce, to, value, stateOverride, ...rest } = args;
    const account = account_ ? (0, parseAccount_js_1.parseAccount)(account_) : undefined;
    if (code && (factory || factoryData))
        throw new base_js_1.BaseError('Cannot provide both `code` & `factory`/`factoryData` as parameters.');
    if (code && to)
        throw new base_js_1.BaseError('Cannot provide both `code` & `to` as parameters.');
    const deploylessCallViaBytecode = code && data_;
    const deploylessCallViaFactory = factory && factoryData && to && data_;
    const deploylessCall = deploylessCallViaBytecode || deploylessCallViaFactory;
    const data = (() => {
        if (deploylessCallViaBytecode)
            return toDeploylessCallViaBytecodeData({
                code,
                data: data_,
            });
        if (deploylessCallViaFactory)
            return toDeploylessCallViaFactoryData({
                data: data_,
                factory,
                factoryData,
                to,
            });
        return data_;
    })();
    try {
        (0, assertRequest_js_1.assertRequest)(args);
        const blockNumberHex = typeof blockNumber === 'bigint' ? (0, toHex_js_1.numberToHex)(blockNumber) : undefined;
        const block = blockNumberHex || blockTag;
        const rpcBlockOverrides = blockOverrides
            ? BlockOverrides.toRpc(blockOverrides)
            : undefined;
        const rpcStateOverride = (0, stateOverride_js_1.serializeStateOverride)(stateOverride);
        const chainFormat = client.chain?.formatters?.transactionRequest?.format;
        const format = chainFormat || transactionRequest_js_1.formatTransactionRequest;
        const request = format({
            ...(0, extract_js_1.extract)(rest, { format: chainFormat }),
            from: account?.address,
            accessList,
            authorizationList,
            blobs,
            data,
            gas,
            gasPrice,
            maxFeePerBlobGas,
            maxFeePerGas,
            maxPriorityFeePerGas,
            nonce,
            to: deploylessCall ? undefined : to,
            value,
        });
        if (batch &&
            shouldPerformMulticall({ request }) &&
            !rpcStateOverride &&
            !rpcBlockOverrides) {
            try {
                return await scheduleMulticall(client, {
                    ...request,
                    blockNumber,
                    blockTag,
                });
            }
            catch (err) {
                if (!(err instanceof chain_js_1.ClientChainNotConfiguredError) &&
                    !(err instanceof chain_js_1.ChainDoesNotSupportContract))
                    throw err;
            }
        }
        const params = (() => {
            const base = [
                request,
                block,
            ];
            if (rpcStateOverride && rpcBlockOverrides)
                return [...base, rpcStateOverride, rpcBlockOverrides];
            if (rpcStateOverride)
                return [...base, rpcStateOverride];
            if (rpcBlockOverrides)
                return [...base, {}, rpcBlockOverrides];
            return base;
        })();
        const response = await client.request({
            method: 'eth_call',
            params,
        });
        if (response === '0x')
            return { data: undefined };
        return { data: response };
    }
    catch (err) {
        const data = getRevertErrorData(err);
        const { offchainLookup, offchainLookupSignature } = await Promise.resolve().then(() => __webpack_require__(/*! ../../utils/ccip.js */ "./node_modules/viem/_cjs/utils/ccip.js"));
        if (client.ccipRead !== false &&
            data?.slice(0, 10) === offchainLookupSignature &&
            to)
            return { data: await offchainLookup(client, { data, to }) };
        if (deploylessCall && data?.slice(0, 10) === '0x101bb98d')
            throw new contract_js_2.CounterfactualDeploymentFailedError({ factory });
        throw (0, getCallError_js_1.getCallError)(err, {
            ...args,
            account,
            chain: client.chain,
        });
    }
}
function shouldPerformMulticall({ request }) {
    const { data, to, ...request_ } = request;
    if (!data)
        return false;
    if (data.startsWith(contract_js_1.aggregate3Signature))
        return false;
    if (!to)
        return false;
    if (Object.values(request_).filter((x) => typeof x !== 'undefined').length > 0)
        return false;
    return true;
}
async function scheduleMulticall(client, args) {
    const { batchSize = 1024, deployless = false, wait = 0, } = typeof client.batch?.multicall === 'object' ? client.batch.multicall : {};
    const { blockNumber, blockTag = client.experimental_blockTag ?? 'latest', data, to, } = args;
    const multicallAddress = (() => {
        if (deployless)
            return null;
        if (args.multicallAddress)
            return args.multicallAddress;
        if (client.chain) {
            return (0, getChainContractAddress_js_1.getChainContractAddress)({
                blockNumber,
                chain: client.chain,
                contract: 'multicall3',
            });
        }
        throw new chain_js_1.ClientChainNotConfiguredError();
    })();
    const blockNumberHex = typeof blockNumber === 'bigint' ? (0, toHex_js_1.numberToHex)(blockNumber) : undefined;
    const block = blockNumberHex || blockTag;
    const { schedule } = (0, createBatchScheduler_js_1.createBatchScheduler)({
        id: `${client.uid}.${block}`,
        wait,
        shouldSplitBatch(args) {
            const size = args.reduce((size, { data }) => size + (data.length - 2), 0);
            return size > batchSize * 2;
        },
        fn: async (requests) => {
            const calls = requests.map((request) => ({
                allowFailure: true,
                callData: request.data,
                target: request.to,
            }));
            const calldata = (0, encodeFunctionData_js_1.encodeFunctionData)({
                abi: abis_js_1.multicall3Abi,
                args: [calls],
                functionName: 'aggregate3',
            });
            const data = await client.request({
                method: 'eth_call',
                params: [
                    {
                        ...(multicallAddress === null
                            ? {
                                data: toDeploylessCallViaBytecodeData({
                                    code: contracts_js_1.multicall3Bytecode,
                                    data: calldata,
                                }),
                            }
                            : { to: multicallAddress, data: calldata }),
                    },
                    block,
                ],
            });
            return (0, decodeFunctionResult_js_1.decodeFunctionResult)({
                abi: abis_js_1.multicall3Abi,
                args: [calls],
                functionName: 'aggregate3',
                data: data || '0x',
            });
        },
    });
    const [{ returnData, success }] = await schedule({ data, to });
    if (!success)
        throw new contract_js_2.RawContractError({ data: returnData });
    if (returnData === '0x')
        return { data: undefined };
    return { data: returnData };
}
function toDeploylessCallViaBytecodeData(parameters) {
    const { code, data } = parameters;
    return (0, encodeDeployData_js_1.encodeDeployData)({
        abi: (0, abitype_1.parseAbi)(['constructor(bytes, bytes)']),
        bytecode: contracts_js_1.deploylessCallViaBytecodeBytecode,
        args: [code, data],
    });
}
function toDeploylessCallViaFactoryData(parameters) {
    const { data, factory, factoryData, to } = parameters;
    return (0, encodeDeployData_js_1.encodeDeployData)({
        abi: (0, abitype_1.parseAbi)(['constructor(address, bytes, address, bytes)']),
        bytecode: contracts_js_1.deploylessCallViaFactoryBytecode,
        args: [to, data, factory, factoryData],
    });
}
function getRevertErrorData(err) {
    if (!(err instanceof base_js_1.BaseError))
        return undefined;
    const error = err.walk();
    return typeof error?.data === 'object' ? error.data?.data : error.data;
}
//# sourceMappingURL=call.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/actions/public/createAccessList.js":
/*!*******************************************************************!*\
  !*** ./node_modules/viem/_cjs/actions/public/createAccessList.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createAccessList = createAccessList;
const parseAccount_js_1 = __webpack_require__(/*! ../../accounts/utils/parseAccount.js */ "./node_modules/viem/_cjs/accounts/utils/parseAccount.js");
const toHex_js_1 = __webpack_require__(/*! ../../utils/encoding/toHex.js */ "./node_modules/viem/_cjs/utils/encoding/toHex.js");
const getCallError_js_1 = __webpack_require__(/*! ../../utils/errors/getCallError.js */ "./node_modules/viem/_cjs/utils/errors/getCallError.js");
const extract_js_1 = __webpack_require__(/*! ../../utils/formatters/extract.js */ "./node_modules/viem/_cjs/utils/formatters/extract.js");
const transactionRequest_js_1 = __webpack_require__(/*! ../../utils/formatters/transactionRequest.js */ "./node_modules/viem/_cjs/utils/formatters/transactionRequest.js");
const assertRequest_js_1 = __webpack_require__(/*! ../../utils/transaction/assertRequest.js */ "./node_modules/viem/_cjs/utils/transaction/assertRequest.js");
async function createAccessList(client, args) {
    const { account: account_ = client.account, blockNumber, blockTag = 'latest', blobs, data, gas, gasPrice, maxFeePerBlobGas, maxFeePerGas, maxPriorityFeePerGas, to, value, ...rest } = args;
    const account = account_ ? (0, parseAccount_js_1.parseAccount)(account_) : undefined;
    try {
        (0, assertRequest_js_1.assertRequest)(args);
        const blockNumberHex = typeof blockNumber === 'bigint' ? (0, toHex_js_1.numberToHex)(blockNumber) : undefined;
        const block = blockNumberHex || blockTag;
        const chainFormat = client.chain?.formatters?.transactionRequest?.format;
        const format = chainFormat || transactionRequest_js_1.formatTransactionRequest;
        const request = format({
            ...(0, extract_js_1.extract)(rest, { format: chainFormat }),
            from: account?.address,
            blobs,
            data,
            gas,
            gasPrice,
            maxFeePerBlobGas,
            maxFeePerGas,
            maxPriorityFeePerGas,
            to,
            value,
        });
        const response = await client.request({
            method: 'eth_createAccessList',
            params: [request, block],
        });
        return {
            accessList: response.accessList,
            gasUsed: BigInt(response.gasUsed),
        };
    }
    catch (err) {
        throw (0, getCallError_js_1.getCallError)(err, {
            ...args,
            account,
            chain: client.chain,
        });
    }
}
//# sourceMappingURL=createAccessList.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/actions/public/createBlockFilter.js":
/*!********************************************************************!*\
  !*** ./node_modules/viem/_cjs/actions/public/createBlockFilter.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createBlockFilter = createBlockFilter;
const createFilterRequestScope_js_1 = __webpack_require__(/*! ../../utils/filters/createFilterRequestScope.js */ "./node_modules/viem/_cjs/utils/filters/createFilterRequestScope.js");
async function createBlockFilter(client) {
    const getRequest = (0, createFilterRequestScope_js_1.createFilterRequestScope)(client, {
        method: 'eth_newBlockFilter',
    });
    const id = await client.request({
        method: 'eth_newBlockFilter',
    });
    return { id, request: getRequest(id), type: 'block' };
}
//# sourceMappingURL=createBlockFilter.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/actions/public/createContractEventFilter.js":
/*!****************************************************************************!*\
  !*** ./node_modules/viem/_cjs/actions/public/createContractEventFilter.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createContractEventFilter = createContractEventFilter;
const encodeEventTopics_js_1 = __webpack_require__(/*! ../../utils/abi/encodeEventTopics.js */ "./node_modules/viem/_cjs/utils/abi/encodeEventTopics.js");
const toHex_js_1 = __webpack_require__(/*! ../../utils/encoding/toHex.js */ "./node_modules/viem/_cjs/utils/encoding/toHex.js");
const createFilterRequestScope_js_1 = __webpack_require__(/*! ../../utils/filters/createFilterRequestScope.js */ "./node_modules/viem/_cjs/utils/filters/createFilterRequestScope.js");
async function createContractEventFilter(client, parameters) {
    const { address, abi, args, eventName, fromBlock, strict, toBlock } = parameters;
    const getRequest = (0, createFilterRequestScope_js_1.createFilterRequestScope)(client, {
        method: 'eth_newFilter',
    });
    const topics = eventName
        ? (0, encodeEventTopics_js_1.encodeEventTopics)({
            abi,
            args,
            eventName,
        })
        : undefined;
    const id = await client.request({
        method: 'eth_newFilter',
        params: [
            {
                address,
                fromBlock: typeof fromBlock === 'bigint' ? (0, toHex_js_1.numberToHex)(fromBlock) : fromBlock,
                toBlock: typeof toBlock === 'bigint' ? (0, toHex_js_1.numberToHex)(toBlock) : toBlock,
                topics,
            },
        ],
    });
    return {
        abi,
        args,
        eventName,
        id,
        request: getRequest(id),
        strict: Boolean(strict),
        type: 'event',
    };
}
//# sourceMappingURL=createContractEventFilter.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/actions/public/createEventFilter.js":
/*!********************************************************************!*\
  !*** ./node_modules/viem/_cjs/actions/public/createEventFilter.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createEventFilter = createEventFilter;
const encodeEventTopics_js_1 = __webpack_require__(/*! ../../utils/abi/encodeEventTopics.js */ "./node_modules/viem/_cjs/utils/abi/encodeEventTopics.js");
const toHex_js_1 = __webpack_require__(/*! ../../utils/encoding/toHex.js */ "./node_modules/viem/_cjs/utils/encoding/toHex.js");
const createFilterRequestScope_js_1 = __webpack_require__(/*! ../../utils/filters/createFilterRequestScope.js */ "./node_modules/viem/_cjs/utils/filters/createFilterRequestScope.js");
async function createEventFilter(client, { address, args, event, events: events_, fromBlock, strict, toBlock, } = {}) {
    const events = events_ ?? (event ? [event] : undefined);
    const getRequest = (0, createFilterRequestScope_js_1.createFilterRequestScope)(client, {
        method: 'eth_newFilter',
    });
    let topics = [];
    if (events) {
        const encoded = events.flatMap((event) => (0, encodeEventTopics_js_1.encodeEventTopics)({
            abi: [event],
            eventName: event.name,
            args,
        }));
        topics = [encoded];
        if (event)
            topics = topics[0];
    }
    const id = await client.request({
        method: 'eth_newFilter',
        params: [
            {
                address,
                fromBlock: typeof fromBlock === 'bigint' ? (0, toHex_js_1.numberToHex)(fromBlock) : fromBlock,
                toBlock: typeof toBlock === 'bigint' ? (0, toHex_js_1.numberToHex)(toBlock) : toBlock,
                ...(topics.length ? { topics } : {}),
            },
        ],
    });
    return {
        abi: events,
        args,
        eventName: event ? event.name : undefined,
        fromBlock,
        id,
        request: getRequest(id),
        strict: Boolean(strict),
        toBlock,
        type: 'event',
    };
}
//# sourceMappingURL=createEventFilter.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/actions/public/createPendingTransactionFilter.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/viem/_cjs/actions/public/createPendingTransactionFilter.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createPendingTransactionFilter = createPendingTransactionFilter;
const createFilterRequestScope_js_1 = __webpack_require__(/*! ../../utils/filters/createFilterRequestScope.js */ "./node_modules/viem/_cjs/utils/filters/createFilterRequestScope.js");
async function createPendingTransactionFilter(client) {
    const getRequest = (0, createFilterRequestScope_js_1.createFilterRequestScope)(client, {
        method: 'eth_newPendingTransactionFilter',
    });
    const id = await client.request({
        method: 'eth_newPendingTransactionFilter',
    });
    return { id, request: getRequest(id), type: 'transaction' };
}
//# sourceMappingURL=createPendingTransactionFilter.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/actions/public/estimateContractGas.js":
/*!**********************************************************************!*\
  !*** ./node_modules/viem/_cjs/actions/public/estimateContractGas.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.estimateContractGas = estimateContractGas;
const parseAccount_js_1 = __webpack_require__(/*! ../../accounts/utils/parseAccount.js */ "./node_modules/viem/_cjs/accounts/utils/parseAccount.js");
const encodeFunctionData_js_1 = __webpack_require__(/*! ../../utils/abi/encodeFunctionData.js */ "./node_modules/viem/_cjs/utils/abi/encodeFunctionData.js");
const getContractError_js_1 = __webpack_require__(/*! ../../utils/errors/getContractError.js */ "./node_modules/viem/_cjs/utils/errors/getContractError.js");
const getAction_js_1 = __webpack_require__(/*! ../../utils/getAction.js */ "./node_modules/viem/_cjs/utils/getAction.js");
const estimateGas_js_1 = __webpack_require__(/*! ./estimateGas.js */ "./node_modules/viem/_cjs/actions/public/estimateGas.js");
async function estimateContractGas(client, parameters) {
    const { abi, address, args, functionName, dataSuffix, ...request } = parameters;
    const data = (0, encodeFunctionData_js_1.encodeFunctionData)({
        abi,
        args,
        functionName,
    });
    try {
        const gas = await (0, getAction_js_1.getAction)(client, estimateGas_js_1.estimateGas, 'estimateGas')({
            data: `${data}${dataSuffix ? dataSuffix.replace('0x', '') : ''}`,
            to: address,
            ...request,
        });
        return gas;
    }
    catch (error) {
        const account = request.account ? (0, parseAccount_js_1.parseAccount)(request.account) : undefined;
        throw (0, getContractError_js_1.getContractError)(error, {
            abi,
            address,
            args,
            docsPath: '/docs/contract/estimateContractGas',
            functionName,
            sender: account?.address,
        });
    }
}
//# sourceMappingURL=estimateContractGas.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/actions/public/estimateFeesPerGas.js":
/*!*********************************************************************!*\
  !*** ./node_modules/viem/_cjs/actions/public/estimateFeesPerGas.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.estimateFeesPerGas = estimateFeesPerGas;
exports.internal_estimateFeesPerGas = internal_estimateFeesPerGas;
const fee_js_1 = __webpack_require__(/*! ../../errors/fee.js */ "./node_modules/viem/_cjs/errors/fee.js");
const getAction_js_1 = __webpack_require__(/*! ../../utils/getAction.js */ "./node_modules/viem/_cjs/utils/getAction.js");
const estimateMaxPriorityFeePerGas_js_1 = __webpack_require__(/*! ./estimateMaxPriorityFeePerGas.js */ "./node_modules/viem/_cjs/actions/public/estimateMaxPriorityFeePerGas.js");
const getBlock_js_1 = __webpack_require__(/*! ./getBlock.js */ "./node_modules/viem/_cjs/actions/public/getBlock.js");
const getGasPrice_js_1 = __webpack_require__(/*! ./getGasPrice.js */ "./node_modules/viem/_cjs/actions/public/getGasPrice.js");
async function estimateFeesPerGas(client, args) {
    return internal_estimateFeesPerGas(client, args);
}
async function internal_estimateFeesPerGas(client, args) {
    const { block: block_, chain = client.chain, request, type = 'eip1559', } = args || {};
    const baseFeeMultiplier = await (async () => {
        if (typeof chain?.fees?.baseFeeMultiplier === 'function')
            return chain.fees.baseFeeMultiplier({
                block: block_,
                client,
                request,
            });
        return chain?.fees?.baseFeeMultiplier ?? 1.2;
    })();
    if (baseFeeMultiplier < 1)
        throw new fee_js_1.BaseFeeScalarError();
    const decimals = baseFeeMultiplier.toString().split('.')[1]?.length ?? 0;
    const denominator = 10 ** decimals;
    const multiply = (base) => (base * BigInt(Math.ceil(baseFeeMultiplier * denominator))) /
        BigInt(denominator);
    const block = block_
        ? block_
        : await (0, getAction_js_1.getAction)(client, getBlock_js_1.getBlock, 'getBlock')({});
    if (typeof chain?.fees?.estimateFeesPerGas === 'function') {
        const fees = (await chain.fees.estimateFeesPerGas({
            block: block_,
            client,
            multiply,
            request,
            type,
        }));
        if (fees !== null)
            return fees;
    }
    if (type === 'eip1559') {
        if (typeof block.baseFeePerGas !== 'bigint')
            throw new fee_js_1.Eip1559FeesNotSupportedError();
        const maxPriorityFeePerGas = typeof request?.maxPriorityFeePerGas === 'bigint'
            ? request.maxPriorityFeePerGas
            : await (0, estimateMaxPriorityFeePerGas_js_1.internal_estimateMaxPriorityFeePerGas)(client, {
                block: block,
                chain,
                request,
            });
        const baseFeePerGas = multiply(block.baseFeePerGas);
        const maxFeePerGas = request?.maxFeePerGas ?? baseFeePerGas + maxPriorityFeePerGas;
        return {
            maxFeePerGas,
            maxPriorityFeePerGas,
        };
    }
    const gasPrice = request?.gasPrice ??
        multiply(await (0, getAction_js_1.getAction)(client, getGasPrice_js_1.getGasPrice, 'getGasPrice')({}));
    return {
        gasPrice,
    };
}
//# sourceMappingURL=estimateFeesPerGas.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/actions/public/estimateGas.js":
/*!**************************************************************!*\
  !*** ./node_modules/viem/_cjs/actions/public/estimateGas.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.estimateGas = estimateGas;
const parseAccount_js_1 = __webpack_require__(/*! ../../accounts/utils/parseAccount.js */ "./node_modules/viem/_cjs/accounts/utils/parseAccount.js");
const base_js_1 = __webpack_require__(/*! ../../errors/base.js */ "./node_modules/viem/_cjs/errors/base.js");
const recoverAuthorizationAddress_js_1 = __webpack_require__(/*! ../../utils/authorization/recoverAuthorizationAddress.js */ "./node_modules/viem/_cjs/utils/authorization/recoverAuthorizationAddress.js");
const toHex_js_1 = __webpack_require__(/*! ../../utils/encoding/toHex.js */ "./node_modules/viem/_cjs/utils/encoding/toHex.js");
const getEstimateGasError_js_1 = __webpack_require__(/*! ../../utils/errors/getEstimateGasError.js */ "./node_modules/viem/_cjs/utils/errors/getEstimateGasError.js");
const extract_js_1 = __webpack_require__(/*! ../../utils/formatters/extract.js */ "./node_modules/viem/_cjs/utils/formatters/extract.js");
const transactionRequest_js_1 = __webpack_require__(/*! ../../utils/formatters/transactionRequest.js */ "./node_modules/viem/_cjs/utils/formatters/transactionRequest.js");
const stateOverride_js_1 = __webpack_require__(/*! ../../utils/stateOverride.js */ "./node_modules/viem/_cjs/utils/stateOverride.js");
const assertRequest_js_1 = __webpack_require__(/*! ../../utils/transaction/assertRequest.js */ "./node_modules/viem/_cjs/utils/transaction/assertRequest.js");
const prepareTransactionRequest_js_1 = __webpack_require__(/*! ../wallet/prepareTransactionRequest.js */ "./node_modules/viem/_cjs/actions/wallet/prepareTransactionRequest.js");
const getBalance_js_1 = __webpack_require__(/*! ./getBalance.js */ "./node_modules/viem/_cjs/actions/public/getBalance.js");
async function estimateGas(client, args) {
    const { account: account_ = client.account } = args;
    const account = account_ ? (0, parseAccount_js_1.parseAccount)(account_) : undefined;
    try {
        const { accessList, authorizationList, blobs, blobVersionedHashes, blockNumber, blockTag, data, gas, gasPrice, maxFeePerBlobGas, maxFeePerGas, maxPriorityFeePerGas, nonce, value, stateOverride, ...rest } = (await (0, prepareTransactionRequest_js_1.prepareTransactionRequest)(client, {
            ...args,
            parameters: account?.type === 'local' ? undefined : ['blobVersionedHashes'],
        }));
        const blockNumberHex = typeof blockNumber === 'bigint' ? (0, toHex_js_1.numberToHex)(blockNumber) : undefined;
        const block = blockNumberHex || blockTag;
        const rpcStateOverride = (0, stateOverride_js_1.serializeStateOverride)(stateOverride);
        const to = await (async () => {
            if (rest.to)
                return rest.to;
            if (authorizationList && authorizationList.length > 0)
                return await (0, recoverAuthorizationAddress_js_1.recoverAuthorizationAddress)({
                    authorization: authorizationList[0],
                }).catch(() => {
                    throw new base_js_1.BaseError('`to` is required. Could not infer from `authorizationList`');
                });
            return undefined;
        })();
        (0, assertRequest_js_1.assertRequest)(args);
        const chainFormat = client.chain?.formatters?.transactionRequest?.format;
        const format = chainFormat || transactionRequest_js_1.formatTransactionRequest;
        const request = format({
            ...(0, extract_js_1.extract)(rest, { format: chainFormat }),
            from: account?.address,
            accessList,
            authorizationList,
            blobs,
            blobVersionedHashes,
            data,
            gas,
            gasPrice,
            maxFeePerBlobGas,
            maxFeePerGas,
            maxPriorityFeePerGas,
            nonce,
            to,
            value,
        });
        function estimateGas_rpc(parameters) {
            const { block, request, rpcStateOverride } = parameters;
            return client.request({
                method: 'eth_estimateGas',
                params: rpcStateOverride
                    ? [
                        request,
                        block ?? client.experimental_blockTag ?? 'latest',
                        rpcStateOverride,
                    ]
                    : block
                        ? [request, block]
                        : [request],
            });
        }
        let estimate = BigInt(await estimateGas_rpc({ block, request, rpcStateOverride }));
        if (authorizationList) {
            const value = await (0, getBalance_js_1.getBalance)(client, { address: request.from });
            const estimates = await Promise.all(authorizationList.map(async (authorization) => {
                const { address } = authorization;
                const estimate = await estimateGas_rpc({
                    block,
                    request: {
                        authorizationList: undefined,
                        data,
                        from: account?.address,
                        to: address,
                        value: (0, toHex_js_1.numberToHex)(value),
                    },
                    rpcStateOverride,
                }).catch(() => 100000n);
                return 2n * BigInt(estimate);
            }));
            estimate += estimates.reduce((acc, curr) => acc + curr, 0n);
        }
        return estimate;
    }
    catch (err) {
        throw (0, getEstimateGasError_js_1.getEstimateGasError)(err, {
            ...args,
            account,
            chain: client.chain,
        });
    }
}
//# sourceMappingURL=estimateGas.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/actions/public/estimateMaxPriorityFeePerGas.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/viem/_cjs/actions/public/estimateMaxPriorityFeePerGas.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.estimateMaxPriorityFeePerGas = estimateMaxPriorityFeePerGas;
exports.internal_estimateMaxPriorityFeePerGas = internal_estimateMaxPriorityFeePerGas;
const fee_js_1 = __webpack_require__(/*! ../../errors/fee.js */ "./node_modules/viem/_cjs/errors/fee.js");
const fromHex_js_1 = __webpack_require__(/*! ../../utils/encoding/fromHex.js */ "./node_modules/viem/_cjs/utils/encoding/fromHex.js");
const getAction_js_1 = __webpack_require__(/*! ../../utils/getAction.js */ "./node_modules/viem/_cjs/utils/getAction.js");
const getBlock_js_1 = __webpack_require__(/*! ./getBlock.js */ "./node_modules/viem/_cjs/actions/public/getBlock.js");
const getGasPrice_js_1 = __webpack_require__(/*! ./getGasPrice.js */ "./node_modules/viem/_cjs/actions/public/getGasPrice.js");
async function estimateMaxPriorityFeePerGas(client, args) {
    return internal_estimateMaxPriorityFeePerGas(client, args);
}
async function internal_estimateMaxPriorityFeePerGas(client, args) {
    const { block: block_, chain = client.chain, request } = args || {};
    try {
        const maxPriorityFeePerGas = chain?.fees?.maxPriorityFeePerGas ?? chain?.fees?.defaultPriorityFee;
        if (typeof maxPriorityFeePerGas === 'function') {
            const block = block_ || (await (0, getAction_js_1.getAction)(client, getBlock_js_1.getBlock, 'getBlock')({}));
            const maxPriorityFeePerGas_ = await maxPriorityFeePerGas({
                block,
                client,
                request,
            });
            if (maxPriorityFeePerGas_ === null)
                throw new Error();
            return maxPriorityFeePerGas_;
        }
        if (typeof maxPriorityFeePerGas !== 'undefined')
            return maxPriorityFeePerGas;
        const maxPriorityFeePerGasHex = await client.request({
            method: 'eth_maxPriorityFeePerGas',
        });
        return (0, fromHex_js_1.hexToBigInt)(maxPriorityFeePerGasHex);
    }
    catch {
        const [block, gasPrice] = await Promise.all([
            block_
                ? Promise.resolve(block_)
                : (0, getAction_js_1.getAction)(client, getBlock_js_1.getBlock, 'getBlock')({}),
            (0, getAction_js_1.getAction)(client, getGasPrice_js_1.getGasPrice, 'getGasPrice')({}),
        ]);
        if (typeof block.baseFeePerGas !== 'bigint')
            throw new fee_js_1.Eip1559FeesNotSupportedError();
        const maxPriorityFeePerGas = gasPrice - block.baseFeePerGas;
        if (maxPriorityFeePerGas < 0n)
            return 0n;
        return maxPriorityFeePerGas;
    }
}
//# sourceMappingURL=estimateMaxPriorityFeePerGas.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/actions/public/getBalance.js":
/*!*************************************************************!*\
  !*** ./node_modules/viem/_cjs/actions/public/getBalance.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getBalance = getBalance;
const toHex_js_1 = __webpack_require__(/*! ../../utils/encoding/toHex.js */ "./node_modules/viem/_cjs/utils/encoding/toHex.js");
async function getBalance(client, { address, blockNumber, blockTag = client.experimental_blockTag ?? 'latest', }) {
    const blockNumberHex = typeof blockNumber === 'bigint' ? (0, toHex_js_1.numberToHex)(blockNumber) : undefined;
    const balance = await client.request({
        method: 'eth_getBalance',
        params: [address, blockNumberHex || blockTag],
    });
    return BigInt(balance);
}
//# sourceMappingURL=getBalance.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/actions/public/getBlobBaseFee.js":
/*!*****************************************************************!*\
  !*** ./node_modules/viem/_cjs/actions/public/getBlobBaseFee.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getBlobBaseFee = getBlobBaseFee;
async function getBlobBaseFee(client) {
    const baseFee = await client.request({
        method: 'eth_blobBaseFee',
    });
    return BigInt(baseFee);
}
//# sourceMappingURL=getBlobBaseFee.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/actions/public/getBlock.js":
/*!***********************************************************!*\
  !*** ./node_modules/viem/_cjs/actions/public/getBlock.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getBlock = getBlock;
const block_js_1 = __webpack_require__(/*! ../../errors/block.js */ "./node_modules/viem/_cjs/errors/block.js");
const toHex_js_1 = __webpack_require__(/*! ../../utils/encoding/toHex.js */ "./node_modules/viem/_cjs/utils/encoding/toHex.js");
const block_js_2 = __webpack_require__(/*! ../../utils/formatters/block.js */ "./node_modules/viem/_cjs/utils/formatters/block.js");
async function getBlock(client, { blockHash, blockNumber, blockTag = client.experimental_blockTag ?? 'latest', includeTransactions: includeTransactions_, } = {}) {
    const includeTransactions = includeTransactions_ ?? false;
    const blockNumberHex = blockNumber !== undefined ? (0, toHex_js_1.numberToHex)(blockNumber) : undefined;
    let block = null;
    if (blockHash) {
        block = await client.request({
            method: 'eth_getBlockByHash',
            params: [blockHash, includeTransactions],
        }, { dedupe: true });
    }
    else {
        block = await client.request({
            method: 'eth_getBlockByNumber',
            params: [blockNumberHex || blockTag, includeTransactions],
        }, { dedupe: Boolean(blockNumberHex) });
    }
    if (!block)
        throw new block_js_1.BlockNotFoundError({ blockHash, blockNumber });
    const format = client.chain?.formatters?.block?.format || block_js_2.formatBlock;
    return format(block);
}
//# sourceMappingURL=getBlock.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/actions/public/getBlockNumber.js":
/*!*****************************************************************!*\
  !*** ./node_modules/viem/_cjs/actions/public/getBlockNumber.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getBlockNumberCache = getBlockNumberCache;
exports.getBlockNumber = getBlockNumber;
const withCache_js_1 = __webpack_require__(/*! ../../utils/promise/withCache.js */ "./node_modules/viem/_cjs/utils/promise/withCache.js");
const cacheKey = (id) => `blockNumber.${id}`;
function getBlockNumberCache(id) {
    return (0, withCache_js_1.getCache)(cacheKey(id));
}
async function getBlockNumber(client, { cacheTime = client.cacheTime } = {}) {
    const blockNumberHex = await (0, withCache_js_1.withCache)(() => client.request({
        method: 'eth_blockNumber',
    }), { cacheKey: cacheKey(client.uid), cacheTime });
    return BigInt(blockNumberHex);
}
//# sourceMappingURL=getBlockNumber.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/actions/public/getBlockTransactionCount.js":
/*!***************************************************************************!*\
  !*** ./node_modules/viem/_cjs/actions/public/getBlockTransactionCount.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getBlockTransactionCount = getBlockTransactionCount;
const fromHex_js_1 = __webpack_require__(/*! ../../utils/encoding/fromHex.js */ "./node_modules/viem/_cjs/utils/encoding/fromHex.js");
const toHex_js_1 = __webpack_require__(/*! ../../utils/encoding/toHex.js */ "./node_modules/viem/_cjs/utils/encoding/toHex.js");
async function getBlockTransactionCount(client, { blockHash, blockNumber, blockTag = 'latest', } = {}) {
    const blockNumberHex = blockNumber !== undefined ? (0, toHex_js_1.numberToHex)(blockNumber) : undefined;
    let count;
    if (blockHash) {
        count = await client.request({
            method: 'eth_getBlockTransactionCountByHash',
            params: [blockHash],
        }, { dedupe: true });
    }
    else {
        count = await client.request({
            method: 'eth_getBlockTransactionCountByNumber',
            params: [blockNumberHex || blockTag],
        }, { dedupe: Boolean(blockNumberHex) });
    }
    return (0, fromHex_js_1.hexToNumber)(count);
}
//# sourceMappingURL=getBlockTransactionCount.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/actions/public/getChainId.js":
/*!*************************************************************!*\
  !*** ./node_modules/viem/_cjs/actions/public/getChainId.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getChainId = getChainId;
const fromHex_js_1 = __webpack_require__(/*! ../../utils/encoding/fromHex.js */ "./node_modules/viem/_cjs/utils/encoding/fromHex.js");
async function getChainId(client) {
    const chainIdHex = await client.request({
        method: 'eth_chainId',
    }, { dedupe: true });
    return (0, fromHex_js_1.hexToNumber)(chainIdHex);
}
//# sourceMappingURL=getChainId.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/actions/public/getCode.js":
/*!**********************************************************!*\
  !*** ./node_modules/viem/_cjs/actions/public/getCode.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getCode = getCode;
const toHex_js_1 = __webpack_require__(/*! ../../utils/encoding/toHex.js */ "./node_modules/viem/_cjs/utils/encoding/toHex.js");
async function getCode(client, { address, blockNumber, blockTag = 'latest' }) {
    const blockNumberHex = blockNumber !== undefined ? (0, toHex_js_1.numberToHex)(blockNumber) : undefined;
    const hex = await client.request({
        method: 'eth_getCode',
        params: [address, blockNumberHex || blockTag],
    }, { dedupe: Boolean(blockNumberHex) });
    if (hex === '0x')
        return undefined;
    return hex;
}
//# sourceMappingURL=getCode.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/actions/public/getContractEvents.js":
/*!********************************************************************!*\
  !*** ./node_modules/viem/_cjs/actions/public/getContractEvents.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getContractEvents = getContractEvents;
const getAbiItem_js_1 = __webpack_require__(/*! ../../utils/abi/getAbiItem.js */ "./node_modules/viem/_cjs/utils/abi/getAbiItem.js");
const getAction_js_1 = __webpack_require__(/*! ../../utils/getAction.js */ "./node_modules/viem/_cjs/utils/getAction.js");
const getLogs_js_1 = __webpack_require__(/*! ./getLogs.js */ "./node_modules/viem/_cjs/actions/public/getLogs.js");
async function getContractEvents(client, parameters) {
    const { abi, address, args, blockHash, eventName, fromBlock, toBlock, strict, } = parameters;
    const event = eventName
        ? (0, getAbiItem_js_1.getAbiItem)({ abi, name: eventName })
        : undefined;
    const events = !event
        ? abi.filter((x) => x.type === 'event')
        : undefined;
    return (0, getAction_js_1.getAction)(client, getLogs_js_1.getLogs, 'getLogs')({
        address,
        args,
        blockHash,
        event,
        events,
        fromBlock,
        toBlock,
        strict,
    });
}
//# sourceMappingURL=getContractEvents.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/actions/public/getEip712Domain.js":
/*!******************************************************************!*\
  !*** ./node_modules/viem/_cjs/actions/public/getEip712Domain.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getEip712Domain = getEip712Domain;
const eip712_js_1 = __webpack_require__(/*! ../../errors/eip712.js */ "./node_modules/viem/_cjs/errors/eip712.js");
const getAction_js_1 = __webpack_require__(/*! ../../utils/getAction.js */ "./node_modules/viem/_cjs/utils/getAction.js");
const readContract_js_1 = __webpack_require__(/*! ./readContract.js */ "./node_modules/viem/_cjs/actions/public/readContract.js");
async function getEip712Domain(client, parameters) {
    const { address, factory, factoryData } = parameters;
    try {
        const [fields, name, version, chainId, verifyingContract, salt, extensions,] = await (0, getAction_js_1.getAction)(client, readContract_js_1.readContract, 'readContract')({
            abi,
            address,
            functionName: 'eip712Domain',
            factory,
            factoryData,
        });
        return {
            domain: {
                name,
                version,
                chainId: Number(chainId),
                verifyingContract,
                salt,
            },
            extensions,
            fields,
        };
    }
    catch (e) {
        const error = e;
        if (error.name === 'ContractFunctionExecutionError' &&
            error.cause.name === 'ContractFunctionZeroDataError') {
            throw new eip712_js_1.Eip712DomainNotFoundError({ address });
        }
        throw error;
    }
}
const abi = [
    {
        inputs: [],
        name: 'eip712Domain',
        outputs: [
            { name: 'fields', type: 'bytes1' },
            { name: 'name', type: 'string' },
            { name: 'version', type: 'string' },
            { name: 'chainId', type: 'uint256' },
            { name: 'verifyingContract', type: 'address' },
            { name: 'salt', type: 'bytes32' },
            { name: 'extensions', type: 'uint256[]' },
        ],
        stateMutability: 'view',
        type: 'function',
    },
];
//# sourceMappingURL=getEip712Domain.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/actions/public/getFeeHistory.js":
/*!****************************************************************!*\
  !*** ./node_modules/viem/_cjs/actions/public/getFeeHistory.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getFeeHistory = getFeeHistory;
const toHex_js_1 = __webpack_require__(/*! ../../utils/encoding/toHex.js */ "./node_modules/viem/_cjs/utils/encoding/toHex.js");
const feeHistory_js_1 = __webpack_require__(/*! ../../utils/formatters/feeHistory.js */ "./node_modules/viem/_cjs/utils/formatters/feeHistory.js");
async function getFeeHistory(client, { blockCount, blockNumber, blockTag = 'latest', rewardPercentiles, }) {
    const blockNumberHex = typeof blockNumber === 'bigint' ? (0, toHex_js_1.numberToHex)(blockNumber) : undefined;
    const feeHistory = await client.request({
        method: 'eth_feeHistory',
        params: [
            (0, toHex_js_1.numberToHex)(blockCount),
            blockNumberHex || blockTag,
            rewardPercentiles,
        ],
    }, { dedupe: Boolean(blockNumberHex) });
    return (0, feeHistory_js_1.formatFeeHistory)(feeHistory);
}
//# sourceMappingURL=getFeeHistory.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/actions/public/getFilterChanges.js":
/*!*******************************************************************!*\
  !*** ./node_modules/viem/_cjs/actions/public/getFilterChanges.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getFilterChanges = getFilterChanges;
const parseEventLogs_js_1 = __webpack_require__(/*! ../../utils/abi/parseEventLogs.js */ "./node_modules/viem/_cjs/utils/abi/parseEventLogs.js");
const log_js_1 = __webpack_require__(/*! ../../utils/formatters/log.js */ "./node_modules/viem/_cjs/utils/formatters/log.js");
async function getFilterChanges(_client, { filter, }) {
    const strict = 'strict' in filter && filter.strict;
    const logs = await filter.request({
        method: 'eth_getFilterChanges',
        params: [filter.id],
    });
    if (typeof logs[0] === 'string')
        return logs;
    const formattedLogs = logs.map((log) => (0, log_js_1.formatLog)(log));
    if (!('abi' in filter) || !filter.abi)
        return formattedLogs;
    return (0, parseEventLogs_js_1.parseEventLogs)({
        abi: filter.abi,
        logs: formattedLogs,
        strict,
    });
}
//# sourceMappingURL=getFilterChanges.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/actions/public/getFilterLogs.js":
/*!****************************************************************!*\
  !*** ./node_modules/viem/_cjs/actions/public/getFilterLogs.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getFilterLogs = getFilterLogs;
const parseEventLogs_js_1 = __webpack_require__(/*! ../../utils/abi/parseEventLogs.js */ "./node_modules/viem/_cjs/utils/abi/parseEventLogs.js");
const log_js_1 = __webpack_require__(/*! ../../utils/formatters/log.js */ "./node_modules/viem/_cjs/utils/formatters/log.js");
async function getFilterLogs(_client, { filter, }) {
    const strict = filter.strict ?? false;
    const logs = await filter.request({
        method: 'eth_getFilterLogs',
        params: [filter.id],
    });
    const formattedLogs = logs.map((log) => (0, log_js_1.formatLog)(log));
    if (!filter.abi)
        return formattedLogs;
    return (0, parseEventLogs_js_1.parseEventLogs)({
        abi: filter.abi,
        logs: formattedLogs,
        strict,
    });
}
//# sourceMappingURL=getFilterLogs.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/actions/public/getGasPrice.js":
/*!**************************************************************!*\
  !*** ./node_modules/viem/_cjs/actions/public/getGasPrice.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getGasPrice = getGasPrice;
async function getGasPrice(client) {
    const gasPrice = await client.request({
        method: 'eth_gasPrice',
    });
    return BigInt(gasPrice);
}
//# sourceMappingURL=getGasPrice.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/actions/public/getLogs.js":
/*!**********************************************************!*\
  !*** ./node_modules/viem/_cjs/actions/public/getLogs.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getLogs = getLogs;
const encodeEventTopics_js_1 = __webpack_require__(/*! ../../utils/abi/encodeEventTopics.js */ "./node_modules/viem/_cjs/utils/abi/encodeEventTopics.js");
const parseEventLogs_js_1 = __webpack_require__(/*! ../../utils/abi/parseEventLogs.js */ "./node_modules/viem/_cjs/utils/abi/parseEventLogs.js");
const toHex_js_1 = __webpack_require__(/*! ../../utils/encoding/toHex.js */ "./node_modules/viem/_cjs/utils/encoding/toHex.js");
const log_js_1 = __webpack_require__(/*! ../../utils/formatters/log.js */ "./node_modules/viem/_cjs/utils/formatters/log.js");
async function getLogs(client, { address, blockHash, fromBlock, toBlock, event, events: events_, args, strict: strict_, } = {}) {
    const strict = strict_ ?? false;
    const events = events_ ?? (event ? [event] : undefined);
    let topics = [];
    if (events) {
        const encoded = events.flatMap((event) => (0, encodeEventTopics_js_1.encodeEventTopics)({
            abi: [event],
            eventName: event.name,
            args: events_ ? undefined : args,
        }));
        topics = [encoded];
        if (event)
            topics = topics[0];
    }
    let logs;
    if (blockHash) {
        logs = await client.request({
            method: 'eth_getLogs',
            params: [{ address, topics, blockHash }],
        });
    }
    else {
        logs = await client.request({
            method: 'eth_getLogs',
            params: [
                {
                    address,
                    topics,
                    fromBlock: typeof fromBlock === 'bigint' ? (0, toHex_js_1.numberToHex)(fromBlock) : fromBlock,
                    toBlock: typeof toBlock === 'bigint' ? (0, toHex_js_1.numberToHex)(toBlock) : toBlock,
                },
            ],
        });
    }
    const formattedLogs = logs.map((log) => (0, log_js_1.formatLog)(log));
    if (!events)
        return formattedLogs;
    return (0, parseEventLogs_js_1.parseEventLogs)({
        abi: events,
        args: args,
        logs: formattedLogs,
        strict,
    });
}
//# sourceMappingURL=getLogs.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/actions/public/getProof.js":
/*!***********************************************************!*\
  !*** ./node_modules/viem/_cjs/actions/public/getProof.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getProof = getProof;
const toHex_js_1 = __webpack_require__(/*! ../../utils/encoding/toHex.js */ "./node_modules/viem/_cjs/utils/encoding/toHex.js");
const proof_js_1 = __webpack_require__(/*! ../../utils/formatters/proof.js */ "./node_modules/viem/_cjs/utils/formatters/proof.js");
async function getProof(client, { address, blockNumber, blockTag: blockTag_, storageKeys, }) {
    const blockTag = blockTag_ ?? 'latest';
    const blockNumberHex = blockNumber !== undefined ? (0, toHex_js_1.numberToHex)(blockNumber) : undefined;
    const proof = await client.request({
        method: 'eth_getProof',
        params: [address, storageKeys, blockNumberHex || blockTag],
    });
    return (0, proof_js_1.formatProof)(proof);
}
//# sourceMappingURL=getProof.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/actions/public/getStorageAt.js":
/*!***************************************************************!*\
  !*** ./node_modules/viem/_cjs/actions/public/getStorageAt.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getStorageAt = getStorageAt;
const toHex_js_1 = __webpack_require__(/*! ../../utils/encoding/toHex.js */ "./node_modules/viem/_cjs/utils/encoding/toHex.js");
async function getStorageAt(client, { address, blockNumber, blockTag = 'latest', slot }) {
    const blockNumberHex = blockNumber !== undefined ? (0, toHex_js_1.numberToHex)(blockNumber) : undefined;
    const data = await client.request({
        method: 'eth_getStorageAt',
        params: [address, slot, blockNumberHex || blockTag],
    });
    return data;
}
//# sourceMappingURL=getStorageAt.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/actions/public/getTransaction.js":
/*!*****************************************************************!*\
  !*** ./node_modules/viem/_cjs/actions/public/getTransaction.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getTransaction = getTransaction;
const transaction_js_1 = __webpack_require__(/*! ../../errors/transaction.js */ "./node_modules/viem/_cjs/errors/transaction.js");
const toHex_js_1 = __webpack_require__(/*! ../../utils/encoding/toHex.js */ "./node_modules/viem/_cjs/utils/encoding/toHex.js");
const transaction_js_2 = __webpack_require__(/*! ../../utils/formatters/transaction.js */ "./node_modules/viem/_cjs/utils/formatters/transaction.js");
async function getTransaction(client, { blockHash, blockNumber, blockTag: blockTag_, hash, index, }) {
    const blockTag = blockTag_ || 'latest';
    const blockNumberHex = blockNumber !== undefined ? (0, toHex_js_1.numberToHex)(blockNumber) : undefined;
    let transaction = null;
    if (hash) {
        transaction = await client.request({
            method: 'eth_getTransactionByHash',
            params: [hash],
        }, { dedupe: true });
    }
    else if (blockHash) {
        transaction = await client.request({
            method: 'eth_getTransactionByBlockHashAndIndex',
            params: [blockHash, (0, toHex_js_1.numberToHex)(index)],
        }, { dedupe: true });
    }
    else if (blockNumberHex || blockTag) {
        transaction = await client.request({
            method: 'eth_getTransactionByBlockNumberAndIndex',
            params: [blockNumberHex || blockTag, (0, toHex_js_1.numberToHex)(index)],
        }, { dedupe: Boolean(blockNumberHex) });
    }
    if (!transaction)
        throw new transaction_js_1.TransactionNotFoundError({
            blockHash,
            blockNumber,
            blockTag,
            hash,
            index,
        });
    const format = client.chain?.formatters?.transaction?.format || transaction_js_2.formatTransaction;
    return format(transaction);
}
//# sourceMappingURL=getTransaction.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/actions/public/getTransactionConfirmations.js":
/*!******************************************************************************!*\
  !*** ./node_modules/viem/_cjs/actions/public/getTransactionConfirmations.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getTransactionConfirmations = getTransactionConfirmations;
const getAction_js_1 = __webpack_require__(/*! ../../utils/getAction.js */ "./node_modules/viem/_cjs/utils/getAction.js");
const getBlockNumber_js_1 = __webpack_require__(/*! ./getBlockNumber.js */ "./node_modules/viem/_cjs/actions/public/getBlockNumber.js");
const getTransaction_js_1 = __webpack_require__(/*! ./getTransaction.js */ "./node_modules/viem/_cjs/actions/public/getTransaction.js");
async function getTransactionConfirmations(client, { hash, transactionReceipt }) {
    const [blockNumber, transaction] = await Promise.all([
        (0, getAction_js_1.getAction)(client, getBlockNumber_js_1.getBlockNumber, 'getBlockNumber')({}),
        hash
            ? (0, getAction_js_1.getAction)(client, getTransaction_js_1.getTransaction, 'getTransaction')({ hash })
            : undefined,
    ]);
    const transactionBlockNumber = transactionReceipt?.blockNumber || transaction?.blockNumber;
    if (!transactionBlockNumber)
        return 0n;
    return blockNumber - transactionBlockNumber + 1n;
}
//# sourceMappingURL=getTransactionConfirmations.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/actions/public/getTransactionCount.js":
/*!**********************************************************************!*\
  !*** ./node_modules/viem/_cjs/actions/public/getTransactionCount.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getTransactionCount = getTransactionCount;
const fromHex_js_1 = __webpack_require__(/*! ../../utils/encoding/fromHex.js */ "./node_modules/viem/_cjs/utils/encoding/fromHex.js");
const toHex_js_1 = __webpack_require__(/*! ../../utils/encoding/toHex.js */ "./node_modules/viem/_cjs/utils/encoding/toHex.js");
async function getTransactionCount(client, { address, blockTag = 'latest', blockNumber }) {
    const count = await client.request({
        method: 'eth_getTransactionCount',
        params: [
            address,
            typeof blockNumber === 'bigint' ? (0, toHex_js_1.numberToHex)(blockNumber) : blockTag,
        ],
    }, {
        dedupe: Boolean(blockNumber),
    });
    return (0, fromHex_js_1.hexToNumber)(count);
}
//# sourceMappingURL=getTransactionCount.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/actions/public/getTransactionReceipt.js":
/*!************************************************************************!*\
  !*** ./node_modules/viem/_cjs/actions/public/getTransactionReceipt.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getTransactionReceipt = getTransactionReceipt;
const transaction_js_1 = __webpack_require__(/*! ../../errors/transaction.js */ "./node_modules/viem/_cjs/errors/transaction.js");
const transactionReceipt_js_1 = __webpack_require__(/*! ../../utils/formatters/transactionReceipt.js */ "./node_modules/viem/_cjs/utils/formatters/transactionReceipt.js");
async function getTransactionReceipt(client, { hash }) {
    const receipt = await client.request({
        method: 'eth_getTransactionReceipt',
        params: [hash],
    }, { dedupe: true });
    if (!receipt)
        throw new transaction_js_1.TransactionReceiptNotFoundError({ hash });
    const format = client.chain?.formatters?.transactionReceipt?.format ||
        transactionReceipt_js_1.formatTransactionReceipt;
    return format(receipt);
}
//# sourceMappingURL=getTransactionReceipt.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/actions/public/multicall.js":
/*!************************************************************!*\
  !*** ./node_modules/viem/_cjs/actions/public/multicall.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.multicall = multicall;
const abis_js_1 = __webpack_require__(/*! ../../constants/abis.js */ "./node_modules/viem/_cjs/constants/abis.js");
const contracts_js_1 = __webpack_require__(/*! ../../constants/contracts.js */ "./node_modules/viem/_cjs/constants/contracts.js");
const abi_js_1 = __webpack_require__(/*! ../../errors/abi.js */ "./node_modules/viem/_cjs/errors/abi.js");
const base_js_1 = __webpack_require__(/*! ../../errors/base.js */ "./node_modules/viem/_cjs/errors/base.js");
const contract_js_1 = __webpack_require__(/*! ../../errors/contract.js */ "./node_modules/viem/_cjs/errors/contract.js");
const decodeFunctionResult_js_1 = __webpack_require__(/*! ../../utils/abi/decodeFunctionResult.js */ "./node_modules/viem/_cjs/utils/abi/decodeFunctionResult.js");
const encodeFunctionData_js_1 = __webpack_require__(/*! ../../utils/abi/encodeFunctionData.js */ "./node_modules/viem/_cjs/utils/abi/encodeFunctionData.js");
const getChainContractAddress_js_1 = __webpack_require__(/*! ../../utils/chain/getChainContractAddress.js */ "./node_modules/viem/_cjs/utils/chain/getChainContractAddress.js");
const getContractError_js_1 = __webpack_require__(/*! ../../utils/errors/getContractError.js */ "./node_modules/viem/_cjs/utils/errors/getContractError.js");
const getAction_js_1 = __webpack_require__(/*! ../../utils/getAction.js */ "./node_modules/viem/_cjs/utils/getAction.js");
const readContract_js_1 = __webpack_require__(/*! ./readContract.js */ "./node_modules/viem/_cjs/actions/public/readContract.js");
async function multicall(client, parameters) {
    const { account, authorizationList, allowFailure = true, blockNumber, blockTag, stateOverride, } = parameters;
    const contracts = parameters.contracts;
    const { batchSize = parameters.batchSize ?? 1024, deployless = parameters.deployless ?? false, } = typeof client.batch?.multicall === 'object' ? client.batch.multicall : {};
    const multicallAddress = (() => {
        if (parameters.multicallAddress)
            return parameters.multicallAddress;
        if (deployless)
            return null;
        if (client.chain) {
            return (0, getChainContractAddress_js_1.getChainContractAddress)({
                blockNumber,
                chain: client.chain,
                contract: 'multicall3',
            });
        }
        throw new Error('client chain not configured. multicallAddress is required.');
    })();
    const chunkedCalls = [[]];
    let currentChunk = 0;
    let currentChunkSize = 0;
    for (let i = 0; i < contracts.length; i++) {
        const { abi, address, args, functionName } = contracts[i];
        try {
            const callData = (0, encodeFunctionData_js_1.encodeFunctionData)({ abi, args, functionName });
            currentChunkSize += (callData.length - 2) / 2;
            if (batchSize > 0 &&
                currentChunkSize > batchSize &&
                chunkedCalls[currentChunk].length > 0) {
                currentChunk++;
                currentChunkSize = (callData.length - 2) / 2;
                chunkedCalls[currentChunk] = [];
            }
            chunkedCalls[currentChunk] = [
                ...chunkedCalls[currentChunk],
                {
                    allowFailure: true,
                    callData,
                    target: address,
                },
            ];
        }
        catch (err) {
            const error = (0, getContractError_js_1.getContractError)(err, {
                abi,
                address,
                args,
                docsPath: '/docs/contract/multicall',
                functionName,
                sender: account,
            });
            if (!allowFailure)
                throw error;
            chunkedCalls[currentChunk] = [
                ...chunkedCalls[currentChunk],
                {
                    allowFailure: true,
                    callData: '0x',
                    target: address,
                },
            ];
        }
    }
    const aggregate3Results = await Promise.allSettled(chunkedCalls.map((calls) => (0, getAction_js_1.getAction)(client, readContract_js_1.readContract, 'readContract')({
        ...(multicallAddress === null
            ? { code: contracts_js_1.multicall3Bytecode }
            : { address: multicallAddress }),
        abi: abis_js_1.multicall3Abi,
        account,
        args: [calls],
        authorizationList,
        blockNumber,
        blockTag,
        functionName: 'aggregate3',
        stateOverride,
    })));
    const results = [];
    for (let i = 0; i < aggregate3Results.length; i++) {
        const result = aggregate3Results[i];
        if (result.status === 'rejected') {
            if (!allowFailure)
                throw result.reason;
            for (let j = 0; j < chunkedCalls[i].length; j++) {
                results.push({
                    status: 'failure',
                    error: result.reason,
                    result: undefined,
                });
            }
            continue;
        }
        const aggregate3Result = result.value;
        for (let j = 0; j < aggregate3Result.length; j++) {
            const { returnData, success } = aggregate3Result[j];
            const { callData } = chunkedCalls[i][j];
            const { abi, address, functionName, args } = contracts[results.length];
            try {
                if (callData === '0x')
                    throw new abi_js_1.AbiDecodingZeroDataError();
                if (!success)
                    throw new contract_js_1.RawContractError({ data: returnData });
                const result = (0, decodeFunctionResult_js_1.decodeFunctionResult)({
                    abi,
                    args,
                    data: returnData,
                    functionName,
                });
                results.push(allowFailure ? { result, status: 'success' } : result);
            }
            catch (err) {
                const error = (0, getContractError_js_1.getContractError)(err, {
                    abi,
                    address,
                    args,
                    docsPath: '/docs/contract/multicall',
                    functionName,
                });
                if (!allowFailure)
                    throw error;
                results.push({ error, result: undefined, status: 'failure' });
            }
        }
    }
    if (results.length !== contracts.length)
        throw new base_js_1.BaseError('multicall results mismatch');
    return results;
}
//# sourceMappingURL=multicall.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/actions/public/readContract.js":
/*!***************************************************************!*\
  !*** ./node_modules/viem/_cjs/actions/public/readContract.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.readContract = readContract;
const decodeFunctionResult_js_1 = __webpack_require__(/*! ../../utils/abi/decodeFunctionResult.js */ "./node_modules/viem/_cjs/utils/abi/decodeFunctionResult.js");
const encodeFunctionData_js_1 = __webpack_require__(/*! ../../utils/abi/encodeFunctionData.js */ "./node_modules/viem/_cjs/utils/abi/encodeFunctionData.js");
const getContractError_js_1 = __webpack_require__(/*! ../../utils/errors/getContractError.js */ "./node_modules/viem/_cjs/utils/errors/getContractError.js");
const getAction_js_1 = __webpack_require__(/*! ../../utils/getAction.js */ "./node_modules/viem/_cjs/utils/getAction.js");
const call_js_1 = __webpack_require__(/*! ./call.js */ "./node_modules/viem/_cjs/actions/public/call.js");
async function readContract(client, parameters) {
    const { abi, address, args, functionName, ...rest } = parameters;
    const calldata = (0, encodeFunctionData_js_1.encodeFunctionData)({
        abi,
        args,
        functionName,
    });
    try {
        const { data } = await (0, getAction_js_1.getAction)(client, call_js_1.call, 'call')({
            ...rest,
            data: calldata,
            to: address,
        });
        return (0, decodeFunctionResult_js_1.decodeFunctionResult)({
            abi,
            args,
            functionName,
            data: data || '0x',
        });
    }
    catch (error) {
        throw (0, getContractError_js_1.getContractError)(error, {
            abi,
            address,
            args,
            docsPath: '/docs/contract/readContract',
            functionName,
        });
    }
}
//# sourceMappingURL=readContract.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/actions/public/simulateBlocks.js":
/*!*****************************************************************!*\
  !*** ./node_modules/viem/_cjs/actions/public/simulateBlocks.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.simulateBlocks = simulateBlocks;
const BlockOverrides = __webpack_require__(/*! ox/BlockOverrides */ "./node_modules/ox/_cjs/core/BlockOverrides.js");
const parseAccount_js_1 = __webpack_require__(/*! ../../accounts/utils/parseAccount.js */ "./node_modules/viem/_cjs/accounts/utils/parseAccount.js");
const abi_js_1 = __webpack_require__(/*! ../../errors/abi.js */ "./node_modules/viem/_cjs/errors/abi.js");
const contract_js_1 = __webpack_require__(/*! ../../errors/contract.js */ "./node_modules/viem/_cjs/errors/contract.js");
const node_js_1 = __webpack_require__(/*! ../../errors/node.js */ "./node_modules/viem/_cjs/errors/node.js");
const decodeFunctionResult_js_1 = __webpack_require__(/*! ../../utils/abi/decodeFunctionResult.js */ "./node_modules/viem/_cjs/utils/abi/decodeFunctionResult.js");
const encodeFunctionData_js_1 = __webpack_require__(/*! ../../utils/abi/encodeFunctionData.js */ "./node_modules/viem/_cjs/utils/abi/encodeFunctionData.js");
const concat_js_1 = __webpack_require__(/*! ../../utils/data/concat.js */ "./node_modules/viem/_cjs/utils/data/concat.js");
const toHex_js_1 = __webpack_require__(/*! ../../utils/encoding/toHex.js */ "./node_modules/viem/_cjs/utils/encoding/toHex.js");
const getContractError_js_1 = __webpack_require__(/*! ../../utils/errors/getContractError.js */ "./node_modules/viem/_cjs/utils/errors/getContractError.js");
const getNodeError_js_1 = __webpack_require__(/*! ../../utils/errors/getNodeError.js */ "./node_modules/viem/_cjs/utils/errors/getNodeError.js");
const block_js_1 = __webpack_require__(/*! ../../utils/formatters/block.js */ "./node_modules/viem/_cjs/utils/formatters/block.js");
const log_js_1 = __webpack_require__(/*! ../../utils/formatters/log.js */ "./node_modules/viem/_cjs/utils/formatters/log.js");
const transactionRequest_js_1 = __webpack_require__(/*! ../../utils/formatters/transactionRequest.js */ "./node_modules/viem/_cjs/utils/formatters/transactionRequest.js");
const stateOverride_js_1 = __webpack_require__(/*! ../../utils/stateOverride.js */ "./node_modules/viem/_cjs/utils/stateOverride.js");
const assertRequest_js_1 = __webpack_require__(/*! ../../utils/transaction/assertRequest.js */ "./node_modules/viem/_cjs/utils/transaction/assertRequest.js");
async function simulateBlocks(client, parameters) {
    const { blockNumber, blockTag = client.experimental_blockTag ?? 'latest', blocks, returnFullTransactions, traceTransfers, validation, } = parameters;
    try {
        const blockStateCalls = [];
        for (const block of blocks) {
            const blockOverrides = block.blockOverrides
                ? BlockOverrides.toRpc(block.blockOverrides)
                : undefined;
            const calls = block.calls.map((call_) => {
                const call = call_;
                const account = call.account ? (0, parseAccount_js_1.parseAccount)(call.account) : undefined;
                const data = call.abi ? (0, encodeFunctionData_js_1.encodeFunctionData)(call) : call.data;
                const request = {
                    ...call,
                    data: call.dataSuffix
                        ? (0, concat_js_1.concat)([data || '0x', call.dataSuffix])
                        : data,
                    from: call.from ?? account?.address,
                };
                (0, assertRequest_js_1.assertRequest)(request);
                return (0, transactionRequest_js_1.formatTransactionRequest)(request);
            });
            const stateOverrides = block.stateOverrides
                ? (0, stateOverride_js_1.serializeStateOverride)(block.stateOverrides)
                : undefined;
            blockStateCalls.push({
                blockOverrides,
                calls,
                stateOverrides,
            });
        }
        const blockNumberHex = typeof blockNumber === 'bigint' ? (0, toHex_js_1.numberToHex)(blockNumber) : undefined;
        const block = blockNumberHex || blockTag;
        const result = await client.request({
            method: 'eth_simulateV1',
            params: [
                { blockStateCalls, returnFullTransactions, traceTransfers, validation },
                block,
            ],
        });
        return result.map((block, i) => ({
            ...(0, block_js_1.formatBlock)(block),
            calls: block.calls.map((call, j) => {
                const { abi, args, functionName, to } = blocks[i].calls[j];
                const data = call.error?.data ?? call.returnData;
                const gasUsed = BigInt(call.gasUsed);
                const logs = call.logs?.map((log) => (0, log_js_1.formatLog)(log));
                const status = call.status === '0x1' ? 'success' : 'failure';
                const result = abi && status === 'success' && data !== '0x'
                    ? (0, decodeFunctionResult_js_1.decodeFunctionResult)({
                        abi,
                        data,
                        functionName,
                    })
                    : null;
                const error = (() => {
                    if (status === 'success')
                        return undefined;
                    let error;
                    if (call.error?.data === '0x')
                        error = new abi_js_1.AbiDecodingZeroDataError();
                    else if (call.error)
                        error = new contract_js_1.RawContractError(call.error);
                    if (!error)
                        return undefined;
                    return (0, getContractError_js_1.getContractError)(error, {
                        abi: (abi ?? []),
                        address: to ?? '0x',
                        args,
                        functionName: functionName ?? '<unknown>',
                    });
                })();
                return {
                    data,
                    gasUsed,
                    logs,
                    status,
                    ...(status === 'success'
                        ? {
                            result,
                        }
                        : {
                            error,
                        }),
                };
            }),
        }));
    }
    catch (e) {
        const cause = e;
        const error = (0, getNodeError_js_1.getNodeError)(cause, {});
        if (error instanceof node_js_1.UnknownNodeError)
            throw cause;
        throw error;
    }
}
//# sourceMappingURL=simulateBlocks.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/actions/public/simulateCalls.js":
/*!****************************************************************!*\
  !*** ./node_modules/viem/_cjs/actions/public/simulateCalls.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.simulateCalls = simulateCalls;
const AbiConstructor = __webpack_require__(/*! ox/AbiConstructor */ "./node_modules/ox/_cjs/core/AbiConstructor.js");
const AbiFunction = __webpack_require__(/*! ox/AbiFunction */ "./node_modules/ox/_cjs/core/AbiFunction.js");
const parseAccount_js_1 = __webpack_require__(/*! ../../accounts/utils/parseAccount.js */ "./node_modules/viem/_cjs/accounts/utils/parseAccount.js");
const address_js_1 = __webpack_require__(/*! ../../constants/address.js */ "./node_modules/viem/_cjs/constants/address.js");
const contracts_js_1 = __webpack_require__(/*! ../../constants/contracts.js */ "./node_modules/viem/_cjs/constants/contracts.js");
const base_js_1 = __webpack_require__(/*! ../../errors/base.js */ "./node_modules/viem/_cjs/errors/base.js");
const encodeFunctionData_js_1 = __webpack_require__(/*! ../../utils/abi/encodeFunctionData.js */ "./node_modules/viem/_cjs/utils/abi/encodeFunctionData.js");
const index_js_1 = __webpack_require__(/*! ../../utils/index.js */ "./node_modules/viem/_cjs/utils/index.js");
const createAccessList_js_1 = __webpack_require__(/*! ./createAccessList.js */ "./node_modules/viem/_cjs/actions/public/createAccessList.js");
const simulateBlocks_js_1 = __webpack_require__(/*! ./simulateBlocks.js */ "./node_modules/viem/_cjs/actions/public/simulateBlocks.js");
const getBalanceCode = '0x6080604052348015600e575f80fd5b5061016d8061001c5f395ff3fe608060405234801561000f575f80fd5b5060043610610029575f3560e01c8063f8b2cb4f1461002d575b5f80fd5b610047600480360381019061004291906100db565b61005d565b604051610054919061011e565b60405180910390f35b5f8173ffffffffffffffffffffffffffffffffffffffff16319050919050565b5f80fd5b5f73ffffffffffffffffffffffffffffffffffffffff82169050919050565b5f6100aa82610081565b9050919050565b6100ba816100a0565b81146100c4575f80fd5b50565b5f813590506100d5816100b1565b92915050565b5f602082840312156100f0576100ef61007d565b5b5f6100fd848285016100c7565b91505092915050565b5f819050919050565b61011881610106565b82525050565b5f6020820190506101315f83018461010f565b9291505056fea26469706673582212203b9fe929fe995c7cf9887f0bdba8a36dd78e8b73f149b17d2d9ad7cd09d2dc6264736f6c634300081a0033';
async function simulateCalls(client, parameters) {
    const { blockNumber, blockTag, calls, stateOverrides, traceAssetChanges, traceTransfers, validation, } = parameters;
    const account = parameters.account
        ? (0, parseAccount_js_1.parseAccount)(parameters.account)
        : undefined;
    if (traceAssetChanges && !account)
        throw new base_js_1.BaseError('`account` is required when `traceAssetChanges` is true');
    const getBalanceData = account
        ? AbiConstructor.encode(AbiConstructor.from('constructor(bytes, bytes)'), {
            bytecode: contracts_js_1.deploylessCallViaBytecodeBytecode,
            args: [
                getBalanceCode,
                AbiFunction.encodeData(AbiFunction.from('function getBalance(address)'), [account.address]),
            ],
        })
        : undefined;
    const assetAddresses = traceAssetChanges
        ? await Promise.all(parameters.calls.map(async (call) => {
            if (!call.data && !call.abi)
                return;
            const { accessList } = await (0, createAccessList_js_1.createAccessList)(client, {
                account: account.address,
                ...call,
                data: call.abi ? (0, encodeFunctionData_js_1.encodeFunctionData)(call) : call.data,
            });
            return accessList.map(({ address, storageKeys }) => storageKeys.length > 0 ? address : null);
        })).then((x) => x.flat().filter(Boolean))
        : [];
    const blocks = await (0, simulateBlocks_js_1.simulateBlocks)(client, {
        blockNumber,
        blockTag: blockTag,
        blocks: [
            ...(traceAssetChanges
                ? [
                    {
                        calls: [{ data: getBalanceData }],
                        stateOverrides,
                    },
                    {
                        calls: assetAddresses.map((address, i) => ({
                            abi: [
                                AbiFunction.from('function balanceOf(address) returns (uint256)'),
                            ],
                            functionName: 'balanceOf',
                            args: [account.address],
                            to: address,
                            from: address_js_1.zeroAddress,
                            nonce: i,
                        })),
                        stateOverrides: [
                            {
                                address: address_js_1.zeroAddress,
                                nonce: 0,
                            },
                        ],
                    },
                ]
                : []),
            {
                calls: [...calls, {}].map((call) => ({
                    ...call,
                    from: account?.address,
                })),
                stateOverrides,
            },
            ...(traceAssetChanges
                ? [
                    {
                        calls: [{ data: getBalanceData }],
                    },
                    {
                        calls: assetAddresses.map((address, i) => ({
                            abi: [
                                AbiFunction.from('function balanceOf(address) returns (uint256)'),
                            ],
                            functionName: 'balanceOf',
                            args: [account.address],
                            to: address,
                            from: address_js_1.zeroAddress,
                            nonce: i,
                        })),
                        stateOverrides: [
                            {
                                address: address_js_1.zeroAddress,
                                nonce: 0,
                            },
                        ],
                    },
                    {
                        calls: assetAddresses.map((address, i) => ({
                            to: address,
                            abi: [
                                AbiFunction.from('function decimals() returns (uint256)'),
                            ],
                            functionName: 'decimals',
                            from: address_js_1.zeroAddress,
                            nonce: i,
                        })),
                        stateOverrides: [
                            {
                                address: address_js_1.zeroAddress,
                                nonce: 0,
                            },
                        ],
                    },
                    {
                        calls: assetAddresses.map((address, i) => ({
                            to: address,
                            abi: [
                                AbiFunction.from('function tokenURI(uint256) returns (string)'),
                            ],
                            functionName: 'tokenURI',
                            args: [0n],
                            from: address_js_1.zeroAddress,
                            nonce: i,
                        })),
                        stateOverrides: [
                            {
                                address: address_js_1.zeroAddress,
                                nonce: 0,
                            },
                        ],
                    },
                    {
                        calls: assetAddresses.map((address, i) => ({
                            to: address,
                            abi: [AbiFunction.from('function symbol() returns (string)')],
                            functionName: 'symbol',
                            from: address_js_1.zeroAddress,
                            nonce: i,
                        })),
                        stateOverrides: [
                            {
                                address: address_js_1.zeroAddress,
                                nonce: 0,
                            },
                        ],
                    },
                ]
                : []),
        ],
        traceTransfers,
        validation,
    });
    const block_results = traceAssetChanges ? blocks[2] : blocks[0];
    const [block_ethPre, block_assetsPre, , block_ethPost, block_assetsPost, block_decimals, block_tokenURI, block_symbols,] = traceAssetChanges ? blocks : [];
    const { calls: block_calls, ...block } = block_results;
    const results = block_calls.slice(0, -1) ?? [];
    const ethPre = block_ethPre?.calls ?? [];
    const assetsPre = block_assetsPre?.calls ?? [];
    const balancesPre = [...ethPre, ...assetsPre].map((call) => call.status === 'success' ? (0, index_js_1.hexToBigInt)(call.data) : null);
    const ethPost = block_ethPost?.calls ?? [];
    const assetsPost = block_assetsPost?.calls ?? [];
    const balancesPost = [...ethPost, ...assetsPost].map((call) => call.status === 'success' ? (0, index_js_1.hexToBigInt)(call.data) : null);
    const decimals = (block_decimals?.calls ?? []).map((x) => x.status === 'success' ? x.result : null);
    const symbols = (block_symbols?.calls ?? []).map((x) => x.status === 'success' ? x.result : null);
    const tokenURI = (block_tokenURI?.calls ?? []).map((x) => x.status === 'success' ? x.result : null);
    const changes = [];
    for (const [i, balancePost] of balancesPost.entries()) {
        const balancePre = balancesPre[i];
        if (typeof balancePost !== 'bigint')
            continue;
        if (typeof balancePre !== 'bigint')
            continue;
        const decimals_ = decimals[i - 1];
        const symbol_ = symbols[i - 1];
        const tokenURI_ = tokenURI[i - 1];
        const token = (() => {
            if (i === 0)
                return {
                    address: address_js_1.ethAddress,
                    decimals: 18,
                    symbol: 'ETH',
                };
            return {
                address: assetAddresses[i - 1],
                decimals: tokenURI_ || decimals_ ? Number(decimals_ ?? 1) : undefined,
                symbol: symbol_ ?? undefined,
            };
        })();
        if (changes.some((change) => change.token.address === token.address))
            continue;
        changes.push({
            token,
            value: {
                pre: balancePre,
                post: balancePost,
                diff: balancePost - balancePre,
            },
        });
    }
    return {
        assetChanges: changes,
        block,
        results,
    };
}
//# sourceMappingURL=simulateCalls.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/actions/public/simulateContract.js":
/*!*******************************************************************!*\
  !*** ./node_modules/viem/_cjs/actions/public/simulateContract.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.simulateContract = simulateContract;
const parseAccount_js_1 = __webpack_require__(/*! ../../accounts/utils/parseAccount.js */ "./node_modules/viem/_cjs/accounts/utils/parseAccount.js");
const decodeFunctionResult_js_1 = __webpack_require__(/*! ../../utils/abi/decodeFunctionResult.js */ "./node_modules/viem/_cjs/utils/abi/decodeFunctionResult.js");
const encodeFunctionData_js_1 = __webpack_require__(/*! ../../utils/abi/encodeFunctionData.js */ "./node_modules/viem/_cjs/utils/abi/encodeFunctionData.js");
const getContractError_js_1 = __webpack_require__(/*! ../../utils/errors/getContractError.js */ "./node_modules/viem/_cjs/utils/errors/getContractError.js");
const getAction_js_1 = __webpack_require__(/*! ../../utils/getAction.js */ "./node_modules/viem/_cjs/utils/getAction.js");
const call_js_1 = __webpack_require__(/*! ./call.js */ "./node_modules/viem/_cjs/actions/public/call.js");
async function simulateContract(client, parameters) {
    const { abi, address, args, dataSuffix, functionName, ...callRequest } = parameters;
    const account = callRequest.account
        ? (0, parseAccount_js_1.parseAccount)(callRequest.account)
        : client.account;
    const calldata = (0, encodeFunctionData_js_1.encodeFunctionData)({ abi, args, functionName });
    try {
        const { data } = await (0, getAction_js_1.getAction)(client, call_js_1.call, 'call')({
            batch: false,
            data: `${calldata}${dataSuffix ? dataSuffix.replace('0x', '') : ''}`,
            to: address,
            ...callRequest,
            account,
        });
        const result = (0, decodeFunctionResult_js_1.decodeFunctionResult)({
            abi,
            args,
            functionName,
            data: data || '0x',
        });
        const minimizedAbi = abi.filter((abiItem) => 'name' in abiItem && abiItem.name === parameters.functionName);
        return {
            result,
            request: {
                abi: minimizedAbi,
                address,
                args,
                dataSuffix,
                functionName,
                ...callRequest,
                account,
            },
        };
    }
    catch (error) {
        throw (0, getContractError_js_1.getContractError)(error, {
            abi,
            address,
            args,
            docsPath: '/docs/contract/simulateContract',
            functionName,
            sender: account?.address,
        });
    }
}
//# sourceMappingURL=simulateContract.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/actions/public/uninstallFilter.js":
/*!******************************************************************!*\
  !*** ./node_modules/viem/_cjs/actions/public/uninstallFilter.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.uninstallFilter = uninstallFilter;
async function uninstallFilter(_client, { filter }) {
    return filter.request({
        method: 'eth_uninstallFilter',
        params: [filter.id],
    });
}
//# sourceMappingURL=uninstallFilter.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/actions/public/verifyHash.js":
/*!*************************************************************!*\
  !*** ./node_modules/viem/_cjs/actions/public/verifyHash.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.verifyHash = verifyHash;
const abis_js_1 = __webpack_require__(/*! ../../constants/abis.js */ "./node_modules/viem/_cjs/constants/abis.js");
const contracts_js_1 = __webpack_require__(/*! ../../constants/contracts.js */ "./node_modules/viem/_cjs/constants/contracts.js");
const contract_js_1 = __webpack_require__(/*! ../../errors/contract.js */ "./node_modules/viem/_cjs/errors/contract.js");
const encodeDeployData_js_1 = __webpack_require__(/*! ../../utils/abi/encodeDeployData.js */ "./node_modules/viem/_cjs/utils/abi/encodeDeployData.js");
const getAddress_js_1 = __webpack_require__(/*! ../../utils/address/getAddress.js */ "./node_modules/viem/_cjs/utils/address/getAddress.js");
const isAddressEqual_js_1 = __webpack_require__(/*! ../../utils/address/isAddressEqual.js */ "./node_modules/viem/_cjs/utils/address/isAddressEqual.js");
const isHex_js_1 = __webpack_require__(/*! ../../utils/data/isHex.js */ "./node_modules/viem/_cjs/utils/data/isHex.js");
const toHex_js_1 = __webpack_require__(/*! ../../utils/encoding/toHex.js */ "./node_modules/viem/_cjs/utils/encoding/toHex.js");
const getAction_js_1 = __webpack_require__(/*! ../../utils/getAction.js */ "./node_modules/viem/_cjs/utils/getAction.js");
const index_js_1 = __webpack_require__(/*! ../../utils/index.js */ "./node_modules/viem/_cjs/utils/index.js");
const isErc6492Signature_js_1 = __webpack_require__(/*! ../../utils/signature/isErc6492Signature.js */ "./node_modules/viem/_cjs/utils/signature/isErc6492Signature.js");
const recoverAddress_js_1 = __webpack_require__(/*! ../../utils/signature/recoverAddress.js */ "./node_modules/viem/_cjs/utils/signature/recoverAddress.js");
const serializeErc6492Signature_js_1 = __webpack_require__(/*! ../../utils/signature/serializeErc6492Signature.js */ "./node_modules/viem/_cjs/utils/signature/serializeErc6492Signature.js");
const serializeSignature_js_1 = __webpack_require__(/*! ../../utils/signature/serializeSignature.js */ "./node_modules/viem/_cjs/utils/signature/serializeSignature.js");
const call_js_1 = __webpack_require__(/*! ./call.js */ "./node_modules/viem/_cjs/actions/public/call.js");
async function verifyHash(client, parameters) {
    const { address, factory, factoryData, hash, signature, universalSignatureVerifierAddress = client.chain?.contracts
        ?.universalSignatureVerifier?.address, ...rest } = parameters;
    const signatureHex = (() => {
        if ((0, isHex_js_1.isHex)(signature))
            return signature;
        if (typeof signature === 'object' && 'r' in signature && 's' in signature)
            return (0, serializeSignature_js_1.serializeSignature)(signature);
        return (0, toHex_js_1.bytesToHex)(signature);
    })();
    const wrappedSignature = await (async () => {
        if (!factory && !factoryData)
            return signatureHex;
        if ((0, isErc6492Signature_js_1.isErc6492Signature)(signatureHex))
            return signatureHex;
        return (0, serializeErc6492Signature_js_1.serializeErc6492Signature)({
            address: factory,
            data: factoryData,
            signature: signatureHex,
        });
    })();
    try {
        const args = universalSignatureVerifierAddress
            ? {
                to: universalSignatureVerifierAddress,
                data: (0, index_js_1.encodeFunctionData)({
                    abi: abis_js_1.universalSignatureValidatorAbi,
                    functionName: 'isValidSig',
                    args: [address, hash, wrappedSignature],
                }),
                ...rest,
            }
            : {
                data: (0, encodeDeployData_js_1.encodeDeployData)({
                    abi: abis_js_1.universalSignatureValidatorAbi,
                    args: [address, hash, wrappedSignature],
                    bytecode: contracts_js_1.universalSignatureValidatorByteCode,
                }),
                ...rest,
            };
        const { data } = await (0, getAction_js_1.getAction)(client, call_js_1.call, 'call')(args);
        return (0, index_js_1.hexToBool)(data ?? '0x0');
    }
    catch (error) {
        try {
            const verified = (0, isAddressEqual_js_1.isAddressEqual)((0, getAddress_js_1.getAddress)(address), await (0, recoverAddress_js_1.recoverAddress)({ hash, signature }));
            if (verified)
                return true;
        }
        catch { }
        if (error instanceof contract_js_1.CallExecutionError) {
            return false;
        }
        throw error;
    }
}
//# sourceMappingURL=verifyHash.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/actions/public/verifyMessage.js":
/*!****************************************************************!*\
  !*** ./node_modules/viem/_cjs/actions/public/verifyMessage.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.verifyMessage = verifyMessage;
const hashMessage_js_1 = __webpack_require__(/*! ../../utils/signature/hashMessage.js */ "./node_modules/viem/_cjs/utils/signature/hashMessage.js");
const verifyHash_js_1 = __webpack_require__(/*! ./verifyHash.js */ "./node_modules/viem/_cjs/actions/public/verifyHash.js");
async function verifyMessage(client, { address, message, factory, factoryData, signature, ...callRequest }) {
    const hash = (0, hashMessage_js_1.hashMessage)(message);
    return (0, verifyHash_js_1.verifyHash)(client, {
        address,
        factory: factory,
        factoryData: factoryData,
        hash,
        signature,
        ...callRequest,
    });
}
//# sourceMappingURL=verifyMessage.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/actions/public/verifyTypedData.js":
/*!******************************************************************!*\
  !*** ./node_modules/viem/_cjs/actions/public/verifyTypedData.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.verifyTypedData = verifyTypedData;
const hashTypedData_js_1 = __webpack_require__(/*! ../../utils/signature/hashTypedData.js */ "./node_modules/viem/_cjs/utils/signature/hashTypedData.js");
const verifyHash_js_1 = __webpack_require__(/*! ./verifyHash.js */ "./node_modules/viem/_cjs/actions/public/verifyHash.js");
async function verifyTypedData(client, parameters) {
    const { address, factory, factoryData, signature, message, primaryType, types, domain, ...callRequest } = parameters;
    const hash = (0, hashTypedData_js_1.hashTypedData)({ message, primaryType, types, domain });
    return (0, verifyHash_js_1.verifyHash)(client, {
        address,
        factory: factory,
        factoryData: factoryData,
        hash,
        signature,
        ...callRequest,
    });
}
//# sourceMappingURL=verifyTypedData.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/actions/public/waitForTransactionReceipt.js":
/*!****************************************************************************!*\
  !*** ./node_modules/viem/_cjs/actions/public/waitForTransactionReceipt.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.waitForTransactionReceipt = waitForTransactionReceipt;
const block_js_1 = __webpack_require__(/*! ../../errors/block.js */ "./node_modules/viem/_cjs/errors/block.js");
const transaction_js_1 = __webpack_require__(/*! ../../errors/transaction.js */ "./node_modules/viem/_cjs/errors/transaction.js");
const getAction_js_1 = __webpack_require__(/*! ../../utils/getAction.js */ "./node_modules/viem/_cjs/utils/getAction.js");
const observe_js_1 = __webpack_require__(/*! ../../utils/observe.js */ "./node_modules/viem/_cjs/utils/observe.js");
const withResolvers_js_1 = __webpack_require__(/*! ../../utils/promise/withResolvers.js */ "./node_modules/viem/_cjs/utils/promise/withResolvers.js");
const withRetry_js_1 = __webpack_require__(/*! ../../utils/promise/withRetry.js */ "./node_modules/viem/_cjs/utils/promise/withRetry.js");
const stringify_js_1 = __webpack_require__(/*! ../../utils/stringify.js */ "./node_modules/viem/_cjs/utils/stringify.js");
const getBlock_js_1 = __webpack_require__(/*! ./getBlock.js */ "./node_modules/viem/_cjs/actions/public/getBlock.js");
const getTransaction_js_1 = __webpack_require__(/*! ./getTransaction.js */ "./node_modules/viem/_cjs/actions/public/getTransaction.js");
const getTransactionReceipt_js_1 = __webpack_require__(/*! ./getTransactionReceipt.js */ "./node_modules/viem/_cjs/actions/public/getTransactionReceipt.js");
const watchBlockNumber_js_1 = __webpack_require__(/*! ./watchBlockNumber.js */ "./node_modules/viem/_cjs/actions/public/watchBlockNumber.js");
async function waitForTransactionReceipt(client, parameters) {
    const { checkReplacement = true, confirmations = 1, hash, onReplaced, retryCount = 6, retryDelay = ({ count }) => ~~(1 << count) * 200, timeout = 180_000, } = parameters;
    const observerId = (0, stringify_js_1.stringify)(['waitForTransactionReceipt', client.uid, hash]);
    const pollingInterval = (() => {
        if (parameters.pollingInterval)
            return parameters.pollingInterval;
        if (client.chain?.experimental_preconfirmationTime)
            return client.chain.experimental_preconfirmationTime;
        return client.pollingInterval;
    })();
    let transaction;
    let replacedTransaction;
    let receipt;
    let retrying = false;
    let _unobserve;
    let _unwatch;
    const { promise, resolve, reject } = (0, withResolvers_js_1.withResolvers)();
    const timer = timeout
        ? setTimeout(() => {
            _unwatch?.();
            _unobserve?.();
            reject(new transaction_js_1.WaitForTransactionReceiptTimeoutError({ hash }));
        }, timeout)
        : undefined;
    _unobserve = (0, observe_js_1.observe)(observerId, { onReplaced, resolve, reject }, async (emit) => {
        receipt = await (0, getAction_js_1.getAction)(client, getTransactionReceipt_js_1.getTransactionReceipt, 'getTransactionReceipt')({ hash }).catch(() => undefined);
        if (receipt && confirmations <= 1) {
            clearTimeout(timer);
            emit.resolve(receipt);
            _unobserve?.();
            return;
        }
        _unwatch = (0, getAction_js_1.getAction)(client, watchBlockNumber_js_1.watchBlockNumber, 'watchBlockNumber')({
            emitMissed: true,
            emitOnBegin: true,
            poll: true,
            pollingInterval,
            async onBlockNumber(blockNumber_) {
                const done = (fn) => {
                    clearTimeout(timer);
                    _unwatch?.();
                    fn();
                    _unobserve?.();
                };
                let blockNumber = blockNumber_;
                if (retrying)
                    return;
                try {
                    if (receipt) {
                        if (confirmations > 1 &&
                            (!receipt.blockNumber ||
                                blockNumber - receipt.blockNumber + 1n < confirmations))
                            return;
                        done(() => emit.resolve(receipt));
                        return;
                    }
                    if (checkReplacement && !transaction) {
                        retrying = true;
                        await (0, withRetry_js_1.withRetry)(async () => {
                            transaction = (await (0, getAction_js_1.getAction)(client, getTransaction_js_1.getTransaction, 'getTransaction')({ hash }));
                            if (transaction.blockNumber)
                                blockNumber = transaction.blockNumber;
                        }, {
                            delay: retryDelay,
                            retryCount,
                        });
                        retrying = false;
                    }
                    receipt = await (0, getAction_js_1.getAction)(client, getTransactionReceipt_js_1.getTransactionReceipt, 'getTransactionReceipt')({ hash });
                    if (confirmations > 1 &&
                        (!receipt.blockNumber ||
                            blockNumber - receipt.blockNumber + 1n < confirmations))
                        return;
                    done(() => emit.resolve(receipt));
                }
                catch (err) {
                    if (err instanceof transaction_js_1.TransactionNotFoundError ||
                        err instanceof transaction_js_1.TransactionReceiptNotFoundError) {
                        if (!transaction) {
                            retrying = false;
                            return;
                        }
                        try {
                            replacedTransaction = transaction;
                            retrying = true;
                            const block = await (0, withRetry_js_1.withRetry)(() => (0, getAction_js_1.getAction)(client, getBlock_js_1.getBlock, 'getBlock')({
                                blockNumber,
                                includeTransactions: true,
                            }), {
                                delay: retryDelay,
                                retryCount,
                                shouldRetry: ({ error }) => error instanceof block_js_1.BlockNotFoundError,
                            });
                            retrying = false;
                            const replacementTransaction = block.transactions.find(({ from, nonce }) => from === replacedTransaction.from &&
                                nonce === replacedTransaction.nonce);
                            if (!replacementTransaction)
                                return;
                            receipt = await (0, getAction_js_1.getAction)(client, getTransactionReceipt_js_1.getTransactionReceipt, 'getTransactionReceipt')({
                                hash: replacementTransaction.hash,
                            });
                            if (confirmations > 1 &&
                                (!receipt.blockNumber ||
                                    blockNumber - receipt.blockNumber + 1n < confirmations))
                                return;
                            let reason = 'replaced';
                            if (replacementTransaction.to === replacedTransaction.to &&
                                replacementTransaction.value === replacedTransaction.value &&
                                replacementTransaction.input === replacedTransaction.input) {
                                reason = 'repriced';
                            }
                            else if (replacementTransaction.from === replacementTransaction.to &&
                                replacementTransaction.value === 0n) {
                                reason = 'cancelled';
                            }
                            done(() => {
                                emit.onReplaced?.({
                                    reason,
                                    replacedTransaction: replacedTransaction,
                                    transaction: replacementTransaction,
                                    transactionReceipt: receipt,
                                });
                                emit.resolve(receipt);
                            });
                        }
                        catch (err_) {
                            done(() => emit.reject(err_));
                        }
                    }
                    else {
                        done(() => emit.reject(err));
                    }
                }
            },
        });
    });
    return promise;
}
//# sourceMappingURL=waitForTransactionReceipt.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/actions/public/watchBlockNumber.js":
/*!*******************************************************************!*\
  !*** ./node_modules/viem/_cjs/actions/public/watchBlockNumber.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.watchBlockNumber = watchBlockNumber;
const fromHex_js_1 = __webpack_require__(/*! ../../utils/encoding/fromHex.js */ "./node_modules/viem/_cjs/utils/encoding/fromHex.js");
const getAction_js_1 = __webpack_require__(/*! ../../utils/getAction.js */ "./node_modules/viem/_cjs/utils/getAction.js");
const observe_js_1 = __webpack_require__(/*! ../../utils/observe.js */ "./node_modules/viem/_cjs/utils/observe.js");
const poll_js_1 = __webpack_require__(/*! ../../utils/poll.js */ "./node_modules/viem/_cjs/utils/poll.js");
const stringify_js_1 = __webpack_require__(/*! ../../utils/stringify.js */ "./node_modules/viem/_cjs/utils/stringify.js");
const getBlockNumber_js_1 = __webpack_require__(/*! ./getBlockNumber.js */ "./node_modules/viem/_cjs/actions/public/getBlockNumber.js");
function watchBlockNumber(client, { emitOnBegin = false, emitMissed = false, onBlockNumber, onError, poll: poll_, pollingInterval = client.pollingInterval, }) {
    const enablePolling = (() => {
        if (typeof poll_ !== 'undefined')
            return poll_;
        if (client.transport.type === 'webSocket' ||
            client.transport.type === 'ipc')
            return false;
        if (client.transport.type === 'fallback' &&
            (client.transport.transports[0].config.type === 'webSocket' ||
                client.transport.transports[0].config.type === 'ipc'))
            return false;
        return true;
    })();
    let prevBlockNumber;
    const pollBlockNumber = () => {
        const observerId = (0, stringify_js_1.stringify)([
            'watchBlockNumber',
            client.uid,
            emitOnBegin,
            emitMissed,
            pollingInterval,
        ]);
        return (0, observe_js_1.observe)(observerId, { onBlockNumber, onError }, (emit) => (0, poll_js_1.poll)(async () => {
            try {
                const blockNumber = await (0, getAction_js_1.getAction)(client, getBlockNumber_js_1.getBlockNumber, 'getBlockNumber')({ cacheTime: 0 });
                if (prevBlockNumber) {
                    if (blockNumber === prevBlockNumber)
                        return;
                    if (blockNumber - prevBlockNumber > 1 && emitMissed) {
                        for (let i = prevBlockNumber + 1n; i < blockNumber; i++) {
                            emit.onBlockNumber(i, prevBlockNumber);
                            prevBlockNumber = i;
                        }
                    }
                }
                if (!prevBlockNumber || blockNumber > prevBlockNumber) {
                    emit.onBlockNumber(blockNumber, prevBlockNumber);
                    prevBlockNumber = blockNumber;
                }
            }
            catch (err) {
                emit.onError?.(err);
            }
        }, {
            emitOnBegin,
            interval: pollingInterval,
        }));
    };
    const subscribeBlockNumber = () => {
        const observerId = (0, stringify_js_1.stringify)([
            'watchBlockNumber',
            client.uid,
            emitOnBegin,
            emitMissed,
        ]);
        return (0, observe_js_1.observe)(observerId, { onBlockNumber, onError }, (emit) => {
            let active = true;
            let unsubscribe = () => (active = false);
            (async () => {
                try {
                    const transport = (() => {
                        if (client.transport.type === 'fallback') {
                            const transport = client.transport.transports.find((transport) => transport.config.type === 'webSocket' ||
                                transport.config.type === 'ipc');
                            if (!transport)
                                return client.transport;
                            return transport.value;
                        }
                        return client.transport;
                    })();
                    const { unsubscribe: unsubscribe_ } = await transport.subscribe({
                        params: ['newHeads'],
                        onData(data) {
                            if (!active)
                                return;
                            const blockNumber = (0, fromHex_js_1.hexToBigInt)(data.result?.number);
                            emit.onBlockNumber(blockNumber, prevBlockNumber);
                            prevBlockNumber = blockNumber;
                        },
                        onError(error) {
                            emit.onError?.(error);
                        },
                    });
                    unsubscribe = unsubscribe_;
                    if (!active)
                        unsubscribe();
                }
                catch (err) {
                    onError?.(err);
                }
            })();
            return () => unsubscribe();
        });
    };
    return enablePolling ? pollBlockNumber() : subscribeBlockNumber();
}
//# sourceMappingURL=watchBlockNumber.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/actions/public/watchBlocks.js":
/*!**************************************************************!*\
  !*** ./node_modules/viem/_cjs/actions/public/watchBlocks.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.watchBlocks = watchBlocks;
const getAction_js_1 = __webpack_require__(/*! ../../utils/getAction.js */ "./node_modules/viem/_cjs/utils/getAction.js");
const observe_js_1 = __webpack_require__(/*! ../../utils/observe.js */ "./node_modules/viem/_cjs/utils/observe.js");
const poll_js_1 = __webpack_require__(/*! ../../utils/poll.js */ "./node_modules/viem/_cjs/utils/poll.js");
const stringify_js_1 = __webpack_require__(/*! ../../utils/stringify.js */ "./node_modules/viem/_cjs/utils/stringify.js");
const getBlock_js_1 = __webpack_require__(/*! ./getBlock.js */ "./node_modules/viem/_cjs/actions/public/getBlock.js");
function watchBlocks(client, { blockTag = client.experimental_blockTag ?? 'latest', emitMissed = false, emitOnBegin = false, onBlock, onError, includeTransactions: includeTransactions_, poll: poll_, pollingInterval = client.pollingInterval, }) {
    const enablePolling = (() => {
        if (typeof poll_ !== 'undefined')
            return poll_;
        if (client.transport.type === 'webSocket' ||
            client.transport.type === 'ipc')
            return false;
        if (client.transport.type === 'fallback' &&
            (client.transport.transports[0].config.type === 'webSocket' ||
                client.transport.transports[0].config.type === 'ipc'))
            return false;
        return true;
    })();
    const includeTransactions = includeTransactions_ ?? false;
    let prevBlock;
    const pollBlocks = () => {
        const observerId = (0, stringify_js_1.stringify)([
            'watchBlocks',
            client.uid,
            blockTag,
            emitMissed,
            emitOnBegin,
            includeTransactions,
            pollingInterval,
        ]);
        return (0, observe_js_1.observe)(observerId, { onBlock, onError }, (emit) => (0, poll_js_1.poll)(async () => {
            try {
                const block = await (0, getAction_js_1.getAction)(client, getBlock_js_1.getBlock, 'getBlock')({
                    blockTag,
                    includeTransactions,
                });
                if (block.number !== null && prevBlock?.number != null) {
                    if (block.number === prevBlock.number)
                        return;
                    if (block.number - prevBlock.number > 1 && emitMissed) {
                        for (let i = prevBlock?.number + 1n; i < block.number; i++) {
                            const block = (await (0, getAction_js_1.getAction)(client, getBlock_js_1.getBlock, 'getBlock')({
                                blockNumber: i,
                                includeTransactions,
                            }));
                            emit.onBlock(block, prevBlock);
                            prevBlock = block;
                        }
                    }
                }
                if (prevBlock?.number == null ||
                    (blockTag === 'pending' && block?.number == null) ||
                    (block.number !== null && block.number > prevBlock.number)) {
                    emit.onBlock(block, prevBlock);
                    prevBlock = block;
                }
            }
            catch (err) {
                emit.onError?.(err);
            }
        }, {
            emitOnBegin,
            interval: pollingInterval,
        }));
    };
    const subscribeBlocks = () => {
        let active = true;
        let emitFetched = true;
        let unsubscribe = () => (active = false);
        (async () => {
            try {
                if (emitOnBegin) {
                    (0, getAction_js_1.getAction)(client, getBlock_js_1.getBlock, 'getBlock')({
                        blockTag,
                        includeTransactions,
                    })
                        .then((block) => {
                        if (!active)
                            return;
                        if (!emitFetched)
                            return;
                        onBlock(block, undefined);
                        emitFetched = false;
                    })
                        .catch(onError);
                }
                const transport = (() => {
                    if (client.transport.type === 'fallback') {
                        const transport = client.transport.transports.find((transport) => transport.config.type === 'webSocket' ||
                            transport.config.type === 'ipc');
                        if (!transport)
                            return client.transport;
                        return transport.value;
                    }
                    return client.transport;
                })();
                const { unsubscribe: unsubscribe_ } = await transport.subscribe({
                    params: ['newHeads'],
                    async onData(data) {
                        if (!active)
                            return;
                        const block = (await (0, getAction_js_1.getAction)(client, getBlock_js_1.getBlock, 'getBlock')({
                            blockNumber: data.result?.number,
                            includeTransactions,
                        }).catch(() => { }));
                        if (!active)
                            return;
                        onBlock(block, prevBlock);
                        emitFetched = false;
                        prevBlock = block;
                    },
                    onError(error) {
                        onError?.(error);
                    },
                });
                unsubscribe = unsubscribe_;
                if (!active)
                    unsubscribe();
            }
            catch (err) {
                onError?.(err);
            }
        })();
        return () => unsubscribe();
    };
    return enablePolling ? pollBlocks() : subscribeBlocks();
}
//# sourceMappingURL=watchBlocks.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/actions/public/watchContractEvent.js":
/*!*********************************************************************!*\
  !*** ./node_modules/viem/_cjs/actions/public/watchContractEvent.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.watchContractEvent = watchContractEvent;
const abi_js_1 = __webpack_require__(/*! ../../errors/abi.js */ "./node_modules/viem/_cjs/errors/abi.js");
const rpc_js_1 = __webpack_require__(/*! ../../errors/rpc.js */ "./node_modules/viem/_cjs/errors/rpc.js");
const decodeEventLog_js_1 = __webpack_require__(/*! ../../utils/abi/decodeEventLog.js */ "./node_modules/viem/_cjs/utils/abi/decodeEventLog.js");
const encodeEventTopics_js_1 = __webpack_require__(/*! ../../utils/abi/encodeEventTopics.js */ "./node_modules/viem/_cjs/utils/abi/encodeEventTopics.js");
const log_js_1 = __webpack_require__(/*! ../../utils/formatters/log.js */ "./node_modules/viem/_cjs/utils/formatters/log.js");
const getAction_js_1 = __webpack_require__(/*! ../../utils/getAction.js */ "./node_modules/viem/_cjs/utils/getAction.js");
const observe_js_1 = __webpack_require__(/*! ../../utils/observe.js */ "./node_modules/viem/_cjs/utils/observe.js");
const poll_js_1 = __webpack_require__(/*! ../../utils/poll.js */ "./node_modules/viem/_cjs/utils/poll.js");
const stringify_js_1 = __webpack_require__(/*! ../../utils/stringify.js */ "./node_modules/viem/_cjs/utils/stringify.js");
const createContractEventFilter_js_1 = __webpack_require__(/*! ./createContractEventFilter.js */ "./node_modules/viem/_cjs/actions/public/createContractEventFilter.js");
const getBlockNumber_js_1 = __webpack_require__(/*! ./getBlockNumber.js */ "./node_modules/viem/_cjs/actions/public/getBlockNumber.js");
const getContractEvents_js_1 = __webpack_require__(/*! ./getContractEvents.js */ "./node_modules/viem/_cjs/actions/public/getContractEvents.js");
const getFilterChanges_js_1 = __webpack_require__(/*! ./getFilterChanges.js */ "./node_modules/viem/_cjs/actions/public/getFilterChanges.js");
const uninstallFilter_js_1 = __webpack_require__(/*! ./uninstallFilter.js */ "./node_modules/viem/_cjs/actions/public/uninstallFilter.js");
function watchContractEvent(client, parameters) {
    const { abi, address, args, batch = true, eventName, fromBlock, onError, onLogs, poll: poll_, pollingInterval = client.pollingInterval, strict: strict_, } = parameters;
    const enablePolling = (() => {
        if (typeof poll_ !== 'undefined')
            return poll_;
        if (typeof fromBlock === 'bigint')
            return true;
        if (client.transport.type === 'webSocket' ||
            client.transport.type === 'ipc')
            return false;
        if (client.transport.type === 'fallback' &&
            (client.transport.transports[0].config.type === 'webSocket' ||
                client.transport.transports[0].config.type === 'ipc'))
            return false;
        return true;
    })();
    const pollContractEvent = () => {
        const strict = strict_ ?? false;
        const observerId = (0, stringify_js_1.stringify)([
            'watchContractEvent',
            address,
            args,
            batch,
            client.uid,
            eventName,
            pollingInterval,
            strict,
            fromBlock,
        ]);
        return (0, observe_js_1.observe)(observerId, { onLogs, onError }, (emit) => {
            let previousBlockNumber;
            if (fromBlock !== undefined)
                previousBlockNumber = fromBlock - 1n;
            let filter;
            let initialized = false;
            const unwatch = (0, poll_js_1.poll)(async () => {
                if (!initialized) {
                    try {
                        filter = (await (0, getAction_js_1.getAction)(client, createContractEventFilter_js_1.createContractEventFilter, 'createContractEventFilter')({
                            abi,
                            address,
                            args: args,
                            eventName: eventName,
                            strict: strict,
                            fromBlock,
                        }));
                    }
                    catch { }
                    initialized = true;
                    return;
                }
                try {
                    let logs;
                    if (filter) {
                        logs = await (0, getAction_js_1.getAction)(client, getFilterChanges_js_1.getFilterChanges, 'getFilterChanges')({ filter });
                    }
                    else {
                        const blockNumber = await (0, getAction_js_1.getAction)(client, getBlockNumber_js_1.getBlockNumber, 'getBlockNumber')({});
                        if (previousBlockNumber && previousBlockNumber < blockNumber) {
                            logs = await (0, getAction_js_1.getAction)(client, getContractEvents_js_1.getContractEvents, 'getContractEvents')({
                                abi,
                                address,
                                args,
                                eventName,
                                fromBlock: previousBlockNumber + 1n,
                                toBlock: blockNumber,
                                strict,
                            });
                        }
                        else {
                            logs = [];
                        }
                        previousBlockNumber = blockNumber;
                    }
                    if (logs.length === 0)
                        return;
                    if (batch)
                        emit.onLogs(logs);
                    else
                        for (const log of logs)
                            emit.onLogs([log]);
                }
                catch (err) {
                    if (filter && err instanceof rpc_js_1.InvalidInputRpcError)
                        initialized = false;
                    emit.onError?.(err);
                }
            }, {
                emitOnBegin: true,
                interval: pollingInterval,
            });
            return async () => {
                if (filter)
                    await (0, getAction_js_1.getAction)(client, uninstallFilter_js_1.uninstallFilter, 'uninstallFilter')({ filter });
                unwatch();
            };
        });
    };
    const subscribeContractEvent = () => {
        const strict = strict_ ?? false;
        const observerId = (0, stringify_js_1.stringify)([
            'watchContractEvent',
            address,
            args,
            batch,
            client.uid,
            eventName,
            pollingInterval,
            strict,
        ]);
        let active = true;
        let unsubscribe = () => (active = false);
        return (0, observe_js_1.observe)(observerId, { onLogs, onError }, (emit) => {
            ;
            (async () => {
                try {
                    const transport = (() => {
                        if (client.transport.type === 'fallback') {
                            const transport = client.transport.transports.find((transport) => transport.config.type === 'webSocket' ||
                                transport.config.type === 'ipc');
                            if (!transport)
                                return client.transport;
                            return transport.value;
                        }
                        return client.transport;
                    })();
                    const topics = eventName
                        ? (0, encodeEventTopics_js_1.encodeEventTopics)({
                            abi: abi,
                            eventName: eventName,
                            args,
                        })
                        : [];
                    const { unsubscribe: unsubscribe_ } = await transport.subscribe({
                        params: ['logs', { address, topics }],
                        onData(data) {
                            if (!active)
                                return;
                            const log = data.result;
                            try {
                                const { eventName, args } = (0, decodeEventLog_js_1.decodeEventLog)({
                                    abi: abi,
                                    data: log.data,
                                    topics: log.topics,
                                    strict: strict_,
                                });
                                const formatted = (0, log_js_1.formatLog)(log, {
                                    args,
                                    eventName: eventName,
                                });
                                emit.onLogs([formatted]);
                            }
                            catch (err) {
                                let eventName;
                                let isUnnamed;
                                if (err instanceof abi_js_1.DecodeLogDataMismatch ||
                                    err instanceof abi_js_1.DecodeLogTopicsMismatch) {
                                    if (strict_)
                                        return;
                                    eventName = err.abiItem.name;
                                    isUnnamed = err.abiItem.inputs?.some((x) => !('name' in x && x.name));
                                }
                                const formatted = (0, log_js_1.formatLog)(log, {
                                    args: isUnnamed ? [] : {},
                                    eventName,
                                });
                                emit.onLogs([formatted]);
                            }
                        },
                        onError(error) {
                            emit.onError?.(error);
                        },
                    });
                    unsubscribe = unsubscribe_;
                    if (!active)
                        unsubscribe();
                }
                catch (err) {
                    onError?.(err);
                }
            })();
            return () => unsubscribe();
        });
    };
    return enablePolling ? pollContractEvent() : subscribeContractEvent();
}
//# sourceMappingURL=watchContractEvent.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/actions/public/watchEvent.js":
/*!*************************************************************!*\
  !*** ./node_modules/viem/_cjs/actions/public/watchEvent.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.watchEvent = watchEvent;
const abi_js_1 = __webpack_require__(/*! ../../errors/abi.js */ "./node_modules/viem/_cjs/errors/abi.js");
const rpc_js_1 = __webpack_require__(/*! ../../errors/rpc.js */ "./node_modules/viem/_cjs/errors/rpc.js");
const decodeEventLog_js_1 = __webpack_require__(/*! ../../utils/abi/decodeEventLog.js */ "./node_modules/viem/_cjs/utils/abi/decodeEventLog.js");
const encodeEventTopics_js_1 = __webpack_require__(/*! ../../utils/abi/encodeEventTopics.js */ "./node_modules/viem/_cjs/utils/abi/encodeEventTopics.js");
const log_js_1 = __webpack_require__(/*! ../../utils/formatters/log.js */ "./node_modules/viem/_cjs/utils/formatters/log.js");
const getAction_js_1 = __webpack_require__(/*! ../../utils/getAction.js */ "./node_modules/viem/_cjs/utils/getAction.js");
const observe_js_1 = __webpack_require__(/*! ../../utils/observe.js */ "./node_modules/viem/_cjs/utils/observe.js");
const poll_js_1 = __webpack_require__(/*! ../../utils/poll.js */ "./node_modules/viem/_cjs/utils/poll.js");
const stringify_js_1 = __webpack_require__(/*! ../../utils/stringify.js */ "./node_modules/viem/_cjs/utils/stringify.js");
const createEventFilter_js_1 = __webpack_require__(/*! ./createEventFilter.js */ "./node_modules/viem/_cjs/actions/public/createEventFilter.js");
const getBlockNumber_js_1 = __webpack_require__(/*! ./getBlockNumber.js */ "./node_modules/viem/_cjs/actions/public/getBlockNumber.js");
const getFilterChanges_js_1 = __webpack_require__(/*! ./getFilterChanges.js */ "./node_modules/viem/_cjs/actions/public/getFilterChanges.js");
const getLogs_js_1 = __webpack_require__(/*! ./getLogs.js */ "./node_modules/viem/_cjs/actions/public/getLogs.js");
const uninstallFilter_js_1 = __webpack_require__(/*! ./uninstallFilter.js */ "./node_modules/viem/_cjs/actions/public/uninstallFilter.js");
function watchEvent(client, { address, args, batch = true, event, events, fromBlock, onError, onLogs, poll: poll_, pollingInterval = client.pollingInterval, strict: strict_, }) {
    const enablePolling = (() => {
        if (typeof poll_ !== 'undefined')
            return poll_;
        if (typeof fromBlock === 'bigint')
            return true;
        if (client.transport.type === 'webSocket' ||
            client.transport.type === 'ipc')
            return false;
        if (client.transport.type === 'fallback' &&
            (client.transport.transports[0].config.type === 'webSocket' ||
                client.transport.transports[0].config.type === 'ipc'))
            return false;
        return true;
    })();
    const strict = strict_ ?? false;
    const pollEvent = () => {
        const observerId = (0, stringify_js_1.stringify)([
            'watchEvent',
            address,
            args,
            batch,
            client.uid,
            event,
            pollingInterval,
            fromBlock,
        ]);
        return (0, observe_js_1.observe)(observerId, { onLogs, onError }, (emit) => {
            let previousBlockNumber;
            if (fromBlock !== undefined)
                previousBlockNumber = fromBlock - 1n;
            let filter;
            let initialized = false;
            const unwatch = (0, poll_js_1.poll)(async () => {
                if (!initialized) {
                    try {
                        filter = (await (0, getAction_js_1.getAction)(client, createEventFilter_js_1.createEventFilter, 'createEventFilter')({
                            address,
                            args,
                            event: event,
                            events,
                            strict,
                            fromBlock,
                        }));
                    }
                    catch { }
                    initialized = true;
                    return;
                }
                try {
                    let logs;
                    if (filter) {
                        logs = await (0, getAction_js_1.getAction)(client, getFilterChanges_js_1.getFilterChanges, 'getFilterChanges')({ filter });
                    }
                    else {
                        const blockNumber = await (0, getAction_js_1.getAction)(client, getBlockNumber_js_1.getBlockNumber, 'getBlockNumber')({});
                        if (previousBlockNumber && previousBlockNumber !== blockNumber) {
                            logs = await (0, getAction_js_1.getAction)(client, getLogs_js_1.getLogs, 'getLogs')({
                                address,
                                args,
                                event: event,
                                events,
                                fromBlock: previousBlockNumber + 1n,
                                toBlock: blockNumber,
                            });
                        }
                        else {
                            logs = [];
                        }
                        previousBlockNumber = blockNumber;
                    }
                    if (logs.length === 0)
                        return;
                    if (batch)
                        emit.onLogs(logs);
                    else
                        for (const log of logs)
                            emit.onLogs([log]);
                }
                catch (err) {
                    if (filter && err instanceof rpc_js_1.InvalidInputRpcError)
                        initialized = false;
                    emit.onError?.(err);
                }
            }, {
                emitOnBegin: true,
                interval: pollingInterval,
            });
            return async () => {
                if (filter)
                    await (0, getAction_js_1.getAction)(client, uninstallFilter_js_1.uninstallFilter, 'uninstallFilter')({ filter });
                unwatch();
            };
        });
    };
    const subscribeEvent = () => {
        let active = true;
        let unsubscribe = () => (active = false);
        (async () => {
            try {
                const transport = (() => {
                    if (client.transport.type === 'fallback') {
                        const transport = client.transport.transports.find((transport) => transport.config.type === 'webSocket' ||
                            transport.config.type === 'ipc');
                        if (!transport)
                            return client.transport;
                        return transport.value;
                    }
                    return client.transport;
                })();
                const events_ = events ?? (event ? [event] : undefined);
                let topics = [];
                if (events_) {
                    const encoded = events_.flatMap((event) => (0, encodeEventTopics_js_1.encodeEventTopics)({
                        abi: [event],
                        eventName: event.name,
                        args,
                    }));
                    topics = [encoded];
                    if (event)
                        topics = topics[0];
                }
                const { unsubscribe: unsubscribe_ } = await transport.subscribe({
                    params: ['logs', { address, topics }],
                    onData(data) {
                        if (!active)
                            return;
                        const log = data.result;
                        try {
                            const { eventName, args } = (0, decodeEventLog_js_1.decodeEventLog)({
                                abi: events_ ?? [],
                                data: log.data,
                                topics: log.topics,
                                strict,
                            });
                            const formatted = (0, log_js_1.formatLog)(log, { args, eventName });
                            onLogs([formatted]);
                        }
                        catch (err) {
                            let eventName;
                            let isUnnamed;
                            if (err instanceof abi_js_1.DecodeLogDataMismatch ||
                                err instanceof abi_js_1.DecodeLogTopicsMismatch) {
                                if (strict_)
                                    return;
                                eventName = err.abiItem.name;
                                isUnnamed = err.abiItem.inputs?.some((x) => !('name' in x && x.name));
                            }
                            const formatted = (0, log_js_1.formatLog)(log, {
                                args: isUnnamed ? [] : {},
                                eventName,
                            });
                            onLogs([formatted]);
                        }
                    },
                    onError(error) {
                        onError?.(error);
                    },
                });
                unsubscribe = unsubscribe_;
                if (!active)
                    unsubscribe();
            }
            catch (err) {
                onError?.(err);
            }
        })();
        return () => unsubscribe();
    };
    return enablePolling ? pollEvent() : subscribeEvent();
}
//# sourceMappingURL=watchEvent.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/actions/public/watchPendingTransactions.js":
/*!***************************************************************************!*\
  !*** ./node_modules/viem/_cjs/actions/public/watchPendingTransactions.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.watchPendingTransactions = watchPendingTransactions;
const getAction_js_1 = __webpack_require__(/*! ../../utils/getAction.js */ "./node_modules/viem/_cjs/utils/getAction.js");
const observe_js_1 = __webpack_require__(/*! ../../utils/observe.js */ "./node_modules/viem/_cjs/utils/observe.js");
const poll_js_1 = __webpack_require__(/*! ../../utils/poll.js */ "./node_modules/viem/_cjs/utils/poll.js");
const stringify_js_1 = __webpack_require__(/*! ../../utils/stringify.js */ "./node_modules/viem/_cjs/utils/stringify.js");
const createPendingTransactionFilter_js_1 = __webpack_require__(/*! ./createPendingTransactionFilter.js */ "./node_modules/viem/_cjs/actions/public/createPendingTransactionFilter.js");
const getFilterChanges_js_1 = __webpack_require__(/*! ./getFilterChanges.js */ "./node_modules/viem/_cjs/actions/public/getFilterChanges.js");
const uninstallFilter_js_1 = __webpack_require__(/*! ./uninstallFilter.js */ "./node_modules/viem/_cjs/actions/public/uninstallFilter.js");
function watchPendingTransactions(client, { batch = true, onError, onTransactions, poll: poll_, pollingInterval = client.pollingInterval, }) {
    const enablePolling = typeof poll_ !== 'undefined'
        ? poll_
        : client.transport.type !== 'webSocket' && client.transport.type !== 'ipc';
    const pollPendingTransactions = () => {
        const observerId = (0, stringify_js_1.stringify)([
            'watchPendingTransactions',
            client.uid,
            batch,
            pollingInterval,
        ]);
        return (0, observe_js_1.observe)(observerId, { onTransactions, onError }, (emit) => {
            let filter;
            const unwatch = (0, poll_js_1.poll)(async () => {
                try {
                    if (!filter) {
                        try {
                            filter = await (0, getAction_js_1.getAction)(client, createPendingTransactionFilter_js_1.createPendingTransactionFilter, 'createPendingTransactionFilter')({});
                            return;
                        }
                        catch (err) {
                            unwatch();
                            throw err;
                        }
                    }
                    const hashes = await (0, getAction_js_1.getAction)(client, getFilterChanges_js_1.getFilterChanges, 'getFilterChanges')({ filter });
                    if (hashes.length === 0)
                        return;
                    if (batch)
                        emit.onTransactions(hashes);
                    else
                        for (const hash of hashes)
                            emit.onTransactions([hash]);
                }
                catch (err) {
                    emit.onError?.(err);
                }
            }, {
                emitOnBegin: true,
                interval: pollingInterval,
            });
            return async () => {
                if (filter)
                    await (0, getAction_js_1.getAction)(client, uninstallFilter_js_1.uninstallFilter, 'uninstallFilter')({ filter });
                unwatch();
            };
        });
    };
    const subscribePendingTransactions = () => {
        let active = true;
        let unsubscribe = () => (active = false);
        (async () => {
            try {
                const { unsubscribe: unsubscribe_ } = await client.transport.subscribe({
                    params: ['newPendingTransactions'],
                    onData(data) {
                        if (!active)
                            return;
                        const transaction = data.result;
                        onTransactions([transaction]);
                    },
                    onError(error) {
                        onError?.(error);
                    },
                });
                unsubscribe = unsubscribe_;
                if (!active)
                    unsubscribe();
            }
            catch (err) {
                onError?.(err);
            }
        })();
        return () => unsubscribe();
    };
    return enablePolling
        ? pollPendingTransactions()
        : subscribePendingTransactions();
}
//# sourceMappingURL=watchPendingTransactions.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/actions/siwe/verifySiweMessage.js":
/*!******************************************************************!*\
  !*** ./node_modules/viem/_cjs/actions/siwe/verifySiweMessage.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.verifySiweMessage = verifySiweMessage;
const hashMessage_js_1 = __webpack_require__(/*! ../../utils/signature/hashMessage.js */ "./node_modules/viem/_cjs/utils/signature/hashMessage.js");
const parseSiweMessage_js_1 = __webpack_require__(/*! ../../utils/siwe/parseSiweMessage.js */ "./node_modules/viem/_cjs/utils/siwe/parseSiweMessage.js");
const validateSiweMessage_js_1 = __webpack_require__(/*! ../../utils/siwe/validateSiweMessage.js */ "./node_modules/viem/_cjs/utils/siwe/validateSiweMessage.js");
const verifyHash_js_1 = __webpack_require__(/*! ../public/verifyHash.js */ "./node_modules/viem/_cjs/actions/public/verifyHash.js");
async function verifySiweMessage(client, parameters) {
    const { address, domain, message, nonce, scheme, signature, time = new Date(), ...callRequest } = parameters;
    const parsed = (0, parseSiweMessage_js_1.parseSiweMessage)(message);
    if (!parsed.address)
        return false;
    const isValid = (0, validateSiweMessage_js_1.validateSiweMessage)({
        address,
        domain,
        message: parsed,
        nonce,
        scheme,
        time,
    });
    if (!isValid)
        return false;
    const hash = (0, hashMessage_js_1.hashMessage)(message);
    return (0, verifyHash_js_1.verifyHash)(client, {
        address: parsed.address,
        hash,
        signature,
        ...callRequest,
    });
}
//# sourceMappingURL=verifySiweMessage.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/actions/test/dropTransaction.js":
/*!****************************************************************!*\
  !*** ./node_modules/viem/_cjs/actions/test/dropTransaction.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.dropTransaction = dropTransaction;
async function dropTransaction(client, { hash }) {
    await client.request({
        method: `${client.mode}_dropTransaction`,
        params: [hash],
    });
}
//# sourceMappingURL=dropTransaction.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/actions/test/dumpState.js":
/*!**********************************************************!*\
  !*** ./node_modules/viem/_cjs/actions/test/dumpState.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.dumpState = dumpState;
async function dumpState(client) {
    return client.request({
        method: `${client.mode}_dumpState`,
    });
}
//# sourceMappingURL=dumpState.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/actions/test/getAutomine.js":
/*!************************************************************!*\
  !*** ./node_modules/viem/_cjs/actions/test/getAutomine.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getAutomine = getAutomine;
async function getAutomine(client) {
    if (client.mode === 'ganache')
        return await client.request({
            method: 'eth_mining',
        });
    return await client.request({
        method: `${client.mode}_getAutomine`,
    });
}
//# sourceMappingURL=getAutomine.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/actions/test/getTxpoolContent.js":
/*!*****************************************************************!*\
  !*** ./node_modules/viem/_cjs/actions/test/getTxpoolContent.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getTxpoolContent = getTxpoolContent;
async function getTxpoolContent(client) {
    return await client.request({
        method: 'txpool_content',
    });
}
//# sourceMappingURL=getTxpoolContent.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/actions/test/getTxpoolStatus.js":
/*!****************************************************************!*\
  !*** ./node_modules/viem/_cjs/actions/test/getTxpoolStatus.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getTxpoolStatus = getTxpoolStatus;
const fromHex_js_1 = __webpack_require__(/*! ../../utils/encoding/fromHex.js */ "./node_modules/viem/_cjs/utils/encoding/fromHex.js");
async function getTxpoolStatus(client) {
    const { pending, queued } = await client.request({
        method: 'txpool_status',
    });
    return {
        pending: (0, fromHex_js_1.hexToNumber)(pending),
        queued: (0, fromHex_js_1.hexToNumber)(queued),
    };
}
//# sourceMappingURL=getTxpoolStatus.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/actions/test/impersonateAccount.js":
/*!*******************************************************************!*\
  !*** ./node_modules/viem/_cjs/actions/test/impersonateAccount.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.impersonateAccount = impersonateAccount;
async function impersonateAccount(client, { address }) {
    await client.request({
        method: `${client.mode}_impersonateAccount`,
        params: [address],
    });
}
//# sourceMappingURL=impersonateAccount.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/actions/test/increaseTime.js":
/*!*************************************************************!*\
  !*** ./node_modules/viem/_cjs/actions/test/increaseTime.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.increaseTime = increaseTime;
const toHex_js_1 = __webpack_require__(/*! ../../utils/encoding/toHex.js */ "./node_modules/viem/_cjs/utils/encoding/toHex.js");
async function increaseTime(client, { seconds }) {
    return await client.request({
        method: 'evm_increaseTime',
        params: [(0, toHex_js_1.numberToHex)(seconds)],
    });
}
//# sourceMappingURL=increaseTime.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/actions/test/inspectTxpool.js":
/*!**************************************************************!*\
  !*** ./node_modules/viem/_cjs/actions/test/inspectTxpool.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.inspectTxpool = inspectTxpool;
async function inspectTxpool(client) {
    return await client.request({
        method: 'txpool_inspect',
    });
}
//# sourceMappingURL=inspectTxpool.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/actions/test/loadState.js":
/*!**********************************************************!*\
  !*** ./node_modules/viem/_cjs/actions/test/loadState.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.loadState = loadState;
async function loadState(client, { state }) {
    await client.request({
        method: `${client.mode}_loadState`,
        params: [state],
    });
}
//# sourceMappingURL=loadState.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/actions/test/mine.js":
/*!*****************************************************!*\
  !*** ./node_modules/viem/_cjs/actions/test/mine.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.mine = mine;
const toHex_js_1 = __webpack_require__(/*! ../../utils/encoding/toHex.js */ "./node_modules/viem/_cjs/utils/encoding/toHex.js");
async function mine(client, { blocks, interval }) {
    if (client.mode === 'ganache')
        await client.request({
            method: 'evm_mine',
            params: [{ blocks: (0, toHex_js_1.numberToHex)(blocks) }],
        });
    else
        await client.request({
            method: `${client.mode}_mine`,
            params: [(0, toHex_js_1.numberToHex)(blocks), (0, toHex_js_1.numberToHex)(interval || 0)],
        });
}
//# sourceMappingURL=mine.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/actions/test/removeBlockTimestampInterval.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/viem/_cjs/actions/test/removeBlockTimestampInterval.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.removeBlockTimestampInterval = removeBlockTimestampInterval;
async function removeBlockTimestampInterval(client) {
    await client.request({
        method: `${client.mode}_removeBlockTimestampInterval`,
    });
}
//# sourceMappingURL=removeBlockTimestampInterval.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/actions/test/reset.js":
/*!******************************************************!*\
  !*** ./node_modules/viem/_cjs/actions/test/reset.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.reset = reset;
async function reset(client, { blockNumber, jsonRpcUrl } = {}) {
    await client.request({
        method: `${client.mode}_reset`,
        params: [{ forking: { blockNumber: Number(blockNumber), jsonRpcUrl } }],
    });
}
//# sourceMappingURL=reset.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/actions/test/revert.js":
/*!*******************************************************!*\
  !*** ./node_modules/viem/_cjs/actions/test/revert.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.revert = revert;
async function revert(client, { id }) {
    await client.request({
        method: 'evm_revert',
        params: [id],
    });
}
//# sourceMappingURL=revert.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/actions/test/sendUnsignedTransaction.js":
/*!************************************************************************!*\
  !*** ./node_modules/viem/_cjs/actions/test/sendUnsignedTransaction.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.sendUnsignedTransaction = sendUnsignedTransaction;
const extract_js_1 = __webpack_require__(/*! ../../utils/formatters/extract.js */ "./node_modules/viem/_cjs/utils/formatters/extract.js");
const transactionRequest_js_1 = __webpack_require__(/*! ../../utils/formatters/transactionRequest.js */ "./node_modules/viem/_cjs/utils/formatters/transactionRequest.js");
async function sendUnsignedTransaction(client, args) {
    const { accessList, data, from, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce, to, value, ...rest } = args;
    const chainFormat = client.chain?.formatters?.transactionRequest?.format;
    const format = chainFormat || transactionRequest_js_1.formatTransactionRequest;
    const request = format({
        ...(0, extract_js_1.extract)(rest, { format: chainFormat }),
        accessList,
        data,
        from,
        gas,
        gasPrice,
        maxFeePerGas,
        maxPriorityFeePerGas,
        nonce,
        to,
        value,
    });
    const hash = await client.request({
        method: 'eth_sendUnsignedTransaction',
        params: [request],
    });
    return hash;
}
//# sourceMappingURL=sendUnsignedTransaction.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/actions/test/setAutomine.js":
/*!************************************************************!*\
  !*** ./node_modules/viem/_cjs/actions/test/setAutomine.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.setAutomine = setAutomine;
async function setAutomine(client, enabled) {
    if (client.mode === 'ganache') {
        if (enabled)
            await client.request({ method: 'miner_start' });
        else
            await client.request({ method: 'miner_stop' });
    }
    else
        await client.request({
            method: 'evm_setAutomine',
            params: [enabled],
        });
}
//# sourceMappingURL=setAutomine.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/actions/test/setBalance.js":
/*!***********************************************************!*\
  !*** ./node_modules/viem/_cjs/actions/test/setBalance.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.setBalance = setBalance;
const toHex_js_1 = __webpack_require__(/*! ../../utils/encoding/toHex.js */ "./node_modules/viem/_cjs/utils/encoding/toHex.js");
async function setBalance(client, { address, value }) {
    if (client.mode === 'ganache')
        await client.request({
            method: 'evm_setAccountBalance',
            params: [address, (0, toHex_js_1.numberToHex)(value)],
        });
    else
        await client.request({
            method: `${client.mode}_setBalance`,
            params: [address, (0, toHex_js_1.numberToHex)(value)],
        });
}
//# sourceMappingURL=setBalance.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/actions/test/setBlockGasLimit.js":
/*!*****************************************************************!*\
  !*** ./node_modules/viem/_cjs/actions/test/setBlockGasLimit.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.setBlockGasLimit = setBlockGasLimit;
const toHex_js_1 = __webpack_require__(/*! ../../utils/encoding/toHex.js */ "./node_modules/viem/_cjs/utils/encoding/toHex.js");
async function setBlockGasLimit(client, { gasLimit }) {
    await client.request({
        method: 'evm_setBlockGasLimit',
        params: [(0, toHex_js_1.numberToHex)(gasLimit)],
    });
}
//# sourceMappingURL=setBlockGasLimit.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/actions/test/setBlockTimestampInterval.js":
/*!**************************************************************************!*\
  !*** ./node_modules/viem/_cjs/actions/test/setBlockTimestampInterval.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.setBlockTimestampInterval = setBlockTimestampInterval;
async function setBlockTimestampInterval(client, { interval }) {
    const interval_ = (() => {
        if (client.mode === 'hardhat')
            return interval * 1000;
        return interval;
    })();
    await client.request({
        method: `${client.mode}_setBlockTimestampInterval`,
        params: [interval_],
    });
}
//# sourceMappingURL=setBlockTimestampInterval.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/actions/test/setCode.js":
/*!********************************************************!*\
  !*** ./node_modules/viem/_cjs/actions/test/setCode.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.setCode = setCode;
async function setCode(client, { address, bytecode }) {
    if (client.mode === 'ganache')
        await client.request({
            method: 'evm_setAccountCode',
            params: [address, bytecode],
        });
    else
        await client.request({
            method: `${client.mode}_setCode`,
            params: [address, bytecode],
        });
}
//# sourceMappingURL=setCode.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/actions/test/setCoinbase.js":
/*!************************************************************!*\
  !*** ./node_modules/viem/_cjs/actions/test/setCoinbase.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.setCoinbase = setCoinbase;
async function setCoinbase(client, { address }) {
    await client.request({
        method: `${client.mode}_setCoinbase`,
        params: [address],
    });
}
//# sourceMappingURL=setCoinbase.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/actions/test/setIntervalMining.js":
/*!******************************************************************!*\
  !*** ./node_modules/viem/_cjs/actions/test/setIntervalMining.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.setIntervalMining = setIntervalMining;
async function setIntervalMining(client, { interval }) {
    const interval_ = (() => {
        if (client.mode === 'hardhat')
            return interval * 1000;
        return interval;
    })();
    await client.request({
        method: 'evm_setIntervalMining',
        params: [interval_],
    });
}
//# sourceMappingURL=setIntervalMining.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/actions/test/setLoggingEnabled.js":
/*!******************************************************************!*\
  !*** ./node_modules/viem/_cjs/actions/test/setLoggingEnabled.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.setLoggingEnabled = setLoggingEnabled;
async function setLoggingEnabled(client, enabled) {
    await client.request({
        method: `${client.mode}_setLoggingEnabled`,
        params: [enabled],
    });
}
//# sourceMappingURL=setLoggingEnabled.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/actions/test/setMinGasPrice.js":
/*!***************************************************************!*\
  !*** ./node_modules/viem/_cjs/actions/test/setMinGasPrice.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.setMinGasPrice = setMinGasPrice;
const toHex_js_1 = __webpack_require__(/*! ../../utils/encoding/toHex.js */ "./node_modules/viem/_cjs/utils/encoding/toHex.js");
async function setMinGasPrice(client, { gasPrice }) {
    await client.request({
        method: `${client.mode}_setMinGasPrice`,
        params: [(0, toHex_js_1.numberToHex)(gasPrice)],
    });
}
//# sourceMappingURL=setMinGasPrice.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/actions/test/setNextBlockBaseFeePerGas.js":
/*!**************************************************************************!*\
  !*** ./node_modules/viem/_cjs/actions/test/setNextBlockBaseFeePerGas.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.setNextBlockBaseFeePerGas = setNextBlockBaseFeePerGas;
const toHex_js_1 = __webpack_require__(/*! ../../utils/encoding/toHex.js */ "./node_modules/viem/_cjs/utils/encoding/toHex.js");
async function setNextBlockBaseFeePerGas(client, { baseFeePerGas }) {
    await client.request({
        method: `${client.mode}_setNextBlockBaseFeePerGas`,
        params: [(0, toHex_js_1.numberToHex)(baseFeePerGas)],
    });
}
//# sourceMappingURL=setNextBlockBaseFeePerGas.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/actions/test/setNextBlockTimestamp.js":
/*!**********************************************************************!*\
  !*** ./node_modules/viem/_cjs/actions/test/setNextBlockTimestamp.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.setNextBlockTimestamp = setNextBlockTimestamp;
const toHex_js_1 = __webpack_require__(/*! ../../utils/encoding/toHex.js */ "./node_modules/viem/_cjs/utils/encoding/toHex.js");
async function setNextBlockTimestamp(client, { timestamp }) {
    await client.request({
        method: 'evm_setNextBlockTimestamp',
        params: [(0, toHex_js_1.numberToHex)(timestamp)],
    });
}
//# sourceMappingURL=setNextBlockTimestamp.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/actions/test/setNonce.js":
/*!*********************************************************!*\
  !*** ./node_modules/viem/_cjs/actions/test/setNonce.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.setNonce = setNonce;
const toHex_js_1 = __webpack_require__(/*! ../../utils/encoding/toHex.js */ "./node_modules/viem/_cjs/utils/encoding/toHex.js");
async function setNonce(client, { address, nonce }) {
    await client.request({
        method: `${client.mode}_setNonce`,
        params: [address, (0, toHex_js_1.numberToHex)(nonce)],
    });
}
//# sourceMappingURL=setNonce.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/actions/test/setRpcUrl.js":
/*!**********************************************************!*\
  !*** ./node_modules/viem/_cjs/actions/test/setRpcUrl.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.setRpcUrl = setRpcUrl;
async function setRpcUrl(client, jsonRpcUrl) {
    await client.request({
        method: `${client.mode}_setRpcUrl`,
        params: [jsonRpcUrl],
    });
}
//# sourceMappingURL=setRpcUrl.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/actions/test/setStorageAt.js":
/*!*************************************************************!*\
  !*** ./node_modules/viem/_cjs/actions/test/setStorageAt.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.setStorageAt = setStorageAt;
const toHex_js_1 = __webpack_require__(/*! ../../utils/encoding/toHex.js */ "./node_modules/viem/_cjs/utils/encoding/toHex.js");
async function setStorageAt(client, { address, index, value }) {
    await client.request({
        method: `${client.mode}_setStorageAt`,
        params: [
            address,
            typeof index === 'number' ? (0, toHex_js_1.numberToHex)(index) : index,
            value,
        ],
    });
}
//# sourceMappingURL=setStorageAt.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/actions/test/snapshot.js":
/*!*********************************************************!*\
  !*** ./node_modules/viem/_cjs/actions/test/snapshot.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.snapshot = snapshot;
async function snapshot(client) {
    return await client.request({
        method: 'evm_snapshot',
    });
}
//# sourceMappingURL=snapshot.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/actions/test/stopImpersonatingAccount.js":
/*!*************************************************************************!*\
  !*** ./node_modules/viem/_cjs/actions/test/stopImpersonatingAccount.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.stopImpersonatingAccount = stopImpersonatingAccount;
async function stopImpersonatingAccount(client, { address }) {
    await client.request({
        method: `${client.mode}_stopImpersonatingAccount`,
        params: [address],
    });
}
//# sourceMappingURL=stopImpersonatingAccount.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/actions/wallet/addChain.js":
/*!***********************************************************!*\
  !*** ./node_modules/viem/_cjs/actions/wallet/addChain.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.addChain = addChain;
const toHex_js_1 = __webpack_require__(/*! ../../utils/encoding/toHex.js */ "./node_modules/viem/_cjs/utils/encoding/toHex.js");
async function addChain(client, { chain }) {
    const { id, name, nativeCurrency, rpcUrls, blockExplorers } = chain;
    await client.request({
        method: 'wallet_addEthereumChain',
        params: [
            {
                chainId: (0, toHex_js_1.numberToHex)(id),
                chainName: name,
                nativeCurrency,
                rpcUrls: rpcUrls.default.http,
                blockExplorerUrls: blockExplorers
                    ? Object.values(blockExplorers).map(({ url }) => url)
                    : undefined,
            },
        ],
    }, { dedupe: true, retryCount: 0 });
}
//# sourceMappingURL=addChain.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/actions/wallet/deployContract.js":
/*!*****************************************************************!*\
  !*** ./node_modules/viem/_cjs/actions/wallet/deployContract.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.deployContract = deployContract;
const encodeDeployData_js_1 = __webpack_require__(/*! ../../utils/abi/encodeDeployData.js */ "./node_modules/viem/_cjs/utils/abi/encodeDeployData.js");
const sendTransaction_js_1 = __webpack_require__(/*! ./sendTransaction.js */ "./node_modules/viem/_cjs/actions/wallet/sendTransaction.js");
function deployContract(walletClient, parameters) {
    const { abi, args, bytecode, ...request } = parameters;
    const calldata = (0, encodeDeployData_js_1.encodeDeployData)({ abi, args, bytecode });
    return (0, sendTransaction_js_1.sendTransaction)(walletClient, {
        ...request,
        ...(request.authorizationList ? { to: null } : {}),
        data: calldata,
    });
}
//# sourceMappingURL=deployContract.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/actions/wallet/getAddresses.js":
/*!***************************************************************!*\
  !*** ./node_modules/viem/_cjs/actions/wallet/getAddresses.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getAddresses = getAddresses;
const getAddress_js_1 = __webpack_require__(/*! ../../utils/address/getAddress.js */ "./node_modules/viem/_cjs/utils/address/getAddress.js");
async function getAddresses(client) {
    if (client.account?.type === 'local')
        return [client.account.address];
    const addresses = await client.request({ method: 'eth_accounts' }, { dedupe: true });
    return addresses.map((address) => (0, getAddress_js_1.checksumAddress)(address));
}
//# sourceMappingURL=getAddresses.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/actions/wallet/getCallsStatus.js":
/*!*****************************************************************!*\
  !*** ./node_modules/viem/_cjs/actions/wallet/getCallsStatus.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getCallsStatus = getCallsStatus;
const slice_js_1 = __webpack_require__(/*! ../../utils/data/slice.js */ "./node_modules/viem/_cjs/utils/data/slice.js");
const trim_js_1 = __webpack_require__(/*! ../../utils/data/trim.js */ "./node_modules/viem/_cjs/utils/data/trim.js");
const fromHex_js_1 = __webpack_require__(/*! ../../utils/encoding/fromHex.js */ "./node_modules/viem/_cjs/utils/encoding/fromHex.js");
const transactionReceipt_js_1 = __webpack_require__(/*! ../../utils/formatters/transactionReceipt.js */ "./node_modules/viem/_cjs/utils/formatters/transactionReceipt.js");
const sendCalls_js_1 = __webpack_require__(/*! ./sendCalls.js */ "./node_modules/viem/_cjs/actions/wallet/sendCalls.js");
async function getCallsStatus(client, parameters) {
    async function getStatus(id) {
        const isTransactions = id.endsWith(sendCalls_js_1.fallbackMagicIdentifier.slice(2));
        if (isTransactions) {
            const chainId = (0, trim_js_1.trim)((0, slice_js_1.sliceHex)(id, -64, -32));
            const hashes = (0, slice_js_1.sliceHex)(id, 0, -64)
                .slice(2)
                .match(/.{1,64}/g);
            const receipts = await Promise.all(hashes.map((hash) => sendCalls_js_1.fallbackTransactionErrorMagicIdentifier.slice(2) !== hash
                ? client.request({
                    method: 'eth_getTransactionReceipt',
                    params: [`0x${hash}`],
                }, { dedupe: true })
                : undefined));
            const status = (() => {
                if (receipts.some((r) => r === null))
                    return 100;
                if (receipts.every((r) => r?.status === '0x1'))
                    return 200;
                if (receipts.every((r) => r?.status === '0x0'))
                    return 500;
                return 600;
            })();
            return {
                atomic: false,
                chainId: (0, fromHex_js_1.hexToNumber)(chainId),
                receipts: receipts.filter(Boolean),
                status,
                version: '2.0.0',
            };
        }
        return client.request({
            method: 'wallet_getCallsStatus',
            params: [id],
        });
    }
    const { atomic = false, chainId, receipts, version = '2.0.0', ...response } = await getStatus(parameters.id);
    const [status, statusCode] = (() => {
        const statusCode = response.status;
        if (statusCode >= 100 && statusCode < 200)
            return ['pending', statusCode];
        if (statusCode >= 200 && statusCode < 300)
            return ['success', statusCode];
        if (statusCode >= 300 && statusCode < 700)
            return ['failure', statusCode];
        if (statusCode === 'CONFIRMED')
            return ['success', 200];
        if (statusCode === 'PENDING')
            return ['pending', 100];
        return [undefined, statusCode];
    })();
    return {
        ...response,
        atomic,
        chainId: chainId ? (0, fromHex_js_1.hexToNumber)(chainId) : undefined,
        receipts: receipts?.map((receipt) => ({
            ...receipt,
            blockNumber: (0, fromHex_js_1.hexToBigInt)(receipt.blockNumber),
            gasUsed: (0, fromHex_js_1.hexToBigInt)(receipt.gasUsed),
            status: transactionReceipt_js_1.receiptStatuses[receipt.status],
        })) ?? [],
        statusCode,
        status,
        version,
    };
}
//# sourceMappingURL=getCallsStatus.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/actions/wallet/getCapabilities.js":
/*!******************************************************************!*\
  !*** ./node_modules/viem/_cjs/actions/wallet/getCapabilities.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getCapabilities = getCapabilities;
const parseAccount_js_1 = __webpack_require__(/*! ../../accounts/utils/parseAccount.js */ "./node_modules/viem/_cjs/accounts/utils/parseAccount.js");
const toHex_js_1 = __webpack_require__(/*! ../../utils/encoding/toHex.js */ "./node_modules/viem/_cjs/utils/encoding/toHex.js");
async function getCapabilities(client, parameters = {}) {
    const { account = client.account, chainId } = parameters;
    const account_ = account ? (0, parseAccount_js_1.parseAccount)(account) : undefined;
    const params = chainId
        ? [account_?.address, [(0, toHex_js_1.numberToHex)(chainId)]]
        : [account_?.address];
    const capabilities_raw = await client.request({
        method: 'wallet_getCapabilities',
        params,
    });
    const capabilities = {};
    for (const [chainId, capabilities_] of Object.entries(capabilities_raw)) {
        capabilities[Number(chainId)] = {};
        for (let [key, value] of Object.entries(capabilities_)) {
            if (key === 'addSubAccount')
                key = 'unstable_addSubAccount';
            capabilities[Number(chainId)][key] = value;
        }
    }
    return (typeof chainId === 'number' ? capabilities[chainId] : capabilities);
}
//# sourceMappingURL=getCapabilities.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/actions/wallet/getPermissions.js":
/*!*****************************************************************!*\
  !*** ./node_modules/viem/_cjs/actions/wallet/getPermissions.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getPermissions = getPermissions;
async function getPermissions(client) {
    const permissions = await client.request({ method: 'wallet_getPermissions' }, { dedupe: true });
    return permissions;
}
//# sourceMappingURL=getPermissions.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/actions/wallet/prepareAuthorization.js":
/*!***********************************************************************!*\
  !*** ./node_modules/viem/_cjs/actions/wallet/prepareAuthorization.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.prepareAuthorization = prepareAuthorization;
const parseAccount_js_1 = __webpack_require__(/*! ../../accounts/utils/parseAccount.js */ "./node_modules/viem/_cjs/accounts/utils/parseAccount.js");
const account_js_1 = __webpack_require__(/*! ../../errors/account.js */ "./node_modules/viem/_cjs/errors/account.js");
const isAddressEqual_js_1 = __webpack_require__(/*! ../../utils/address/isAddressEqual.js */ "./node_modules/viem/_cjs/utils/address/isAddressEqual.js");
const getAction_js_1 = __webpack_require__(/*! ../../utils/getAction.js */ "./node_modules/viem/_cjs/utils/getAction.js");
const getChainId_js_1 = __webpack_require__(/*! ../public/getChainId.js */ "./node_modules/viem/_cjs/actions/public/getChainId.js");
const getTransactionCount_js_1 = __webpack_require__(/*! ../public/getTransactionCount.js */ "./node_modules/viem/_cjs/actions/public/getTransactionCount.js");
async function prepareAuthorization(client, parameters) {
    const { account: account_ = client.account, chainId, nonce } = parameters;
    if (!account_)
        throw new account_js_1.AccountNotFoundError({
            docsPath: '/docs/eip7702/prepareAuthorization',
        });
    const account = (0, parseAccount_js_1.parseAccount)(account_);
    const executor = (() => {
        if (!parameters.executor)
            return undefined;
        if (parameters.executor === 'self')
            return parameters.executor;
        return (0, parseAccount_js_1.parseAccount)(parameters.executor);
    })();
    const authorization = {
        address: parameters.contractAddress ?? parameters.address,
        chainId,
        nonce,
    };
    if (typeof authorization.chainId === 'undefined')
        authorization.chainId =
            client.chain?.id ??
                (await (0, getAction_js_1.getAction)(client, getChainId_js_1.getChainId, 'getChainId')({}));
    if (typeof authorization.nonce === 'undefined') {
        authorization.nonce = await (0, getAction_js_1.getAction)(client, getTransactionCount_js_1.getTransactionCount, 'getTransactionCount')({
            address: account.address,
            blockTag: 'pending',
        });
        if (executor === 'self' ||
            (executor?.address && (0, isAddressEqual_js_1.isAddressEqual)(executor.address, account.address)))
            authorization.nonce += 1;
    }
    return authorization;
}
//# sourceMappingURL=prepareAuthorization.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/actions/wallet/prepareTransactionRequest.js":
/*!****************************************************************************!*\
  !*** ./node_modules/viem/_cjs/actions/wallet/prepareTransactionRequest.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.eip1559NetworkCache = exports.defaultParameters = void 0;
exports.prepareTransactionRequest = prepareTransactionRequest;
const parseAccount_js_1 = __webpack_require__(/*! ../../accounts/utils/parseAccount.js */ "./node_modules/viem/_cjs/accounts/utils/parseAccount.js");
const estimateFeesPerGas_js_1 = __webpack_require__(/*! ../../actions/public/estimateFeesPerGas.js */ "./node_modules/viem/_cjs/actions/public/estimateFeesPerGas.js");
const estimateGas_js_1 = __webpack_require__(/*! ../../actions/public/estimateGas.js */ "./node_modules/viem/_cjs/actions/public/estimateGas.js");
const getBlock_js_1 = __webpack_require__(/*! ../../actions/public/getBlock.js */ "./node_modules/viem/_cjs/actions/public/getBlock.js");
const getTransactionCount_js_1 = __webpack_require__(/*! ../../actions/public/getTransactionCount.js */ "./node_modules/viem/_cjs/actions/public/getTransactionCount.js");
const fee_js_1 = __webpack_require__(/*! ../../errors/fee.js */ "./node_modules/viem/_cjs/errors/fee.js");
const blobsToCommitments_js_1 = __webpack_require__(/*! ../../utils/blob/blobsToCommitments.js */ "./node_modules/viem/_cjs/utils/blob/blobsToCommitments.js");
const blobsToProofs_js_1 = __webpack_require__(/*! ../../utils/blob/blobsToProofs.js */ "./node_modules/viem/_cjs/utils/blob/blobsToProofs.js");
const commitmentsToVersionedHashes_js_1 = __webpack_require__(/*! ../../utils/blob/commitmentsToVersionedHashes.js */ "./node_modules/viem/_cjs/utils/blob/commitmentsToVersionedHashes.js");
const toBlobSidecars_js_1 = __webpack_require__(/*! ../../utils/blob/toBlobSidecars.js */ "./node_modules/viem/_cjs/utils/blob/toBlobSidecars.js");
const getAction_js_1 = __webpack_require__(/*! ../../utils/getAction.js */ "./node_modules/viem/_cjs/utils/getAction.js");
const assertRequest_js_1 = __webpack_require__(/*! ../../utils/transaction/assertRequest.js */ "./node_modules/viem/_cjs/utils/transaction/assertRequest.js");
const getTransactionType_js_1 = __webpack_require__(/*! ../../utils/transaction/getTransactionType.js */ "./node_modules/viem/_cjs/utils/transaction/getTransactionType.js");
const getChainId_js_1 = __webpack_require__(/*! ../public/getChainId.js */ "./node_modules/viem/_cjs/actions/public/getChainId.js");
exports.defaultParameters = [
    'blobVersionedHashes',
    'chainId',
    'fees',
    'gas',
    'nonce',
    'type',
];
exports.eip1559NetworkCache = new Map();
async function prepareTransactionRequest(client, args) {
    const { account: account_ = client.account, blobs, chain, gas, kzg, nonce, nonceManager, parameters = exports.defaultParameters, type, } = args;
    const account = account_ ? (0, parseAccount_js_1.parseAccount)(account_) : account_;
    const request = { ...args, ...(account ? { from: account?.address } : {}) };
    let block;
    async function getBlock() {
        if (block)
            return block;
        block = await (0, getAction_js_1.getAction)(client, getBlock_js_1.getBlock, 'getBlock')({ blockTag: 'latest' });
        return block;
    }
    let chainId;
    async function getChainId() {
        if (chainId)
            return chainId;
        if (chain)
            return chain.id;
        if (typeof args.chainId !== 'undefined')
            return args.chainId;
        const chainId_ = await (0, getAction_js_1.getAction)(client, getChainId_js_1.getChainId, 'getChainId')({});
        chainId = chainId_;
        return chainId;
    }
    if (parameters.includes('nonce') && typeof nonce === 'undefined' && account) {
        if (nonceManager) {
            const chainId = await getChainId();
            request.nonce = await nonceManager.consume({
                address: account.address,
                chainId,
                client,
            });
        }
        else {
            request.nonce = await (0, getAction_js_1.getAction)(client, getTransactionCount_js_1.getTransactionCount, 'getTransactionCount')({
                address: account.address,
                blockTag: 'pending',
            });
        }
    }
    if ((parameters.includes('blobVersionedHashes') ||
        parameters.includes('sidecars')) &&
        blobs &&
        kzg) {
        const commitments = (0, blobsToCommitments_js_1.blobsToCommitments)({ blobs, kzg });
        if (parameters.includes('blobVersionedHashes')) {
            const versionedHashes = (0, commitmentsToVersionedHashes_js_1.commitmentsToVersionedHashes)({
                commitments,
                to: 'hex',
            });
            request.blobVersionedHashes = versionedHashes;
        }
        if (parameters.includes('sidecars')) {
            const proofs = (0, blobsToProofs_js_1.blobsToProofs)({ blobs, commitments, kzg });
            const sidecars = (0, toBlobSidecars_js_1.toBlobSidecars)({
                blobs,
                commitments,
                proofs,
                to: 'hex',
            });
            request.sidecars = sidecars;
        }
    }
    if (parameters.includes('chainId'))
        request.chainId = await getChainId();
    if ((parameters.includes('fees') || parameters.includes('type')) &&
        typeof type === 'undefined') {
        try {
            request.type = (0, getTransactionType_js_1.getTransactionType)(request);
        }
        catch {
            let isEip1559Network = exports.eip1559NetworkCache.get(client.uid);
            if (typeof isEip1559Network === 'undefined') {
                const block = await getBlock();
                isEip1559Network = typeof block?.baseFeePerGas === 'bigint';
                exports.eip1559NetworkCache.set(client.uid, isEip1559Network);
            }
            request.type = isEip1559Network ? 'eip1559' : 'legacy';
        }
    }
    if (parameters.includes('fees')) {
        if (request.type !== 'legacy' && request.type !== 'eip2930') {
            if (typeof request.maxFeePerGas === 'undefined' ||
                typeof request.maxPriorityFeePerGas === 'undefined') {
                const block = await getBlock();
                const { maxFeePerGas, maxPriorityFeePerGas } = await (0, estimateFeesPerGas_js_1.internal_estimateFeesPerGas)(client, {
                    block: block,
                    chain,
                    request: request,
                });
                if (typeof args.maxPriorityFeePerGas === 'undefined' &&
                    args.maxFeePerGas &&
                    args.maxFeePerGas < maxPriorityFeePerGas)
                    throw new fee_js_1.MaxFeePerGasTooLowError({
                        maxPriorityFeePerGas,
                    });
                request.maxPriorityFeePerGas = maxPriorityFeePerGas;
                request.maxFeePerGas = maxFeePerGas;
            }
        }
        else {
            if (typeof args.maxFeePerGas !== 'undefined' ||
                typeof args.maxPriorityFeePerGas !== 'undefined')
                throw new fee_js_1.Eip1559FeesNotSupportedError();
            if (typeof args.gasPrice === 'undefined') {
                const block = await getBlock();
                const { gasPrice: gasPrice_ } = await (0, estimateFeesPerGas_js_1.internal_estimateFeesPerGas)(client, {
                    block: block,
                    chain,
                    request: request,
                    type: 'legacy',
                });
                request.gasPrice = gasPrice_;
            }
        }
    }
    if (parameters.includes('gas') && typeof gas === 'undefined')
        request.gas = await (0, getAction_js_1.getAction)(client, estimateGas_js_1.estimateGas, 'estimateGas')({
            ...request,
            account: account
                ? { address: account.address, type: 'json-rpc' }
                : account,
        });
    (0, assertRequest_js_1.assertRequest)(request);
    delete request.parameters;
    return request;
}
//# sourceMappingURL=prepareTransactionRequest.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/actions/wallet/requestAddresses.js":
/*!*******************************************************************!*\
  !*** ./node_modules/viem/_cjs/actions/wallet/requestAddresses.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.requestAddresses = requestAddresses;
const getAddress_js_1 = __webpack_require__(/*! ../../utils/address/getAddress.js */ "./node_modules/viem/_cjs/utils/address/getAddress.js");
async function requestAddresses(client) {
    const addresses = await client.request({ method: 'eth_requestAccounts' }, { dedupe: true, retryCount: 0 });
    return addresses.map((address) => (0, getAddress_js_1.getAddress)(address));
}
//# sourceMappingURL=requestAddresses.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/actions/wallet/requestPermissions.js":
/*!*********************************************************************!*\
  !*** ./node_modules/viem/_cjs/actions/wallet/requestPermissions.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.requestPermissions = requestPermissions;
async function requestPermissions(client, permissions) {
    return client.request({
        method: 'wallet_requestPermissions',
        params: [permissions],
    }, { retryCount: 0 });
}
//# sourceMappingURL=requestPermissions.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/actions/wallet/sendCalls.js":
/*!************************************************************!*\
  !*** ./node_modules/viem/_cjs/actions/wallet/sendCalls.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.fallbackTransactionErrorMagicIdentifier = exports.fallbackMagicIdentifier = void 0;
exports.sendCalls = sendCalls;
const parseAccount_js_1 = __webpack_require__(/*! ../../accounts/utils/parseAccount.js */ "./node_modules/viem/_cjs/accounts/utils/parseAccount.js");
const base_js_1 = __webpack_require__(/*! ../../errors/base.js */ "./node_modules/viem/_cjs/errors/base.js");
const rpc_js_1 = __webpack_require__(/*! ../../errors/rpc.js */ "./node_modules/viem/_cjs/errors/rpc.js");
const encodeFunctionData_js_1 = __webpack_require__(/*! ../../utils/abi/encodeFunctionData.js */ "./node_modules/viem/_cjs/utils/abi/encodeFunctionData.js");
const concat_js_1 = __webpack_require__(/*! ../../utils/data/concat.js */ "./node_modules/viem/_cjs/utils/data/concat.js");
const fromHex_js_1 = __webpack_require__(/*! ../../utils/encoding/fromHex.js */ "./node_modules/viem/_cjs/utils/encoding/fromHex.js");
const toHex_js_1 = __webpack_require__(/*! ../../utils/encoding/toHex.js */ "./node_modules/viem/_cjs/utils/encoding/toHex.js");
const getTransactionError_js_1 = __webpack_require__(/*! ../../utils/errors/getTransactionError.js */ "./node_modules/viem/_cjs/utils/errors/getTransactionError.js");
const sendTransaction_js_1 = __webpack_require__(/*! ./sendTransaction.js */ "./node_modules/viem/_cjs/actions/wallet/sendTransaction.js");
exports.fallbackMagicIdentifier = '0x5792579257925792579257925792579257925792579257925792579257925792';
exports.fallbackTransactionErrorMagicIdentifier = (0, toHex_js_1.numberToHex)(0, {
    size: 32,
});
async function sendCalls(client, parameters) {
    const { account: account_ = client.account, capabilities, chain = client.chain, experimental_fallback, experimental_fallbackDelay = 32, forceAtomic = false, id, version = '2.0.0', } = parameters;
    const account = account_ ? (0, parseAccount_js_1.parseAccount)(account_) : null;
    const calls = parameters.calls.map((call_) => {
        const call = call_;
        const data = call.abi
            ? (0, encodeFunctionData_js_1.encodeFunctionData)({
                abi: call.abi,
                functionName: call.functionName,
                args: call.args,
            })
            : call.data;
        return {
            data: call.dataSuffix && data ? (0, concat_js_1.concat)([data, call.dataSuffix]) : data,
            to: call.to,
            value: call.value ? (0, toHex_js_1.numberToHex)(call.value) : undefined,
        };
    });
    try {
        const response = await client.request({
            method: 'wallet_sendCalls',
            params: [
                {
                    atomicRequired: forceAtomic,
                    calls,
                    capabilities,
                    chainId: (0, toHex_js_1.numberToHex)(chain.id),
                    from: account?.address,
                    id,
                    version,
                },
            ],
        }, { retryCount: 0 });
        if (typeof response === 'string')
            return { id: response };
        return response;
    }
    catch (err) {
        const error = err;
        if (experimental_fallback &&
            (error.name === 'MethodNotFoundRpcError' ||
                error.name === 'MethodNotSupportedRpcError' ||
                error.name === 'UnknownRpcError' ||
                error.details
                    .toLowerCase()
                    .includes('does not exist / is not available') ||
                error.details.toLowerCase().includes('missing or invalid. request()') ||
                error.details
                    .toLowerCase()
                    .includes('did not match any variant of untagged enum') ||
                error.details
                    .toLowerCase()
                    .includes('account upgraded to unsupported contract') ||
                error.details.toLowerCase().includes('eip-7702 not supported') ||
                error.details.toLowerCase().includes('unsupported wc_ method') ||
                error.details.toLowerCase().includes('feature toggled misconfigured'))) {
            if (capabilities) {
                const hasNonOptionalCapability = Object.values(capabilities).some((capability) => !capability.optional);
                if (hasNonOptionalCapability) {
                    const message = 'non-optional `capabilities` are not supported on fallback to `eth_sendTransaction`.';
                    throw new rpc_js_1.UnsupportedNonOptionalCapabilityError(new base_js_1.BaseError(message, {
                        details: message,
                    }));
                }
            }
            if (forceAtomic && calls.length > 1) {
                const message = '`forceAtomic` is not supported on fallback to `eth_sendTransaction`.';
                throw new rpc_js_1.AtomicityNotSupportedError(new base_js_1.BaseError(message, {
                    details: message,
                }));
            }
            const promises = [];
            for (const call of calls) {
                const promise = (0, sendTransaction_js_1.sendTransaction)(client, {
                    account,
                    chain,
                    data: call.data,
                    to: call.to,
                    value: call.value ? (0, fromHex_js_1.hexToBigInt)(call.value) : undefined,
                });
                promises.push(promise);
                if (experimental_fallbackDelay > 0)
                    await new Promise((resolve) => setTimeout(resolve, experimental_fallbackDelay));
            }
            const results = await Promise.allSettled(promises);
            if (results.every((r) => r.status === 'rejected'))
                throw results[0].reason;
            const hashes = results.map((result) => {
                if (result.status === 'fulfilled')
                    return result.value;
                return exports.fallbackTransactionErrorMagicIdentifier;
            });
            return {
                id: (0, concat_js_1.concat)([
                    ...hashes,
                    (0, toHex_js_1.numberToHex)(chain.id, { size: 32 }),
                    exports.fallbackMagicIdentifier,
                ]),
            };
        }
        throw (0, getTransactionError_js_1.getTransactionError)(err, {
            ...parameters,
            account,
            chain: parameters.chain,
        });
    }
}
//# sourceMappingURL=sendCalls.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/actions/wallet/sendRawTransaction.js":
/*!*********************************************************************!*\
  !*** ./node_modules/viem/_cjs/actions/wallet/sendRawTransaction.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.sendRawTransaction = sendRawTransaction;
async function sendRawTransaction(client, { serializedTransaction }) {
    return client.request({
        method: 'eth_sendRawTransaction',
        params: [serializedTransaction],
    }, { retryCount: 0 });
}
//# sourceMappingURL=sendRawTransaction.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/actions/wallet/sendTransaction.js":
/*!******************************************************************!*\
  !*** ./node_modules/viem/_cjs/actions/wallet/sendTransaction.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.sendTransaction = sendTransaction;
const parseAccount_js_1 = __webpack_require__(/*! ../../accounts/utils/parseAccount.js */ "./node_modules/viem/_cjs/accounts/utils/parseAccount.js");
const account_js_1 = __webpack_require__(/*! ../../errors/account.js */ "./node_modules/viem/_cjs/errors/account.js");
const base_js_1 = __webpack_require__(/*! ../../errors/base.js */ "./node_modules/viem/_cjs/errors/base.js");
const recoverAuthorizationAddress_js_1 = __webpack_require__(/*! ../../utils/authorization/recoverAuthorizationAddress.js */ "./node_modules/viem/_cjs/utils/authorization/recoverAuthorizationAddress.js");
const assertCurrentChain_js_1 = __webpack_require__(/*! ../../utils/chain/assertCurrentChain.js */ "./node_modules/viem/_cjs/utils/chain/assertCurrentChain.js");
const getTransactionError_js_1 = __webpack_require__(/*! ../../utils/errors/getTransactionError.js */ "./node_modules/viem/_cjs/utils/errors/getTransactionError.js");
const extract_js_1 = __webpack_require__(/*! ../../utils/formatters/extract.js */ "./node_modules/viem/_cjs/utils/formatters/extract.js");
const transactionRequest_js_1 = __webpack_require__(/*! ../../utils/formatters/transactionRequest.js */ "./node_modules/viem/_cjs/utils/formatters/transactionRequest.js");
const getAction_js_1 = __webpack_require__(/*! ../../utils/getAction.js */ "./node_modules/viem/_cjs/utils/getAction.js");
const lru_js_1 = __webpack_require__(/*! ../../utils/lru.js */ "./node_modules/viem/_cjs/utils/lru.js");
const assertRequest_js_1 = __webpack_require__(/*! ../../utils/transaction/assertRequest.js */ "./node_modules/viem/_cjs/utils/transaction/assertRequest.js");
const getChainId_js_1 = __webpack_require__(/*! ../public/getChainId.js */ "./node_modules/viem/_cjs/actions/public/getChainId.js");
const prepareTransactionRequest_js_1 = __webpack_require__(/*! ./prepareTransactionRequest.js */ "./node_modules/viem/_cjs/actions/wallet/prepareTransactionRequest.js");
const sendRawTransaction_js_1 = __webpack_require__(/*! ./sendRawTransaction.js */ "./node_modules/viem/_cjs/actions/wallet/sendRawTransaction.js");
const supportsWalletNamespace = new lru_js_1.LruMap(128);
async function sendTransaction(client, parameters) {
    const { account: account_ = client.account, chain = client.chain, accessList, authorizationList, blobs, data, gas, gasPrice, maxFeePerBlobGas, maxFeePerGas, maxPriorityFeePerGas, nonce, type, value, ...rest } = parameters;
    if (typeof account_ === 'undefined')
        throw new account_js_1.AccountNotFoundError({
            docsPath: '/docs/actions/wallet/sendTransaction',
        });
    const account = account_ ? (0, parseAccount_js_1.parseAccount)(account_) : null;
    try {
        (0, assertRequest_js_1.assertRequest)(parameters);
        const to = await (async () => {
            if (parameters.to)
                return parameters.to;
            if (parameters.to === null)
                return undefined;
            if (authorizationList && authorizationList.length > 0)
                return await (0, recoverAuthorizationAddress_js_1.recoverAuthorizationAddress)({
                    authorization: authorizationList[0],
                }).catch(() => {
                    throw new base_js_1.BaseError('`to` is required. Could not infer from `authorizationList`.');
                });
            return undefined;
        })();
        if (account?.type === 'json-rpc' || account === null) {
            let chainId;
            if (chain !== null) {
                chainId = await (0, getAction_js_1.getAction)(client, getChainId_js_1.getChainId, 'getChainId')({});
                (0, assertCurrentChain_js_1.assertCurrentChain)({
                    currentChainId: chainId,
                    chain,
                });
            }
            const chainFormat = client.chain?.formatters?.transactionRequest?.format;
            const format = chainFormat || transactionRequest_js_1.formatTransactionRequest;
            const request = format({
                ...(0, extract_js_1.extract)(rest, { format: chainFormat }),
                accessList,
                authorizationList,
                blobs,
                chainId,
                data,
                from: account?.address,
                gas,
                gasPrice,
                maxFeePerBlobGas,
                maxFeePerGas,
                maxPriorityFeePerGas,
                nonce,
                to,
                type,
                value,
            });
            const isWalletNamespaceSupported = supportsWalletNamespace.get(client.uid);
            const method = isWalletNamespaceSupported
                ? 'wallet_sendTransaction'
                : 'eth_sendTransaction';
            try {
                return await client.request({
                    method,
                    params: [request],
                }, { retryCount: 0 });
            }
            catch (e) {
                if (isWalletNamespaceSupported === false)
                    throw e;
                const error = e;
                if (error.name === 'InvalidInputRpcError' ||
                    error.name === 'InvalidParamsRpcError' ||
                    error.name === 'MethodNotFoundRpcError' ||
                    error.name === 'MethodNotSupportedRpcError') {
                    return await client
                        .request({
                        method: 'wallet_sendTransaction',
                        params: [request],
                    }, { retryCount: 0 })
                        .then((hash) => {
                        supportsWalletNamespace.set(client.uid, true);
                        return hash;
                    })
                        .catch((e) => {
                        const walletNamespaceError = e;
                        if (walletNamespaceError.name === 'MethodNotFoundRpcError' ||
                            walletNamespaceError.name === 'MethodNotSupportedRpcError') {
                            supportsWalletNamespace.set(client.uid, false);
                            throw error;
                        }
                        throw walletNamespaceError;
                    });
                }
                throw error;
            }
        }
        if (account?.type === 'local') {
            const request = await (0, getAction_js_1.getAction)(client, prepareTransactionRequest_js_1.prepareTransactionRequest, 'prepareTransactionRequest')({
                account,
                accessList,
                authorizationList,
                blobs,
                chain,
                data,
                gas,
                gasPrice,
                maxFeePerBlobGas,
                maxFeePerGas,
                maxPriorityFeePerGas,
                nonce,
                nonceManager: account.nonceManager,
                parameters: [...prepareTransactionRequest_js_1.defaultParameters, 'sidecars'],
                type,
                value,
                ...rest,
                to,
            });
            const serializer = chain?.serializers?.transaction;
            const serializedTransaction = (await account.signTransaction(request, {
                serializer,
            }));
            return await (0, getAction_js_1.getAction)(client, sendRawTransaction_js_1.sendRawTransaction, 'sendRawTransaction')({
                serializedTransaction,
            });
        }
        if (account?.type === 'smart')
            throw new account_js_1.AccountTypeNotSupportedError({
                metaMessages: [
                    'Consider using the `sendUserOperation` Action instead.',
                ],
                docsPath: '/docs/actions/bundler/sendUserOperation',
                type: 'smart',
            });
        throw new account_js_1.AccountTypeNotSupportedError({
            docsPath: '/docs/actions/wallet/sendTransaction',
            type: account?.type,
        });
    }
    catch (err) {
        if (err instanceof account_js_1.AccountTypeNotSupportedError)
            throw err;
        throw (0, getTransactionError_js_1.getTransactionError)(err, {
            ...parameters,
            account,
            chain: parameters.chain || undefined,
        });
    }
}
//# sourceMappingURL=sendTransaction.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/actions/wallet/showCallsStatus.js":
/*!******************************************************************!*\
  !*** ./node_modules/viem/_cjs/actions/wallet/showCallsStatus.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.showCallsStatus = showCallsStatus;
async function showCallsStatus(client, parameters) {
    const { id } = parameters;
    await client.request({
        method: 'wallet_showCallsStatus',
        params: [id],
    });
    return;
}
//# sourceMappingURL=showCallsStatus.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/actions/wallet/signAuthorization.js":
/*!********************************************************************!*\
  !*** ./node_modules/viem/_cjs/actions/wallet/signAuthorization.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.signAuthorization = signAuthorization;
const parseAccount_js_1 = __webpack_require__(/*! ../../accounts/utils/parseAccount.js */ "./node_modules/viem/_cjs/accounts/utils/parseAccount.js");
const account_js_1 = __webpack_require__(/*! ../../errors/account.js */ "./node_modules/viem/_cjs/errors/account.js");
const prepareAuthorization_js_1 = __webpack_require__(/*! ./prepareAuthorization.js */ "./node_modules/viem/_cjs/actions/wallet/prepareAuthorization.js");
async function signAuthorization(client, parameters) {
    const { account: account_ = client.account } = parameters;
    if (!account_)
        throw new account_js_1.AccountNotFoundError({
            docsPath: '/docs/eip7702/signAuthorization',
        });
    const account = (0, parseAccount_js_1.parseAccount)(account_);
    if (!account.signAuthorization)
        throw new account_js_1.AccountTypeNotSupportedError({
            docsPath: '/docs/eip7702/signAuthorization',
            metaMessages: [
                'The `signAuthorization` Action does not support JSON-RPC Accounts.',
            ],
            type: account.type,
        });
    const authorization = await (0, prepareAuthorization_js_1.prepareAuthorization)(client, parameters);
    return account.signAuthorization(authorization);
}
//# sourceMappingURL=signAuthorization.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/actions/wallet/signMessage.js":
/*!**************************************************************!*\
  !*** ./node_modules/viem/_cjs/actions/wallet/signMessage.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.signMessage = signMessage;
const parseAccount_js_1 = __webpack_require__(/*! ../../accounts/utils/parseAccount.js */ "./node_modules/viem/_cjs/accounts/utils/parseAccount.js");
const account_js_1 = __webpack_require__(/*! ../../errors/account.js */ "./node_modules/viem/_cjs/errors/account.js");
const toHex_js_1 = __webpack_require__(/*! ../../utils/encoding/toHex.js */ "./node_modules/viem/_cjs/utils/encoding/toHex.js");
async function signMessage(client, { account: account_ = client.account, message, }) {
    if (!account_)
        throw new account_js_1.AccountNotFoundError({
            docsPath: '/docs/actions/wallet/signMessage',
        });
    const account = (0, parseAccount_js_1.parseAccount)(account_);
    if (account.signMessage)
        return account.signMessage({ message });
    const message_ = (() => {
        if (typeof message === 'string')
            return (0, toHex_js_1.stringToHex)(message);
        if (message.raw instanceof Uint8Array)
            return (0, toHex_js_1.toHex)(message.raw);
        return message.raw;
    })();
    return client.request({
        method: 'personal_sign',
        params: [message_, account.address],
    }, { retryCount: 0 });
}
//# sourceMappingURL=signMessage.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/actions/wallet/signTransaction.js":
/*!******************************************************************!*\
  !*** ./node_modules/viem/_cjs/actions/wallet/signTransaction.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.signTransaction = signTransaction;
const parseAccount_js_1 = __webpack_require__(/*! ../../accounts/utils/parseAccount.js */ "./node_modules/viem/_cjs/accounts/utils/parseAccount.js");
const account_js_1 = __webpack_require__(/*! ../../errors/account.js */ "./node_modules/viem/_cjs/errors/account.js");
const assertCurrentChain_js_1 = __webpack_require__(/*! ../../utils/chain/assertCurrentChain.js */ "./node_modules/viem/_cjs/utils/chain/assertCurrentChain.js");
const toHex_js_1 = __webpack_require__(/*! ../../utils/encoding/toHex.js */ "./node_modules/viem/_cjs/utils/encoding/toHex.js");
const transactionRequest_js_1 = __webpack_require__(/*! ../../utils/formatters/transactionRequest.js */ "./node_modules/viem/_cjs/utils/formatters/transactionRequest.js");
const getAction_js_1 = __webpack_require__(/*! ../../utils/getAction.js */ "./node_modules/viem/_cjs/utils/getAction.js");
const assertRequest_js_1 = __webpack_require__(/*! ../../utils/transaction/assertRequest.js */ "./node_modules/viem/_cjs/utils/transaction/assertRequest.js");
const getChainId_js_1 = __webpack_require__(/*! ../public/getChainId.js */ "./node_modules/viem/_cjs/actions/public/getChainId.js");
async function signTransaction(client, parameters) {
    const { account: account_ = client.account, chain = client.chain, ...transaction } = parameters;
    if (!account_)
        throw new account_js_1.AccountNotFoundError({
            docsPath: '/docs/actions/wallet/signTransaction',
        });
    const account = (0, parseAccount_js_1.parseAccount)(account_);
    (0, assertRequest_js_1.assertRequest)({
        account,
        ...parameters,
    });
    const chainId = await (0, getAction_js_1.getAction)(client, getChainId_js_1.getChainId, 'getChainId')({});
    if (chain !== null)
        (0, assertCurrentChain_js_1.assertCurrentChain)({
            currentChainId: chainId,
            chain,
        });
    const formatters = chain?.formatters || client.chain?.formatters;
    const format = formatters?.transactionRequest?.format || transactionRequest_js_1.formatTransactionRequest;
    if (account.signTransaction)
        return account.signTransaction({
            ...transaction,
            chainId,
        }, { serializer: client.chain?.serializers?.transaction });
    return await client.request({
        method: 'eth_signTransaction',
        params: [
            {
                ...format(transaction),
                chainId: (0, toHex_js_1.numberToHex)(chainId),
                from: account.address,
            },
        ],
    }, { retryCount: 0 });
}
//# sourceMappingURL=signTransaction.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/actions/wallet/signTypedData.js":
/*!****************************************************************!*\
  !*** ./node_modules/viem/_cjs/actions/wallet/signTypedData.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.signTypedData = signTypedData;
const parseAccount_js_1 = __webpack_require__(/*! ../../accounts/utils/parseAccount.js */ "./node_modules/viem/_cjs/accounts/utils/parseAccount.js");
const account_js_1 = __webpack_require__(/*! ../../errors/account.js */ "./node_modules/viem/_cjs/errors/account.js");
const typedData_js_1 = __webpack_require__(/*! ../../utils/typedData.js */ "./node_modules/viem/_cjs/utils/typedData.js");
async function signTypedData(client, parameters) {
    const { account: account_ = client.account, domain, message, primaryType, } = parameters;
    if (!account_)
        throw new account_js_1.AccountNotFoundError({
            docsPath: '/docs/actions/wallet/signTypedData',
        });
    const account = (0, parseAccount_js_1.parseAccount)(account_);
    const types = {
        EIP712Domain: (0, typedData_js_1.getTypesForEIP712Domain)({ domain }),
        ...parameters.types,
    };
    (0, typedData_js_1.validateTypedData)({ domain, message, primaryType, types });
    if (account.signTypedData)
        return account.signTypedData({ domain, message, primaryType, types });
    const typedData = (0, typedData_js_1.serializeTypedData)({ domain, message, primaryType, types });
    return client.request({
        method: 'eth_signTypedData_v4',
        params: [account.address, typedData],
    }, { retryCount: 0 });
}
//# sourceMappingURL=signTypedData.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/actions/wallet/switchChain.js":
/*!**************************************************************!*\
  !*** ./node_modules/viem/_cjs/actions/wallet/switchChain.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.switchChain = switchChain;
const toHex_js_1 = __webpack_require__(/*! ../../utils/encoding/toHex.js */ "./node_modules/viem/_cjs/utils/encoding/toHex.js");
async function switchChain(client, { id }) {
    await client.request({
        method: 'wallet_switchEthereumChain',
        params: [
            {
                chainId: (0, toHex_js_1.numberToHex)(id),
            },
        ],
    }, { retryCount: 0 });
}
//# sourceMappingURL=switchChain.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/actions/wallet/waitForCallsStatus.js":
/*!*********************************************************************!*\
  !*** ./node_modules/viem/_cjs/actions/wallet/waitForCallsStatus.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WaitForCallsStatusTimeoutError = void 0;
exports.waitForCallsStatus = waitForCallsStatus;
const base_js_1 = __webpack_require__(/*! ../../errors/base.js */ "./node_modules/viem/_cjs/errors/base.js");
const calls_js_1 = __webpack_require__(/*! ../../errors/calls.js */ "./node_modules/viem/_cjs/errors/calls.js");
const observe_js_1 = __webpack_require__(/*! ../../utils/observe.js */ "./node_modules/viem/_cjs/utils/observe.js");
const poll_js_1 = __webpack_require__(/*! ../../utils/poll.js */ "./node_modules/viem/_cjs/utils/poll.js");
const withResolvers_js_1 = __webpack_require__(/*! ../../utils/promise/withResolvers.js */ "./node_modules/viem/_cjs/utils/promise/withResolvers.js");
const withRetry_js_1 = __webpack_require__(/*! ../../utils/promise/withRetry.js */ "./node_modules/viem/_cjs/utils/promise/withRetry.js");
const stringify_js_1 = __webpack_require__(/*! ../../utils/stringify.js */ "./node_modules/viem/_cjs/utils/stringify.js");
const getCallsStatus_js_1 = __webpack_require__(/*! ./getCallsStatus.js */ "./node_modules/viem/_cjs/actions/wallet/getCallsStatus.js");
async function waitForCallsStatus(client, parameters) {
    const { id, pollingInterval = client.pollingInterval, status = ({ statusCode }) => statusCode === 200 || statusCode >= 300, retryCount = 4, retryDelay = ({ count }) => ~~(1 << count) * 200, timeout = 60_000, throwOnFailure = false, } = parameters;
    const observerId = (0, stringify_js_1.stringify)(['waitForCallsStatus', client.uid, id]);
    const { promise, resolve, reject } = (0, withResolvers_js_1.withResolvers)();
    let timer;
    const unobserve = (0, observe_js_1.observe)(observerId, { resolve, reject }, (emit) => {
        const unpoll = (0, poll_js_1.poll)(async () => {
            const done = (fn) => {
                clearTimeout(timer);
                unpoll();
                fn();
                unobserve();
            };
            try {
                const result = await (0, withRetry_js_1.withRetry)(async () => {
                    const result = await (0, getCallsStatus_js_1.getCallsStatus)(client, { id });
                    if (throwOnFailure && result.status === 'failure')
                        throw new calls_js_1.BundleFailedError(result);
                    return result;
                }, {
                    retryCount,
                    delay: retryDelay,
                });
                if (!status(result))
                    return;
                done(() => emit.resolve(result));
            }
            catch (error) {
                done(() => emit.reject(error));
            }
        }, {
            interval: pollingInterval,
            emitOnBegin: true,
        });
        return unpoll;
    });
    timer = timeout
        ? setTimeout(() => {
            unobserve();
            clearTimeout(timer);
            reject(new WaitForCallsStatusTimeoutError({ id }));
        }, timeout)
        : undefined;
    return await promise;
}
class WaitForCallsStatusTimeoutError extends base_js_1.BaseError {
    constructor({ id }) {
        super(`Timed out while waiting for call bundle with id "${id}" to be confirmed.`, { name: 'WaitForCallsStatusTimeoutError' });
    }
}
exports.WaitForCallsStatusTimeoutError = WaitForCallsStatusTimeoutError;
//# sourceMappingURL=waitForCallsStatus.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/actions/wallet/watchAsset.js":
/*!*************************************************************!*\
  !*** ./node_modules/viem/_cjs/actions/wallet/watchAsset.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.watchAsset = watchAsset;
async function watchAsset(client, params) {
    const added = await client.request({
        method: 'wallet_watchAsset',
        params,
    }, { retryCount: 0 });
    return added;
}
//# sourceMappingURL=watchAsset.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/actions/wallet/writeContract.js":
/*!****************************************************************!*\
  !*** ./node_modules/viem/_cjs/actions/wallet/writeContract.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.writeContract = writeContract;
const parseAccount_js_1 = __webpack_require__(/*! ../../accounts/utils/parseAccount.js */ "./node_modules/viem/_cjs/accounts/utils/parseAccount.js");
const account_js_1 = __webpack_require__(/*! ../../errors/account.js */ "./node_modules/viem/_cjs/errors/account.js");
const encodeFunctionData_js_1 = __webpack_require__(/*! ../../utils/abi/encodeFunctionData.js */ "./node_modules/viem/_cjs/utils/abi/encodeFunctionData.js");
const getContractError_js_1 = __webpack_require__(/*! ../../utils/errors/getContractError.js */ "./node_modules/viem/_cjs/utils/errors/getContractError.js");
const getAction_js_1 = __webpack_require__(/*! ../../utils/getAction.js */ "./node_modules/viem/_cjs/utils/getAction.js");
const sendTransaction_js_1 = __webpack_require__(/*! ./sendTransaction.js */ "./node_modules/viem/_cjs/actions/wallet/sendTransaction.js");
async function writeContract(client, parameters) {
    const { abi, account: account_ = client.account, address, args, dataSuffix, functionName, ...request } = parameters;
    if (typeof account_ === 'undefined')
        throw new account_js_1.AccountNotFoundError({
            docsPath: '/docs/contract/writeContract',
        });
    const account = account_ ? (0, parseAccount_js_1.parseAccount)(account_) : null;
    const data = (0, encodeFunctionData_js_1.encodeFunctionData)({
        abi,
        args,
        functionName,
    });
    try {
        return await (0, getAction_js_1.getAction)(client, sendTransaction_js_1.sendTransaction, 'sendTransaction')({
            data: `${data}${dataSuffix ? dataSuffix.replace('0x', '') : ''}`,
            to: address,
            account,
            ...request,
        });
    }
    catch (error) {
        throw (0, getContractError_js_1.getContractError)(error, {
            abi,
            address,
            args,
            docsPath: '/docs/contract/writeContract',
            functionName,
            sender: account?.address,
        });
    }
}
//# sourceMappingURL=writeContract.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/clients/createClient.js":
/*!********************************************************!*\
  !*** ./node_modules/viem/_cjs/clients/createClient.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createClient = createClient;
exports.rpcSchema = rpcSchema;
const parseAccount_js_1 = __webpack_require__(/*! ../accounts/utils/parseAccount.js */ "./node_modules/viem/_cjs/accounts/utils/parseAccount.js");
const uid_js_1 = __webpack_require__(/*! ../utils/uid.js */ "./node_modules/viem/_cjs/utils/uid.js");
function createClient(parameters) {
    const { batch, chain, ccipRead, key = 'base', name = 'Base Client', type = 'base', } = parameters;
    const experimental_blockTag = parameters.experimental_blockTag ??
        (typeof chain?.experimental_preconfirmationTime === 'number'
            ? 'pending'
            : undefined);
    const blockTime = chain?.blockTime ?? 12_000;
    const defaultPollingInterval = Math.min(Math.max(Math.floor(blockTime / 2), 500), 4_000);
    const pollingInterval = parameters.pollingInterval ?? defaultPollingInterval;
    const cacheTime = parameters.cacheTime ?? pollingInterval;
    const account = parameters.account
        ? (0, parseAccount_js_1.parseAccount)(parameters.account)
        : undefined;
    const { config, request, value } = parameters.transport({
        chain,
        pollingInterval,
    });
    const transport = { ...config, ...value };
    const client = {
        account,
        batch,
        cacheTime,
        ccipRead,
        chain,
        key,
        name,
        pollingInterval,
        request,
        transport,
        type,
        uid: (0, uid_js_1.uid)(),
        ...(experimental_blockTag ? { experimental_blockTag } : {}),
    };
    function extend(base) {
        return (extendFn) => {
            const extended = extendFn(base);
            for (const key in client)
                delete extended[key];
            const combined = { ...base, ...extended };
            return Object.assign(combined, { extend: extend(combined) });
        };
    }
    return Object.assign(client, { extend: extend(client) });
}
function rpcSchema() {
    return null;
}
//# sourceMappingURL=createClient.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/clients/createPublicClient.js":
/*!**************************************************************!*\
  !*** ./node_modules/viem/_cjs/clients/createPublicClient.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createPublicClient = createPublicClient;
const createClient_js_1 = __webpack_require__(/*! ./createClient.js */ "./node_modules/viem/_cjs/clients/createClient.js");
const public_js_1 = __webpack_require__(/*! ./decorators/public.js */ "./node_modules/viem/_cjs/clients/decorators/public.js");
function createPublicClient(parameters) {
    const { key = 'public', name = 'Public Client' } = parameters;
    const client = (0, createClient_js_1.createClient)({
        ...parameters,
        key,
        name,
        type: 'publicClient',
    });
    return client.extend(public_js_1.publicActions);
}
//# sourceMappingURL=createPublicClient.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/clients/createTestClient.js":
/*!************************************************************!*\
  !*** ./node_modules/viem/_cjs/clients/createTestClient.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createTestClient = createTestClient;
const createClient_js_1 = __webpack_require__(/*! ./createClient.js */ "./node_modules/viem/_cjs/clients/createClient.js");
const test_js_1 = __webpack_require__(/*! ./decorators/test.js */ "./node_modules/viem/_cjs/clients/decorators/test.js");
function createTestClient(parameters) {
    const { key = 'test', name = 'Test Client', mode } = parameters;
    const client = (0, createClient_js_1.createClient)({
        ...parameters,
        key,
        name,
        type: 'testClient',
    });
    return client.extend((config) => ({
        mode,
        ...(0, test_js_1.testActions)({ mode })(config),
    }));
}
//# sourceMappingURL=createTestClient.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/clients/createWalletClient.js":
/*!**************************************************************!*\
  !*** ./node_modules/viem/_cjs/clients/createWalletClient.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createWalletClient = createWalletClient;
const createClient_js_1 = __webpack_require__(/*! ./createClient.js */ "./node_modules/viem/_cjs/clients/createClient.js");
const wallet_js_1 = __webpack_require__(/*! ./decorators/wallet.js */ "./node_modules/viem/_cjs/clients/decorators/wallet.js");
function createWalletClient(parameters) {
    const { key = 'wallet', name = 'Wallet Client', transport } = parameters;
    const client = (0, createClient_js_1.createClient)({
        ...parameters,
        key,
        name,
        transport,
        type: 'walletClient',
    });
    return client.extend(wallet_js_1.walletActions);
}
//# sourceMappingURL=createWalletClient.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/clients/decorators/public.js":
/*!*************************************************************!*\
  !*** ./node_modules/viem/_cjs/clients/decorators/public.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.publicActions = publicActions;
const getEnsAddress_js_1 = __webpack_require__(/*! ../../actions/ens/getEnsAddress.js */ "./node_modules/viem/_cjs/actions/ens/getEnsAddress.js");
const getEnsAvatar_js_1 = __webpack_require__(/*! ../../actions/ens/getEnsAvatar.js */ "./node_modules/viem/_cjs/actions/ens/getEnsAvatar.js");
const getEnsName_js_1 = __webpack_require__(/*! ../../actions/ens/getEnsName.js */ "./node_modules/viem/_cjs/actions/ens/getEnsName.js");
const getEnsResolver_js_1 = __webpack_require__(/*! ../../actions/ens/getEnsResolver.js */ "./node_modules/viem/_cjs/actions/ens/getEnsResolver.js");
const getEnsText_js_1 = __webpack_require__(/*! ../../actions/ens/getEnsText.js */ "./node_modules/viem/_cjs/actions/ens/getEnsText.js");
const call_js_1 = __webpack_require__(/*! ../../actions/public/call.js */ "./node_modules/viem/_cjs/actions/public/call.js");
const createAccessList_js_1 = __webpack_require__(/*! ../../actions/public/createAccessList.js */ "./node_modules/viem/_cjs/actions/public/createAccessList.js");
const createBlockFilter_js_1 = __webpack_require__(/*! ../../actions/public/createBlockFilter.js */ "./node_modules/viem/_cjs/actions/public/createBlockFilter.js");
const createContractEventFilter_js_1 = __webpack_require__(/*! ../../actions/public/createContractEventFilter.js */ "./node_modules/viem/_cjs/actions/public/createContractEventFilter.js");
const createEventFilter_js_1 = __webpack_require__(/*! ../../actions/public/createEventFilter.js */ "./node_modules/viem/_cjs/actions/public/createEventFilter.js");
const createPendingTransactionFilter_js_1 = __webpack_require__(/*! ../../actions/public/createPendingTransactionFilter.js */ "./node_modules/viem/_cjs/actions/public/createPendingTransactionFilter.js");
const estimateContractGas_js_1 = __webpack_require__(/*! ../../actions/public/estimateContractGas.js */ "./node_modules/viem/_cjs/actions/public/estimateContractGas.js");
const estimateFeesPerGas_js_1 = __webpack_require__(/*! ../../actions/public/estimateFeesPerGas.js */ "./node_modules/viem/_cjs/actions/public/estimateFeesPerGas.js");
const estimateGas_js_1 = __webpack_require__(/*! ../../actions/public/estimateGas.js */ "./node_modules/viem/_cjs/actions/public/estimateGas.js");
const estimateMaxPriorityFeePerGas_js_1 = __webpack_require__(/*! ../../actions/public/estimateMaxPriorityFeePerGas.js */ "./node_modules/viem/_cjs/actions/public/estimateMaxPriorityFeePerGas.js");
const getBalance_js_1 = __webpack_require__(/*! ../../actions/public/getBalance.js */ "./node_modules/viem/_cjs/actions/public/getBalance.js");
const getBlobBaseFee_js_1 = __webpack_require__(/*! ../../actions/public/getBlobBaseFee.js */ "./node_modules/viem/_cjs/actions/public/getBlobBaseFee.js");
const getBlock_js_1 = __webpack_require__(/*! ../../actions/public/getBlock.js */ "./node_modules/viem/_cjs/actions/public/getBlock.js");
const getBlockNumber_js_1 = __webpack_require__(/*! ../../actions/public/getBlockNumber.js */ "./node_modules/viem/_cjs/actions/public/getBlockNumber.js");
const getBlockTransactionCount_js_1 = __webpack_require__(/*! ../../actions/public/getBlockTransactionCount.js */ "./node_modules/viem/_cjs/actions/public/getBlockTransactionCount.js");
const getChainId_js_1 = __webpack_require__(/*! ../../actions/public/getChainId.js */ "./node_modules/viem/_cjs/actions/public/getChainId.js");
const getCode_js_1 = __webpack_require__(/*! ../../actions/public/getCode.js */ "./node_modules/viem/_cjs/actions/public/getCode.js");
const getContractEvents_js_1 = __webpack_require__(/*! ../../actions/public/getContractEvents.js */ "./node_modules/viem/_cjs/actions/public/getContractEvents.js");
const getEip712Domain_js_1 = __webpack_require__(/*! ../../actions/public/getEip712Domain.js */ "./node_modules/viem/_cjs/actions/public/getEip712Domain.js");
const getFeeHistory_js_1 = __webpack_require__(/*! ../../actions/public/getFeeHistory.js */ "./node_modules/viem/_cjs/actions/public/getFeeHistory.js");
const getFilterChanges_js_1 = __webpack_require__(/*! ../../actions/public/getFilterChanges.js */ "./node_modules/viem/_cjs/actions/public/getFilterChanges.js");
const getFilterLogs_js_1 = __webpack_require__(/*! ../../actions/public/getFilterLogs.js */ "./node_modules/viem/_cjs/actions/public/getFilterLogs.js");
const getGasPrice_js_1 = __webpack_require__(/*! ../../actions/public/getGasPrice.js */ "./node_modules/viem/_cjs/actions/public/getGasPrice.js");
const getLogs_js_1 = __webpack_require__(/*! ../../actions/public/getLogs.js */ "./node_modules/viem/_cjs/actions/public/getLogs.js");
const getProof_js_1 = __webpack_require__(/*! ../../actions/public/getProof.js */ "./node_modules/viem/_cjs/actions/public/getProof.js");
const getStorageAt_js_1 = __webpack_require__(/*! ../../actions/public/getStorageAt.js */ "./node_modules/viem/_cjs/actions/public/getStorageAt.js");
const getTransaction_js_1 = __webpack_require__(/*! ../../actions/public/getTransaction.js */ "./node_modules/viem/_cjs/actions/public/getTransaction.js");
const getTransactionConfirmations_js_1 = __webpack_require__(/*! ../../actions/public/getTransactionConfirmations.js */ "./node_modules/viem/_cjs/actions/public/getTransactionConfirmations.js");
const getTransactionCount_js_1 = __webpack_require__(/*! ../../actions/public/getTransactionCount.js */ "./node_modules/viem/_cjs/actions/public/getTransactionCount.js");
const getTransactionReceipt_js_1 = __webpack_require__(/*! ../../actions/public/getTransactionReceipt.js */ "./node_modules/viem/_cjs/actions/public/getTransactionReceipt.js");
const multicall_js_1 = __webpack_require__(/*! ../../actions/public/multicall.js */ "./node_modules/viem/_cjs/actions/public/multicall.js");
const readContract_js_1 = __webpack_require__(/*! ../../actions/public/readContract.js */ "./node_modules/viem/_cjs/actions/public/readContract.js");
const simulateBlocks_js_1 = __webpack_require__(/*! ../../actions/public/simulateBlocks.js */ "./node_modules/viem/_cjs/actions/public/simulateBlocks.js");
const simulateCalls_js_1 = __webpack_require__(/*! ../../actions/public/simulateCalls.js */ "./node_modules/viem/_cjs/actions/public/simulateCalls.js");
const simulateContract_js_1 = __webpack_require__(/*! ../../actions/public/simulateContract.js */ "./node_modules/viem/_cjs/actions/public/simulateContract.js");
const uninstallFilter_js_1 = __webpack_require__(/*! ../../actions/public/uninstallFilter.js */ "./node_modules/viem/_cjs/actions/public/uninstallFilter.js");
const verifyMessage_js_1 = __webpack_require__(/*! ../../actions/public/verifyMessage.js */ "./node_modules/viem/_cjs/actions/public/verifyMessage.js");
const verifyTypedData_js_1 = __webpack_require__(/*! ../../actions/public/verifyTypedData.js */ "./node_modules/viem/_cjs/actions/public/verifyTypedData.js");
const waitForTransactionReceipt_js_1 = __webpack_require__(/*! ../../actions/public/waitForTransactionReceipt.js */ "./node_modules/viem/_cjs/actions/public/waitForTransactionReceipt.js");
const watchBlockNumber_js_1 = __webpack_require__(/*! ../../actions/public/watchBlockNumber.js */ "./node_modules/viem/_cjs/actions/public/watchBlockNumber.js");
const watchBlocks_js_1 = __webpack_require__(/*! ../../actions/public/watchBlocks.js */ "./node_modules/viem/_cjs/actions/public/watchBlocks.js");
const watchContractEvent_js_1 = __webpack_require__(/*! ../../actions/public/watchContractEvent.js */ "./node_modules/viem/_cjs/actions/public/watchContractEvent.js");
const watchEvent_js_1 = __webpack_require__(/*! ../../actions/public/watchEvent.js */ "./node_modules/viem/_cjs/actions/public/watchEvent.js");
const watchPendingTransactions_js_1 = __webpack_require__(/*! ../../actions/public/watchPendingTransactions.js */ "./node_modules/viem/_cjs/actions/public/watchPendingTransactions.js");
const verifySiweMessage_js_1 = __webpack_require__(/*! ../../actions/siwe/verifySiweMessage.js */ "./node_modules/viem/_cjs/actions/siwe/verifySiweMessage.js");
const prepareTransactionRequest_js_1 = __webpack_require__(/*! ../../actions/wallet/prepareTransactionRequest.js */ "./node_modules/viem/_cjs/actions/wallet/prepareTransactionRequest.js");
const sendRawTransaction_js_1 = __webpack_require__(/*! ../../actions/wallet/sendRawTransaction.js */ "./node_modules/viem/_cjs/actions/wallet/sendRawTransaction.js");
function publicActions(client) {
    return {
        call: (args) => (0, call_js_1.call)(client, args),
        createAccessList: (args) => (0, createAccessList_js_1.createAccessList)(client, args),
        createBlockFilter: () => (0, createBlockFilter_js_1.createBlockFilter)(client),
        createContractEventFilter: (args) => (0, createContractEventFilter_js_1.createContractEventFilter)(client, args),
        createEventFilter: (args) => (0, createEventFilter_js_1.createEventFilter)(client, args),
        createPendingTransactionFilter: () => (0, createPendingTransactionFilter_js_1.createPendingTransactionFilter)(client),
        estimateContractGas: (args) => (0, estimateContractGas_js_1.estimateContractGas)(client, args),
        estimateGas: (args) => (0, estimateGas_js_1.estimateGas)(client, args),
        getBalance: (args) => (0, getBalance_js_1.getBalance)(client, args),
        getBlobBaseFee: () => (0, getBlobBaseFee_js_1.getBlobBaseFee)(client),
        getBlock: (args) => (0, getBlock_js_1.getBlock)(client, args),
        getBlockNumber: (args) => (0, getBlockNumber_js_1.getBlockNumber)(client, args),
        getBlockTransactionCount: (args) => (0, getBlockTransactionCount_js_1.getBlockTransactionCount)(client, args),
        getBytecode: (args) => (0, getCode_js_1.getCode)(client, args),
        getChainId: () => (0, getChainId_js_1.getChainId)(client),
        getCode: (args) => (0, getCode_js_1.getCode)(client, args),
        getContractEvents: (args) => (0, getContractEvents_js_1.getContractEvents)(client, args),
        getEip712Domain: (args) => (0, getEip712Domain_js_1.getEip712Domain)(client, args),
        getEnsAddress: (args) => (0, getEnsAddress_js_1.getEnsAddress)(client, args),
        getEnsAvatar: (args) => (0, getEnsAvatar_js_1.getEnsAvatar)(client, args),
        getEnsName: (args) => (0, getEnsName_js_1.getEnsName)(client, args),
        getEnsResolver: (args) => (0, getEnsResolver_js_1.getEnsResolver)(client, args),
        getEnsText: (args) => (0, getEnsText_js_1.getEnsText)(client, args),
        getFeeHistory: (args) => (0, getFeeHistory_js_1.getFeeHistory)(client, args),
        estimateFeesPerGas: (args) => (0, estimateFeesPerGas_js_1.estimateFeesPerGas)(client, args),
        getFilterChanges: (args) => (0, getFilterChanges_js_1.getFilterChanges)(client, args),
        getFilterLogs: (args) => (0, getFilterLogs_js_1.getFilterLogs)(client, args),
        getGasPrice: () => (0, getGasPrice_js_1.getGasPrice)(client),
        getLogs: (args) => (0, getLogs_js_1.getLogs)(client, args),
        getProof: (args) => (0, getProof_js_1.getProof)(client, args),
        estimateMaxPriorityFeePerGas: (args) => (0, estimateMaxPriorityFeePerGas_js_1.estimateMaxPriorityFeePerGas)(client, args),
        getStorageAt: (args) => (0, getStorageAt_js_1.getStorageAt)(client, args),
        getTransaction: (args) => (0, getTransaction_js_1.getTransaction)(client, args),
        getTransactionConfirmations: (args) => (0, getTransactionConfirmations_js_1.getTransactionConfirmations)(client, args),
        getTransactionCount: (args) => (0, getTransactionCount_js_1.getTransactionCount)(client, args),
        getTransactionReceipt: (args) => (0, getTransactionReceipt_js_1.getTransactionReceipt)(client, args),
        multicall: (args) => (0, multicall_js_1.multicall)(client, args),
        prepareTransactionRequest: (args) => (0, prepareTransactionRequest_js_1.prepareTransactionRequest)(client, args),
        readContract: (args) => (0, readContract_js_1.readContract)(client, args),
        sendRawTransaction: (args) => (0, sendRawTransaction_js_1.sendRawTransaction)(client, args),
        simulate: (args) => (0, simulateBlocks_js_1.simulateBlocks)(client, args),
        simulateBlocks: (args) => (0, simulateBlocks_js_1.simulateBlocks)(client, args),
        simulateCalls: (args) => (0, simulateCalls_js_1.simulateCalls)(client, args),
        simulateContract: (args) => (0, simulateContract_js_1.simulateContract)(client, args),
        verifyMessage: (args) => (0, verifyMessage_js_1.verifyMessage)(client, args),
        verifySiweMessage: (args) => (0, verifySiweMessage_js_1.verifySiweMessage)(client, args),
        verifyTypedData: (args) => (0, verifyTypedData_js_1.verifyTypedData)(client, args),
        uninstallFilter: (args) => (0, uninstallFilter_js_1.uninstallFilter)(client, args),
        waitForTransactionReceipt: (args) => (0, waitForTransactionReceipt_js_1.waitForTransactionReceipt)(client, args),
        watchBlocks: (args) => (0, watchBlocks_js_1.watchBlocks)(client, args),
        watchBlockNumber: (args) => (0, watchBlockNumber_js_1.watchBlockNumber)(client, args),
        watchContractEvent: (args) => (0, watchContractEvent_js_1.watchContractEvent)(client, args),
        watchEvent: (args) => (0, watchEvent_js_1.watchEvent)(client, args),
        watchPendingTransactions: (args) => (0, watchPendingTransactions_js_1.watchPendingTransactions)(client, args),
    };
}
//# sourceMappingURL=public.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/clients/decorators/test.js":
/*!***********************************************************!*\
  !*** ./node_modules/viem/_cjs/clients/decorators/test.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.testActions = testActions;
const dropTransaction_js_1 = __webpack_require__(/*! ../../actions/test/dropTransaction.js */ "./node_modules/viem/_cjs/actions/test/dropTransaction.js");
const dumpState_js_1 = __webpack_require__(/*! ../../actions/test/dumpState.js */ "./node_modules/viem/_cjs/actions/test/dumpState.js");
const getAutomine_js_1 = __webpack_require__(/*! ../../actions/test/getAutomine.js */ "./node_modules/viem/_cjs/actions/test/getAutomine.js");
const getTxpoolContent_js_1 = __webpack_require__(/*! ../../actions/test/getTxpoolContent.js */ "./node_modules/viem/_cjs/actions/test/getTxpoolContent.js");
const getTxpoolStatus_js_1 = __webpack_require__(/*! ../../actions/test/getTxpoolStatus.js */ "./node_modules/viem/_cjs/actions/test/getTxpoolStatus.js");
const impersonateAccount_js_1 = __webpack_require__(/*! ../../actions/test/impersonateAccount.js */ "./node_modules/viem/_cjs/actions/test/impersonateAccount.js");
const increaseTime_js_1 = __webpack_require__(/*! ../../actions/test/increaseTime.js */ "./node_modules/viem/_cjs/actions/test/increaseTime.js");
const inspectTxpool_js_1 = __webpack_require__(/*! ../../actions/test/inspectTxpool.js */ "./node_modules/viem/_cjs/actions/test/inspectTxpool.js");
const loadState_js_1 = __webpack_require__(/*! ../../actions/test/loadState.js */ "./node_modules/viem/_cjs/actions/test/loadState.js");
const mine_js_1 = __webpack_require__(/*! ../../actions/test/mine.js */ "./node_modules/viem/_cjs/actions/test/mine.js");
const removeBlockTimestampInterval_js_1 = __webpack_require__(/*! ../../actions/test/removeBlockTimestampInterval.js */ "./node_modules/viem/_cjs/actions/test/removeBlockTimestampInterval.js");
const reset_js_1 = __webpack_require__(/*! ../../actions/test/reset.js */ "./node_modules/viem/_cjs/actions/test/reset.js");
const revert_js_1 = __webpack_require__(/*! ../../actions/test/revert.js */ "./node_modules/viem/_cjs/actions/test/revert.js");
const sendUnsignedTransaction_js_1 = __webpack_require__(/*! ../../actions/test/sendUnsignedTransaction.js */ "./node_modules/viem/_cjs/actions/test/sendUnsignedTransaction.js");
const setAutomine_js_1 = __webpack_require__(/*! ../../actions/test/setAutomine.js */ "./node_modules/viem/_cjs/actions/test/setAutomine.js");
const setBalance_js_1 = __webpack_require__(/*! ../../actions/test/setBalance.js */ "./node_modules/viem/_cjs/actions/test/setBalance.js");
const setBlockGasLimit_js_1 = __webpack_require__(/*! ../../actions/test/setBlockGasLimit.js */ "./node_modules/viem/_cjs/actions/test/setBlockGasLimit.js");
const setBlockTimestampInterval_js_1 = __webpack_require__(/*! ../../actions/test/setBlockTimestampInterval.js */ "./node_modules/viem/_cjs/actions/test/setBlockTimestampInterval.js");
const setCode_js_1 = __webpack_require__(/*! ../../actions/test/setCode.js */ "./node_modules/viem/_cjs/actions/test/setCode.js");
const setCoinbase_js_1 = __webpack_require__(/*! ../../actions/test/setCoinbase.js */ "./node_modules/viem/_cjs/actions/test/setCoinbase.js");
const setIntervalMining_js_1 = __webpack_require__(/*! ../../actions/test/setIntervalMining.js */ "./node_modules/viem/_cjs/actions/test/setIntervalMining.js");
const setLoggingEnabled_js_1 = __webpack_require__(/*! ../../actions/test/setLoggingEnabled.js */ "./node_modules/viem/_cjs/actions/test/setLoggingEnabled.js");
const setMinGasPrice_js_1 = __webpack_require__(/*! ../../actions/test/setMinGasPrice.js */ "./node_modules/viem/_cjs/actions/test/setMinGasPrice.js");
const setNextBlockBaseFeePerGas_js_1 = __webpack_require__(/*! ../../actions/test/setNextBlockBaseFeePerGas.js */ "./node_modules/viem/_cjs/actions/test/setNextBlockBaseFeePerGas.js");
const setNextBlockTimestamp_js_1 = __webpack_require__(/*! ../../actions/test/setNextBlockTimestamp.js */ "./node_modules/viem/_cjs/actions/test/setNextBlockTimestamp.js");
const setNonce_js_1 = __webpack_require__(/*! ../../actions/test/setNonce.js */ "./node_modules/viem/_cjs/actions/test/setNonce.js");
const setRpcUrl_js_1 = __webpack_require__(/*! ../../actions/test/setRpcUrl.js */ "./node_modules/viem/_cjs/actions/test/setRpcUrl.js");
const setStorageAt_js_1 = __webpack_require__(/*! ../../actions/test/setStorageAt.js */ "./node_modules/viem/_cjs/actions/test/setStorageAt.js");
const snapshot_js_1 = __webpack_require__(/*! ../../actions/test/snapshot.js */ "./node_modules/viem/_cjs/actions/test/snapshot.js");
const stopImpersonatingAccount_js_1 = __webpack_require__(/*! ../../actions/test/stopImpersonatingAccount.js */ "./node_modules/viem/_cjs/actions/test/stopImpersonatingAccount.js");
function testActions({ mode, }) {
    return (client_) => {
        const client = client_.extend(() => ({
            mode,
        }));
        return {
            dropTransaction: (args) => (0, dropTransaction_js_1.dropTransaction)(client, args),
            dumpState: () => (0, dumpState_js_1.dumpState)(client),
            getAutomine: () => (0, getAutomine_js_1.getAutomine)(client),
            getTxpoolContent: () => (0, getTxpoolContent_js_1.getTxpoolContent)(client),
            getTxpoolStatus: () => (0, getTxpoolStatus_js_1.getTxpoolStatus)(client),
            impersonateAccount: (args) => (0, impersonateAccount_js_1.impersonateAccount)(client, args),
            increaseTime: (args) => (0, increaseTime_js_1.increaseTime)(client, args),
            inspectTxpool: () => (0, inspectTxpool_js_1.inspectTxpool)(client),
            loadState: (args) => (0, loadState_js_1.loadState)(client, args),
            mine: (args) => (0, mine_js_1.mine)(client, args),
            removeBlockTimestampInterval: () => (0, removeBlockTimestampInterval_js_1.removeBlockTimestampInterval)(client),
            reset: (args) => (0, reset_js_1.reset)(client, args),
            revert: (args) => (0, revert_js_1.revert)(client, args),
            sendUnsignedTransaction: (args) => (0, sendUnsignedTransaction_js_1.sendUnsignedTransaction)(client, args),
            setAutomine: (args) => (0, setAutomine_js_1.setAutomine)(client, args),
            setBalance: (args) => (0, setBalance_js_1.setBalance)(client, args),
            setBlockGasLimit: (args) => (0, setBlockGasLimit_js_1.setBlockGasLimit)(client, args),
            setBlockTimestampInterval: (args) => (0, setBlockTimestampInterval_js_1.setBlockTimestampInterval)(client, args),
            setCode: (args) => (0, setCode_js_1.setCode)(client, args),
            setCoinbase: (args) => (0, setCoinbase_js_1.setCoinbase)(client, args),
            setIntervalMining: (args) => (0, setIntervalMining_js_1.setIntervalMining)(client, args),
            setLoggingEnabled: (args) => (0, setLoggingEnabled_js_1.setLoggingEnabled)(client, args),
            setMinGasPrice: (args) => (0, setMinGasPrice_js_1.setMinGasPrice)(client, args),
            setNextBlockBaseFeePerGas: (args) => (0, setNextBlockBaseFeePerGas_js_1.setNextBlockBaseFeePerGas)(client, args),
            setNextBlockTimestamp: (args) => (0, setNextBlockTimestamp_js_1.setNextBlockTimestamp)(client, args),
            setNonce: (args) => (0, setNonce_js_1.setNonce)(client, args),
            setRpcUrl: (args) => (0, setRpcUrl_js_1.setRpcUrl)(client, args),
            setStorageAt: (args) => (0, setStorageAt_js_1.setStorageAt)(client, args),
            snapshot: () => (0, snapshot_js_1.snapshot)(client),
            stopImpersonatingAccount: (args) => (0, stopImpersonatingAccount_js_1.stopImpersonatingAccount)(client, args),
        };
    };
}
//# sourceMappingURL=test.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/clients/decorators/wallet.js":
/*!*************************************************************!*\
  !*** ./node_modules/viem/_cjs/clients/decorators/wallet.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.walletActions = walletActions;
const getChainId_js_1 = __webpack_require__(/*! ../../actions/public/getChainId.js */ "./node_modules/viem/_cjs/actions/public/getChainId.js");
const addChain_js_1 = __webpack_require__(/*! ../../actions/wallet/addChain.js */ "./node_modules/viem/_cjs/actions/wallet/addChain.js");
const deployContract_js_1 = __webpack_require__(/*! ../../actions/wallet/deployContract.js */ "./node_modules/viem/_cjs/actions/wallet/deployContract.js");
const getAddresses_js_1 = __webpack_require__(/*! ../../actions/wallet/getAddresses.js */ "./node_modules/viem/_cjs/actions/wallet/getAddresses.js");
const getCallsStatus_js_1 = __webpack_require__(/*! ../../actions/wallet/getCallsStatus.js */ "./node_modules/viem/_cjs/actions/wallet/getCallsStatus.js");
const getCapabilities_js_1 = __webpack_require__(/*! ../../actions/wallet/getCapabilities.js */ "./node_modules/viem/_cjs/actions/wallet/getCapabilities.js");
const getPermissions_js_1 = __webpack_require__(/*! ../../actions/wallet/getPermissions.js */ "./node_modules/viem/_cjs/actions/wallet/getPermissions.js");
const prepareAuthorization_js_1 = __webpack_require__(/*! ../../actions/wallet/prepareAuthorization.js */ "./node_modules/viem/_cjs/actions/wallet/prepareAuthorization.js");
const prepareTransactionRequest_js_1 = __webpack_require__(/*! ../../actions/wallet/prepareTransactionRequest.js */ "./node_modules/viem/_cjs/actions/wallet/prepareTransactionRequest.js");
const requestAddresses_js_1 = __webpack_require__(/*! ../../actions/wallet/requestAddresses.js */ "./node_modules/viem/_cjs/actions/wallet/requestAddresses.js");
const requestPermissions_js_1 = __webpack_require__(/*! ../../actions/wallet/requestPermissions.js */ "./node_modules/viem/_cjs/actions/wallet/requestPermissions.js");
const sendCalls_js_1 = __webpack_require__(/*! ../../actions/wallet/sendCalls.js */ "./node_modules/viem/_cjs/actions/wallet/sendCalls.js");
const sendRawTransaction_js_1 = __webpack_require__(/*! ../../actions/wallet/sendRawTransaction.js */ "./node_modules/viem/_cjs/actions/wallet/sendRawTransaction.js");
const sendTransaction_js_1 = __webpack_require__(/*! ../../actions/wallet/sendTransaction.js */ "./node_modules/viem/_cjs/actions/wallet/sendTransaction.js");
const showCallsStatus_js_1 = __webpack_require__(/*! ../../actions/wallet/showCallsStatus.js */ "./node_modules/viem/_cjs/actions/wallet/showCallsStatus.js");
const signAuthorization_js_1 = __webpack_require__(/*! ../../actions/wallet/signAuthorization.js */ "./node_modules/viem/_cjs/actions/wallet/signAuthorization.js");
const signMessage_js_1 = __webpack_require__(/*! ../../actions/wallet/signMessage.js */ "./node_modules/viem/_cjs/actions/wallet/signMessage.js");
const signTransaction_js_1 = __webpack_require__(/*! ../../actions/wallet/signTransaction.js */ "./node_modules/viem/_cjs/actions/wallet/signTransaction.js");
const signTypedData_js_1 = __webpack_require__(/*! ../../actions/wallet/signTypedData.js */ "./node_modules/viem/_cjs/actions/wallet/signTypedData.js");
const switchChain_js_1 = __webpack_require__(/*! ../../actions/wallet/switchChain.js */ "./node_modules/viem/_cjs/actions/wallet/switchChain.js");
const waitForCallsStatus_js_1 = __webpack_require__(/*! ../../actions/wallet/waitForCallsStatus.js */ "./node_modules/viem/_cjs/actions/wallet/waitForCallsStatus.js");
const watchAsset_js_1 = __webpack_require__(/*! ../../actions/wallet/watchAsset.js */ "./node_modules/viem/_cjs/actions/wallet/watchAsset.js");
const writeContract_js_1 = __webpack_require__(/*! ../../actions/wallet/writeContract.js */ "./node_modules/viem/_cjs/actions/wallet/writeContract.js");
function walletActions(client) {
    return {
        addChain: (args) => (0, addChain_js_1.addChain)(client, args),
        deployContract: (args) => (0, deployContract_js_1.deployContract)(client, args),
        getAddresses: () => (0, getAddresses_js_1.getAddresses)(client),
        getCallsStatus: (args) => (0, getCallsStatus_js_1.getCallsStatus)(client, args),
        getCapabilities: (args) => (0, getCapabilities_js_1.getCapabilities)(client, args),
        getChainId: () => (0, getChainId_js_1.getChainId)(client),
        getPermissions: () => (0, getPermissions_js_1.getPermissions)(client),
        prepareAuthorization: (args) => (0, prepareAuthorization_js_1.prepareAuthorization)(client, args),
        prepareTransactionRequest: (args) => (0, prepareTransactionRequest_js_1.prepareTransactionRequest)(client, args),
        requestAddresses: () => (0, requestAddresses_js_1.requestAddresses)(client),
        requestPermissions: (args) => (0, requestPermissions_js_1.requestPermissions)(client, args),
        sendCalls: (args) => (0, sendCalls_js_1.sendCalls)(client, args),
        sendRawTransaction: (args) => (0, sendRawTransaction_js_1.sendRawTransaction)(client, args),
        sendTransaction: (args) => (0, sendTransaction_js_1.sendTransaction)(client, args),
        showCallsStatus: (args) => (0, showCallsStatus_js_1.showCallsStatus)(client, args),
        signAuthorization: (args) => (0, signAuthorization_js_1.signAuthorization)(client, args),
        signMessage: (args) => (0, signMessage_js_1.signMessage)(client, args),
        signTransaction: (args) => (0, signTransaction_js_1.signTransaction)(client, args),
        signTypedData: (args) => (0, signTypedData_js_1.signTypedData)(client, args),
        switchChain: (args) => (0, switchChain_js_1.switchChain)(client, args),
        waitForCallsStatus: (args) => (0, waitForCallsStatus_js_1.waitForCallsStatus)(client, args),
        watchAsset: (args) => (0, watchAsset_js_1.watchAsset)(client, args),
        writeContract: (args) => (0, writeContract_js_1.writeContract)(client, args),
    };
}
//# sourceMappingURL=wallet.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/clients/transports/createTransport.js":
/*!**********************************************************************!*\
  !*** ./node_modules/viem/_cjs/clients/transports/createTransport.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createTransport = createTransport;
const buildRequest_js_1 = __webpack_require__(/*! ../../utils/buildRequest.js */ "./node_modules/viem/_cjs/utils/buildRequest.js");
const uid_js_1 = __webpack_require__(/*! ../../utils/uid.js */ "./node_modules/viem/_cjs/utils/uid.js");
function createTransport({ key, methods, name, request, retryCount = 3, retryDelay = 150, timeout, type, }, value) {
    const uid = (0, uid_js_1.uid)();
    return {
        config: {
            key,
            methods,
            name,
            request,
            retryCount,
            retryDelay,
            timeout,
            type,
        },
        request: (0, buildRequest_js_1.buildRequest)(request, { methods, retryCount, retryDelay, uid }),
        value,
    };
}
//# sourceMappingURL=createTransport.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/clients/transports/custom.js":
/*!*************************************************************!*\
  !*** ./node_modules/viem/_cjs/clients/transports/custom.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.custom = custom;
const createTransport_js_1 = __webpack_require__(/*! ./createTransport.js */ "./node_modules/viem/_cjs/clients/transports/createTransport.js");
function custom(provider, config = {}) {
    const { key = 'custom', methods, name = 'Custom Provider', retryDelay, } = config;
    return ({ retryCount: defaultRetryCount }) => (0, createTransport_js_1.createTransport)({
        key,
        methods,
        name,
        request: provider.request.bind(provider),
        retryCount: config.retryCount ?? defaultRetryCount,
        retryDelay,
        type: 'custom',
    });
}
//# sourceMappingURL=custom.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/clients/transports/fallback.js":
/*!***************************************************************!*\
  !*** ./node_modules/viem/_cjs/clients/transports/fallback.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.fallback = fallback;
exports.shouldThrow = shouldThrow;
exports.rankTransports = rankTransports;
const node_js_1 = __webpack_require__(/*! ../../errors/node.js */ "./node_modules/viem/_cjs/errors/node.js");
const rpc_js_1 = __webpack_require__(/*! ../../errors/rpc.js */ "./node_modules/viem/_cjs/errors/rpc.js");
const wait_js_1 = __webpack_require__(/*! ../../utils/wait.js */ "./node_modules/viem/_cjs/utils/wait.js");
const createTransport_js_1 = __webpack_require__(/*! ./createTransport.js */ "./node_modules/viem/_cjs/clients/transports/createTransport.js");
function fallback(transports_, config = {}) {
    const { key = 'fallback', name = 'Fallback', rank = false, shouldThrow: shouldThrow_ = shouldThrow, retryCount, retryDelay, } = config;
    return (({ chain, pollingInterval = 4_000, timeout, ...rest }) => {
        let transports = transports_;
        let onResponse = () => { };
        const transport = (0, createTransport_js_1.createTransport)({
            key,
            name,
            async request({ method, params }) {
                let includes;
                const fetch = async (i = 0) => {
                    const transport = transports[i]({
                        ...rest,
                        chain,
                        retryCount: 0,
                        timeout,
                    });
                    try {
                        const response = await transport.request({
                            method,
                            params,
                        });
                        onResponse({
                            method,
                            params: params,
                            response,
                            transport,
                            status: 'success',
                        });
                        return response;
                    }
                    catch (err) {
                        onResponse({
                            error: err,
                            method,
                            params: params,
                            transport,
                            status: 'error',
                        });
                        if (shouldThrow_(err))
                            throw err;
                        if (i === transports.length - 1)
                            throw err;
                        includes ??= transports.slice(i + 1).some((transport) => {
                            const { include, exclude } = transport({ chain }).config.methods || {};
                            if (include)
                                return include.includes(method);
                            if (exclude)
                                return !exclude.includes(method);
                            return true;
                        });
                        if (!includes)
                            throw err;
                        return fetch(i + 1);
                    }
                };
                return fetch();
            },
            retryCount,
            retryDelay,
            type: 'fallback',
        }, {
            onResponse: (fn) => (onResponse = fn),
            transports: transports.map((fn) => fn({ chain, retryCount: 0 })),
        });
        if (rank) {
            const rankOptions = (typeof rank === 'object' ? rank : {});
            rankTransports({
                chain,
                interval: rankOptions.interval ?? pollingInterval,
                onTransports: (transports_) => (transports = transports_),
                ping: rankOptions.ping,
                sampleCount: rankOptions.sampleCount,
                timeout: rankOptions.timeout,
                transports,
                weights: rankOptions.weights,
            });
        }
        return transport;
    });
}
function shouldThrow(error) {
    if ('code' in error && typeof error.code === 'number') {
        if (error.code === rpc_js_1.TransactionRejectedRpcError.code ||
            error.code === rpc_js_1.UserRejectedRequestError.code ||
            node_js_1.ExecutionRevertedError.nodeMessage.test(error.message) ||
            error.code === 5000)
            return true;
    }
    return false;
}
function rankTransports({ chain, interval = 4_000, onTransports, ping, sampleCount = 10, timeout = 1_000, transports, weights = {}, }) {
    const { stability: stabilityWeight = 0.7, latency: latencyWeight = 0.3 } = weights;
    const samples = [];
    const rankTransports_ = async () => {
        const sample = await Promise.all(transports.map(async (transport) => {
            const transport_ = transport({ chain, retryCount: 0, timeout });
            const start = Date.now();
            let end;
            let success;
            try {
                await (ping
                    ? ping({ transport: transport_ })
                    : transport_.request({ method: 'net_listening' }));
                success = 1;
            }
            catch {
                success = 0;
            }
            finally {
                end = Date.now();
            }
            const latency = end - start;
            return { latency, success };
        }));
        samples.push(sample);
        if (samples.length > sampleCount)
            samples.shift();
        const maxLatency = Math.max(...samples.map((sample) => Math.max(...sample.map(({ latency }) => latency))));
        const scores = transports
            .map((_, i) => {
            const latencies = samples.map((sample) => sample[i].latency);
            const meanLatency = latencies.reduce((acc, latency) => acc + latency, 0) /
                latencies.length;
            const latencyScore = 1 - meanLatency / maxLatency;
            const successes = samples.map((sample) => sample[i].success);
            const stabilityScore = successes.reduce((acc, success) => acc + success, 0) /
                successes.length;
            if (stabilityScore === 0)
                return [0, i];
            return [
                latencyWeight * latencyScore + stabilityWeight * stabilityScore,
                i,
            ];
        })
            .sort((a, b) => b[0] - a[0]);
        onTransports(scores.map(([, i]) => transports[i]));
        await (0, wait_js_1.wait)(interval);
        rankTransports_();
    };
    rankTransports_();
}
//# sourceMappingURL=fallback.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/clients/transports/http.js":
/*!***********************************************************!*\
  !*** ./node_modules/viem/_cjs/clients/transports/http.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.http = http;
const request_js_1 = __webpack_require__(/*! ../../errors/request.js */ "./node_modules/viem/_cjs/errors/request.js");
const transport_js_1 = __webpack_require__(/*! ../../errors/transport.js */ "./node_modules/viem/_cjs/errors/transport.js");
const createBatchScheduler_js_1 = __webpack_require__(/*! ../../utils/promise/createBatchScheduler.js */ "./node_modules/viem/_cjs/utils/promise/createBatchScheduler.js");
const http_js_1 = __webpack_require__(/*! ../../utils/rpc/http.js */ "./node_modules/viem/_cjs/utils/rpc/http.js");
const createTransport_js_1 = __webpack_require__(/*! ./createTransport.js */ "./node_modules/viem/_cjs/clients/transports/createTransport.js");
function http(url, config = {}) {
    const { batch, fetchOptions, key = 'http', methods, name = 'HTTP JSON-RPC', onFetchRequest, onFetchResponse, retryDelay, raw, } = config;
    return ({ chain, retryCount: retryCount_, timeout: timeout_ }) => {
        const { batchSize = 1000, wait = 0 } = typeof batch === 'object' ? batch : {};
        const retryCount = config.retryCount ?? retryCount_;
        const timeout = timeout_ ?? config.timeout ?? 10_000;
        const url_ = url || chain?.rpcUrls.default.http[0];
        if (!url_)
            throw new transport_js_1.UrlRequiredError();
        const rpcClient = (0, http_js_1.getHttpRpcClient)(url_, {
            fetchOptions,
            onRequest: onFetchRequest,
            onResponse: onFetchResponse,
            timeout,
        });
        return (0, createTransport_js_1.createTransport)({
            key,
            methods,
            name,
            async request({ method, params }) {
                const body = { method, params };
                const { schedule } = (0, createBatchScheduler_js_1.createBatchScheduler)({
                    id: url_,
                    wait,
                    shouldSplitBatch(requests) {
                        return requests.length > batchSize;
                    },
                    fn: (body) => rpcClient.request({
                        body,
                    }),
                    sort: (a, b) => a.id - b.id,
                });
                const fn = async (body) => batch
                    ? schedule(body)
                    : [
                        await rpcClient.request({
                            body,
                        }),
                    ];
                const [{ error, result }] = await fn(body);
                if (raw)
                    return { error, result };
                if (error)
                    throw new request_js_1.RpcRequestError({
                        body,
                        error,
                        url: url_,
                    });
                return result;
            },
            retryCount,
            retryDelay,
            timeout,
            type: 'http',
        }, {
            fetchOptions,
            url: url_,
        });
    };
}
//# sourceMappingURL=http.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/clients/transports/webSocket.js":
/*!****************************************************************!*\
  !*** ./node_modules/viem/_cjs/clients/transports/webSocket.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.webSocket = webSocket;
const request_js_1 = __webpack_require__(/*! ../../errors/request.js */ "./node_modules/viem/_cjs/errors/request.js");
const transport_js_1 = __webpack_require__(/*! ../../errors/transport.js */ "./node_modules/viem/_cjs/errors/transport.js");
const compat_js_1 = __webpack_require__(/*! ../../utils/rpc/compat.js */ "./node_modules/viem/_cjs/utils/rpc/compat.js");
const webSocket_js_1 = __webpack_require__(/*! ../../utils/rpc/webSocket.js */ "./node_modules/viem/_cjs/utils/rpc/webSocket.js");
const createTransport_js_1 = __webpack_require__(/*! ./createTransport.js */ "./node_modules/viem/_cjs/clients/transports/createTransport.js");
function webSocket(url, config = {}) {
    const { keepAlive, key = 'webSocket', methods, name = 'WebSocket JSON-RPC', reconnect, retryDelay, } = config;
    return ({ chain, retryCount: retryCount_, timeout: timeout_ }) => {
        const retryCount = config.retryCount ?? retryCount_;
        const timeout = timeout_ ?? config.timeout ?? 10_000;
        const url_ = url || chain?.rpcUrls.default.webSocket?.[0];
        const wsRpcClientOpts = { keepAlive, reconnect };
        if (!url_)
            throw new transport_js_1.UrlRequiredError();
        return (0, createTransport_js_1.createTransport)({
            key,
            methods,
            name,
            async request({ method, params }) {
                const body = { method, params };
                const rpcClient = await (0, webSocket_js_1.getWebSocketRpcClient)(url_, wsRpcClientOpts);
                const { error, result } = await rpcClient.requestAsync({
                    body,
                    timeout,
                });
                if (error)
                    throw new request_js_1.RpcRequestError({
                        body,
                        error,
                        url: url_,
                    });
                return result;
            },
            retryCount,
            retryDelay,
            timeout,
            type: 'webSocket',
        }, {
            getSocket() {
                return (0, compat_js_1.getSocket)(url_);
            },
            getRpcClient() {
                return (0, webSocket_js_1.getWebSocketRpcClient)(url_, wsRpcClientOpts);
            },
            async subscribe({ params, onData, onError }) {
                const rpcClient = await (0, webSocket_js_1.getWebSocketRpcClient)(url_, wsRpcClientOpts);
                const { result: subscriptionId } = await new Promise((resolve, reject) => rpcClient.request({
                    body: {
                        method: 'eth_subscribe',
                        params,
                    },
                    onError(error) {
                        reject(error);
                        onError?.(error);
                        return;
                    },
                    onResponse(response) {
                        if (response.error) {
                            reject(response.error);
                            onError?.(response.error);
                            return;
                        }
                        if (typeof response.id === 'number') {
                            resolve(response);
                            return;
                        }
                        if (response.method !== 'eth_subscription')
                            return;
                        onData(response.params);
                    },
                }));
                return {
                    subscriptionId,
                    async unsubscribe() {
                        return new Promise((resolve) => rpcClient.request({
                            body: {
                                method: 'eth_unsubscribe',
                                params: [subscriptionId],
                            },
                            onResponse: resolve,
                        }));
                    },
                };
            },
        });
    };
}
//# sourceMappingURL=webSocket.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/constants/abis.js":
/*!**************************************************!*\
  !*** ./node_modules/viem/_cjs/constants/abis.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.erc4626Abi = exports.erc721Abi = exports.erc1155Abi = exports.erc20Abi_bytes32 = exports.erc20Abi = exports.universalSignatureValidatorAbi = exports.smartAccountAbi = exports.addressResolverAbi = exports.textResolverAbi = exports.universalResolverReverseAbi = exports.universalResolverResolveAbi = exports.batchGatewayAbi = exports.multicall3Abi = void 0;
exports.multicall3Abi = [
    {
        inputs: [
            {
                components: [
                    {
                        name: 'target',
                        type: 'address',
                    },
                    {
                        name: 'allowFailure',
                        type: 'bool',
                    },
                    {
                        name: 'callData',
                        type: 'bytes',
                    },
                ],
                name: 'calls',
                type: 'tuple[]',
            },
        ],
        name: 'aggregate3',
        outputs: [
            {
                components: [
                    {
                        name: 'success',
                        type: 'bool',
                    },
                    {
                        name: 'returnData',
                        type: 'bytes',
                    },
                ],
                name: 'returnData',
                type: 'tuple[]',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
];
exports.batchGatewayAbi = [
    {
        name: 'query',
        type: 'function',
        stateMutability: 'view',
        inputs: [
            {
                type: 'tuple[]',
                name: 'queries',
                components: [
                    {
                        type: 'address',
                        name: 'sender',
                    },
                    {
                        type: 'string[]',
                        name: 'urls',
                    },
                    {
                        type: 'bytes',
                        name: 'data',
                    },
                ],
            },
        ],
        outputs: [
            {
                type: 'bool[]',
                name: 'failures',
            },
            {
                type: 'bytes[]',
                name: 'responses',
            },
        ],
    },
    {
        name: 'HttpError',
        type: 'error',
        inputs: [
            {
                type: 'uint16',
                name: 'status',
            },
            {
                type: 'string',
                name: 'message',
            },
        ],
    },
];
const universalResolverErrors = [
    {
        inputs: [
            {
                name: 'dns',
                type: 'bytes',
            },
        ],
        name: 'DNSDecodingFailed',
        type: 'error',
    },
    {
        inputs: [
            {
                name: 'ens',
                type: 'string',
            },
        ],
        name: 'DNSEncodingFailed',
        type: 'error',
    },
    {
        inputs: [],
        name: 'EmptyAddress',
        type: 'error',
    },
    {
        inputs: [
            {
                name: 'status',
                type: 'uint16',
            },
            {
                name: 'message',
                type: 'string',
            },
        ],
        name: 'HttpError',
        type: 'error',
    },
    {
        inputs: [],
        name: 'InvalidBatchGatewayResponse',
        type: 'error',
    },
    {
        inputs: [
            {
                name: 'errorData',
                type: 'bytes',
            },
        ],
        name: 'ResolverError',
        type: 'error',
    },
    {
        inputs: [
            {
                name: 'name',
                type: 'bytes',
            },
            {
                name: 'resolver',
                type: 'address',
            },
        ],
        name: 'ResolverNotContract',
        type: 'error',
    },
    {
        inputs: [
            {
                name: 'name',
                type: 'bytes',
            },
        ],
        name: 'ResolverNotFound',
        type: 'error',
    },
    {
        inputs: [
            {
                name: 'primary',
                type: 'string',
            },
            {
                name: 'primaryAddress',
                type: 'bytes',
            },
        ],
        name: 'ReverseAddressMismatch',
        type: 'error',
    },
    {
        inputs: [
            {
                internalType: 'bytes4',
                name: 'selector',
                type: 'bytes4',
            },
        ],
        name: 'UnsupportedResolverProfile',
        type: 'error',
    },
];
exports.universalResolverResolveAbi = [
    ...universalResolverErrors,
    {
        name: 'resolveWithGateways',
        type: 'function',
        stateMutability: 'view',
        inputs: [
            { name: 'name', type: 'bytes' },
            { name: 'data', type: 'bytes' },
            { name: 'gateways', type: 'string[]' },
        ],
        outputs: [
            { name: '', type: 'bytes' },
            { name: 'address', type: 'address' },
        ],
    },
];
exports.universalResolverReverseAbi = [
    ...universalResolverErrors,
    {
        name: 'reverseWithGateways',
        type: 'function',
        stateMutability: 'view',
        inputs: [
            { type: 'bytes', name: 'reverseName' },
            { type: 'uint256', name: 'coinType' },
            { type: 'string[]', name: 'gateways' },
        ],
        outputs: [
            { type: 'string', name: 'resolvedName' },
            { type: 'address', name: 'resolver' },
            { type: 'address', name: 'reverseResolver' },
        ],
    },
];
exports.textResolverAbi = [
    {
        name: 'text',
        type: 'function',
        stateMutability: 'view',
        inputs: [
            { name: 'name', type: 'bytes32' },
            { name: 'key', type: 'string' },
        ],
        outputs: [{ name: '', type: 'string' }],
    },
];
exports.addressResolverAbi = [
    {
        name: 'addr',
        type: 'function',
        stateMutability: 'view',
        inputs: [{ name: 'name', type: 'bytes32' }],
        outputs: [{ name: '', type: 'address' }],
    },
    {
        name: 'addr',
        type: 'function',
        stateMutability: 'view',
        inputs: [
            { name: 'name', type: 'bytes32' },
            { name: 'coinType', type: 'uint256' },
        ],
        outputs: [{ name: '', type: 'bytes' }],
    },
];
exports.smartAccountAbi = [
    {
        name: 'isValidSignature',
        type: 'function',
        stateMutability: 'view',
        inputs: [
            { name: 'hash', type: 'bytes32' },
            { name: 'signature', type: 'bytes' },
        ],
        outputs: [{ name: '', type: 'bytes4' }],
    },
];
exports.universalSignatureValidatorAbi = [
    {
        inputs: [
            {
                name: '_signer',
                type: 'address',
            },
            {
                name: '_hash',
                type: 'bytes32',
            },
            {
                name: '_signature',
                type: 'bytes',
            },
        ],
        stateMutability: 'nonpayable',
        type: 'constructor',
    },
    {
        inputs: [
            {
                name: '_signer',
                type: 'address',
            },
            {
                name: '_hash',
                type: 'bytes32',
            },
            {
                name: '_signature',
                type: 'bytes',
            },
        ],
        outputs: [
            {
                type: 'bool',
            },
        ],
        stateMutability: 'nonpayable',
        type: 'function',
        name: 'isValidSig',
    },
];
exports.erc20Abi = [
    {
        type: 'event',
        name: 'Approval',
        inputs: [
            {
                indexed: true,
                name: 'owner',
                type: 'address',
            },
            {
                indexed: true,
                name: 'spender',
                type: 'address',
            },
            {
                indexed: false,
                name: 'value',
                type: 'uint256',
            },
        ],
    },
    {
        type: 'event',
        name: 'Transfer',
        inputs: [
            {
                indexed: true,
                name: 'from',
                type: 'address',
            },
            {
                indexed: true,
                name: 'to',
                type: 'address',
            },
            {
                indexed: false,
                name: 'value',
                type: 'uint256',
            },
        ],
    },
    {
        type: 'function',
        name: 'allowance',
        stateMutability: 'view',
        inputs: [
            {
                name: 'owner',
                type: 'address',
            },
            {
                name: 'spender',
                type: 'address',
            },
        ],
        outputs: [
            {
                type: 'uint256',
            },
        ],
    },
    {
        type: 'function',
        name: 'approve',
        stateMutability: 'nonpayable',
        inputs: [
            {
                name: 'spender',
                type: 'address',
            },
            {
                name: 'amount',
                type: 'uint256',
            },
        ],
        outputs: [
            {
                type: 'bool',
            },
        ],
    },
    {
        type: 'function',
        name: 'balanceOf',
        stateMutability: 'view',
        inputs: [
            {
                name: 'account',
                type: 'address',
            },
        ],
        outputs: [
            {
                type: 'uint256',
            },
        ],
    },
    {
        type: 'function',
        name: 'decimals',
        stateMutability: 'view',
        inputs: [],
        outputs: [
            {
                type: 'uint8',
            },
        ],
    },
    {
        type: 'function',
        name: 'name',
        stateMutability: 'view',
        inputs: [],
        outputs: [
            {
                type: 'string',
            },
        ],
    },
    {
        type: 'function',
        name: 'symbol',
        stateMutability: 'view',
        inputs: [],
        outputs: [
            {
                type: 'string',
            },
        ],
    },
    {
        type: 'function',
        name: 'totalSupply',
        stateMutability: 'view',
        inputs: [],
        outputs: [
            {
                type: 'uint256',
            },
        ],
    },
    {
        type: 'function',
        name: 'transfer',
        stateMutability: 'nonpayable',
        inputs: [
            {
                name: 'recipient',
                type: 'address',
            },
            {
                name: 'amount',
                type: 'uint256',
            },
        ],
        outputs: [
            {
                type: 'bool',
            },
        ],
    },
    {
        type: 'function',
        name: 'transferFrom',
        stateMutability: 'nonpayable',
        inputs: [
            {
                name: 'sender',
                type: 'address',
            },
            {
                name: 'recipient',
                type: 'address',
            },
            {
                name: 'amount',
                type: 'uint256',
            },
        ],
        outputs: [
            {
                type: 'bool',
            },
        ],
    },
];
exports.erc20Abi_bytes32 = [
    {
        type: 'event',
        name: 'Approval',
        inputs: [
            {
                indexed: true,
                name: 'owner',
                type: 'address',
            },
            {
                indexed: true,
                name: 'spender',
                type: 'address',
            },
            {
                indexed: false,
                name: 'value',
                type: 'uint256',
            },
        ],
    },
    {
        type: 'event',
        name: 'Transfer',
        inputs: [
            {
                indexed: true,
                name: 'from',
                type: 'address',
            },
            {
                indexed: true,
                name: 'to',
                type: 'address',
            },
            {
                indexed: false,
                name: 'value',
                type: 'uint256',
            },
        ],
    },
    {
        type: 'function',
        name: 'allowance',
        stateMutability: 'view',
        inputs: [
            {
                name: 'owner',
                type: 'address',
            },
            {
                name: 'spender',
                type: 'address',
            },
        ],
        outputs: [
            {
                type: 'uint256',
            },
        ],
    },
    {
        type: 'function',
        name: 'approve',
        stateMutability: 'nonpayable',
        inputs: [
            {
                name: 'spender',
                type: 'address',
            },
            {
                name: 'amount',
                type: 'uint256',
            },
        ],
        outputs: [
            {
                type: 'bool',
            },
        ],
    },
    {
        type: 'function',
        name: 'balanceOf',
        stateMutability: 'view',
        inputs: [
            {
                name: 'account',
                type: 'address',
            },
        ],
        outputs: [
            {
                type: 'uint256',
            },
        ],
    },
    {
        type: 'function',
        name: 'decimals',
        stateMutability: 'view',
        inputs: [],
        outputs: [
            {
                type: 'uint8',
            },
        ],
    },
    {
        type: 'function',
        name: 'name',
        stateMutability: 'view',
        inputs: [],
        outputs: [
            {
                type: 'bytes32',
            },
        ],
    },
    {
        type: 'function',
        name: 'symbol',
        stateMutability: 'view',
        inputs: [],
        outputs: [
            {
                type: 'bytes32',
            },
        ],
    },
    {
        type: 'function',
        name: 'totalSupply',
        stateMutability: 'view',
        inputs: [],
        outputs: [
            {
                type: 'uint256',
            },
        ],
    },
    {
        type: 'function',
        name: 'transfer',
        stateMutability: 'nonpayable',
        inputs: [
            {
                name: 'recipient',
                type: 'address',
            },
            {
                name: 'amount',
                type: 'uint256',
            },
        ],
        outputs: [
            {
                type: 'bool',
            },
        ],
    },
    {
        type: 'function',
        name: 'transferFrom',
        stateMutability: 'nonpayable',
        inputs: [
            {
                name: 'sender',
                type: 'address',
            },
            {
                name: 'recipient',
                type: 'address',
            },
            {
                name: 'amount',
                type: 'uint256',
            },
        ],
        outputs: [
            {
                type: 'bool',
            },
        ],
    },
];
exports.erc1155Abi = [
    {
        inputs: [
            {
                internalType: 'address',
                name: 'sender',
                type: 'address',
            },
            {
                internalType: 'uint256',
                name: 'balance',
                type: 'uint256',
            },
            {
                internalType: 'uint256',
                name: 'needed',
                type: 'uint256',
            },
            {
                internalType: 'uint256',
                name: 'tokenId',
                type: 'uint256',
            },
        ],
        name: 'ERC1155InsufficientBalance',
        type: 'error',
    },
    {
        inputs: [
            {
                internalType: 'address',
                name: 'approver',
                type: 'address',
            },
        ],
        name: 'ERC1155InvalidApprover',
        type: 'error',
    },
    {
        inputs: [
            {
                internalType: 'uint256',
                name: 'idsLength',
                type: 'uint256',
            },
            {
                internalType: 'uint256',
                name: 'valuesLength',
                type: 'uint256',
            },
        ],
        name: 'ERC1155InvalidArrayLength',
        type: 'error',
    },
    {
        inputs: [
            {
                internalType: 'address',
                name: 'operator',
                type: 'address',
            },
        ],
        name: 'ERC1155InvalidOperator',
        type: 'error',
    },
    {
        inputs: [
            {
                internalType: 'address',
                name: 'receiver',
                type: 'address',
            },
        ],
        name: 'ERC1155InvalidReceiver',
        type: 'error',
    },
    {
        inputs: [
            {
                internalType: 'address',
                name: 'sender',
                type: 'address',
            },
        ],
        name: 'ERC1155InvalidSender',
        type: 'error',
    },
    {
        inputs: [
            {
                internalType: 'address',
                name: 'operator',
                type: 'address',
            },
            {
                internalType: 'address',
                name: 'owner',
                type: 'address',
            },
        ],
        name: 'ERC1155MissingApprovalForAll',
        type: 'error',
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: 'address',
                name: 'account',
                type: 'address',
            },
            {
                indexed: true,
                internalType: 'address',
                name: 'operator',
                type: 'address',
            },
            {
                indexed: false,
                internalType: 'bool',
                name: 'approved',
                type: 'bool',
            },
        ],
        name: 'ApprovalForAll',
        type: 'event',
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: 'address',
                name: 'operator',
                type: 'address',
            },
            {
                indexed: true,
                internalType: 'address',
                name: 'from',
                type: 'address',
            },
            {
                indexed: true,
                internalType: 'address',
                name: 'to',
                type: 'address',
            },
            {
                indexed: false,
                internalType: 'uint256[]',
                name: 'ids',
                type: 'uint256[]',
            },
            {
                indexed: false,
                internalType: 'uint256[]',
                name: 'values',
                type: 'uint256[]',
            },
        ],
        name: 'TransferBatch',
        type: 'event',
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: 'address',
                name: 'operator',
                type: 'address',
            },
            {
                indexed: true,
                internalType: 'address',
                name: 'from',
                type: 'address',
            },
            {
                indexed: true,
                internalType: 'address',
                name: 'to',
                type: 'address',
            },
            {
                indexed: false,
                internalType: 'uint256',
                name: 'id',
                type: 'uint256',
            },
            {
                indexed: false,
                internalType: 'uint256',
                name: 'value',
                type: 'uint256',
            },
        ],
        name: 'TransferSingle',
        type: 'event',
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: false,
                internalType: 'string',
                name: 'value',
                type: 'string',
            },
            {
                indexed: true,
                internalType: 'uint256',
                name: 'id',
                type: 'uint256',
            },
        ],
        name: 'URI',
        type: 'event',
    },
    {
        inputs: [
            {
                internalType: 'address',
                name: 'account',
                type: 'address',
            },
            {
                internalType: 'uint256',
                name: 'id',
                type: 'uint256',
            },
        ],
        name: 'balanceOf',
        outputs: [
            {
                internalType: 'uint256',
                name: '',
                type: 'uint256',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [
            {
                internalType: 'address[]',
                name: 'accounts',
                type: 'address[]',
            },
            {
                internalType: 'uint256[]',
                name: 'ids',
                type: 'uint256[]',
            },
        ],
        name: 'balanceOfBatch',
        outputs: [
            {
                internalType: 'uint256[]',
                name: '',
                type: 'uint256[]',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [
            {
                internalType: 'address',
                name: 'account',
                type: 'address',
            },
            {
                internalType: 'address',
                name: 'operator',
                type: 'address',
            },
        ],
        name: 'isApprovedForAll',
        outputs: [
            {
                internalType: 'bool',
                name: '',
                type: 'bool',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [
            {
                internalType: 'address',
                name: 'from',
                type: 'address',
            },
            {
                internalType: 'address',
                name: 'to',
                type: 'address',
            },
            {
                internalType: 'uint256[]',
                name: 'ids',
                type: 'uint256[]',
            },
            {
                internalType: 'uint256[]',
                name: 'values',
                type: 'uint256[]',
            },
            {
                internalType: 'bytes',
                name: 'data',
                type: 'bytes',
            },
        ],
        name: 'safeBatchTransferFrom',
        outputs: [],
        stateMutability: 'nonpayable',
        type: 'function',
    },
    {
        inputs: [
            {
                internalType: 'address',
                name: 'from',
                type: 'address',
            },
            {
                internalType: 'address',
                name: 'to',
                type: 'address',
            },
            {
                internalType: 'uint256',
                name: 'id',
                type: 'uint256',
            },
            {
                internalType: 'uint256',
                name: 'value',
                type: 'uint256',
            },
            {
                internalType: 'bytes',
                name: 'data',
                type: 'bytes',
            },
        ],
        name: 'safeTransferFrom',
        outputs: [],
        stateMutability: 'nonpayable',
        type: 'function',
    },
    {
        inputs: [
            {
                internalType: 'address',
                name: 'operator',
                type: 'address',
            },
            {
                internalType: 'bool',
                name: 'approved',
                type: 'bool',
            },
        ],
        name: 'setApprovalForAll',
        outputs: [],
        stateMutability: 'nonpayable',
        type: 'function',
    },
    {
        inputs: [
            {
                internalType: 'bytes4',
                name: 'interfaceId',
                type: 'bytes4',
            },
        ],
        name: 'supportsInterface',
        outputs: [
            {
                internalType: 'bool',
                name: '',
                type: 'bool',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [
            {
                internalType: 'uint256',
                name: '',
                type: 'uint256',
            },
        ],
        name: 'uri',
        outputs: [
            {
                internalType: 'string',
                name: '',
                type: 'string',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
];
exports.erc721Abi = [
    {
        type: 'event',
        name: 'Approval',
        inputs: [
            {
                indexed: true,
                name: 'owner',
                type: 'address',
            },
            {
                indexed: true,
                name: 'spender',
                type: 'address',
            },
            {
                indexed: true,
                name: 'tokenId',
                type: 'uint256',
            },
        ],
    },
    {
        type: 'event',
        name: 'ApprovalForAll',
        inputs: [
            {
                indexed: true,
                name: 'owner',
                type: 'address',
            },
            {
                indexed: true,
                name: 'operator',
                type: 'address',
            },
            {
                indexed: false,
                name: 'approved',
                type: 'bool',
            },
        ],
    },
    {
        type: 'event',
        name: 'Transfer',
        inputs: [
            {
                indexed: true,
                name: 'from',
                type: 'address',
            },
            {
                indexed: true,
                name: 'to',
                type: 'address',
            },
            {
                indexed: true,
                name: 'tokenId',
                type: 'uint256',
            },
        ],
    },
    {
        type: 'function',
        name: 'approve',
        stateMutability: 'payable',
        inputs: [
            {
                name: 'spender',
                type: 'address',
            },
            {
                name: 'tokenId',
                type: 'uint256',
            },
        ],
        outputs: [],
    },
    {
        type: 'function',
        name: 'balanceOf',
        stateMutability: 'view',
        inputs: [
            {
                name: 'account',
                type: 'address',
            },
        ],
        outputs: [
            {
                type: 'uint256',
            },
        ],
    },
    {
        type: 'function',
        name: 'getApproved',
        stateMutability: 'view',
        inputs: [
            {
                name: 'tokenId',
                type: 'uint256',
            },
        ],
        outputs: [
            {
                type: 'address',
            },
        ],
    },
    {
        type: 'function',
        name: 'isApprovedForAll',
        stateMutability: 'view',
        inputs: [
            {
                name: 'owner',
                type: 'address',
            },
            {
                name: 'operator',
                type: 'address',
            },
        ],
        outputs: [
            {
                type: 'bool',
            },
        ],
    },
    {
        type: 'function',
        name: 'name',
        stateMutability: 'view',
        inputs: [],
        outputs: [
            {
                type: 'string',
            },
        ],
    },
    {
        type: 'function',
        name: 'ownerOf',
        stateMutability: 'view',
        inputs: [
            {
                name: 'tokenId',
                type: 'uint256',
            },
        ],
        outputs: [
            {
                name: 'owner',
                type: 'address',
            },
        ],
    },
    {
        type: 'function',
        name: 'safeTransferFrom',
        stateMutability: 'payable',
        inputs: [
            {
                name: 'from',
                type: 'address',
            },
            {
                name: 'to',
                type: 'address',
            },
            {
                name: 'tokenId',
                type: 'uint256',
            },
        ],
        outputs: [],
    },
    {
        type: 'function',
        name: 'safeTransferFrom',
        stateMutability: 'nonpayable',
        inputs: [
            {
                name: 'from',
                type: 'address',
            },
            {
                name: 'to',
                type: 'address',
            },
            {
                name: 'id',
                type: 'uint256',
            },
            {
                name: 'data',
                type: 'bytes',
            },
        ],
        outputs: [],
    },
    {
        type: 'function',
        name: 'setApprovalForAll',
        stateMutability: 'nonpayable',
        inputs: [
            {
                name: 'operator',
                type: 'address',
            },
            {
                name: 'approved',
                type: 'bool',
            },
        ],
        outputs: [],
    },
    {
        type: 'function',
        name: 'symbol',
        stateMutability: 'view',
        inputs: [],
        outputs: [
            {
                type: 'string',
            },
        ],
    },
    {
        type: 'function',
        name: 'tokenByIndex',
        stateMutability: 'view',
        inputs: [
            {
                name: 'index',
                type: 'uint256',
            },
        ],
        outputs: [
            {
                type: 'uint256',
            },
        ],
    },
    {
        type: 'function',
        name: 'tokenByIndex',
        stateMutability: 'view',
        inputs: [
            {
                name: 'owner',
                type: 'address',
            },
            {
                name: 'index',
                type: 'uint256',
            },
        ],
        outputs: [
            {
                name: 'tokenId',
                type: 'uint256',
            },
        ],
    },
    {
        type: 'function',
        name: 'tokenURI',
        stateMutability: 'view',
        inputs: [
            {
                name: 'tokenId',
                type: 'uint256',
            },
        ],
        outputs: [
            {
                type: 'string',
            },
        ],
    },
    {
        type: 'function',
        name: 'totalSupply',
        stateMutability: 'view',
        inputs: [],
        outputs: [
            {
                type: 'uint256',
            },
        ],
    },
    {
        type: 'function',
        name: 'transferFrom',
        stateMutability: 'payable',
        inputs: [
            {
                name: 'sender',
                type: 'address',
            },
            {
                name: 'recipient',
                type: 'address',
            },
            {
                name: 'tokenId',
                type: 'uint256',
            },
        ],
        outputs: [],
    },
];
exports.erc4626Abi = [
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                name: 'owner',
                type: 'address',
            },
            {
                indexed: true,
                name: 'spender',
                type: 'address',
            },
            {
                indexed: false,
                name: 'value',
                type: 'uint256',
            },
        ],
        name: 'Approval',
        type: 'event',
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                name: 'sender',
                type: 'address',
            },
            {
                indexed: true,
                name: 'receiver',
                type: 'address',
            },
            {
                indexed: false,
                name: 'assets',
                type: 'uint256',
            },
            {
                indexed: false,
                name: 'shares',
                type: 'uint256',
            },
        ],
        name: 'Deposit',
        type: 'event',
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                name: 'from',
                type: 'address',
            },
            {
                indexed: true,
                name: 'to',
                type: 'address',
            },
            {
                indexed: false,
                name: 'value',
                type: 'uint256',
            },
        ],
        name: 'Transfer',
        type: 'event',
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                name: 'sender',
                type: 'address',
            },
            {
                indexed: true,
                name: 'receiver',
                type: 'address',
            },
            {
                indexed: true,
                name: 'owner',
                type: 'address',
            },
            {
                indexed: false,
                name: 'assets',
                type: 'uint256',
            },
            {
                indexed: false,
                name: 'shares',
                type: 'uint256',
            },
        ],
        name: 'Withdraw',
        type: 'event',
    },
    {
        inputs: [
            {
                name: 'owner',
                type: 'address',
            },
            {
                name: 'spender',
                type: 'address',
            },
        ],
        name: 'allowance',
        outputs: [
            {
                type: 'uint256',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [
            {
                name: 'spender',
                type: 'address',
            },
            {
                name: 'amount',
                type: 'uint256',
            },
        ],
        name: 'approve',
        outputs: [
            {
                type: 'bool',
            },
        ],
        stateMutability: 'nonpayable',
        type: 'function',
    },
    {
        inputs: [],
        name: 'asset',
        outputs: [
            {
                name: 'assetTokenAddress',
                type: 'address',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [
            {
                name: 'account',
                type: 'address',
            },
        ],
        name: 'balanceOf',
        outputs: [
            {
                type: 'uint256',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [
            {
                name: 'shares',
                type: 'uint256',
            },
        ],
        name: 'convertToAssets',
        outputs: [
            {
                name: 'assets',
                type: 'uint256',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [
            {
                name: 'assets',
                type: 'uint256',
            },
        ],
        name: 'convertToShares',
        outputs: [
            {
                name: 'shares',
                type: 'uint256',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [
            {
                name: 'assets',
                type: 'uint256',
            },
            {
                name: 'receiver',
                type: 'address',
            },
        ],
        name: 'deposit',
        outputs: [
            {
                name: 'shares',
                type: 'uint256',
            },
        ],
        stateMutability: 'nonpayable',
        type: 'function',
    },
    {
        inputs: [
            {
                name: 'caller',
                type: 'address',
            },
        ],
        name: 'maxDeposit',
        outputs: [
            {
                name: 'maxAssets',
                type: 'uint256',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [
            {
                name: 'caller',
                type: 'address',
            },
        ],
        name: 'maxMint',
        outputs: [
            {
                name: 'maxShares',
                type: 'uint256',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [
            {
                name: 'owner',
                type: 'address',
            },
        ],
        name: 'maxRedeem',
        outputs: [
            {
                name: 'maxShares',
                type: 'uint256',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [
            {
                name: 'owner',
                type: 'address',
            },
        ],
        name: 'maxWithdraw',
        outputs: [
            {
                name: 'maxAssets',
                type: 'uint256',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [
            {
                name: 'shares',
                type: 'uint256',
            },
            {
                name: 'receiver',
                type: 'address',
            },
        ],
        name: 'mint',
        outputs: [
            {
                name: 'assets',
                type: 'uint256',
            },
        ],
        stateMutability: 'nonpayable',
        type: 'function',
    },
    {
        inputs: [
            {
                name: 'assets',
                type: 'uint256',
            },
        ],
        name: 'previewDeposit',
        outputs: [
            {
                name: 'shares',
                type: 'uint256',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [
            {
                name: 'shares',
                type: 'uint256',
            },
        ],
        name: 'previewMint',
        outputs: [
            {
                name: 'assets',
                type: 'uint256',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [
            {
                name: 'shares',
                type: 'uint256',
            },
        ],
        name: 'previewRedeem',
        outputs: [
            {
                name: 'assets',
                type: 'uint256',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [
            {
                name: 'assets',
                type: 'uint256',
            },
        ],
        name: 'previewWithdraw',
        outputs: [
            {
                name: 'shares',
                type: 'uint256',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [
            {
                name: 'shares',
                type: 'uint256',
            },
            {
                name: 'receiver',
                type: 'address',
            },
            {
                name: 'owner',
                type: 'address',
            },
        ],
        name: 'redeem',
        outputs: [
            {
                name: 'assets',
                type: 'uint256',
            },
        ],
        stateMutability: 'nonpayable',
        type: 'function',
    },
    {
        inputs: [],
        name: 'totalAssets',
        outputs: [
            {
                name: 'totalManagedAssets',
                type: 'uint256',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [],
        name: 'totalSupply',
        outputs: [
            {
                type: 'uint256',
            },
        ],
        stateMutability: 'view',
        type: 'function',
    },
    {
        inputs: [
            {
                name: 'to',
                type: 'address',
            },
            {
                name: 'amount',
                type: 'uint256',
            },
        ],
        name: 'transfer',
        outputs: [
            {
                type: 'bool',
            },
        ],
        stateMutability: 'nonpayable',
        type: 'function',
    },
    {
        inputs: [
            {
                name: 'from',
                type: 'address',
            },
            {
                name: 'to',
                type: 'address',
            },
            {
                name: 'amount',
                type: 'uint256',
            },
        ],
        name: 'transferFrom',
        outputs: [
            {
                type: 'bool',
            },
        ],
        stateMutability: 'nonpayable',
        type: 'function',
    },
    {
        inputs: [
            {
                name: 'assets',
                type: 'uint256',
            },
            {
                name: 'receiver',
                type: 'address',
            },
            {
                name: 'owner',
                type: 'address',
            },
        ],
        name: 'withdraw',
        outputs: [
            {
                name: 'shares',
                type: 'uint256',
            },
        ],
        stateMutability: 'nonpayable',
        type: 'function',
    },
];
//# sourceMappingURL=abis.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/constants/address.js":
/*!*****************************************************!*\
  !*** ./node_modules/viem/_cjs/constants/address.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.zeroAddress = exports.ethAddress = exports.entryPoint08Address = exports.entryPoint07Address = exports.entryPoint06Address = void 0;
exports.entryPoint06Address = '0x5FF137D4b0FDCD49DcA30c7CF57E578a026d2789';
exports.entryPoint07Address = '0x0000000071727De22E5E9d8BAf0edAc6f37da032';
exports.entryPoint08Address = '0x4337084D9E255Ff0702461CF8895CE9E3b5Ff108';
exports.ethAddress = '0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee';
exports.zeroAddress = '0x0000000000000000000000000000000000000000';
//# sourceMappingURL=address.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/constants/blob.js":
/*!**************************************************!*\
  !*** ./node_modules/viem/_cjs/constants/blob.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.maxBytesPerTransaction = exports.bytesPerBlob = exports.fieldElementsPerBlob = exports.bytesPerFieldElement = void 0;
const blobsPerTransaction = 6;
exports.bytesPerFieldElement = 32;
exports.fieldElementsPerBlob = 4096;
exports.bytesPerBlob = exports.bytesPerFieldElement * exports.fieldElementsPerBlob;
exports.maxBytesPerTransaction = exports.bytesPerBlob * blobsPerTransaction -
    1 -
    1 * exports.fieldElementsPerBlob * blobsPerTransaction;
//# sourceMappingURL=blob.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/constants/bytes.js":
/*!***************************************************!*\
  !*** ./node_modules/viem/_cjs/constants/bytes.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.zeroHash = exports.erc6492MagicBytes = void 0;
exports.erc6492MagicBytes = '0x6492649264926492649264926492649264926492649264926492649264926492';
exports.zeroHash = '0x0000000000000000000000000000000000000000000000000000000000000000';
//# sourceMappingURL=bytes.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/constants/contract.js":
/*!******************************************************!*\
  !*** ./node_modules/viem/_cjs/constants/contract.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.aggregate3Signature = void 0;
exports.aggregate3Signature = '0x82ad56cb';
//# sourceMappingURL=contract.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/constants/contracts.js":
/*!*******************************************************!*\
  !*** ./node_modules/viem/_cjs/constants/contracts.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.multicall3Bytecode = exports.universalSignatureValidatorByteCode = exports.deploylessCallViaFactoryBytecode = exports.deploylessCallViaBytecodeBytecode = void 0;
exports.deploylessCallViaBytecodeBytecode = '0x608060405234801561001057600080fd5b5060405161018e38038061018e83398101604081905261002f91610124565b6000808351602085016000f59050803b61004857600080fd5b6000808351602085016000855af16040513d6000823e81610067573d81fd5b3d81f35b634e487b7160e01b600052604160045260246000fd5b600082601f83011261009257600080fd5b81516001600160401b038111156100ab576100ab61006b565b604051601f8201601f19908116603f011681016001600160401b03811182821017156100d9576100d961006b565b6040528181528382016020018510156100f157600080fd5b60005b82811015610110576020818601810151838301820152016100f4565b506000918101602001919091529392505050565b6000806040838503121561013757600080fd5b82516001600160401b0381111561014d57600080fd5b61015985828601610081565b602085015190935090506001600160401b0381111561017757600080fd5b61018385828601610081565b915050925092905056fe';
exports.deploylessCallViaFactoryBytecode = '0x608060405234801561001057600080fd5b506040516102c03803806102c083398101604081905261002f916101e6565b836001600160a01b03163b6000036100e457600080836001600160a01b03168360405161005c9190610270565b6000604051808303816000865af19150503d8060008114610099576040519150601f19603f3d011682016040523d82523d6000602084013e61009e565b606091505b50915091508115806100b857506001600160a01b0386163b155b156100e1578060405163101bb98d60e01b81526004016100d8919061028c565b60405180910390fd5b50505b6000808451602086016000885af16040513d6000823e81610103573d81fd5b3d81f35b80516001600160a01b038116811461011e57600080fd5b919050565b634e487b7160e01b600052604160045260246000fd5b60005b8381101561015457818101518382015260200161013c565b50506000910152565b600082601f83011261016e57600080fd5b81516001600160401b0381111561018757610187610123565b604051601f8201601f19908116603f011681016001600160401b03811182821017156101b5576101b5610123565b6040528181528382016020018510156101cd57600080fd5b6101de826020830160208701610139565b949350505050565b600080600080608085870312156101fc57600080fd5b61020585610107565b60208601519094506001600160401b0381111561022157600080fd5b61022d8782880161015d565b93505061023c60408601610107565b60608601519092506001600160401b0381111561025857600080fd5b6102648782880161015d565b91505092959194509250565b60008251610282818460208701610139565b9190910192915050565b60208152600082518060208401526102ab816040850160208701610139565b601f01601f1916919091016040019291505056fe';
exports.universalSignatureValidatorByteCode = '0x608060405234801561001057600080fd5b5060405161069438038061069483398101604081905261002f9161051e565b600061003c848484610048565b9050806000526001601ff35b60007f64926492649264926492649264926492649264926492649264926492649264926100748361040c565b036101e7576000606080848060200190518101906100929190610577565b60405192955090935091506000906001600160a01b038516906100b69085906105dd565b6000604051808303816000865af19150503d80600081146100f3576040519150601f19603f3d011682016040523d82523d6000602084013e6100f8565b606091505b50509050876001600160a01b03163b60000361016057806101605760405162461bcd60e51b815260206004820152601e60248201527f5369676e617475726556616c696461746f723a206465706c6f796d656e74000060448201526064015b60405180910390fd5b604051630b135d3f60e11b808252906001600160a01b038a1690631626ba7e90610190908b9087906004016105f9565b602060405180830381865afa1580156101ad573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906101d19190610633565b6001600160e01b03191614945050505050610405565b6001600160a01b0384163b1561027a57604051630b135d3f60e11b808252906001600160a01b03861690631626ba7e9061022790879087906004016105f9565b602060405180830381865afa158015610244573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102689190610633565b6001600160e01b031916149050610405565b81516041146102df5760405162461bcd60e51b815260206004820152603a602482015260008051602061067483398151915260448201527f3a20696e76616c6964207369676e6174757265206c656e6774680000000000006064820152608401610157565b6102e7610425565b5060208201516040808401518451859392600091859190811061030c5761030c61065d565b016020015160f81c9050601b811480159061032b57508060ff16601c14155b1561038c5760405162461bcd60e51b815260206004820152603b602482015260008051602061067483398151915260448201527f3a20696e76616c6964207369676e617475726520762076616c756500000000006064820152608401610157565b60408051600081526020810180835289905260ff83169181019190915260608101849052608081018390526001600160a01b0389169060019060a0016020604051602081039080840390855afa1580156103ea573d6000803e3d6000fd5b505050602060405103516001600160a01b0316149450505050505b9392505050565b600060208251101561041d57600080fd5b508051015190565b60405180606001604052806003906020820280368337509192915050565b6001600160a01b038116811461045857600080fd5b50565b634e487b7160e01b600052604160045260246000fd5b60005b8381101561048c578181015183820152602001610474565b50506000910152565b600082601f8301126104a657600080fd5b81516001600160401b038111156104bf576104bf61045b565b604051601f8201601f19908116603f011681016001600160401b03811182821017156104ed576104ed61045b565b60405281815283820160200185101561050557600080fd5b610516826020830160208701610471565b949350505050565b60008060006060848603121561053357600080fd5b835161053e81610443565b6020850151604086015191945092506001600160401b0381111561056157600080fd5b61056d86828701610495565b9150509250925092565b60008060006060848603121561058c57600080fd5b835161059781610443565b60208501519093506001600160401b038111156105b357600080fd5b6105bf86828701610495565b604086015190935090506001600160401b0381111561056157600080fd5b600082516105ef818460208701610471565b9190910192915050565b828152604060208201526000825180604084015261061e816060850160208701610471565b601f01601f1916919091016060019392505050565b60006020828403121561064557600080fd5b81516001600160e01b03198116811461040557600080fd5b634e487b7160e01b600052603260045260246000fdfe5369676e617475726556616c696461746f72237265636f7665725369676e6572';
exports.multicall3Bytecode = '0x608060405234801561001057600080fd5b506115b9806100206000396000f3fe6080604052600436106100f35760003560e01c80634d2301cc1161008a578063a8b0574e11610059578063a8b0574e14610325578063bce38bd714610350578063c3077fa914610380578063ee82ac5e146103b2576100f3565b80634d2301cc1461026257806372425d9d1461029f57806382ad56cb146102ca57806386d516e8146102fa576100f3565b80633408e470116100c65780633408e470146101af578063399542e9146101da5780633e64a6961461020c57806342cbb15c14610237576100f3565b80630f28c97d146100f8578063174dea7114610123578063252dba421461015357806327e86d6e14610184575b600080fd5b34801561010457600080fd5b5061010d6103ef565b60405161011a9190610c0a565b60405180910390f35b61013d60048036038101906101389190610c94565b6103f7565b60405161014a9190610e94565b60405180910390f35b61016d60048036038101906101689190610f0c565b610615565b60405161017b92919061101b565b60405180910390f35b34801561019057600080fd5b506101996107ab565b6040516101a69190611064565b60405180910390f35b3480156101bb57600080fd5b506101c46107b7565b6040516101d19190610c0a565b60405180910390f35b6101f460048036038101906101ef91906110ab565b6107bf565b6040516102039392919061110b565b60405180910390f35b34801561021857600080fd5b506102216107e1565b60405161022e9190610c0a565b60405180910390f35b34801561024357600080fd5b5061024c6107e9565b6040516102599190610c0a565b60405180910390f35b34801561026e57600080fd5b50610289600480360381019061028491906111a7565b6107f1565b6040516102969190610c0a565b60405180910390f35b3480156102ab57600080fd5b506102b4610812565b6040516102c19190610c0a565b60405180910390f35b6102e460048036038101906102df919061122a565b61081a565b6040516102f19190610e94565b60405180910390f35b34801561030657600080fd5b5061030f6109e4565b60405161031c9190610c0a565b60405180910390f35b34801561033157600080fd5b5061033a6109ec565b6040516103479190611286565b60405180910390f35b61036a600480360381019061036591906110ab565b6109f4565b6040516103779190610e94565b60405180910390f35b61039a60048036038101906103959190610f0c565b610ba6565b6040516103a99392919061110b565b60405180910390f35b3480156103be57600080fd5b506103d960048036038101906103d491906112cd565b610bca565b6040516103e69190611064565b60405180910390f35b600042905090565b60606000808484905090508067ffffffffffffffff81111561041c5761041b6112fa565b5b60405190808252806020026020018201604052801561045557816020015b610442610bd5565b81526020019060019003908161043a5790505b5092503660005b828110156105c957600085828151811061047957610478611329565b5b6020026020010151905087878381811061049657610495611329565b5b90506020028101906104a89190611367565b925060008360400135905080860195508360000160208101906104cb91906111a7565b73ffffffffffffffffffffffffffffffffffffffff16818580606001906104f2919061138f565b604051610500929190611431565b60006040518083038185875af1925050503d806000811461053d576040519150601f19603f3d011682016040523d82523d6000602084013e610542565b606091505b5083600001846020018290528215151515815250505081516020850135176105bc577f08c379a000000000000000000000000000000000000000000000000000000000600052602060045260176024527f4d756c746963616c6c333a2063616c6c206661696c656400000000000000000060445260846000fd5b826001019250505061045c565b5082341461060c576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610603906114a7565b60405180910390fd5b50505092915050565b6000606043915060008484905090508067ffffffffffffffff81111561063e5761063d6112fa565b5b60405190808252806020026020018201604052801561067157816020015b606081526020019060019003908161065c5790505b5091503660005b828110156107a157600087878381811061069557610694611329565b5b90506020028101906106a791906114c7565b92508260000160208101906106bc91906111a7565b73ffffffffffffffffffffffffffffffffffffffff168380602001906106e2919061138f565b6040516106f0929190611431565b6000604051808303816000865af19150503d806000811461072d576040519150601f19603f3d011682016040523d82523d6000602084013e610732565b606091505b5086848151811061074657610745611329565b5b60200260200101819052819250505080610795576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161078c9061153b565b60405180910390fd5b81600101915050610678565b5050509250929050565b60006001430340905090565b600046905090565b6000806060439250434091506107d68686866109f4565b905093509350939050565b600048905090565b600043905090565b60008173ffffffffffffffffffffffffffffffffffffffff16319050919050565b600044905090565b606060008383905090508067ffffffffffffffff81111561083e5761083d6112fa565b5b60405190808252806020026020018201604052801561087757816020015b610864610bd5565b81526020019060019003908161085c5790505b5091503660005b828110156109db57600084828151811061089b5761089a611329565b5b602002602001015190508686838181106108b8576108b7611329565b5b90506020028101906108ca919061155b565b92508260000160208101906108df91906111a7565b73ffffffffffffffffffffffffffffffffffffffff16838060400190610905919061138f565b604051610913929190611431565b6000604051808303816000865af19150503d8060008114610950576040519150601f19603f3d011682016040523d82523d6000602084013e610955565b606091505b5082600001836020018290528215151515815250505080516020840135176109cf577f08c379a000000000000000000000000000000000000000000000000000000000600052602060045260176024527f4d756c746963616c6c333a2063616c6c206661696c656400000000000000000060445260646000fd5b8160010191505061087e565b50505092915050565b600045905090565b600041905090565b606060008383905090508067ffffffffffffffff811115610a1857610a176112fa565b5b604051908082528060200260200182016040528015610a5157816020015b610a3e610bd5565b815260200190600190039081610a365790505b5091503660005b82811015610b9c576000848281518110610a7557610a74611329565b5b60200260200101519050868683818110610a9257610a91611329565b5b9050602002810190610aa491906114c7565b9250826000016020810190610ab991906111a7565b73ffffffffffffffffffffffffffffffffffffffff16838060200190610adf919061138f565b604051610aed929190611431565b6000604051808303816000865af19150503d8060008114610b2a576040519150601f19603f3d011682016040523d82523d6000602084013e610b2f565b606091505b508260000183602001829052821515151581525050508715610b90578060000151610b8f576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610b869061153b565b60405180910390fd5b5b81600101915050610a58565b5050509392505050565b6000806060610bb7600186866107bf565b8093508194508295505050509250925092565b600081409050919050565b6040518060400160405280600015158152602001606081525090565b6000819050919050565b610c0481610bf1565b82525050565b6000602082019050610c1f6000830184610bfb565b92915050565b600080fd5b600080fd5b600080fd5b600080fd5b600080fd5b60008083601f840112610c5457610c53610c2f565b5b8235905067ffffffffffffffff811115610c7157610c70610c34565b5b602083019150836020820283011115610c8d57610c8c610c39565b5b9250929050565b60008060208385031215610cab57610caa610c25565b5b600083013567ffffffffffffffff811115610cc957610cc8610c2a565b5b610cd585828601610c3e565b92509250509250929050565b600081519050919050565b600082825260208201905092915050565b6000819050602082019050919050565b60008115159050919050565b610d2281610d0d565b82525050565b600081519050919050565b600082825260208201905092915050565b60005b83811015610d62578082015181840152602081019050610d47565b83811115610d71576000848401525b50505050565b6000601f19601f8301169050919050565b6000610d9382610d28565b610d9d8185610d33565b9350610dad818560208601610d44565b610db681610d77565b840191505092915050565b6000604083016000830151610dd96000860182610d19565b5060208301518482036020860152610df18282610d88565b9150508091505092915050565b6000610e0a8383610dc1565b905092915050565b6000602082019050919050565b6000610e2a82610ce1565b610e348185610cec565b935083602082028501610e4685610cfd565b8060005b85811015610e825784840389528151610e638582610dfe565b9450610e6e83610e12565b925060208a01995050600181019050610e4a565b50829750879550505050505092915050565b60006020820190508181036000830152610eae8184610e1f565b905092915050565b60008083601f840112610ecc57610ecb610c2f565b5b8235905067ffffffffffffffff811115610ee957610ee8610c34565b5b602083019150836020820283011115610f0557610f04610c39565b5b9250929050565b60008060208385031215610f2357610f22610c25565b5b600083013567ffffffffffffffff811115610f4157610f40610c2a565b5b610f4d85828601610eb6565b92509250509250929050565b600081519050919050565b600082825260208201905092915050565b6000819050602082019050919050565b6000610f918383610d88565b905092915050565b6000602082019050919050565b6000610fb182610f59565b610fbb8185610f64565b935083602082028501610fcd85610f75565b8060005b858110156110095784840389528151610fea8582610f85565b9450610ff583610f99565b925060208a01995050600181019050610fd1565b50829750879550505050505092915050565b60006040820190506110306000830185610bfb565b81810360208301526110428184610fa6565b90509392505050565b6000819050919050565b61105e8161104b565b82525050565b60006020820190506110796000830184611055565b92915050565b61108881610d0d565b811461109357600080fd5b50565b6000813590506110a58161107f565b92915050565b6000806000604084860312156110c4576110c3610c25565b5b60006110d286828701611096565b935050602084013567ffffffffffffffff8111156110f3576110f2610c2a565b5b6110ff86828701610eb6565b92509250509250925092565b60006060820190506111206000830186610bfb565b61112d6020830185611055565b818103604083015261113f8184610e1f565b9050949350505050565b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b600061117482611149565b9050919050565b61118481611169565b811461118f57600080fd5b50565b6000813590506111a18161117b565b92915050565b6000602082840312156111bd576111bc610c25565b5b60006111cb84828501611192565b91505092915050565b60008083601f8401126111ea576111e9610c2f565b5b8235905067ffffffffffffffff81111561120757611206610c34565b5b60208301915083602082028301111561122357611222610c39565b5b9250929050565b6000806020838503121561124157611240610c25565b5b600083013567ffffffffffffffff81111561125f5761125e610c2a565b5b61126b858286016111d4565b92509250509250929050565b61128081611169565b82525050565b600060208201905061129b6000830184611277565b92915050565b6112aa81610bf1565b81146112b557600080fd5b50565b6000813590506112c7816112a1565b92915050565b6000602082840312156112e3576112e2610c25565b5b60006112f1848285016112b8565b91505092915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b600080fd5b600080fd5b600080fd5b60008235600160800383360303811261138357611382611358565b5b80830191505092915050565b600080833560016020038436030381126113ac576113ab611358565b5b80840192508235915067ffffffffffffffff8211156113ce576113cd61135d565b5b6020830192506001820236038313156113ea576113e9611362565b5b509250929050565b600081905092915050565b82818337600083830152505050565b600061141883856113f2565b93506114258385846113fd565b82840190509392505050565b600061143e82848661140c565b91508190509392505050565b600082825260208201905092915050565b7f4d756c746963616c6c333a2076616c7565206d69736d61746368000000000000600082015250565b6000611491601a8361144a565b915061149c8261145b565b602082019050919050565b600060208201905081810360008301526114c081611484565b9050919050565b6000823560016040038336030381126114e3576114e2611358565b5b80830191505092915050565b7f4d756c746963616c6c333a2063616c6c206661696c6564000000000000000000600082015250565b600061152560178361144a565b9150611530826114ef565b602082019050919050565b6000602082019050818103600083015261155481611518565b9050919050565b60008235600160600383360303811261157757611576611358565b5b8083019150509291505056fea264697066735822122020c1bc9aacf8e4a6507193432a895a8e77094f45a1395583f07b24e860ef06cd64736f6c634300080c0033';
//# sourceMappingURL=contracts.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/constants/kzg.js":
/*!*************************************************!*\
  !*** ./node_modules/viem/_cjs/constants/kzg.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.versionedHashVersionKzg = void 0;
exports.versionedHashVersionKzg = 1;
//# sourceMappingURL=kzg.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/constants/number.js":
/*!****************************************************!*\
  !*** ./node_modules/viem/_cjs/constants/number.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.minInt144 = exports.minInt136 = exports.minInt128 = exports.minInt120 = exports.minInt112 = exports.minInt104 = exports.minInt96 = exports.minInt88 = exports.minInt80 = exports.minInt72 = exports.minInt64 = exports.minInt56 = exports.minInt48 = exports.minInt40 = exports.minInt32 = exports.minInt24 = exports.minInt16 = exports.minInt8 = exports.maxInt256 = exports.maxInt248 = exports.maxInt240 = exports.maxInt232 = exports.maxInt224 = exports.maxInt216 = exports.maxInt208 = exports.maxInt200 = exports.maxInt192 = exports.maxInt184 = exports.maxInt176 = exports.maxInt168 = exports.maxInt160 = exports.maxInt152 = exports.maxInt144 = exports.maxInt136 = exports.maxInt128 = exports.maxInt120 = exports.maxInt112 = exports.maxInt104 = exports.maxInt96 = exports.maxInt88 = exports.maxInt80 = exports.maxInt72 = exports.maxInt64 = exports.maxInt56 = exports.maxInt48 = exports.maxInt40 = exports.maxInt32 = exports.maxInt24 = exports.maxInt16 = exports.maxInt8 = void 0;
exports.maxUint256 = exports.maxUint248 = exports.maxUint240 = exports.maxUint232 = exports.maxUint224 = exports.maxUint216 = exports.maxUint208 = exports.maxUint200 = exports.maxUint192 = exports.maxUint184 = exports.maxUint176 = exports.maxUint168 = exports.maxUint160 = exports.maxUint152 = exports.maxUint144 = exports.maxUint136 = exports.maxUint128 = exports.maxUint120 = exports.maxUint112 = exports.maxUint104 = exports.maxUint96 = exports.maxUint88 = exports.maxUint80 = exports.maxUint72 = exports.maxUint64 = exports.maxUint56 = exports.maxUint48 = exports.maxUint40 = exports.maxUint32 = exports.maxUint24 = exports.maxUint16 = exports.maxUint8 = exports.minInt256 = exports.minInt248 = exports.minInt240 = exports.minInt232 = exports.minInt224 = exports.minInt216 = exports.minInt208 = exports.minInt200 = exports.minInt192 = exports.minInt184 = exports.minInt176 = exports.minInt168 = exports.minInt160 = exports.minInt152 = void 0;
exports.maxInt8 = 2n ** (8n - 1n) - 1n;
exports.maxInt16 = 2n ** (16n - 1n) - 1n;
exports.maxInt24 = 2n ** (24n - 1n) - 1n;
exports.maxInt32 = 2n ** (32n - 1n) - 1n;
exports.maxInt40 = 2n ** (40n - 1n) - 1n;
exports.maxInt48 = 2n ** (48n - 1n) - 1n;
exports.maxInt56 = 2n ** (56n - 1n) - 1n;
exports.maxInt64 = 2n ** (64n - 1n) - 1n;
exports.maxInt72 = 2n ** (72n - 1n) - 1n;
exports.maxInt80 = 2n ** (80n - 1n) - 1n;
exports.maxInt88 = 2n ** (88n - 1n) - 1n;
exports.maxInt96 = 2n ** (96n - 1n) - 1n;
exports.maxInt104 = 2n ** (104n - 1n) - 1n;
exports.maxInt112 = 2n ** (112n - 1n) - 1n;
exports.maxInt120 = 2n ** (120n - 1n) - 1n;
exports.maxInt128 = 2n ** (128n - 1n) - 1n;
exports.maxInt136 = 2n ** (136n - 1n) - 1n;
exports.maxInt144 = 2n ** (144n - 1n) - 1n;
exports.maxInt152 = 2n ** (152n - 1n) - 1n;
exports.maxInt160 = 2n ** (160n - 1n) - 1n;
exports.maxInt168 = 2n ** (168n - 1n) - 1n;
exports.maxInt176 = 2n ** (176n - 1n) - 1n;
exports.maxInt184 = 2n ** (184n - 1n) - 1n;
exports.maxInt192 = 2n ** (192n - 1n) - 1n;
exports.maxInt200 = 2n ** (200n - 1n) - 1n;
exports.maxInt208 = 2n ** (208n - 1n) - 1n;
exports.maxInt216 = 2n ** (216n - 1n) - 1n;
exports.maxInt224 = 2n ** (224n - 1n) - 1n;
exports.maxInt232 = 2n ** (232n - 1n) - 1n;
exports.maxInt240 = 2n ** (240n - 1n) - 1n;
exports.maxInt248 = 2n ** (248n - 1n) - 1n;
exports.maxInt256 = 2n ** (256n - 1n) - 1n;
exports.minInt8 = -(2n ** (8n - 1n));
exports.minInt16 = -(2n ** (16n - 1n));
exports.minInt24 = -(2n ** (24n - 1n));
exports.minInt32 = -(2n ** (32n - 1n));
exports.minInt40 = -(2n ** (40n - 1n));
exports.minInt48 = -(2n ** (48n - 1n));
exports.minInt56 = -(2n ** (56n - 1n));
exports.minInt64 = -(2n ** (64n - 1n));
exports.minInt72 = -(2n ** (72n - 1n));
exports.minInt80 = -(2n ** (80n - 1n));
exports.minInt88 = -(2n ** (88n - 1n));
exports.minInt96 = -(2n ** (96n - 1n));
exports.minInt104 = -(2n ** (104n - 1n));
exports.minInt112 = -(2n ** (112n - 1n));
exports.minInt120 = -(2n ** (120n - 1n));
exports.minInt128 = -(2n ** (128n - 1n));
exports.minInt136 = -(2n ** (136n - 1n));
exports.minInt144 = -(2n ** (144n - 1n));
exports.minInt152 = -(2n ** (152n - 1n));
exports.minInt160 = -(2n ** (160n - 1n));
exports.minInt168 = -(2n ** (168n - 1n));
exports.minInt176 = -(2n ** (176n - 1n));
exports.minInt184 = -(2n ** (184n - 1n));
exports.minInt192 = -(2n ** (192n - 1n));
exports.minInt200 = -(2n ** (200n - 1n));
exports.minInt208 = -(2n ** (208n - 1n));
exports.minInt216 = -(2n ** (216n - 1n));
exports.minInt224 = -(2n ** (224n - 1n));
exports.minInt232 = -(2n ** (232n - 1n));
exports.minInt240 = -(2n ** (240n - 1n));
exports.minInt248 = -(2n ** (248n - 1n));
exports.minInt256 = -(2n ** (256n - 1n));
exports.maxUint8 = 2n ** 8n - 1n;
exports.maxUint16 = 2n ** 16n - 1n;
exports.maxUint24 = 2n ** 24n - 1n;
exports.maxUint32 = 2n ** 32n - 1n;
exports.maxUint40 = 2n ** 40n - 1n;
exports.maxUint48 = 2n ** 48n - 1n;
exports.maxUint56 = 2n ** 56n - 1n;
exports.maxUint64 = 2n ** 64n - 1n;
exports.maxUint72 = 2n ** 72n - 1n;
exports.maxUint80 = 2n ** 80n - 1n;
exports.maxUint88 = 2n ** 88n - 1n;
exports.maxUint96 = 2n ** 96n - 1n;
exports.maxUint104 = 2n ** 104n - 1n;
exports.maxUint112 = 2n ** 112n - 1n;
exports.maxUint120 = 2n ** 120n - 1n;
exports.maxUint128 = 2n ** 128n - 1n;
exports.maxUint136 = 2n ** 136n - 1n;
exports.maxUint144 = 2n ** 144n - 1n;
exports.maxUint152 = 2n ** 152n - 1n;
exports.maxUint160 = 2n ** 160n - 1n;
exports.maxUint168 = 2n ** 168n - 1n;
exports.maxUint176 = 2n ** 176n - 1n;
exports.maxUint184 = 2n ** 184n - 1n;
exports.maxUint192 = 2n ** 192n - 1n;
exports.maxUint200 = 2n ** 200n - 1n;
exports.maxUint208 = 2n ** 208n - 1n;
exports.maxUint216 = 2n ** 216n - 1n;
exports.maxUint224 = 2n ** 224n - 1n;
exports.maxUint232 = 2n ** 232n - 1n;
exports.maxUint240 = 2n ** 240n - 1n;
exports.maxUint248 = 2n ** 248n - 1n;
exports.maxUint256 = 2n ** 256n - 1n;
//# sourceMappingURL=number.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/constants/solidity.js":
/*!******************************************************!*\
  !*** ./node_modules/viem/_cjs/constants/solidity.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.solidityPanic = exports.solidityError = exports.panicReasons = void 0;
exports.panicReasons = {
    1: 'An `assert` condition failed.',
    17: 'Arithmetic operation resulted in underflow or overflow.',
    18: 'Division or modulo by zero (e.g. `5 / 0` or `23 % 0`).',
    33: 'Attempted to convert to an invalid type.',
    34: 'Attempted to access a storage byte array that is incorrectly encoded.',
    49: 'Performed `.pop()` on an empty array',
    50: 'Array index is out of bounds.',
    65: 'Allocated too much memory or created an array which is too large.',
    81: 'Attempted to call a zero-initialized variable of internal function type.',
};
exports.solidityError = {
    inputs: [
        {
            name: 'message',
            type: 'string',
        },
    ],
    name: 'Error',
    type: 'error',
};
exports.solidityPanic = {
    inputs: [
        {
            name: 'reason',
            type: 'uint256',
        },
    ],
    name: 'Panic',
    type: 'error',
};
//# sourceMappingURL=solidity.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/constants/strings.js":
/*!*****************************************************!*\
  !*** ./node_modules/viem/_cjs/constants/strings.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.presignMessagePrefix = void 0;
exports.presignMessagePrefix = '\x19Ethereum Signed Message:\n';
//# sourceMappingURL=strings.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/constants/unit.js":
/*!**************************************************!*\
  !*** ./node_modules/viem/_cjs/constants/unit.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.weiUnits = exports.gweiUnits = exports.etherUnits = void 0;
exports.etherUnits = {
    gwei: 9,
    wei: 18,
};
exports.gweiUnits = {
    ether: -9,
    wei: 9,
};
exports.weiUnits = {
    ether: -18,
    gwei: -9,
};
//# sourceMappingURL=unit.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/errors/abi.js":
/*!**********************************************!*\
  !*** ./node_modules/viem/_cjs/errors/abi.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UnsupportedPackedAbiType = exports.InvalidDefinitionTypeError = exports.InvalidArrayError = exports.InvalidAbiDecodingTypeError = exports.InvalidAbiEncodingTypeError = exports.DecodeLogTopicsMismatch = exports.DecodeLogDataMismatch = exports.BytesSizeMismatchError = exports.AbiItemAmbiguityError = exports.AbiFunctionSignatureNotFoundError = exports.AbiFunctionOutputsNotFoundError = exports.AbiFunctionNotFoundError = exports.AbiEventNotFoundError = exports.AbiEventSignatureNotFoundError = exports.AbiEventSignatureEmptyTopicsError = exports.AbiErrorSignatureNotFoundError = exports.AbiErrorNotFoundError = exports.AbiErrorInputsNotFoundError = exports.AbiEncodingLengthMismatchError = exports.AbiEncodingBytesSizeMismatchError = exports.AbiEncodingArrayLengthMismatchError = exports.AbiDecodingZeroDataError = exports.AbiDecodingDataSizeTooSmallError = exports.AbiDecodingDataSizeInvalidError = exports.AbiConstructorParamsNotFoundError = exports.AbiConstructorNotFoundError = void 0;
const formatAbiItem_js_1 = __webpack_require__(/*! ../utils/abi/formatAbiItem.js */ "./node_modules/viem/_cjs/utils/abi/formatAbiItem.js");
const size_js_1 = __webpack_require__(/*! ../utils/data/size.js */ "./node_modules/viem/_cjs/utils/data/size.js");
const base_js_1 = __webpack_require__(/*! ./base.js */ "./node_modules/viem/_cjs/errors/base.js");
class AbiConstructorNotFoundError extends base_js_1.BaseError {
    constructor({ docsPath }) {
        super([
            'A constructor was not found on the ABI.',
            'Make sure you are using the correct ABI and that the constructor exists on it.',
        ].join('\n'), {
            docsPath,
            name: 'AbiConstructorNotFoundError',
        });
    }
}
exports.AbiConstructorNotFoundError = AbiConstructorNotFoundError;
class AbiConstructorParamsNotFoundError extends base_js_1.BaseError {
    constructor({ docsPath }) {
        super([
            'Constructor arguments were provided (`args`), but a constructor parameters (`inputs`) were not found on the ABI.',
            'Make sure you are using the correct ABI, and that the `inputs` attribute on the constructor exists.',
        ].join('\n'), {
            docsPath,
            name: 'AbiConstructorParamsNotFoundError',
        });
    }
}
exports.AbiConstructorParamsNotFoundError = AbiConstructorParamsNotFoundError;
class AbiDecodingDataSizeInvalidError extends base_js_1.BaseError {
    constructor({ data, size }) {
        super([
            `Data size of ${size} bytes is invalid.`,
            'Size must be in increments of 32 bytes (size % 32 === 0).',
        ].join('\n'), {
            metaMessages: [`Data: ${data} (${size} bytes)`],
            name: 'AbiDecodingDataSizeInvalidError',
        });
    }
}
exports.AbiDecodingDataSizeInvalidError = AbiDecodingDataSizeInvalidError;
class AbiDecodingDataSizeTooSmallError extends base_js_1.BaseError {
    constructor({ data, params, size, }) {
        super([`Data size of ${size} bytes is too small for given parameters.`].join('\n'), {
            metaMessages: [
                `Params: (${(0, formatAbiItem_js_1.formatAbiParams)(params, { includeName: true })})`,
                `Data:   ${data} (${size} bytes)`,
            ],
            name: 'AbiDecodingDataSizeTooSmallError',
        });
        Object.defineProperty(this, "data", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "params", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "size", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.data = data;
        this.params = params;
        this.size = size;
    }
}
exports.AbiDecodingDataSizeTooSmallError = AbiDecodingDataSizeTooSmallError;
class AbiDecodingZeroDataError extends base_js_1.BaseError {
    constructor() {
        super('Cannot decode zero data ("0x") with ABI parameters.', {
            name: 'AbiDecodingZeroDataError',
        });
    }
}
exports.AbiDecodingZeroDataError = AbiDecodingZeroDataError;
class AbiEncodingArrayLengthMismatchError extends base_js_1.BaseError {
    constructor({ expectedLength, givenLength, type, }) {
        super([
            `ABI encoding array length mismatch for type ${type}.`,
            `Expected length: ${expectedLength}`,
            `Given length: ${givenLength}`,
        ].join('\n'), { name: 'AbiEncodingArrayLengthMismatchError' });
    }
}
exports.AbiEncodingArrayLengthMismatchError = AbiEncodingArrayLengthMismatchError;
class AbiEncodingBytesSizeMismatchError extends base_js_1.BaseError {
    constructor({ expectedSize, value }) {
        super(`Size of bytes "${value}" (bytes${(0, size_js_1.size)(value)}) does not match expected size (bytes${expectedSize}).`, { name: 'AbiEncodingBytesSizeMismatchError' });
    }
}
exports.AbiEncodingBytesSizeMismatchError = AbiEncodingBytesSizeMismatchError;
class AbiEncodingLengthMismatchError extends base_js_1.BaseError {
    constructor({ expectedLength, givenLength, }) {
        super([
            'ABI encoding params/values length mismatch.',
            `Expected length (params): ${expectedLength}`,
            `Given length (values): ${givenLength}`,
        ].join('\n'), { name: 'AbiEncodingLengthMismatchError' });
    }
}
exports.AbiEncodingLengthMismatchError = AbiEncodingLengthMismatchError;
class AbiErrorInputsNotFoundError extends base_js_1.BaseError {
    constructor(errorName, { docsPath }) {
        super([
            `Arguments (\`args\`) were provided to "${errorName}", but "${errorName}" on the ABI does not contain any parameters (\`inputs\`).`,
            'Cannot encode error result without knowing what the parameter types are.',
            'Make sure you are using the correct ABI and that the inputs exist on it.',
        ].join('\n'), {
            docsPath,
            name: 'AbiErrorInputsNotFoundError',
        });
    }
}
exports.AbiErrorInputsNotFoundError = AbiErrorInputsNotFoundError;
class AbiErrorNotFoundError extends base_js_1.BaseError {
    constructor(errorName, { docsPath } = {}) {
        super([
            `Error ${errorName ? `"${errorName}" ` : ''}not found on ABI.`,
            'Make sure you are using the correct ABI and that the error exists on it.',
        ].join('\n'), {
            docsPath,
            name: 'AbiErrorNotFoundError',
        });
    }
}
exports.AbiErrorNotFoundError = AbiErrorNotFoundError;
class AbiErrorSignatureNotFoundError extends base_js_1.BaseError {
    constructor(signature, { docsPath }) {
        super([
            `Encoded error signature "${signature}" not found on ABI.`,
            'Make sure you are using the correct ABI and that the error exists on it.',
            `You can look up the decoded signature here: https://openchain.xyz/signatures?query=${signature}.`,
        ].join('\n'), {
            docsPath,
            name: 'AbiErrorSignatureNotFoundError',
        });
        Object.defineProperty(this, "signature", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.signature = signature;
    }
}
exports.AbiErrorSignatureNotFoundError = AbiErrorSignatureNotFoundError;
class AbiEventSignatureEmptyTopicsError extends base_js_1.BaseError {
    constructor({ docsPath }) {
        super('Cannot extract event signature from empty topics.', {
            docsPath,
            name: 'AbiEventSignatureEmptyTopicsError',
        });
    }
}
exports.AbiEventSignatureEmptyTopicsError = AbiEventSignatureEmptyTopicsError;
class AbiEventSignatureNotFoundError extends base_js_1.BaseError {
    constructor(signature, { docsPath }) {
        super([
            `Encoded event signature "${signature}" not found on ABI.`,
            'Make sure you are using the correct ABI and that the event exists on it.',
            `You can look up the signature here: https://openchain.xyz/signatures?query=${signature}.`,
        ].join('\n'), {
            docsPath,
            name: 'AbiEventSignatureNotFoundError',
        });
    }
}
exports.AbiEventSignatureNotFoundError = AbiEventSignatureNotFoundError;
class AbiEventNotFoundError extends base_js_1.BaseError {
    constructor(eventName, { docsPath } = {}) {
        super([
            `Event ${eventName ? `"${eventName}" ` : ''}not found on ABI.`,
            'Make sure you are using the correct ABI and that the event exists on it.',
        ].join('\n'), {
            docsPath,
            name: 'AbiEventNotFoundError',
        });
    }
}
exports.AbiEventNotFoundError = AbiEventNotFoundError;
class AbiFunctionNotFoundError extends base_js_1.BaseError {
    constructor(functionName, { docsPath } = {}) {
        super([
            `Function ${functionName ? `"${functionName}" ` : ''}not found on ABI.`,
            'Make sure you are using the correct ABI and that the function exists on it.',
        ].join('\n'), {
            docsPath,
            name: 'AbiFunctionNotFoundError',
        });
    }
}
exports.AbiFunctionNotFoundError = AbiFunctionNotFoundError;
class AbiFunctionOutputsNotFoundError extends base_js_1.BaseError {
    constructor(functionName, { docsPath }) {
        super([
            `Function "${functionName}" does not contain any \`outputs\` on ABI.`,
            'Cannot decode function result without knowing what the parameter types are.',
            'Make sure you are using the correct ABI and that the function exists on it.',
        ].join('\n'), {
            docsPath,
            name: 'AbiFunctionOutputsNotFoundError',
        });
    }
}
exports.AbiFunctionOutputsNotFoundError = AbiFunctionOutputsNotFoundError;
class AbiFunctionSignatureNotFoundError extends base_js_1.BaseError {
    constructor(signature, { docsPath }) {
        super([
            `Encoded function signature "${signature}" not found on ABI.`,
            'Make sure you are using the correct ABI and that the function exists on it.',
            `You can look up the signature here: https://openchain.xyz/signatures?query=${signature}.`,
        ].join('\n'), {
            docsPath,
            name: 'AbiFunctionSignatureNotFoundError',
        });
    }
}
exports.AbiFunctionSignatureNotFoundError = AbiFunctionSignatureNotFoundError;
class AbiItemAmbiguityError extends base_js_1.BaseError {
    constructor(x, y) {
        super('Found ambiguous types in overloaded ABI items.', {
            metaMessages: [
                `\`${x.type}\` in \`${(0, formatAbiItem_js_1.formatAbiItem)(x.abiItem)}\`, and`,
                `\`${y.type}\` in \`${(0, formatAbiItem_js_1.formatAbiItem)(y.abiItem)}\``,
                '',
                'These types encode differently and cannot be distinguished at runtime.',
                'Remove one of the ambiguous items in the ABI.',
            ],
            name: 'AbiItemAmbiguityError',
        });
    }
}
exports.AbiItemAmbiguityError = AbiItemAmbiguityError;
class BytesSizeMismatchError extends base_js_1.BaseError {
    constructor({ expectedSize, givenSize, }) {
        super(`Expected bytes${expectedSize}, got bytes${givenSize}.`, {
            name: 'BytesSizeMismatchError',
        });
    }
}
exports.BytesSizeMismatchError = BytesSizeMismatchError;
class DecodeLogDataMismatch extends base_js_1.BaseError {
    constructor({ abiItem, data, params, size, }) {
        super([
            `Data size of ${size} bytes is too small for non-indexed event parameters.`,
        ].join('\n'), {
            metaMessages: [
                `Params: (${(0, formatAbiItem_js_1.formatAbiParams)(params, { includeName: true })})`,
                `Data:   ${data} (${size} bytes)`,
            ],
            name: 'DecodeLogDataMismatch',
        });
        Object.defineProperty(this, "abiItem", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "data", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "params", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "size", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.abiItem = abiItem;
        this.data = data;
        this.params = params;
        this.size = size;
    }
}
exports.DecodeLogDataMismatch = DecodeLogDataMismatch;
class DecodeLogTopicsMismatch extends base_js_1.BaseError {
    constructor({ abiItem, param, }) {
        super([
            `Expected a topic for indexed event parameter${param.name ? ` "${param.name}"` : ''} on event "${(0, formatAbiItem_js_1.formatAbiItem)(abiItem, { includeName: true })}".`,
        ].join('\n'), { name: 'DecodeLogTopicsMismatch' });
        Object.defineProperty(this, "abiItem", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.abiItem = abiItem;
    }
}
exports.DecodeLogTopicsMismatch = DecodeLogTopicsMismatch;
class InvalidAbiEncodingTypeError extends base_js_1.BaseError {
    constructor(type, { docsPath }) {
        super([
            `Type "${type}" is not a valid encoding type.`,
            'Please provide a valid ABI type.',
        ].join('\n'), { docsPath, name: 'InvalidAbiEncodingType' });
    }
}
exports.InvalidAbiEncodingTypeError = InvalidAbiEncodingTypeError;
class InvalidAbiDecodingTypeError extends base_js_1.BaseError {
    constructor(type, { docsPath }) {
        super([
            `Type "${type}" is not a valid decoding type.`,
            'Please provide a valid ABI type.',
        ].join('\n'), { docsPath, name: 'InvalidAbiDecodingType' });
    }
}
exports.InvalidAbiDecodingTypeError = InvalidAbiDecodingTypeError;
class InvalidArrayError extends base_js_1.BaseError {
    constructor(value) {
        super([`Value "${value}" is not a valid array.`].join('\n'), {
            name: 'InvalidArrayError',
        });
    }
}
exports.InvalidArrayError = InvalidArrayError;
class InvalidDefinitionTypeError extends base_js_1.BaseError {
    constructor(type) {
        super([
            `"${type}" is not a valid definition type.`,
            'Valid types: "function", "event", "error"',
        ].join('\n'), { name: 'InvalidDefinitionTypeError' });
    }
}
exports.InvalidDefinitionTypeError = InvalidDefinitionTypeError;
class UnsupportedPackedAbiType extends base_js_1.BaseError {
    constructor(type) {
        super(`Type "${type}" is not supported for packed encoding.`, {
            name: 'UnsupportedPackedAbiType',
        });
    }
}
exports.UnsupportedPackedAbiType = UnsupportedPackedAbiType;
//# sourceMappingURL=abi.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/errors/account.js":
/*!**************************************************!*\
  !*** ./node_modules/viem/_cjs/errors/account.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AccountTypeNotSupportedError = exports.AccountNotFoundError = void 0;
const base_js_1 = __webpack_require__(/*! ./base.js */ "./node_modules/viem/_cjs/errors/base.js");
class AccountNotFoundError extends base_js_1.BaseError {
    constructor({ docsPath } = {}) {
        super([
            'Could not find an Account to execute with this Action.',
            'Please provide an Account with the `account` argument on the Action, or by supplying an `account` to the Client.',
        ].join('\n'), {
            docsPath,
            docsSlug: 'account',
            name: 'AccountNotFoundError',
        });
    }
}
exports.AccountNotFoundError = AccountNotFoundError;
class AccountTypeNotSupportedError extends base_js_1.BaseError {
    constructor({ docsPath, metaMessages, type, }) {
        super(`Account type "${type}" is not supported.`, {
            docsPath,
            metaMessages,
            name: 'AccountTypeNotSupportedError',
        });
    }
}
exports.AccountTypeNotSupportedError = AccountTypeNotSupportedError;
//# sourceMappingURL=account.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/errors/address.js":
/*!**************************************************!*\
  !*** ./node_modules/viem/_cjs/errors/address.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.InvalidAddressError = void 0;
const base_js_1 = __webpack_require__(/*! ./base.js */ "./node_modules/viem/_cjs/errors/base.js");
class InvalidAddressError extends base_js_1.BaseError {
    constructor({ address }) {
        super(`Address "${address}" is invalid.`, {
            metaMessages: [
                '- Address must be a hex value of 20 bytes (40 hex characters).',
                '- Address must match its checksum counterpart.',
            ],
            name: 'InvalidAddressError',
        });
    }
}
exports.InvalidAddressError = InvalidAddressError;
//# sourceMappingURL=address.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/errors/base.js":
/*!***********************************************!*\
  !*** ./node_modules/viem/_cjs/errors/base.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BaseError = void 0;
exports.setErrorConfig = setErrorConfig;
const version_js_1 = __webpack_require__(/*! ./version.js */ "./node_modules/viem/_cjs/errors/version.js");
let errorConfig = {
    getDocsUrl: ({ docsBaseUrl, docsPath = '', docsSlug, }) => docsPath
        ? `${docsBaseUrl ?? 'https://viem.sh'}${docsPath}${docsSlug ? `#${docsSlug}` : ''}`
        : undefined,
    version: `viem@${version_js_1.version}`,
};
function setErrorConfig(config) {
    errorConfig = config;
}
class BaseError extends Error {
    constructor(shortMessage, args = {}) {
        const details = (() => {
            if (args.cause instanceof BaseError)
                return args.cause.details;
            if (args.cause?.message)
                return args.cause.message;
            return args.details;
        })();
        const docsPath = (() => {
            if (args.cause instanceof BaseError)
                return args.cause.docsPath || args.docsPath;
            return args.docsPath;
        })();
        const docsUrl = errorConfig.getDocsUrl?.({ ...args, docsPath });
        const message = [
            shortMessage || 'An error occurred.',
            '',
            ...(args.metaMessages ? [...args.metaMessages, ''] : []),
            ...(docsUrl ? [`Docs: ${docsUrl}`] : []),
            ...(details ? [`Details: ${details}`] : []),
            ...(errorConfig.version ? [`Version: ${errorConfig.version}`] : []),
        ].join('\n');
        super(message, args.cause ? { cause: args.cause } : undefined);
        Object.defineProperty(this, "details", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "docsPath", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "metaMessages", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "shortMessage", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "version", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'BaseError'
        });
        this.details = details;
        this.docsPath = docsPath;
        this.metaMessages = args.metaMessages;
        this.name = args.name ?? this.name;
        this.shortMessage = shortMessage;
        this.version = version_js_1.version;
    }
    walk(fn) {
        return walk(this, fn);
    }
}
exports.BaseError = BaseError;
function walk(err, fn) {
    if (fn?.(err))
        return err;
    if (err &&
        typeof err === 'object' &&
        'cause' in err &&
        err.cause !== undefined)
        return walk(err.cause, fn);
    return fn ? null : err;
}
//# sourceMappingURL=base.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/errors/blob.js":
/*!***********************************************!*\
  !*** ./node_modules/viem/_cjs/errors/blob.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.InvalidVersionedHashVersionError = exports.InvalidVersionedHashSizeError = exports.EmptyBlobError = exports.BlobSizeTooLargeError = void 0;
const kzg_js_1 = __webpack_require__(/*! ../constants/kzg.js */ "./node_modules/viem/_cjs/constants/kzg.js");
const base_js_1 = __webpack_require__(/*! ./base.js */ "./node_modules/viem/_cjs/errors/base.js");
class BlobSizeTooLargeError extends base_js_1.BaseError {
    constructor({ maxSize, size }) {
        super('Blob size is too large.', {
            metaMessages: [`Max: ${maxSize} bytes`, `Given: ${size} bytes`],
            name: 'BlobSizeTooLargeError',
        });
    }
}
exports.BlobSizeTooLargeError = BlobSizeTooLargeError;
class EmptyBlobError extends base_js_1.BaseError {
    constructor() {
        super('Blob data must not be empty.', { name: 'EmptyBlobError' });
    }
}
exports.EmptyBlobError = EmptyBlobError;
class InvalidVersionedHashSizeError extends base_js_1.BaseError {
    constructor({ hash, size, }) {
        super(`Versioned hash "${hash}" size is invalid.`, {
            metaMessages: ['Expected: 32', `Received: ${size}`],
            name: 'InvalidVersionedHashSizeError',
        });
    }
}
exports.InvalidVersionedHashSizeError = InvalidVersionedHashSizeError;
class InvalidVersionedHashVersionError extends base_js_1.BaseError {
    constructor({ hash, version, }) {
        super(`Versioned hash "${hash}" version is invalid.`, {
            metaMessages: [
                `Expected: ${kzg_js_1.versionedHashVersionKzg}`,
                `Received: ${version}`,
            ],
            name: 'InvalidVersionedHashVersionError',
        });
    }
}
exports.InvalidVersionedHashVersionError = InvalidVersionedHashVersionError;
//# sourceMappingURL=blob.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/errors/block.js":
/*!************************************************!*\
  !*** ./node_modules/viem/_cjs/errors/block.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BlockNotFoundError = void 0;
const base_js_1 = __webpack_require__(/*! ./base.js */ "./node_modules/viem/_cjs/errors/base.js");
class BlockNotFoundError extends base_js_1.BaseError {
    constructor({ blockHash, blockNumber, }) {
        let identifier = 'Block';
        if (blockHash)
            identifier = `Block at hash "${blockHash}"`;
        if (blockNumber)
            identifier = `Block at number "${blockNumber}"`;
        super(`${identifier} could not be found.`, { name: 'BlockNotFoundError' });
    }
}
exports.BlockNotFoundError = BlockNotFoundError;
//# sourceMappingURL=block.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/errors/calls.js":
/*!************************************************!*\
  !*** ./node_modules/viem/_cjs/errors/calls.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BundleFailedError = void 0;
const base_js_1 = __webpack_require__(/*! ./base.js */ "./node_modules/viem/_cjs/errors/base.js");
class BundleFailedError extends base_js_1.BaseError {
    constructor(result) {
        super(`Call bundle failed with status: ${result.statusCode}`, {
            name: 'BundleFailedError',
        });
        Object.defineProperty(this, "result", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.result = result;
    }
}
exports.BundleFailedError = BundleFailedError;
//# sourceMappingURL=calls.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/errors/ccip.js":
/*!***********************************************!*\
  !*** ./node_modules/viem/_cjs/errors/ccip.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.OffchainLookupSenderMismatchError = exports.OffchainLookupResponseMalformedError = exports.OffchainLookupError = void 0;
const stringify_js_1 = __webpack_require__(/*! ../utils/stringify.js */ "./node_modules/viem/_cjs/utils/stringify.js");
const base_js_1 = __webpack_require__(/*! ./base.js */ "./node_modules/viem/_cjs/errors/base.js");
const utils_js_1 = __webpack_require__(/*! ./utils.js */ "./node_modules/viem/_cjs/errors/utils.js");
class OffchainLookupError extends base_js_1.BaseError {
    constructor({ callbackSelector, cause, data, extraData, sender, urls, }) {
        super(cause.shortMessage ||
            'An error occurred while fetching for an offchain result.', {
            cause,
            metaMessages: [
                ...(cause.metaMessages || []),
                cause.metaMessages?.length ? '' : [],
                'Offchain Gateway Call:',
                urls && [
                    '  Gateway URL(s):',
                    ...urls.map((url) => `    ${(0, utils_js_1.getUrl)(url)}`),
                ],
                `  Sender: ${sender}`,
                `  Data: ${data}`,
                `  Callback selector: ${callbackSelector}`,
                `  Extra data: ${extraData}`,
            ].flat(),
            name: 'OffchainLookupError',
        });
    }
}
exports.OffchainLookupError = OffchainLookupError;
class OffchainLookupResponseMalformedError extends base_js_1.BaseError {
    constructor({ result, url }) {
        super('Offchain gateway response is malformed. Response data must be a hex value.', {
            metaMessages: [
                `Gateway URL: ${(0, utils_js_1.getUrl)(url)}`,
                `Response: ${(0, stringify_js_1.stringify)(result)}`,
            ],
            name: 'OffchainLookupResponseMalformedError',
        });
    }
}
exports.OffchainLookupResponseMalformedError = OffchainLookupResponseMalformedError;
class OffchainLookupSenderMismatchError extends base_js_1.BaseError {
    constructor({ sender, to }) {
        super('Reverted sender address does not match target contract address (`to`).', {
            metaMessages: [
                `Contract address: ${to}`,
                `OffchainLookup sender address: ${sender}`,
            ],
            name: 'OffchainLookupSenderMismatchError',
        });
    }
}
exports.OffchainLookupSenderMismatchError = OffchainLookupSenderMismatchError;
//# sourceMappingURL=ccip.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/errors/chain.js":
/*!************************************************!*\
  !*** ./node_modules/viem/_cjs/errors/chain.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.InvalidChainIdError = exports.ClientChainNotConfiguredError = exports.ChainNotFoundError = exports.ChainMismatchError = exports.ChainDoesNotSupportContract = void 0;
const base_js_1 = __webpack_require__(/*! ./base.js */ "./node_modules/viem/_cjs/errors/base.js");
class ChainDoesNotSupportContract extends base_js_1.BaseError {
    constructor({ blockNumber, chain, contract, }) {
        super(`Chain "${chain.name}" does not support contract "${contract.name}".`, {
            metaMessages: [
                'This could be due to any of the following:',
                ...(blockNumber &&
                    contract.blockCreated &&
                    contract.blockCreated > blockNumber
                    ? [
                        `- The contract "${contract.name}" was not deployed until block ${contract.blockCreated} (current block ${blockNumber}).`,
                    ]
                    : [
                        `- The chain does not have the contract "${contract.name}" configured.`,
                    ]),
            ],
            name: 'ChainDoesNotSupportContract',
        });
    }
}
exports.ChainDoesNotSupportContract = ChainDoesNotSupportContract;
class ChainMismatchError extends base_js_1.BaseError {
    constructor({ chain, currentChainId, }) {
        super(`The current chain of the wallet (id: ${currentChainId}) does not match the target chain for the transaction (id: ${chain.id} – ${chain.name}).`, {
            metaMessages: [
                `Current Chain ID:  ${currentChainId}`,
                `Expected Chain ID: ${chain.id} – ${chain.name}`,
            ],
            name: 'ChainMismatchError',
        });
    }
}
exports.ChainMismatchError = ChainMismatchError;
class ChainNotFoundError extends base_js_1.BaseError {
    constructor() {
        super([
            'No chain was provided to the request.',
            'Please provide a chain with the `chain` argument on the Action, or by supplying a `chain` to WalletClient.',
        ].join('\n'), {
            name: 'ChainNotFoundError',
        });
    }
}
exports.ChainNotFoundError = ChainNotFoundError;
class ClientChainNotConfiguredError extends base_js_1.BaseError {
    constructor() {
        super('No chain was provided to the Client.', {
            name: 'ClientChainNotConfiguredError',
        });
    }
}
exports.ClientChainNotConfiguredError = ClientChainNotConfiguredError;
class InvalidChainIdError extends base_js_1.BaseError {
    constructor({ chainId }) {
        super(typeof chainId === 'number'
            ? `Chain ID "${chainId}" is invalid.`
            : 'Chain ID is invalid.', { name: 'InvalidChainIdError' });
    }
}
exports.InvalidChainIdError = InvalidChainIdError;
//# sourceMappingURL=chain.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/errors/contract.js":
/*!***************************************************!*\
  !*** ./node_modules/viem/_cjs/errors/contract.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RawContractError = exports.CounterfactualDeploymentFailedError = exports.ContractFunctionZeroDataError = exports.ContractFunctionRevertedError = exports.ContractFunctionExecutionError = exports.CallExecutionError = void 0;
const parseAccount_js_1 = __webpack_require__(/*! ../accounts/utils/parseAccount.js */ "./node_modules/viem/_cjs/accounts/utils/parseAccount.js");
const solidity_js_1 = __webpack_require__(/*! ../constants/solidity.js */ "./node_modules/viem/_cjs/constants/solidity.js");
const decodeErrorResult_js_1 = __webpack_require__(/*! ../utils/abi/decodeErrorResult.js */ "./node_modules/viem/_cjs/utils/abi/decodeErrorResult.js");
const formatAbiItem_js_1 = __webpack_require__(/*! ../utils/abi/formatAbiItem.js */ "./node_modules/viem/_cjs/utils/abi/formatAbiItem.js");
const formatAbiItemWithArgs_js_1 = __webpack_require__(/*! ../utils/abi/formatAbiItemWithArgs.js */ "./node_modules/viem/_cjs/utils/abi/formatAbiItemWithArgs.js");
const getAbiItem_js_1 = __webpack_require__(/*! ../utils/abi/getAbiItem.js */ "./node_modules/viem/_cjs/utils/abi/getAbiItem.js");
const formatEther_js_1 = __webpack_require__(/*! ../utils/unit/formatEther.js */ "./node_modules/viem/_cjs/utils/unit/formatEther.js");
const formatGwei_js_1 = __webpack_require__(/*! ../utils/unit/formatGwei.js */ "./node_modules/viem/_cjs/utils/unit/formatGwei.js");
const abi_js_1 = __webpack_require__(/*! ./abi.js */ "./node_modules/viem/_cjs/errors/abi.js");
const base_js_1 = __webpack_require__(/*! ./base.js */ "./node_modules/viem/_cjs/errors/base.js");
const stateOverride_js_1 = __webpack_require__(/*! ./stateOverride.js */ "./node_modules/viem/_cjs/errors/stateOverride.js");
const transaction_js_1 = __webpack_require__(/*! ./transaction.js */ "./node_modules/viem/_cjs/errors/transaction.js");
const utils_js_1 = __webpack_require__(/*! ./utils.js */ "./node_modules/viem/_cjs/errors/utils.js");
class CallExecutionError extends base_js_1.BaseError {
    constructor(cause, { account: account_, docsPath, chain, data, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce, to, value, stateOverride, }) {
        const account = account_ ? (0, parseAccount_js_1.parseAccount)(account_) : undefined;
        let prettyArgs = (0, transaction_js_1.prettyPrint)({
            from: account?.address,
            to,
            value: typeof value !== 'undefined' &&
                `${(0, formatEther_js_1.formatEther)(value)} ${chain?.nativeCurrency?.symbol || 'ETH'}`,
            data,
            gas,
            gasPrice: typeof gasPrice !== 'undefined' && `${(0, formatGwei_js_1.formatGwei)(gasPrice)} gwei`,
            maxFeePerGas: typeof maxFeePerGas !== 'undefined' &&
                `${(0, formatGwei_js_1.formatGwei)(maxFeePerGas)} gwei`,
            maxPriorityFeePerGas: typeof maxPriorityFeePerGas !== 'undefined' &&
                `${(0, formatGwei_js_1.formatGwei)(maxPriorityFeePerGas)} gwei`,
            nonce,
        });
        if (stateOverride) {
            prettyArgs += `\n${(0, stateOverride_js_1.prettyStateOverride)(stateOverride)}`;
        }
        super(cause.shortMessage, {
            cause,
            docsPath,
            metaMessages: [
                ...(cause.metaMessages ? [...cause.metaMessages, ' '] : []),
                'Raw Call Arguments:',
                prettyArgs,
            ].filter(Boolean),
            name: 'CallExecutionError',
        });
        Object.defineProperty(this, "cause", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.cause = cause;
    }
}
exports.CallExecutionError = CallExecutionError;
class ContractFunctionExecutionError extends base_js_1.BaseError {
    constructor(cause, { abi, args, contractAddress, docsPath, functionName, sender, }) {
        const abiItem = (0, getAbiItem_js_1.getAbiItem)({ abi, args, name: functionName });
        const formattedArgs = abiItem
            ? (0, formatAbiItemWithArgs_js_1.formatAbiItemWithArgs)({
                abiItem,
                args,
                includeFunctionName: false,
                includeName: false,
            })
            : undefined;
        const functionWithParams = abiItem
            ? (0, formatAbiItem_js_1.formatAbiItem)(abiItem, { includeName: true })
            : undefined;
        const prettyArgs = (0, transaction_js_1.prettyPrint)({
            address: contractAddress && (0, utils_js_1.getContractAddress)(contractAddress),
            function: functionWithParams,
            args: formattedArgs &&
                formattedArgs !== '()' &&
                `${[...Array(functionName?.length ?? 0).keys()]
                    .map(() => ' ')
                    .join('')}${formattedArgs}`,
            sender,
        });
        super(cause.shortMessage ||
            `An unknown error occurred while executing the contract function "${functionName}".`, {
            cause,
            docsPath,
            metaMessages: [
                ...(cause.metaMessages ? [...cause.metaMessages, ' '] : []),
                prettyArgs && 'Contract Call:',
                prettyArgs,
            ].filter(Boolean),
            name: 'ContractFunctionExecutionError',
        });
        Object.defineProperty(this, "abi", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "args", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "cause", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "contractAddress", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "formattedArgs", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "functionName", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "sender", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.abi = abi;
        this.args = args;
        this.cause = cause;
        this.contractAddress = contractAddress;
        this.functionName = functionName;
        this.sender = sender;
    }
}
exports.ContractFunctionExecutionError = ContractFunctionExecutionError;
class ContractFunctionRevertedError extends base_js_1.BaseError {
    constructor({ abi, data, functionName, message, }) {
        let cause;
        let decodedData;
        let metaMessages;
        let reason;
        if (data && data !== '0x') {
            try {
                decodedData = (0, decodeErrorResult_js_1.decodeErrorResult)({ abi, data });
                const { abiItem, errorName, args: errorArgs } = decodedData;
                if (errorName === 'Error') {
                    reason = errorArgs[0];
                }
                else if (errorName === 'Panic') {
                    const [firstArg] = errorArgs;
                    reason = solidity_js_1.panicReasons[firstArg];
                }
                else {
                    const errorWithParams = abiItem
                        ? (0, formatAbiItem_js_1.formatAbiItem)(abiItem, { includeName: true })
                        : undefined;
                    const formattedArgs = abiItem && errorArgs
                        ? (0, formatAbiItemWithArgs_js_1.formatAbiItemWithArgs)({
                            abiItem,
                            args: errorArgs,
                            includeFunctionName: false,
                            includeName: false,
                        })
                        : undefined;
                    metaMessages = [
                        errorWithParams ? `Error: ${errorWithParams}` : '',
                        formattedArgs && formattedArgs !== '()'
                            ? `       ${[...Array(errorName?.length ?? 0).keys()]
                                .map(() => ' ')
                                .join('')}${formattedArgs}`
                            : '',
                    ];
                }
            }
            catch (err) {
                cause = err;
            }
        }
        else if (message)
            reason = message;
        let signature;
        if (cause instanceof abi_js_1.AbiErrorSignatureNotFoundError) {
            signature = cause.signature;
            metaMessages = [
                `Unable to decode signature "${signature}" as it was not found on the provided ABI.`,
                'Make sure you are using the correct ABI and that the error exists on it.',
                `You can look up the decoded signature here: https://openchain.xyz/signatures?query=${signature}.`,
            ];
        }
        super((reason && reason !== 'execution reverted') || signature
            ? [
                `The contract function "${functionName}" reverted with the following ${signature ? 'signature' : 'reason'}:`,
                reason || signature,
            ].join('\n')
            : `The contract function "${functionName}" reverted.`, {
            cause,
            metaMessages,
            name: 'ContractFunctionRevertedError',
        });
        Object.defineProperty(this, "data", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "raw", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "reason", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "signature", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.data = decodedData;
        this.raw = data;
        this.reason = reason;
        this.signature = signature;
    }
}
exports.ContractFunctionRevertedError = ContractFunctionRevertedError;
class ContractFunctionZeroDataError extends base_js_1.BaseError {
    constructor({ functionName }) {
        super(`The contract function "${functionName}" returned no data ("0x").`, {
            metaMessages: [
                'This could be due to any of the following:',
                `  - The contract does not have the function "${functionName}",`,
                '  - The parameters passed to the contract function may be invalid, or',
                '  - The address is not a contract.',
            ],
            name: 'ContractFunctionZeroDataError',
        });
    }
}
exports.ContractFunctionZeroDataError = ContractFunctionZeroDataError;
class CounterfactualDeploymentFailedError extends base_js_1.BaseError {
    constructor({ factory }) {
        super(`Deployment for counterfactual contract call failed${factory ? ` for factory "${factory}".` : ''}`, {
            metaMessages: [
                'Please ensure:',
                '- The `factory` is a valid contract deployment factory (ie. Create2 Factory, ERC-4337 Factory, etc).',
                '- The `factoryData` is a valid encoded function call for contract deployment function on the factory.',
            ],
            name: 'CounterfactualDeploymentFailedError',
        });
    }
}
exports.CounterfactualDeploymentFailedError = CounterfactualDeploymentFailedError;
class RawContractError extends base_js_1.BaseError {
    constructor({ data, message, }) {
        super(message || '', { name: 'RawContractError' });
        Object.defineProperty(this, "code", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 3
        });
        Object.defineProperty(this, "data", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.data = data;
    }
}
exports.RawContractError = RawContractError;
//# sourceMappingURL=contract.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/errors/cursor.js":
/*!*************************************************!*\
  !*** ./node_modules/viem/_cjs/errors/cursor.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RecursiveReadLimitExceededError = exports.PositionOutOfBoundsError = exports.NegativeOffsetError = void 0;
const base_js_1 = __webpack_require__(/*! ./base.js */ "./node_modules/viem/_cjs/errors/base.js");
class NegativeOffsetError extends base_js_1.BaseError {
    constructor({ offset }) {
        super(`Offset \`${offset}\` cannot be negative.`, {
            name: 'NegativeOffsetError',
        });
    }
}
exports.NegativeOffsetError = NegativeOffsetError;
class PositionOutOfBoundsError extends base_js_1.BaseError {
    constructor({ length, position }) {
        super(`Position \`${position}\` is out of bounds (\`0 < position < ${length}\`).`, { name: 'PositionOutOfBoundsError' });
    }
}
exports.PositionOutOfBoundsError = PositionOutOfBoundsError;
class RecursiveReadLimitExceededError extends base_js_1.BaseError {
    constructor({ count, limit }) {
        super(`Recursive read limit of \`${limit}\` exceeded (recursive read count: \`${count}\`).`, { name: 'RecursiveReadLimitExceededError' });
    }
}
exports.RecursiveReadLimitExceededError = RecursiveReadLimitExceededError;
//# sourceMappingURL=cursor.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/errors/data.js":
/*!***********************************************!*\
  !*** ./node_modules/viem/_cjs/errors/data.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.InvalidBytesLengthError = exports.SizeExceedsPaddingSizeError = exports.SliceOffsetOutOfBoundsError = void 0;
const base_js_1 = __webpack_require__(/*! ./base.js */ "./node_modules/viem/_cjs/errors/base.js");
class SliceOffsetOutOfBoundsError extends base_js_1.BaseError {
    constructor({ offset, position, size, }) {
        super(`Slice ${position === 'start' ? 'starting' : 'ending'} at offset "${offset}" is out-of-bounds (size: ${size}).`, { name: 'SliceOffsetOutOfBoundsError' });
    }
}
exports.SliceOffsetOutOfBoundsError = SliceOffsetOutOfBoundsError;
class SizeExceedsPaddingSizeError extends base_js_1.BaseError {
    constructor({ size, targetSize, type, }) {
        super(`${type.charAt(0).toUpperCase()}${type
            .slice(1)
            .toLowerCase()} size (${size}) exceeds padding size (${targetSize}).`, { name: 'SizeExceedsPaddingSizeError' });
    }
}
exports.SizeExceedsPaddingSizeError = SizeExceedsPaddingSizeError;
class InvalidBytesLengthError extends base_js_1.BaseError {
    constructor({ size, targetSize, type, }) {
        super(`${type.charAt(0).toUpperCase()}${type
            .slice(1)
            .toLowerCase()} is expected to be ${targetSize} ${type} long, but is ${size} ${type} long.`, { name: 'InvalidBytesLengthError' });
    }
}
exports.InvalidBytesLengthError = InvalidBytesLengthError;
//# sourceMappingURL=data.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/errors/eip712.js":
/*!*************************************************!*\
  !*** ./node_modules/viem/_cjs/errors/eip712.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Eip712DomainNotFoundError = void 0;
const base_js_1 = __webpack_require__(/*! ./base.js */ "./node_modules/viem/_cjs/errors/base.js");
class Eip712DomainNotFoundError extends base_js_1.BaseError {
    constructor({ address }) {
        super(`No EIP-712 domain found on contract "${address}".`, {
            metaMessages: [
                'Ensure that:',
                `- The contract is deployed at the address "${address}".`,
                '- `eip712Domain()` function exists on the contract.',
                '- `eip712Domain()` function matches signature to ERC-5267 specification.',
            ],
            name: 'Eip712DomainNotFoundError',
        });
    }
}
exports.Eip712DomainNotFoundError = Eip712DomainNotFoundError;
//# sourceMappingURL=eip712.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/errors/encoding.js":
/*!***************************************************!*\
  !*** ./node_modules/viem/_cjs/errors/encoding.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SizeOverflowError = exports.InvalidHexValueError = exports.InvalidHexBooleanError = exports.InvalidBytesBooleanError = exports.IntegerOutOfRangeError = void 0;
const base_js_1 = __webpack_require__(/*! ./base.js */ "./node_modules/viem/_cjs/errors/base.js");
class IntegerOutOfRangeError extends base_js_1.BaseError {
    constructor({ max, min, signed, size, value, }) {
        super(`Number "${value}" is not in safe ${size ? `${size * 8}-bit ${signed ? 'signed' : 'unsigned'} ` : ''}integer range ${max ? `(${min} to ${max})` : `(above ${min})`}`, { name: 'IntegerOutOfRangeError' });
    }
}
exports.IntegerOutOfRangeError = IntegerOutOfRangeError;
class InvalidBytesBooleanError extends base_js_1.BaseError {
    constructor(bytes) {
        super(`Bytes value "${bytes}" is not a valid boolean. The bytes array must contain a single byte of either a 0 or 1 value.`, {
            name: 'InvalidBytesBooleanError',
        });
    }
}
exports.InvalidBytesBooleanError = InvalidBytesBooleanError;
class InvalidHexBooleanError extends base_js_1.BaseError {
    constructor(hex) {
        super(`Hex value "${hex}" is not a valid boolean. The hex value must be "0x0" (false) or "0x1" (true).`, { name: 'InvalidHexBooleanError' });
    }
}
exports.InvalidHexBooleanError = InvalidHexBooleanError;
class InvalidHexValueError extends base_js_1.BaseError {
    constructor(value) {
        super(`Hex value "${value}" is an odd length (${value.length}). It must be an even length.`, { name: 'InvalidHexValueError' });
    }
}
exports.InvalidHexValueError = InvalidHexValueError;
class SizeOverflowError extends base_js_1.BaseError {
    constructor({ givenSize, maxSize }) {
        super(`Size cannot exceed ${maxSize} bytes. Given size: ${givenSize} bytes.`, { name: 'SizeOverflowError' });
    }
}
exports.SizeOverflowError = SizeOverflowError;
//# sourceMappingURL=encoding.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/errors/ens.js":
/*!**********************************************!*\
  !*** ./node_modules/viem/_cjs/errors/ens.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EnsInvalidChainIdError = exports.EnsAvatarUnsupportedNamespaceError = exports.EnsAvatarUriResolutionError = exports.EnsAvatarInvalidNftUriError = exports.EnsAvatarInvalidMetadataError = void 0;
const base_js_1 = __webpack_require__(/*! ./base.js */ "./node_modules/viem/_cjs/errors/base.js");
class EnsAvatarInvalidMetadataError extends base_js_1.BaseError {
    constructor({ data }) {
        super('Unable to extract image from metadata. The metadata may be malformed or invalid.', {
            metaMessages: [
                '- Metadata must be a JSON object with at least an `image`, `image_url` or `image_data` property.',
                '',
                `Provided data: ${JSON.stringify(data)}`,
            ],
            name: 'EnsAvatarInvalidMetadataError',
        });
    }
}
exports.EnsAvatarInvalidMetadataError = EnsAvatarInvalidMetadataError;
class EnsAvatarInvalidNftUriError extends base_js_1.BaseError {
    constructor({ reason }) {
        super(`ENS NFT avatar URI is invalid. ${reason}`, {
            name: 'EnsAvatarInvalidNftUriError',
        });
    }
}
exports.EnsAvatarInvalidNftUriError = EnsAvatarInvalidNftUriError;
class EnsAvatarUriResolutionError extends base_js_1.BaseError {
    constructor({ uri }) {
        super(`Unable to resolve ENS avatar URI "${uri}". The URI may be malformed, invalid, or does not respond with a valid image.`, { name: 'EnsAvatarUriResolutionError' });
    }
}
exports.EnsAvatarUriResolutionError = EnsAvatarUriResolutionError;
class EnsAvatarUnsupportedNamespaceError extends base_js_1.BaseError {
    constructor({ namespace }) {
        super(`ENS NFT avatar namespace "${namespace}" is not supported. Must be "erc721" or "erc1155".`, { name: 'EnsAvatarUnsupportedNamespaceError' });
    }
}
exports.EnsAvatarUnsupportedNamespaceError = EnsAvatarUnsupportedNamespaceError;
class EnsInvalidChainIdError extends base_js_1.BaseError {
    constructor({ chainId }) {
        super(`Invalid ENSIP-11 chainId: ${chainId}. Must be between 0 and 0x7fffffff, or 1.`, {
            name: 'EnsInvalidChainIdError',
        });
    }
}
exports.EnsInvalidChainIdError = EnsInvalidChainIdError;
//# sourceMappingURL=ens.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/errors/estimateGas.js":
/*!******************************************************!*\
  !*** ./node_modules/viem/_cjs/errors/estimateGas.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EstimateGasExecutionError = void 0;
const formatEther_js_1 = __webpack_require__(/*! ../utils/unit/formatEther.js */ "./node_modules/viem/_cjs/utils/unit/formatEther.js");
const formatGwei_js_1 = __webpack_require__(/*! ../utils/unit/formatGwei.js */ "./node_modules/viem/_cjs/utils/unit/formatGwei.js");
const base_js_1 = __webpack_require__(/*! ./base.js */ "./node_modules/viem/_cjs/errors/base.js");
const transaction_js_1 = __webpack_require__(/*! ./transaction.js */ "./node_modules/viem/_cjs/errors/transaction.js");
class EstimateGasExecutionError extends base_js_1.BaseError {
    constructor(cause, { account, docsPath, chain, data, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce, to, value, }) {
        const prettyArgs = (0, transaction_js_1.prettyPrint)({
            from: account?.address,
            to,
            value: typeof value !== 'undefined' &&
                `${(0, formatEther_js_1.formatEther)(value)} ${chain?.nativeCurrency?.symbol || 'ETH'}`,
            data,
            gas,
            gasPrice: typeof gasPrice !== 'undefined' && `${(0, formatGwei_js_1.formatGwei)(gasPrice)} gwei`,
            maxFeePerGas: typeof maxFeePerGas !== 'undefined' &&
                `${(0, formatGwei_js_1.formatGwei)(maxFeePerGas)} gwei`,
            maxPriorityFeePerGas: typeof maxPriorityFeePerGas !== 'undefined' &&
                `${(0, formatGwei_js_1.formatGwei)(maxPriorityFeePerGas)} gwei`,
            nonce,
        });
        super(cause.shortMessage, {
            cause,
            docsPath,
            metaMessages: [
                ...(cause.metaMessages ? [...cause.metaMessages, ' '] : []),
                'Estimate Gas Arguments:',
                prettyArgs,
            ].filter(Boolean),
            name: 'EstimateGasExecutionError',
        });
        Object.defineProperty(this, "cause", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.cause = cause;
    }
}
exports.EstimateGasExecutionError = EstimateGasExecutionError;
//# sourceMappingURL=estimateGas.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/errors/fee.js":
/*!**********************************************!*\
  !*** ./node_modules/viem/_cjs/errors/fee.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MaxFeePerGasTooLowError = exports.Eip1559FeesNotSupportedError = exports.BaseFeeScalarError = void 0;
const formatGwei_js_1 = __webpack_require__(/*! ../utils/unit/formatGwei.js */ "./node_modules/viem/_cjs/utils/unit/formatGwei.js");
const base_js_1 = __webpack_require__(/*! ./base.js */ "./node_modules/viem/_cjs/errors/base.js");
class BaseFeeScalarError extends base_js_1.BaseError {
    constructor() {
        super('`baseFeeMultiplier` must be greater than 1.', {
            name: 'BaseFeeScalarError',
        });
    }
}
exports.BaseFeeScalarError = BaseFeeScalarError;
class Eip1559FeesNotSupportedError extends base_js_1.BaseError {
    constructor() {
        super('Chain does not support EIP-1559 fees.', {
            name: 'Eip1559FeesNotSupportedError',
        });
    }
}
exports.Eip1559FeesNotSupportedError = Eip1559FeesNotSupportedError;
class MaxFeePerGasTooLowError extends base_js_1.BaseError {
    constructor({ maxPriorityFeePerGas }) {
        super(`\`maxFeePerGas\` cannot be less than the \`maxPriorityFeePerGas\` (${(0, formatGwei_js_1.formatGwei)(maxPriorityFeePerGas)} gwei).`, { name: 'MaxFeePerGasTooLowError' });
    }
}
exports.MaxFeePerGasTooLowError = MaxFeePerGasTooLowError;
//# sourceMappingURL=fee.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/errors/log.js":
/*!**********************************************!*\
  !*** ./node_modules/viem/_cjs/errors/log.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FilterTypeNotSupportedError = void 0;
const base_js_1 = __webpack_require__(/*! ./base.js */ "./node_modules/viem/_cjs/errors/base.js");
class FilterTypeNotSupportedError extends base_js_1.BaseError {
    constructor(type) {
        super(`Filter type "${type}" is not supported.`, {
            name: 'FilterTypeNotSupportedError',
        });
    }
}
exports.FilterTypeNotSupportedError = FilterTypeNotSupportedError;
//# sourceMappingURL=log.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/errors/node.js":
/*!***********************************************!*\
  !*** ./node_modules/viem/_cjs/errors/node.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UnknownNodeError = exports.TipAboveFeeCapError = exports.TransactionTypeNotSupportedError = exports.IntrinsicGasTooLowError = exports.IntrinsicGasTooHighError = exports.InsufficientFundsError = exports.NonceMaxValueError = exports.NonceTooLowError = exports.NonceTooHighError = exports.FeeCapTooLowError = exports.FeeCapTooHighError = exports.ExecutionRevertedError = void 0;
const formatGwei_js_1 = __webpack_require__(/*! ../utils/unit/formatGwei.js */ "./node_modules/viem/_cjs/utils/unit/formatGwei.js");
const base_js_1 = __webpack_require__(/*! ./base.js */ "./node_modules/viem/_cjs/errors/base.js");
class ExecutionRevertedError extends base_js_1.BaseError {
    constructor({ cause, message, } = {}) {
        const reason = message
            ?.replace('execution reverted: ', '')
            ?.replace('execution reverted', '');
        super(`Execution reverted ${reason ? `with reason: ${reason}` : 'for an unknown reason'}.`, {
            cause,
            name: 'ExecutionRevertedError',
        });
    }
}
exports.ExecutionRevertedError = ExecutionRevertedError;
Object.defineProperty(ExecutionRevertedError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: 3
});
Object.defineProperty(ExecutionRevertedError, "nodeMessage", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: /execution reverted/
});
class FeeCapTooHighError extends base_js_1.BaseError {
    constructor({ cause, maxFeePerGas, } = {}) {
        super(`The fee cap (\`maxFeePerGas\`${maxFeePerGas ? ` = ${(0, formatGwei_js_1.formatGwei)(maxFeePerGas)} gwei` : ''}) cannot be higher than the maximum allowed value (2^256-1).`, {
            cause,
            name: 'FeeCapTooHighError',
        });
    }
}
exports.FeeCapTooHighError = FeeCapTooHighError;
Object.defineProperty(FeeCapTooHighError, "nodeMessage", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: /max fee per gas higher than 2\^256-1|fee cap higher than 2\^256-1/
});
class FeeCapTooLowError extends base_js_1.BaseError {
    constructor({ cause, maxFeePerGas, } = {}) {
        super(`The fee cap (\`maxFeePerGas\`${maxFeePerGas ? ` = ${(0, formatGwei_js_1.formatGwei)(maxFeePerGas)}` : ''} gwei) cannot be lower than the block base fee.`, {
            cause,
            name: 'FeeCapTooLowError',
        });
    }
}
exports.FeeCapTooLowError = FeeCapTooLowError;
Object.defineProperty(FeeCapTooLowError, "nodeMessage", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: /max fee per gas less than block base fee|fee cap less than block base fee|transaction is outdated/
});
class NonceTooHighError extends base_js_1.BaseError {
    constructor({ cause, nonce, } = {}) {
        super(`Nonce provided for the transaction ${nonce ? `(${nonce}) ` : ''}is higher than the next one expected.`, { cause, name: 'NonceTooHighError' });
    }
}
exports.NonceTooHighError = NonceTooHighError;
Object.defineProperty(NonceTooHighError, "nodeMessage", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: /nonce too high/
});
class NonceTooLowError extends base_js_1.BaseError {
    constructor({ cause, nonce, } = {}) {
        super([
            `Nonce provided for the transaction ${nonce ? `(${nonce}) ` : ''}is lower than the current nonce of the account.`,
            'Try increasing the nonce or find the latest nonce with `getTransactionCount`.',
        ].join('\n'), { cause, name: 'NonceTooLowError' });
    }
}
exports.NonceTooLowError = NonceTooLowError;
Object.defineProperty(NonceTooLowError, "nodeMessage", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: /nonce too low|transaction already imported|already known/
});
class NonceMaxValueError extends base_js_1.BaseError {
    constructor({ cause, nonce, } = {}) {
        super(`Nonce provided for the transaction ${nonce ? `(${nonce}) ` : ''}exceeds the maximum allowed nonce.`, { cause, name: 'NonceMaxValueError' });
    }
}
exports.NonceMaxValueError = NonceMaxValueError;
Object.defineProperty(NonceMaxValueError, "nodeMessage", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: /nonce has max value/
});
class InsufficientFundsError extends base_js_1.BaseError {
    constructor({ cause } = {}) {
        super([
            'The total cost (gas * gas fee + value) of executing this transaction exceeds the balance of the account.',
        ].join('\n'), {
            cause,
            metaMessages: [
                'This error could arise when the account does not have enough funds to:',
                ' - pay for the total gas fee,',
                ' - pay for the value to send.',
                ' ',
                'The cost of the transaction is calculated as `gas * gas fee + value`, where:',
                ' - `gas` is the amount of gas needed for transaction to execute,',
                ' - `gas fee` is the gas fee,',
                ' - `value` is the amount of ether to send to the recipient.',
            ],
            name: 'InsufficientFundsError',
        });
    }
}
exports.InsufficientFundsError = InsufficientFundsError;
Object.defineProperty(InsufficientFundsError, "nodeMessage", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: /insufficient funds|exceeds transaction sender account balance/
});
class IntrinsicGasTooHighError extends base_js_1.BaseError {
    constructor({ cause, gas, } = {}) {
        super(`The amount of gas ${gas ? `(${gas}) ` : ''}provided for the transaction exceeds the limit allowed for the block.`, {
            cause,
            name: 'IntrinsicGasTooHighError',
        });
    }
}
exports.IntrinsicGasTooHighError = IntrinsicGasTooHighError;
Object.defineProperty(IntrinsicGasTooHighError, "nodeMessage", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: /intrinsic gas too high|gas limit reached/
});
class IntrinsicGasTooLowError extends base_js_1.BaseError {
    constructor({ cause, gas, } = {}) {
        super(`The amount of gas ${gas ? `(${gas}) ` : ''}provided for the transaction is too low.`, {
            cause,
            name: 'IntrinsicGasTooLowError',
        });
    }
}
exports.IntrinsicGasTooLowError = IntrinsicGasTooLowError;
Object.defineProperty(IntrinsicGasTooLowError, "nodeMessage", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: /intrinsic gas too low/
});
class TransactionTypeNotSupportedError extends base_js_1.BaseError {
    constructor({ cause }) {
        super('The transaction type is not supported for this chain.', {
            cause,
            name: 'TransactionTypeNotSupportedError',
        });
    }
}
exports.TransactionTypeNotSupportedError = TransactionTypeNotSupportedError;
Object.defineProperty(TransactionTypeNotSupportedError, "nodeMessage", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: /transaction type not valid/
});
class TipAboveFeeCapError extends base_js_1.BaseError {
    constructor({ cause, maxPriorityFeePerGas, maxFeePerGas, } = {}) {
        super([
            `The provided tip (\`maxPriorityFeePerGas\`${maxPriorityFeePerGas
                ? ` = ${(0, formatGwei_js_1.formatGwei)(maxPriorityFeePerGas)} gwei`
                : ''}) cannot be higher than the fee cap (\`maxFeePerGas\`${maxFeePerGas ? ` = ${(0, formatGwei_js_1.formatGwei)(maxFeePerGas)} gwei` : ''}).`,
        ].join('\n'), {
            cause,
            name: 'TipAboveFeeCapError',
        });
    }
}
exports.TipAboveFeeCapError = TipAboveFeeCapError;
Object.defineProperty(TipAboveFeeCapError, "nodeMessage", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: /max priority fee per gas higher than max fee per gas|tip higher than fee cap/
});
class UnknownNodeError extends base_js_1.BaseError {
    constructor({ cause }) {
        super(`An error occurred while executing: ${cause?.shortMessage}`, {
            cause,
            name: 'UnknownNodeError',
        });
    }
}
exports.UnknownNodeError = UnknownNodeError;
//# sourceMappingURL=node.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/errors/request.js":
/*!**************************************************!*\
  !*** ./node_modules/viem/_cjs/errors/request.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TimeoutError = exports.SocketClosedError = exports.RpcRequestError = exports.WebSocketRequestError = exports.HttpRequestError = void 0;
const stringify_js_1 = __webpack_require__(/*! ../utils/stringify.js */ "./node_modules/viem/_cjs/utils/stringify.js");
const base_js_1 = __webpack_require__(/*! ./base.js */ "./node_modules/viem/_cjs/errors/base.js");
const utils_js_1 = __webpack_require__(/*! ./utils.js */ "./node_modules/viem/_cjs/errors/utils.js");
class HttpRequestError extends base_js_1.BaseError {
    constructor({ body, cause, details, headers, status, url, }) {
        super('HTTP request failed.', {
            cause,
            details,
            metaMessages: [
                status && `Status: ${status}`,
                `URL: ${(0, utils_js_1.getUrl)(url)}`,
                body && `Request body: ${(0, stringify_js_1.stringify)(body)}`,
            ].filter(Boolean),
            name: 'HttpRequestError',
        });
        Object.defineProperty(this, "body", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "headers", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "status", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "url", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.body = body;
        this.headers = headers;
        this.status = status;
        this.url = url;
    }
}
exports.HttpRequestError = HttpRequestError;
class WebSocketRequestError extends base_js_1.BaseError {
    constructor({ body, cause, details, url, }) {
        super('WebSocket request failed.', {
            cause,
            details,
            metaMessages: [
                `URL: ${(0, utils_js_1.getUrl)(url)}`,
                body && `Request body: ${(0, stringify_js_1.stringify)(body)}`,
            ].filter(Boolean),
            name: 'WebSocketRequestError',
        });
    }
}
exports.WebSocketRequestError = WebSocketRequestError;
class RpcRequestError extends base_js_1.BaseError {
    constructor({ body, error, url, }) {
        super('RPC Request failed.', {
            cause: error,
            details: error.message,
            metaMessages: [`URL: ${(0, utils_js_1.getUrl)(url)}`, `Request body: ${(0, stringify_js_1.stringify)(body)}`],
            name: 'RpcRequestError',
        });
        Object.defineProperty(this, "code", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "data", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.code = error.code;
        this.data = error.data;
    }
}
exports.RpcRequestError = RpcRequestError;
class SocketClosedError extends base_js_1.BaseError {
    constructor({ url, } = {}) {
        super('The socket has been closed.', {
            metaMessages: [url && `URL: ${(0, utils_js_1.getUrl)(url)}`].filter(Boolean),
            name: 'SocketClosedError',
        });
    }
}
exports.SocketClosedError = SocketClosedError;
class TimeoutError extends base_js_1.BaseError {
    constructor({ body, url, }) {
        super('The request took too long to respond.', {
            details: 'The request timed out.',
            metaMessages: [`URL: ${(0, utils_js_1.getUrl)(url)}`, `Request body: ${(0, stringify_js_1.stringify)(body)}`],
            name: 'TimeoutError',
        });
    }
}
exports.TimeoutError = TimeoutError;
//# sourceMappingURL=request.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/errors/rpc.js":
/*!**********************************************!*\
  !*** ./node_modules/viem/_cjs/errors/rpc.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UnknownRpcError = exports.AtomicityNotSupportedError = exports.AtomicReadyWalletRejectedUpgradeError = exports.BundleTooLargeError = exports.UnknownBundleIdError = exports.DuplicateIdError = exports.UnsupportedChainIdError = exports.UnsupportedNonOptionalCapabilityError = exports.SwitchChainError = exports.ChainDisconnectedError = exports.ProviderDisconnectedError = exports.UnsupportedProviderMethodError = exports.UnauthorizedProviderError = exports.UserRejectedRequestError = exports.JsonRpcVersionUnsupportedError = exports.LimitExceededRpcError = exports.MethodNotSupportedRpcError = exports.TransactionRejectedRpcError = exports.ResourceUnavailableRpcError = exports.ResourceNotFoundRpcError = exports.InvalidInputRpcError = exports.InternalRpcError = exports.InvalidParamsRpcError = exports.MethodNotFoundRpcError = exports.InvalidRequestRpcError = exports.ParseRpcError = exports.ProviderRpcError = exports.RpcError = void 0;
const base_js_1 = __webpack_require__(/*! ./base.js */ "./node_modules/viem/_cjs/errors/base.js");
const request_js_1 = __webpack_require__(/*! ./request.js */ "./node_modules/viem/_cjs/errors/request.js");
const unknownErrorCode = -1;
class RpcError extends base_js_1.BaseError {
    constructor(cause, { code, docsPath, metaMessages, name, shortMessage, }) {
        super(shortMessage, {
            cause,
            docsPath,
            metaMessages: metaMessages || cause?.metaMessages,
            name: name || 'RpcError',
        });
        Object.defineProperty(this, "code", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.name = name || cause.name;
        this.code = (cause instanceof request_js_1.RpcRequestError ? cause.code : (code ?? unknownErrorCode));
    }
}
exports.RpcError = RpcError;
class ProviderRpcError extends RpcError {
    constructor(cause, options) {
        super(cause, options);
        Object.defineProperty(this, "data", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.data = options.data;
    }
}
exports.ProviderRpcError = ProviderRpcError;
class ParseRpcError extends RpcError {
    constructor(cause) {
        super(cause, {
            code: ParseRpcError.code,
            name: 'ParseRpcError',
            shortMessage: 'Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text.',
        });
    }
}
exports.ParseRpcError = ParseRpcError;
Object.defineProperty(ParseRpcError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: -32700
});
class InvalidRequestRpcError extends RpcError {
    constructor(cause) {
        super(cause, {
            code: InvalidRequestRpcError.code,
            name: 'InvalidRequestRpcError',
            shortMessage: 'JSON is not a valid request object.',
        });
    }
}
exports.InvalidRequestRpcError = InvalidRequestRpcError;
Object.defineProperty(InvalidRequestRpcError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: -32600
});
class MethodNotFoundRpcError extends RpcError {
    constructor(cause, { method } = {}) {
        super(cause, {
            code: MethodNotFoundRpcError.code,
            name: 'MethodNotFoundRpcError',
            shortMessage: `The method${method ? ` "${method}"` : ''} does not exist / is not available.`,
        });
    }
}
exports.MethodNotFoundRpcError = MethodNotFoundRpcError;
Object.defineProperty(MethodNotFoundRpcError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: -32601
});
class InvalidParamsRpcError extends RpcError {
    constructor(cause) {
        super(cause, {
            code: InvalidParamsRpcError.code,
            name: 'InvalidParamsRpcError',
            shortMessage: [
                'Invalid parameters were provided to the RPC method.',
                'Double check you have provided the correct parameters.',
            ].join('\n'),
        });
    }
}
exports.InvalidParamsRpcError = InvalidParamsRpcError;
Object.defineProperty(InvalidParamsRpcError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: -32602
});
class InternalRpcError extends RpcError {
    constructor(cause) {
        super(cause, {
            code: InternalRpcError.code,
            name: 'InternalRpcError',
            shortMessage: 'An internal error was received.',
        });
    }
}
exports.InternalRpcError = InternalRpcError;
Object.defineProperty(InternalRpcError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: -32603
});
class InvalidInputRpcError extends RpcError {
    constructor(cause) {
        super(cause, {
            code: InvalidInputRpcError.code,
            name: 'InvalidInputRpcError',
            shortMessage: [
                'Missing or invalid parameters.',
                'Double check you have provided the correct parameters.',
            ].join('\n'),
        });
    }
}
exports.InvalidInputRpcError = InvalidInputRpcError;
Object.defineProperty(InvalidInputRpcError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: -32000
});
class ResourceNotFoundRpcError extends RpcError {
    constructor(cause) {
        super(cause, {
            code: ResourceNotFoundRpcError.code,
            name: 'ResourceNotFoundRpcError',
            shortMessage: 'Requested resource not found.',
        });
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'ResourceNotFoundRpcError'
        });
    }
}
exports.ResourceNotFoundRpcError = ResourceNotFoundRpcError;
Object.defineProperty(ResourceNotFoundRpcError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: -32001
});
class ResourceUnavailableRpcError extends RpcError {
    constructor(cause) {
        super(cause, {
            code: ResourceUnavailableRpcError.code,
            name: 'ResourceUnavailableRpcError',
            shortMessage: 'Requested resource not available.',
        });
    }
}
exports.ResourceUnavailableRpcError = ResourceUnavailableRpcError;
Object.defineProperty(ResourceUnavailableRpcError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: -32002
});
class TransactionRejectedRpcError extends RpcError {
    constructor(cause) {
        super(cause, {
            code: TransactionRejectedRpcError.code,
            name: 'TransactionRejectedRpcError',
            shortMessage: 'Transaction creation failed.',
        });
    }
}
exports.TransactionRejectedRpcError = TransactionRejectedRpcError;
Object.defineProperty(TransactionRejectedRpcError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: -32003
});
class MethodNotSupportedRpcError extends RpcError {
    constructor(cause, { method } = {}) {
        super(cause, {
            code: MethodNotSupportedRpcError.code,
            name: 'MethodNotSupportedRpcError',
            shortMessage: `Method${method ? ` "${method}"` : ''} is not supported.`,
        });
    }
}
exports.MethodNotSupportedRpcError = MethodNotSupportedRpcError;
Object.defineProperty(MethodNotSupportedRpcError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: -32004
});
class LimitExceededRpcError extends RpcError {
    constructor(cause) {
        super(cause, {
            code: LimitExceededRpcError.code,
            name: 'LimitExceededRpcError',
            shortMessage: 'Request exceeds defined limit.',
        });
    }
}
exports.LimitExceededRpcError = LimitExceededRpcError;
Object.defineProperty(LimitExceededRpcError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: -32005
});
class JsonRpcVersionUnsupportedError extends RpcError {
    constructor(cause) {
        super(cause, {
            code: JsonRpcVersionUnsupportedError.code,
            name: 'JsonRpcVersionUnsupportedError',
            shortMessage: 'Version of JSON-RPC protocol is not supported.',
        });
    }
}
exports.JsonRpcVersionUnsupportedError = JsonRpcVersionUnsupportedError;
Object.defineProperty(JsonRpcVersionUnsupportedError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: -32006
});
class UserRejectedRequestError extends ProviderRpcError {
    constructor(cause) {
        super(cause, {
            code: UserRejectedRequestError.code,
            name: 'UserRejectedRequestError',
            shortMessage: 'User rejected the request.',
        });
    }
}
exports.UserRejectedRequestError = UserRejectedRequestError;
Object.defineProperty(UserRejectedRequestError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: 4001
});
class UnauthorizedProviderError extends ProviderRpcError {
    constructor(cause) {
        super(cause, {
            code: UnauthorizedProviderError.code,
            name: 'UnauthorizedProviderError',
            shortMessage: 'The requested method and/or account has not been authorized by the user.',
        });
    }
}
exports.UnauthorizedProviderError = UnauthorizedProviderError;
Object.defineProperty(UnauthorizedProviderError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: 4100
});
class UnsupportedProviderMethodError extends ProviderRpcError {
    constructor(cause, { method } = {}) {
        super(cause, {
            code: UnsupportedProviderMethodError.code,
            name: 'UnsupportedProviderMethodError',
            shortMessage: `The Provider does not support the requested method${method ? ` " ${method}"` : ''}.`,
        });
    }
}
exports.UnsupportedProviderMethodError = UnsupportedProviderMethodError;
Object.defineProperty(UnsupportedProviderMethodError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: 4200
});
class ProviderDisconnectedError extends ProviderRpcError {
    constructor(cause) {
        super(cause, {
            code: ProviderDisconnectedError.code,
            name: 'ProviderDisconnectedError',
            shortMessage: 'The Provider is disconnected from all chains.',
        });
    }
}
exports.ProviderDisconnectedError = ProviderDisconnectedError;
Object.defineProperty(ProviderDisconnectedError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: 4900
});
class ChainDisconnectedError extends ProviderRpcError {
    constructor(cause) {
        super(cause, {
            code: ChainDisconnectedError.code,
            name: 'ChainDisconnectedError',
            shortMessage: 'The Provider is not connected to the requested chain.',
        });
    }
}
exports.ChainDisconnectedError = ChainDisconnectedError;
Object.defineProperty(ChainDisconnectedError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: 4901
});
class SwitchChainError extends ProviderRpcError {
    constructor(cause) {
        super(cause, {
            code: SwitchChainError.code,
            name: 'SwitchChainError',
            shortMessage: 'An error occurred when attempting to switch chain.',
        });
    }
}
exports.SwitchChainError = SwitchChainError;
Object.defineProperty(SwitchChainError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: 4902
});
class UnsupportedNonOptionalCapabilityError extends ProviderRpcError {
    constructor(cause) {
        super(cause, {
            code: UnsupportedNonOptionalCapabilityError.code,
            name: 'UnsupportedNonOptionalCapabilityError',
            shortMessage: 'This Wallet does not support a capability that was not marked as optional.',
        });
    }
}
exports.UnsupportedNonOptionalCapabilityError = UnsupportedNonOptionalCapabilityError;
Object.defineProperty(UnsupportedNonOptionalCapabilityError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: 5700
});
class UnsupportedChainIdError extends ProviderRpcError {
    constructor(cause) {
        super(cause, {
            code: UnsupportedChainIdError.code,
            name: 'UnsupportedChainIdError',
            shortMessage: 'This Wallet does not support the requested chain ID.',
        });
    }
}
exports.UnsupportedChainIdError = UnsupportedChainIdError;
Object.defineProperty(UnsupportedChainIdError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: 5710
});
class DuplicateIdError extends ProviderRpcError {
    constructor(cause) {
        super(cause, {
            code: DuplicateIdError.code,
            name: 'DuplicateIdError',
            shortMessage: 'There is already a bundle submitted with this ID.',
        });
    }
}
exports.DuplicateIdError = DuplicateIdError;
Object.defineProperty(DuplicateIdError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: 5720
});
class UnknownBundleIdError extends ProviderRpcError {
    constructor(cause) {
        super(cause, {
            code: UnknownBundleIdError.code,
            name: 'UnknownBundleIdError',
            shortMessage: 'This bundle id is unknown / has not been submitted',
        });
    }
}
exports.UnknownBundleIdError = UnknownBundleIdError;
Object.defineProperty(UnknownBundleIdError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: 5730
});
class BundleTooLargeError extends ProviderRpcError {
    constructor(cause) {
        super(cause, {
            code: BundleTooLargeError.code,
            name: 'BundleTooLargeError',
            shortMessage: 'The call bundle is too large for the Wallet to process.',
        });
    }
}
exports.BundleTooLargeError = BundleTooLargeError;
Object.defineProperty(BundleTooLargeError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: 5740
});
class AtomicReadyWalletRejectedUpgradeError extends ProviderRpcError {
    constructor(cause) {
        super(cause, {
            code: AtomicReadyWalletRejectedUpgradeError.code,
            name: 'AtomicReadyWalletRejectedUpgradeError',
            shortMessage: 'The Wallet can support atomicity after an upgrade, but the user rejected the upgrade.',
        });
    }
}
exports.AtomicReadyWalletRejectedUpgradeError = AtomicReadyWalletRejectedUpgradeError;
Object.defineProperty(AtomicReadyWalletRejectedUpgradeError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: 5750
});
class AtomicityNotSupportedError extends ProviderRpcError {
    constructor(cause) {
        super(cause, {
            code: AtomicityNotSupportedError.code,
            name: 'AtomicityNotSupportedError',
            shortMessage: 'The wallet does not support atomic execution but the request requires it.',
        });
    }
}
exports.AtomicityNotSupportedError = AtomicityNotSupportedError;
Object.defineProperty(AtomicityNotSupportedError, "code", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: 5760
});
class UnknownRpcError extends RpcError {
    constructor(cause) {
        super(cause, {
            name: 'UnknownRpcError',
            shortMessage: 'An unknown RPC error occurred.',
        });
    }
}
exports.UnknownRpcError = UnknownRpcError;
//# sourceMappingURL=rpc.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/errors/stateOverride.js":
/*!********************************************************!*\
  !*** ./node_modules/viem/_cjs/errors/stateOverride.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.StateAssignmentConflictError = exports.AccountStateConflictError = void 0;
exports.prettyStateMapping = prettyStateMapping;
exports.prettyStateOverride = prettyStateOverride;
const base_js_1 = __webpack_require__(/*! ./base.js */ "./node_modules/viem/_cjs/errors/base.js");
class AccountStateConflictError extends base_js_1.BaseError {
    constructor({ address }) {
        super(`State for account "${address}" is set multiple times.`, {
            name: 'AccountStateConflictError',
        });
    }
}
exports.AccountStateConflictError = AccountStateConflictError;
class StateAssignmentConflictError extends base_js_1.BaseError {
    constructor() {
        super('state and stateDiff are set on the same account.', {
            name: 'StateAssignmentConflictError',
        });
    }
}
exports.StateAssignmentConflictError = StateAssignmentConflictError;
function prettyStateMapping(stateMapping) {
    return stateMapping.reduce((pretty, { slot, value }) => {
        return `${pretty}        ${slot}: ${value}\n`;
    }, '');
}
function prettyStateOverride(stateOverride) {
    return stateOverride
        .reduce((pretty, { address, ...state }) => {
        let val = `${pretty}    ${address}:\n`;
        if (state.nonce)
            val += `      nonce: ${state.nonce}\n`;
        if (state.balance)
            val += `      balance: ${state.balance}\n`;
        if (state.code)
            val += `      code: ${state.code}\n`;
        if (state.state) {
            val += '      state:\n';
            val += prettyStateMapping(state.state);
        }
        if (state.stateDiff) {
            val += '      stateDiff:\n';
            val += prettyStateMapping(state.stateDiff);
        }
        return val;
    }, '  State Override:\n')
        .slice(0, -1);
}
//# sourceMappingURL=stateOverride.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/errors/transaction.js":
/*!******************************************************!*\
  !*** ./node_modules/viem/_cjs/errors/transaction.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WaitForTransactionReceiptTimeoutError = exports.TransactionReceiptNotFoundError = exports.TransactionNotFoundError = exports.TransactionExecutionError = exports.InvalidStorageKeySizeError = exports.InvalidSerializedTransactionError = exports.InvalidSerializedTransactionTypeError = exports.InvalidSerializableTransactionError = exports.InvalidLegacyVError = exports.FeeConflictError = void 0;
exports.prettyPrint = prettyPrint;
const formatEther_js_1 = __webpack_require__(/*! ../utils/unit/formatEther.js */ "./node_modules/viem/_cjs/utils/unit/formatEther.js");
const formatGwei_js_1 = __webpack_require__(/*! ../utils/unit/formatGwei.js */ "./node_modules/viem/_cjs/utils/unit/formatGwei.js");
const base_js_1 = __webpack_require__(/*! ./base.js */ "./node_modules/viem/_cjs/errors/base.js");
function prettyPrint(args) {
    const entries = Object.entries(args)
        .map(([key, value]) => {
        if (value === undefined || value === false)
            return null;
        return [key, value];
    })
        .filter(Boolean);
    const maxLength = entries.reduce((acc, [key]) => Math.max(acc, key.length), 0);
    return entries
        .map(([key, value]) => `  ${`${key}:`.padEnd(maxLength + 1)}  ${value}`)
        .join('\n');
}
class FeeConflictError extends base_js_1.BaseError {
    constructor() {
        super([
            'Cannot specify both a `gasPrice` and a `maxFeePerGas`/`maxPriorityFeePerGas`.',
            'Use `maxFeePerGas`/`maxPriorityFeePerGas` for EIP-1559 compatible networks, and `gasPrice` for others.',
        ].join('\n'), { name: 'FeeConflictError' });
    }
}
exports.FeeConflictError = FeeConflictError;
class InvalidLegacyVError extends base_js_1.BaseError {
    constructor({ v }) {
        super(`Invalid \`v\` value "${v}". Expected 27 or 28.`, {
            name: 'InvalidLegacyVError',
        });
    }
}
exports.InvalidLegacyVError = InvalidLegacyVError;
class InvalidSerializableTransactionError extends base_js_1.BaseError {
    constructor({ transaction }) {
        super('Cannot infer a transaction type from provided transaction.', {
            metaMessages: [
                'Provided Transaction:',
                '{',
                prettyPrint(transaction),
                '}',
                '',
                'To infer the type, either provide:',
                '- a `type` to the Transaction, or',
                '- an EIP-1559 Transaction with `maxFeePerGas`, or',
                '- an EIP-2930 Transaction with `gasPrice` & `accessList`, or',
                '- an EIP-4844 Transaction with `blobs`, `blobVersionedHashes`, `sidecars`, or',
                '- an EIP-7702 Transaction with `authorizationList`, or',
                '- a Legacy Transaction with `gasPrice`',
            ],
            name: 'InvalidSerializableTransactionError',
        });
    }
}
exports.InvalidSerializableTransactionError = InvalidSerializableTransactionError;
class InvalidSerializedTransactionTypeError extends base_js_1.BaseError {
    constructor({ serializedType }) {
        super(`Serialized transaction type "${serializedType}" is invalid.`, {
            name: 'InvalidSerializedTransactionType',
        });
        Object.defineProperty(this, "serializedType", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.serializedType = serializedType;
    }
}
exports.InvalidSerializedTransactionTypeError = InvalidSerializedTransactionTypeError;
class InvalidSerializedTransactionError extends base_js_1.BaseError {
    constructor({ attributes, serializedTransaction, type, }) {
        const missing = Object.entries(attributes)
            .map(([key, value]) => (typeof value === 'undefined' ? key : undefined))
            .filter(Boolean);
        super(`Invalid serialized transaction of type "${type}" was provided.`, {
            metaMessages: [
                `Serialized Transaction: "${serializedTransaction}"`,
                missing.length > 0 ? `Missing Attributes: ${missing.join(', ')}` : '',
            ].filter(Boolean),
            name: 'InvalidSerializedTransactionError',
        });
        Object.defineProperty(this, "serializedTransaction", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "type", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.serializedTransaction = serializedTransaction;
        this.type = type;
    }
}
exports.InvalidSerializedTransactionError = InvalidSerializedTransactionError;
class InvalidStorageKeySizeError extends base_js_1.BaseError {
    constructor({ storageKey }) {
        super(`Size for storage key "${storageKey}" is invalid. Expected 32 bytes. Got ${Math.floor((storageKey.length - 2) / 2)} bytes.`, { name: 'InvalidStorageKeySizeError' });
    }
}
exports.InvalidStorageKeySizeError = InvalidStorageKeySizeError;
class TransactionExecutionError extends base_js_1.BaseError {
    constructor(cause, { account, docsPath, chain, data, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce, to, value, }) {
        const prettyArgs = prettyPrint({
            chain: chain && `${chain?.name} (id: ${chain?.id})`,
            from: account?.address,
            to,
            value: typeof value !== 'undefined' &&
                `${(0, formatEther_js_1.formatEther)(value)} ${chain?.nativeCurrency?.symbol || 'ETH'}`,
            data,
            gas,
            gasPrice: typeof gasPrice !== 'undefined' && `${(0, formatGwei_js_1.formatGwei)(gasPrice)} gwei`,
            maxFeePerGas: typeof maxFeePerGas !== 'undefined' &&
                `${(0, formatGwei_js_1.formatGwei)(maxFeePerGas)} gwei`,
            maxPriorityFeePerGas: typeof maxPriorityFeePerGas !== 'undefined' &&
                `${(0, formatGwei_js_1.formatGwei)(maxPriorityFeePerGas)} gwei`,
            nonce,
        });
        super(cause.shortMessage, {
            cause,
            docsPath,
            metaMessages: [
                ...(cause.metaMessages ? [...cause.metaMessages, ' '] : []),
                'Request Arguments:',
                prettyArgs,
            ].filter(Boolean),
            name: 'TransactionExecutionError',
        });
        Object.defineProperty(this, "cause", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.cause = cause;
    }
}
exports.TransactionExecutionError = TransactionExecutionError;
class TransactionNotFoundError extends base_js_1.BaseError {
    constructor({ blockHash, blockNumber, blockTag, hash, index, }) {
        let identifier = 'Transaction';
        if (blockTag && index !== undefined)
            identifier = `Transaction at block time "${blockTag}" at index "${index}"`;
        if (blockHash && index !== undefined)
            identifier = `Transaction at block hash "${blockHash}" at index "${index}"`;
        if (blockNumber && index !== undefined)
            identifier = `Transaction at block number "${blockNumber}" at index "${index}"`;
        if (hash)
            identifier = `Transaction with hash "${hash}"`;
        super(`${identifier} could not be found.`, {
            name: 'TransactionNotFoundError',
        });
    }
}
exports.TransactionNotFoundError = TransactionNotFoundError;
class TransactionReceiptNotFoundError extends base_js_1.BaseError {
    constructor({ hash }) {
        super(`Transaction receipt with hash "${hash}" could not be found. The Transaction may not be processed on a block yet.`, {
            name: 'TransactionReceiptNotFoundError',
        });
    }
}
exports.TransactionReceiptNotFoundError = TransactionReceiptNotFoundError;
class WaitForTransactionReceiptTimeoutError extends base_js_1.BaseError {
    constructor({ hash }) {
        super(`Timed out while waiting for transaction with hash "${hash}" to be confirmed.`, { name: 'WaitForTransactionReceiptTimeoutError' });
    }
}
exports.WaitForTransactionReceiptTimeoutError = WaitForTransactionReceiptTimeoutError;
//# sourceMappingURL=transaction.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/errors/transport.js":
/*!****************************************************!*\
  !*** ./node_modules/viem/_cjs/errors/transport.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UrlRequiredError = void 0;
const base_js_1 = __webpack_require__(/*! ./base.js */ "./node_modules/viem/_cjs/errors/base.js");
class UrlRequiredError extends base_js_1.BaseError {
    constructor() {
        super('No URL was provided to the Transport. Please provide a valid RPC URL to the Transport.', {
            docsPath: '/docs/clients/intro',
            name: 'UrlRequiredError',
        });
    }
}
exports.UrlRequiredError = UrlRequiredError;
//# sourceMappingURL=transport.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/errors/typedData.js":
/*!****************************************************!*\
  !*** ./node_modules/viem/_cjs/errors/typedData.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.InvalidStructTypeError = exports.InvalidPrimaryTypeError = exports.InvalidDomainError = void 0;
const stringify_js_1 = __webpack_require__(/*! ../utils/stringify.js */ "./node_modules/viem/_cjs/utils/stringify.js");
const base_js_1 = __webpack_require__(/*! ./base.js */ "./node_modules/viem/_cjs/errors/base.js");
class InvalidDomainError extends base_js_1.BaseError {
    constructor({ domain }) {
        super(`Invalid domain "${(0, stringify_js_1.stringify)(domain)}".`, {
            metaMessages: ['Must be a valid EIP-712 domain.'],
        });
    }
}
exports.InvalidDomainError = InvalidDomainError;
class InvalidPrimaryTypeError extends base_js_1.BaseError {
    constructor({ primaryType, types, }) {
        super(`Invalid primary type \`${primaryType}\` must be one of \`${JSON.stringify(Object.keys(types))}\`.`, {
            docsPath: '/api/glossary/Errors#typeddatainvalidprimarytypeerror',
            metaMessages: ['Check that the primary type is a key in `types`.'],
        });
    }
}
exports.InvalidPrimaryTypeError = InvalidPrimaryTypeError;
class InvalidStructTypeError extends base_js_1.BaseError {
    constructor({ type }) {
        super(`Struct type "${type}" is invalid.`, {
            metaMessages: ['Struct type must not be a Solidity type.'],
            name: 'InvalidStructTypeError',
        });
    }
}
exports.InvalidStructTypeError = InvalidStructTypeError;
//# sourceMappingURL=typedData.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/errors/unit.js":
/*!***********************************************!*\
  !*** ./node_modules/viem/_cjs/errors/unit.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.InvalidDecimalNumberError = void 0;
const base_js_1 = __webpack_require__(/*! ./base.js */ "./node_modules/viem/_cjs/errors/base.js");
class InvalidDecimalNumberError extends base_js_1.BaseError {
    constructor({ value }) {
        super(`Number \`${value}\` is not a valid decimal number.`, {
            name: 'InvalidDecimalNumberError',
        });
    }
}
exports.InvalidDecimalNumberError = InvalidDecimalNumberError;
//# sourceMappingURL=unit.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/errors/utils.js":
/*!************************************************!*\
  !*** ./node_modules/viem/_cjs/errors/utils.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getUrl = exports.getContractAddress = void 0;
const getContractAddress = (address) => address;
exports.getContractAddress = getContractAddress;
const getUrl = (url) => url;
exports.getUrl = getUrl;
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/errors/version.js":
/*!**************************************************!*\
  !*** ./node_modules/viem/_cjs/errors/version.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.version = void 0;
exports.version = '2.36.0';
//# sourceMappingURL=version.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/index.js":
/*!*****************************************!*\
  !*** ./node_modules/viem/_cjs/index.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.maxInt24 = exports.maxInt16 = exports.maxInt8 = exports.universalSignatureValidatorByteCode = exports.deploylessCallViaFactoryBytecode = exports.deploylessCallViaBytecodeBytecode = exports.zeroHash = exports.zeroAddress = exports.ethAddress = exports.universalSignatureValidatorAbi = exports.multicall3Abi = exports.erc4626Abi = exports.erc1155Abi = exports.erc721Abi = exports.erc20Abi_bytes32 = exports.erc20Abi = exports.webSocket = exports.http = exports.shouldThrow = exports.fallback = exports.custom = exports.createTransport = exports.walletActions = exports.testActions = exports.publicActions = exports.createWalletClient = exports.createTestClient = exports.createPublicClient = exports.rpcSchema = exports.createClient = exports.WaitForCallsStatusTimeoutError = exports.getContract = exports.UnknownTypeError = exports.UnknownSignatureError = exports.SolidityProtectedKeywordError = exports.parseAbiParameters = exports.parseAbiParameter = exports.parseAbiItem = exports.parseAbi = exports.InvalidStructSignatureError = exports.InvalidSignatureError = exports.InvalidParenthesisError = exports.InvalidParameterError = exports.InvalidModifierError = exports.InvalidFunctionModifierError = exports.InvalidAbiTypeParameterError = exports.InvalidAbiParametersError = exports.InvalidAbiParameterError = exports.InvalidAbiItemError = exports.CircularReferenceError = void 0;
exports.maxUint168 = exports.maxUint160 = exports.maxUint152 = exports.maxUint144 = exports.maxUint136 = exports.maxUint128 = exports.maxUint120 = exports.maxUint112 = exports.maxUint104 = exports.maxUint96 = exports.maxUint88 = exports.maxUint80 = exports.maxUint72 = exports.maxUint64 = exports.maxUint56 = exports.maxUint48 = exports.maxUint40 = exports.maxUint32 = exports.maxUint24 = exports.maxUint16 = exports.maxUint8 = exports.maxInt256 = exports.maxInt248 = exports.maxInt240 = exports.maxInt232 = exports.maxInt224 = exports.maxInt216 = exports.maxInt208 = exports.maxInt200 = exports.maxInt192 = exports.maxInt184 = exports.maxInt176 = exports.maxInt168 = exports.maxInt160 = exports.maxInt152 = exports.maxInt144 = exports.maxInt136 = exports.maxInt128 = exports.maxInt120 = exports.maxInt112 = exports.maxInt104 = exports.maxInt96 = exports.maxInt88 = exports.maxInt80 = exports.maxInt72 = exports.maxInt64 = exports.maxInt56 = exports.maxInt48 = exports.maxInt40 = exports.maxInt32 = void 0;
exports.AbiDecodingDataSizeInvalidError = exports.AbiConstructorParamsNotFoundError = exports.AbiConstructorNotFoundError = exports.weiUnits = exports.gweiUnits = exports.etherUnits = exports.presignMessagePrefix = exports.minInt256 = exports.minInt248 = exports.minInt240 = exports.minInt232 = exports.minInt224 = exports.minInt216 = exports.minInt208 = exports.minInt200 = exports.minInt192 = exports.minInt184 = exports.minInt176 = exports.minInt168 = exports.minInt160 = exports.minInt152 = exports.minInt144 = exports.minInt136 = exports.minInt128 = exports.minInt120 = exports.minInt112 = exports.minInt104 = exports.minInt96 = exports.minInt88 = exports.minInt80 = exports.minInt72 = exports.minInt64 = exports.minInt56 = exports.minInt48 = exports.minInt40 = exports.minInt32 = exports.minInt24 = exports.minInt16 = exports.minInt8 = exports.maxUint256 = exports.maxUint248 = exports.maxUint240 = exports.maxUint232 = exports.maxUint224 = exports.maxUint216 = exports.maxUint208 = exports.maxUint200 = exports.maxUint192 = exports.maxUint184 = exports.maxUint176 = void 0;
exports.EstimateGasExecutionError = exports.EnsInvalidChainIdError = exports.EnsAvatarUriResolutionError = exports.EnsAvatarUnsupportedNamespaceError = exports.EnsAvatarInvalidNftUriError = exports.SizeOverflowError = exports.InvalidHexValueError = exports.InvalidHexBooleanError = exports.InvalidBytesBooleanError = exports.IntegerOutOfRangeError = exports.SliceOffsetOutOfBoundsError = exports.SizeExceedsPaddingSizeError = exports.RawContractError = exports.CounterfactualDeploymentFailedError = exports.ContractFunctionZeroDataError = exports.ContractFunctionRevertedError = exports.ContractFunctionExecutionError = exports.CallExecutionError = exports.InvalidChainIdError = exports.ClientChainNotConfiguredError = exports.ChainNotFoundError = exports.ChainMismatchError = exports.ChainDoesNotSupportContract = exports.BundleFailedError = exports.BlockNotFoundError = exports.setErrorConfig = exports.BaseError = exports.InvalidAddressError = exports.UnsupportedPackedAbiType = exports.InvalidDefinitionTypeError = exports.InvalidArrayError = exports.InvalidAbiEncodingTypeError = exports.InvalidAbiDecodingTypeError = exports.DecodeLogTopicsMismatch = exports.DecodeLogDataMismatch = exports.BytesSizeMismatchError = exports.AbiFunctionSignatureNotFoundError = exports.AbiFunctionOutputsNotFoundError = exports.AbiFunctionNotFoundError = exports.AbiEventSignatureNotFoundError = exports.AbiEventSignatureEmptyTopicsError = exports.AbiEventNotFoundError = exports.AbiErrorSignatureNotFoundError = exports.AbiErrorNotFoundError = exports.AbiErrorInputsNotFoundError = exports.AbiEncodingLengthMismatchError = exports.AbiEncodingBytesSizeMismatchError = exports.AbiEncodingArrayLengthMismatchError = exports.AbiDecodingZeroDataError = exports.AbiDecodingDataSizeTooSmallError = void 0;
exports.AccountStateConflictError = exports.UserRejectedRequestError = exports.UnsupportedProviderMethodError = exports.UnsupportedNonOptionalCapabilityError = exports.UnsupportedChainIdError = exports.UnknownRpcError = exports.UnknownBundleIdError = exports.UnauthorizedProviderError = exports.TransactionRejectedRpcError = exports.SwitchChainError = exports.RpcError = exports.ResourceUnavailableRpcError = exports.ResourceNotFoundRpcError = exports.ProviderRpcError = exports.ProviderDisconnectedError = exports.ParseRpcError = exports.MethodNotSupportedRpcError = exports.MethodNotFoundRpcError = exports.LimitExceededRpcError = exports.JsonRpcVersionUnsupportedError = exports.InvalidRequestRpcError = exports.InvalidParamsRpcError = exports.InvalidInputRpcError = exports.InternalRpcError = exports.DuplicateIdError = exports.ChainDisconnectedError = exports.BundleTooLargeError = exports.AtomicReadyWalletRejectedUpgradeError = exports.AtomicityNotSupportedError = exports.WebSocketRequestError = exports.TimeoutError = exports.SocketClosedError = exports.RpcRequestError = exports.HttpRequestError = exports.UnknownNodeError = exports.TransactionTypeNotSupportedError = exports.TipAboveFeeCapError = exports.NonceTooLowError = exports.NonceTooHighError = exports.NonceMaxValueError = exports.IntrinsicGasTooLowError = exports.IntrinsicGasTooHighError = exports.InsufficientFundsError = exports.FeeCapTooLowError = exports.FeeCapTooHighError = exports.ExecutionRevertedError = exports.FilterTypeNotSupportedError = exports.MaxFeePerGasTooLowError = exports.Eip1559FeesNotSupportedError = exports.BaseFeeScalarError = void 0;
exports.ccipFetch = exports.ccipRequest = exports.toBlobs = exports.toBlobSidecars = exports.sidecarsToVersionedHashes = exports.fromBlobs = exports.commitmentToVersionedHash = exports.commitmentsToVersionedHashes = exports.blobsToProofs = exports.blobsToCommitments = exports.isAddressEqual = exports.isAddress = exports.getCreateAddress = exports.getCreate2Address = exports.getContractAddress = exports.getAddress = exports.checksumAddress = exports.prepareEncodeFunctionData = exports.parseEventLogs = exports.getAbiItem = exports.encodePacked = exports.encodeFunctionResult = exports.encodeFunctionData = exports.encodeEventTopics = exports.encodeErrorResult = exports.encodeDeployData = exports.encodeAbiParameters = exports.decodeFunctionResult = exports.decodeFunctionData = exports.decodeEventLog = exports.decodeErrorResult = exports.decodeDeployData = exports.decodeAbiParameters = exports.EIP1193ProviderRpcError = exports.InvalidDecimalNumberError = exports.InvalidStructTypeError = exports.InvalidPrimaryTypeError = exports.InvalidDomainError = exports.UrlRequiredError = exports.WaitForTransactionReceiptTimeoutError = exports.TransactionReceiptNotFoundError = exports.TransactionNotFoundError = exports.TransactionExecutionError = exports.InvalidStorageKeySizeError = exports.InvalidSerializedTransactionTypeError = exports.InvalidSerializedTransactionError = exports.InvalidSerializableTransactionError = exports.InvalidLegacyVError = exports.FeeConflictError = exports.StateAssignmentConflictError = void 0;
exports.formatBlock = exports.defineBlock = exports.getContractError = exports.toCoinType = exports.namehash = exports.labelhash = exports.toRlp = exports.hexToRlp = exports.bytesToRlp = exports.toHex = exports.stringToHex = exports.numberToHex = exports.bytesToHex = exports.boolToHex = exports.toBytes = exports.stringToBytes = exports.numberToBytes = exports.hexToBytes = exports.boolToBytes = exports.fromRlp = exports.hexToString = exports.hexToNumber = exports.hexToBool = exports.hexToBigInt = exports.fromHex = exports.fromBytes = exports.bytesToString = exports.bytesToNumber = exports.bytesToBool = exports.bytesToBigInt = exports.trim = exports.sliceHex = exports.sliceBytes = exports.slice = exports.size = exports.padHex = exports.padBytes = exports.pad = exports.isHex = exports.isBytes = exports.concatHex = exports.concatBytes = exports.concat = exports.getChainContractAddress = exports.extractChain = exports.defineChain = exports.assertCurrentChain = exports.offchainLookupSignature = exports.offchainLookupAbiItem = exports.offchainLookup = void 0;
exports.signatureToHex = exports.serializeErc6492Signature = exports.serializeCompactSignature = exports.compactSignatureToHex = exports.recoverTypedDataAddress = exports.recoverTransactionAddress = exports.recoverPublicKey = exports.recoverMessageAddress = exports.recoverAddress = exports.parseSignature = exports.hexToSignature = exports.parseErc6492Signature = exports.parseCompactSignature = exports.hexToCompactSignature = exports.isErc6492Signature = exports.hashTypedData = exports.hashStruct = exports.hashDomain = exports.hashMessage = exports.compactSignatureToSignature = exports.withTimeout = exports.withRetry = exports.withCache = exports.nonceManager = exports.createNonceManager = exports.setupKzg = exports.defineKzg = exports.getFunctionSignature = exports.toFunctionSignature = exports.getFunctionSelector = exports.toFunctionSelector = exports.toFunctionHash = exports.getEventSignature = exports.toEventSignature = exports.getEventSelector = exports.toEventSelector = exports.toEventHash = exports.sha256 = exports.ripemd160 = exports.keccak256 = exports.isHash = exports.rpcTransactionType = exports.formatTransactionRequest = exports.defineTransactionRequest = exports.formatTransactionReceipt = exports.defineTransactionReceipt = exports.transactionType = exports.formatTransaction = exports.defineTransaction = exports.formatLog = void 0;
exports.parseUnits = exports.parseGwei = exports.parseEther = exports.formatUnits = exports.formatGwei = exports.formatEther = exports.validateTypedData = exports.serializeTypedData = exports.getTypesForEIP712Domain = exports.domainSeparator = exports.serializeTransaction = exports.serializeAccessList = exports.parseTransaction = exports.getTransactionType = exports.getSerializedTransactionType = exports.assertTransactionLegacy = exports.assertTransactionEIP2930 = exports.assertTransactionEIP1559 = exports.assertRequest = exports.stringify = exports.verifyTypedData = exports.verifyMessage = exports.verifyHash = exports.toPrefixedMessage = exports.signatureToCompactSignature = exports.serializeSignature = void 0;
var abitype_1 = __webpack_require__(/*! abitype */ "./node_modules/abitype/dist/cjs/exports/index.js");
Object.defineProperty(exports, "CircularReferenceError", ({ enumerable: true, get: function () { return abitype_1.CircularReferenceError; } }));
Object.defineProperty(exports, "InvalidAbiItemError", ({ enumerable: true, get: function () { return abitype_1.InvalidAbiItemError; } }));
Object.defineProperty(exports, "InvalidAbiParameterError", ({ enumerable: true, get: function () { return abitype_1.InvalidAbiParameterError; } }));
Object.defineProperty(exports, "InvalidAbiParametersError", ({ enumerable: true, get: function () { return abitype_1.InvalidAbiParametersError; } }));
Object.defineProperty(exports, "InvalidAbiTypeParameterError", ({ enumerable: true, get: function () { return abitype_1.InvalidAbiTypeParameterError; } }));
Object.defineProperty(exports, "InvalidFunctionModifierError", ({ enumerable: true, get: function () { return abitype_1.InvalidFunctionModifierError; } }));
Object.defineProperty(exports, "InvalidModifierError", ({ enumerable: true, get: function () { return abitype_1.InvalidModifierError; } }));
Object.defineProperty(exports, "InvalidParameterError", ({ enumerable: true, get: function () { return abitype_1.InvalidParameterError; } }));
Object.defineProperty(exports, "InvalidParenthesisError", ({ enumerable: true, get: function () { return abitype_1.InvalidParenthesisError; } }));
Object.defineProperty(exports, "InvalidSignatureError", ({ enumerable: true, get: function () { return abitype_1.InvalidSignatureError; } }));
Object.defineProperty(exports, "InvalidStructSignatureError", ({ enumerable: true, get: function () { return abitype_1.InvalidStructSignatureError; } }));
Object.defineProperty(exports, "parseAbi", ({ enumerable: true, get: function () { return abitype_1.parseAbi; } }));
Object.defineProperty(exports, "parseAbiItem", ({ enumerable: true, get: function () { return abitype_1.parseAbiItem; } }));
Object.defineProperty(exports, "parseAbiParameter", ({ enumerable: true, get: function () { return abitype_1.parseAbiParameter; } }));
Object.defineProperty(exports, "parseAbiParameters", ({ enumerable: true, get: function () { return abitype_1.parseAbiParameters; } }));
Object.defineProperty(exports, "SolidityProtectedKeywordError", ({ enumerable: true, get: function () { return abitype_1.SolidityProtectedKeywordError; } }));
Object.defineProperty(exports, "UnknownSignatureError", ({ enumerable: true, get: function () { return abitype_1.UnknownSignatureError; } }));
Object.defineProperty(exports, "UnknownTypeError", ({ enumerable: true, get: function () { return abitype_1.UnknownTypeError; } }));
var getContract_js_1 = __webpack_require__(/*! ./actions/getContract.js */ "./node_modules/viem/_cjs/actions/getContract.js");
Object.defineProperty(exports, "getContract", ({ enumerable: true, get: function () { return getContract_js_1.getContract; } }));
var waitForCallsStatus_js_1 = __webpack_require__(/*! ./actions/wallet/waitForCallsStatus.js */ "./node_modules/viem/_cjs/actions/wallet/waitForCallsStatus.js");
Object.defineProperty(exports, "WaitForCallsStatusTimeoutError", ({ enumerable: true, get: function () { return waitForCallsStatus_js_1.WaitForCallsStatusTimeoutError; } }));
var createClient_js_1 = __webpack_require__(/*! ./clients/createClient.js */ "./node_modules/viem/_cjs/clients/createClient.js");
Object.defineProperty(exports, "createClient", ({ enumerable: true, get: function () { return createClient_js_1.createClient; } }));
Object.defineProperty(exports, "rpcSchema", ({ enumerable: true, get: function () { return createClient_js_1.rpcSchema; } }));
var createPublicClient_js_1 = __webpack_require__(/*! ./clients/createPublicClient.js */ "./node_modules/viem/_cjs/clients/createPublicClient.js");
Object.defineProperty(exports, "createPublicClient", ({ enumerable: true, get: function () { return createPublicClient_js_1.createPublicClient; } }));
var createTestClient_js_1 = __webpack_require__(/*! ./clients/createTestClient.js */ "./node_modules/viem/_cjs/clients/createTestClient.js");
Object.defineProperty(exports, "createTestClient", ({ enumerable: true, get: function () { return createTestClient_js_1.createTestClient; } }));
var createWalletClient_js_1 = __webpack_require__(/*! ./clients/createWalletClient.js */ "./node_modules/viem/_cjs/clients/createWalletClient.js");
Object.defineProperty(exports, "createWalletClient", ({ enumerable: true, get: function () { return createWalletClient_js_1.createWalletClient; } }));
var public_js_1 = __webpack_require__(/*! ./clients/decorators/public.js */ "./node_modules/viem/_cjs/clients/decorators/public.js");
Object.defineProperty(exports, "publicActions", ({ enumerable: true, get: function () { return public_js_1.publicActions; } }));
var test_js_1 = __webpack_require__(/*! ./clients/decorators/test.js */ "./node_modules/viem/_cjs/clients/decorators/test.js");
Object.defineProperty(exports, "testActions", ({ enumerable: true, get: function () { return test_js_1.testActions; } }));
var wallet_js_1 = __webpack_require__(/*! ./clients/decorators/wallet.js */ "./node_modules/viem/_cjs/clients/decorators/wallet.js");
Object.defineProperty(exports, "walletActions", ({ enumerable: true, get: function () { return wallet_js_1.walletActions; } }));
var createTransport_js_1 = __webpack_require__(/*! ./clients/transports/createTransport.js */ "./node_modules/viem/_cjs/clients/transports/createTransport.js");
Object.defineProperty(exports, "createTransport", ({ enumerable: true, get: function () { return createTransport_js_1.createTransport; } }));
var custom_js_1 = __webpack_require__(/*! ./clients/transports/custom.js */ "./node_modules/viem/_cjs/clients/transports/custom.js");
Object.defineProperty(exports, "custom", ({ enumerable: true, get: function () { return custom_js_1.custom; } }));
var fallback_js_1 = __webpack_require__(/*! ./clients/transports/fallback.js */ "./node_modules/viem/_cjs/clients/transports/fallback.js");
Object.defineProperty(exports, "fallback", ({ enumerable: true, get: function () { return fallback_js_1.fallback; } }));
Object.defineProperty(exports, "shouldThrow", ({ enumerable: true, get: function () { return fallback_js_1.shouldThrow; } }));
var http_js_1 = __webpack_require__(/*! ./clients/transports/http.js */ "./node_modules/viem/_cjs/clients/transports/http.js");
Object.defineProperty(exports, "http", ({ enumerable: true, get: function () { return http_js_1.http; } }));
var webSocket_js_1 = __webpack_require__(/*! ./clients/transports/webSocket.js */ "./node_modules/viem/_cjs/clients/transports/webSocket.js");
Object.defineProperty(exports, "webSocket", ({ enumerable: true, get: function () { return webSocket_js_1.webSocket; } }));
var abis_js_1 = __webpack_require__(/*! ./constants/abis.js */ "./node_modules/viem/_cjs/constants/abis.js");
Object.defineProperty(exports, "erc20Abi", ({ enumerable: true, get: function () { return abis_js_1.erc20Abi; } }));
Object.defineProperty(exports, "erc20Abi_bytes32", ({ enumerable: true, get: function () { return abis_js_1.erc20Abi_bytes32; } }));
Object.defineProperty(exports, "erc721Abi", ({ enumerable: true, get: function () { return abis_js_1.erc721Abi; } }));
Object.defineProperty(exports, "erc1155Abi", ({ enumerable: true, get: function () { return abis_js_1.erc1155Abi; } }));
Object.defineProperty(exports, "erc4626Abi", ({ enumerable: true, get: function () { return abis_js_1.erc4626Abi; } }));
Object.defineProperty(exports, "multicall3Abi", ({ enumerable: true, get: function () { return abis_js_1.multicall3Abi; } }));
Object.defineProperty(exports, "universalSignatureValidatorAbi", ({ enumerable: true, get: function () { return abis_js_1.universalSignatureValidatorAbi; } }));
var address_js_1 = __webpack_require__(/*! ./constants/address.js */ "./node_modules/viem/_cjs/constants/address.js");
Object.defineProperty(exports, "ethAddress", ({ enumerable: true, get: function () { return address_js_1.ethAddress; } }));
Object.defineProperty(exports, "zeroAddress", ({ enumerable: true, get: function () { return address_js_1.zeroAddress; } }));
var bytes_js_1 = __webpack_require__(/*! ./constants/bytes.js */ "./node_modules/viem/_cjs/constants/bytes.js");
Object.defineProperty(exports, "zeroHash", ({ enumerable: true, get: function () { return bytes_js_1.zeroHash; } }));
var contracts_js_1 = __webpack_require__(/*! ./constants/contracts.js */ "./node_modules/viem/_cjs/constants/contracts.js");
Object.defineProperty(exports, "deploylessCallViaBytecodeBytecode", ({ enumerable: true, get: function () { return contracts_js_1.deploylessCallViaBytecodeBytecode; } }));
Object.defineProperty(exports, "deploylessCallViaFactoryBytecode", ({ enumerable: true, get: function () { return contracts_js_1.deploylessCallViaFactoryBytecode; } }));
Object.defineProperty(exports, "universalSignatureValidatorByteCode", ({ enumerable: true, get: function () { return contracts_js_1.universalSignatureValidatorByteCode; } }));
var number_js_1 = __webpack_require__(/*! ./constants/number.js */ "./node_modules/viem/_cjs/constants/number.js");
Object.defineProperty(exports, "maxInt8", ({ enumerable: true, get: function () { return number_js_1.maxInt8; } }));
Object.defineProperty(exports, "maxInt16", ({ enumerable: true, get: function () { return number_js_1.maxInt16; } }));
Object.defineProperty(exports, "maxInt24", ({ enumerable: true, get: function () { return number_js_1.maxInt24; } }));
Object.defineProperty(exports, "maxInt32", ({ enumerable: true, get: function () { return number_js_1.maxInt32; } }));
Object.defineProperty(exports, "maxInt40", ({ enumerable: true, get: function () { return number_js_1.maxInt40; } }));
Object.defineProperty(exports, "maxInt48", ({ enumerable: true, get: function () { return number_js_1.maxInt48; } }));
Object.defineProperty(exports, "maxInt56", ({ enumerable: true, get: function () { return number_js_1.maxInt56; } }));
Object.defineProperty(exports, "maxInt64", ({ enumerable: true, get: function () { return number_js_1.maxInt64; } }));
Object.defineProperty(exports, "maxInt72", ({ enumerable: true, get: function () { return number_js_1.maxInt72; } }));
Object.defineProperty(exports, "maxInt80", ({ enumerable: true, get: function () { return number_js_1.maxInt80; } }));
Object.defineProperty(exports, "maxInt88", ({ enumerable: true, get: function () { return number_js_1.maxInt88; } }));
Object.defineProperty(exports, "maxInt96", ({ enumerable: true, get: function () { return number_js_1.maxInt96; } }));
Object.defineProperty(exports, "maxInt104", ({ enumerable: true, get: function () { return number_js_1.maxInt104; } }));
Object.defineProperty(exports, "maxInt112", ({ enumerable: true, get: function () { return number_js_1.maxInt112; } }));
Object.defineProperty(exports, "maxInt120", ({ enumerable: true, get: function () { return number_js_1.maxInt120; } }));
Object.defineProperty(exports, "maxInt128", ({ enumerable: true, get: function () { return number_js_1.maxInt128; } }));
Object.defineProperty(exports, "maxInt136", ({ enumerable: true, get: function () { return number_js_1.maxInt136; } }));
Object.defineProperty(exports, "maxInt144", ({ enumerable: true, get: function () { return number_js_1.maxInt144; } }));
Object.defineProperty(exports, "maxInt152", ({ enumerable: true, get: function () { return number_js_1.maxInt152; } }));
Object.defineProperty(exports, "maxInt160", ({ enumerable: true, get: function () { return number_js_1.maxInt160; } }));
Object.defineProperty(exports, "maxInt168", ({ enumerable: true, get: function () { return number_js_1.maxInt168; } }));
Object.defineProperty(exports, "maxInt176", ({ enumerable: true, get: function () { return number_js_1.maxInt176; } }));
Object.defineProperty(exports, "maxInt184", ({ enumerable: true, get: function () { return number_js_1.maxInt184; } }));
Object.defineProperty(exports, "maxInt192", ({ enumerable: true, get: function () { return number_js_1.maxInt192; } }));
Object.defineProperty(exports, "maxInt200", ({ enumerable: true, get: function () { return number_js_1.maxInt200; } }));
Object.defineProperty(exports, "maxInt208", ({ enumerable: true, get: function () { return number_js_1.maxInt208; } }));
Object.defineProperty(exports, "maxInt216", ({ enumerable: true, get: function () { return number_js_1.maxInt216; } }));
Object.defineProperty(exports, "maxInt224", ({ enumerable: true, get: function () { return number_js_1.maxInt224; } }));
Object.defineProperty(exports, "maxInt232", ({ enumerable: true, get: function () { return number_js_1.maxInt232; } }));
Object.defineProperty(exports, "maxInt240", ({ enumerable: true, get: function () { return number_js_1.maxInt240; } }));
Object.defineProperty(exports, "maxInt248", ({ enumerable: true, get: function () { return number_js_1.maxInt248; } }));
Object.defineProperty(exports, "maxInt256", ({ enumerable: true, get: function () { return number_js_1.maxInt256; } }));
Object.defineProperty(exports, "maxUint8", ({ enumerable: true, get: function () { return number_js_1.maxUint8; } }));
Object.defineProperty(exports, "maxUint16", ({ enumerable: true, get: function () { return number_js_1.maxUint16; } }));
Object.defineProperty(exports, "maxUint24", ({ enumerable: true, get: function () { return number_js_1.maxUint24; } }));
Object.defineProperty(exports, "maxUint32", ({ enumerable: true, get: function () { return number_js_1.maxUint32; } }));
Object.defineProperty(exports, "maxUint40", ({ enumerable: true, get: function () { return number_js_1.maxUint40; } }));
Object.defineProperty(exports, "maxUint48", ({ enumerable: true, get: function () { return number_js_1.maxUint48; } }));
Object.defineProperty(exports, "maxUint56", ({ enumerable: true, get: function () { return number_js_1.maxUint56; } }));
Object.defineProperty(exports, "maxUint64", ({ enumerable: true, get: function () { return number_js_1.maxUint64; } }));
Object.defineProperty(exports, "maxUint72", ({ enumerable: true, get: function () { return number_js_1.maxUint72; } }));
Object.defineProperty(exports, "maxUint80", ({ enumerable: true, get: function () { return number_js_1.maxUint80; } }));
Object.defineProperty(exports, "maxUint88", ({ enumerable: true, get: function () { return number_js_1.maxUint88; } }));
Object.defineProperty(exports, "maxUint96", ({ enumerable: true, get: function () { return number_js_1.maxUint96; } }));
Object.defineProperty(exports, "maxUint104", ({ enumerable: true, get: function () { return number_js_1.maxUint104; } }));
Object.defineProperty(exports, "maxUint112", ({ enumerable: true, get: function () { return number_js_1.maxUint112; } }));
Object.defineProperty(exports, "maxUint120", ({ enumerable: true, get: function () { return number_js_1.maxUint120; } }));
Object.defineProperty(exports, "maxUint128", ({ enumerable: true, get: function () { return number_js_1.maxUint128; } }));
Object.defineProperty(exports, "maxUint136", ({ enumerable: true, get: function () { return number_js_1.maxUint136; } }));
Object.defineProperty(exports, "maxUint144", ({ enumerable: true, get: function () { return number_js_1.maxUint144; } }));
Object.defineProperty(exports, "maxUint152", ({ enumerable: true, get: function () { return number_js_1.maxUint152; } }));
Object.defineProperty(exports, "maxUint160", ({ enumerable: true, get: function () { return number_js_1.maxUint160; } }));
Object.defineProperty(exports, "maxUint168", ({ enumerable: true, get: function () { return number_js_1.maxUint168; } }));
Object.defineProperty(exports, "maxUint176", ({ enumerable: true, get: function () { return number_js_1.maxUint176; } }));
Object.defineProperty(exports, "maxUint184", ({ enumerable: true, get: function () { return number_js_1.maxUint184; } }));
Object.defineProperty(exports, "maxUint192", ({ enumerable: true, get: function () { return number_js_1.maxUint192; } }));
Object.defineProperty(exports, "maxUint200", ({ enumerable: true, get: function () { return number_js_1.maxUint200; } }));
Object.defineProperty(exports, "maxUint208", ({ enumerable: true, get: function () { return number_js_1.maxUint208; } }));
Object.defineProperty(exports, "maxUint216", ({ enumerable: true, get: function () { return number_js_1.maxUint216; } }));
Object.defineProperty(exports, "maxUint224", ({ enumerable: true, get: function () { return number_js_1.maxUint224; } }));
Object.defineProperty(exports, "maxUint232", ({ enumerable: true, get: function () { return number_js_1.maxUint232; } }));
Object.defineProperty(exports, "maxUint240", ({ enumerable: true, get: function () { return number_js_1.maxUint240; } }));
Object.defineProperty(exports, "maxUint248", ({ enumerable: true, get: function () { return number_js_1.maxUint248; } }));
Object.defineProperty(exports, "maxUint256", ({ enumerable: true, get: function () { return number_js_1.maxUint256; } }));
Object.defineProperty(exports, "minInt8", ({ enumerable: true, get: function () { return number_js_1.minInt8; } }));
Object.defineProperty(exports, "minInt16", ({ enumerable: true, get: function () { return number_js_1.minInt16; } }));
Object.defineProperty(exports, "minInt24", ({ enumerable: true, get: function () { return number_js_1.minInt24; } }));
Object.defineProperty(exports, "minInt32", ({ enumerable: true, get: function () { return number_js_1.minInt32; } }));
Object.defineProperty(exports, "minInt40", ({ enumerable: true, get: function () { return number_js_1.minInt40; } }));
Object.defineProperty(exports, "minInt48", ({ enumerable: true, get: function () { return number_js_1.minInt48; } }));
Object.defineProperty(exports, "minInt56", ({ enumerable: true, get: function () { return number_js_1.minInt56; } }));
Object.defineProperty(exports, "minInt64", ({ enumerable: true, get: function () { return number_js_1.minInt64; } }));
Object.defineProperty(exports, "minInt72", ({ enumerable: true, get: function () { return number_js_1.minInt72; } }));
Object.defineProperty(exports, "minInt80", ({ enumerable: true, get: function () { return number_js_1.minInt80; } }));
Object.defineProperty(exports, "minInt88", ({ enumerable: true, get: function () { return number_js_1.minInt88; } }));
Object.defineProperty(exports, "minInt96", ({ enumerable: true, get: function () { return number_js_1.minInt96; } }));
Object.defineProperty(exports, "minInt104", ({ enumerable: true, get: function () { return number_js_1.minInt104; } }));
Object.defineProperty(exports, "minInt112", ({ enumerable: true, get: function () { return number_js_1.minInt112; } }));
Object.defineProperty(exports, "minInt120", ({ enumerable: true, get: function () { return number_js_1.minInt120; } }));
Object.defineProperty(exports, "minInt128", ({ enumerable: true, get: function () { return number_js_1.minInt128; } }));
Object.defineProperty(exports, "minInt136", ({ enumerable: true, get: function () { return number_js_1.minInt136; } }));
Object.defineProperty(exports, "minInt144", ({ enumerable: true, get: function () { return number_js_1.minInt144; } }));
Object.defineProperty(exports, "minInt152", ({ enumerable: true, get: function () { return number_js_1.minInt152; } }));
Object.defineProperty(exports, "minInt160", ({ enumerable: true, get: function () { return number_js_1.minInt160; } }));
Object.defineProperty(exports, "minInt168", ({ enumerable: true, get: function () { return number_js_1.minInt168; } }));
Object.defineProperty(exports, "minInt176", ({ enumerable: true, get: function () { return number_js_1.minInt176; } }));
Object.defineProperty(exports, "minInt184", ({ enumerable: true, get: function () { return number_js_1.minInt184; } }));
Object.defineProperty(exports, "minInt192", ({ enumerable: true, get: function () { return number_js_1.minInt192; } }));
Object.defineProperty(exports, "minInt200", ({ enumerable: true, get: function () { return number_js_1.minInt200; } }));
Object.defineProperty(exports, "minInt208", ({ enumerable: true, get: function () { return number_js_1.minInt208; } }));
Object.defineProperty(exports, "minInt216", ({ enumerable: true, get: function () { return number_js_1.minInt216; } }));
Object.defineProperty(exports, "minInt224", ({ enumerable: true, get: function () { return number_js_1.minInt224; } }));
Object.defineProperty(exports, "minInt232", ({ enumerable: true, get: function () { return number_js_1.minInt232; } }));
Object.defineProperty(exports, "minInt240", ({ enumerable: true, get: function () { return number_js_1.minInt240; } }));
Object.defineProperty(exports, "minInt248", ({ enumerable: true, get: function () { return number_js_1.minInt248; } }));
Object.defineProperty(exports, "minInt256", ({ enumerable: true, get: function () { return number_js_1.minInt256; } }));
var strings_js_1 = __webpack_require__(/*! ./constants/strings.js */ "./node_modules/viem/_cjs/constants/strings.js");
Object.defineProperty(exports, "presignMessagePrefix", ({ enumerable: true, get: function () { return strings_js_1.presignMessagePrefix; } }));
var unit_js_1 = __webpack_require__(/*! ./constants/unit.js */ "./node_modules/viem/_cjs/constants/unit.js");
Object.defineProperty(exports, "etherUnits", ({ enumerable: true, get: function () { return unit_js_1.etherUnits; } }));
Object.defineProperty(exports, "gweiUnits", ({ enumerable: true, get: function () { return unit_js_1.gweiUnits; } }));
Object.defineProperty(exports, "weiUnits", ({ enumerable: true, get: function () { return unit_js_1.weiUnits; } }));
var abi_js_1 = __webpack_require__(/*! ./errors/abi.js */ "./node_modules/viem/_cjs/errors/abi.js");
Object.defineProperty(exports, "AbiConstructorNotFoundError", ({ enumerable: true, get: function () { return abi_js_1.AbiConstructorNotFoundError; } }));
Object.defineProperty(exports, "AbiConstructorParamsNotFoundError", ({ enumerable: true, get: function () { return abi_js_1.AbiConstructorParamsNotFoundError; } }));
Object.defineProperty(exports, "AbiDecodingDataSizeInvalidError", ({ enumerable: true, get: function () { return abi_js_1.AbiDecodingDataSizeInvalidError; } }));
Object.defineProperty(exports, "AbiDecodingDataSizeTooSmallError", ({ enumerable: true, get: function () { return abi_js_1.AbiDecodingDataSizeTooSmallError; } }));
Object.defineProperty(exports, "AbiDecodingZeroDataError", ({ enumerable: true, get: function () { return abi_js_1.AbiDecodingZeroDataError; } }));
Object.defineProperty(exports, "AbiEncodingArrayLengthMismatchError", ({ enumerable: true, get: function () { return abi_js_1.AbiEncodingArrayLengthMismatchError; } }));
Object.defineProperty(exports, "AbiEncodingBytesSizeMismatchError", ({ enumerable: true, get: function () { return abi_js_1.AbiEncodingBytesSizeMismatchError; } }));
Object.defineProperty(exports, "AbiEncodingLengthMismatchError", ({ enumerable: true, get: function () { return abi_js_1.AbiEncodingLengthMismatchError; } }));
Object.defineProperty(exports, "AbiErrorInputsNotFoundError", ({ enumerable: true, get: function () { return abi_js_1.AbiErrorInputsNotFoundError; } }));
Object.defineProperty(exports, "AbiErrorNotFoundError", ({ enumerable: true, get: function () { return abi_js_1.AbiErrorNotFoundError; } }));
Object.defineProperty(exports, "AbiErrorSignatureNotFoundError", ({ enumerable: true, get: function () { return abi_js_1.AbiErrorSignatureNotFoundError; } }));
Object.defineProperty(exports, "AbiEventNotFoundError", ({ enumerable: true, get: function () { return abi_js_1.AbiEventNotFoundError; } }));
Object.defineProperty(exports, "AbiEventSignatureEmptyTopicsError", ({ enumerable: true, get: function () { return abi_js_1.AbiEventSignatureEmptyTopicsError; } }));
Object.defineProperty(exports, "AbiEventSignatureNotFoundError", ({ enumerable: true, get: function () { return abi_js_1.AbiEventSignatureNotFoundError; } }));
Object.defineProperty(exports, "AbiFunctionNotFoundError", ({ enumerable: true, get: function () { return abi_js_1.AbiFunctionNotFoundError; } }));
Object.defineProperty(exports, "AbiFunctionOutputsNotFoundError", ({ enumerable: true, get: function () { return abi_js_1.AbiFunctionOutputsNotFoundError; } }));
Object.defineProperty(exports, "AbiFunctionSignatureNotFoundError", ({ enumerable: true, get: function () { return abi_js_1.AbiFunctionSignatureNotFoundError; } }));
Object.defineProperty(exports, "BytesSizeMismatchError", ({ enumerable: true, get: function () { return abi_js_1.BytesSizeMismatchError; } }));
Object.defineProperty(exports, "DecodeLogDataMismatch", ({ enumerable: true, get: function () { return abi_js_1.DecodeLogDataMismatch; } }));
Object.defineProperty(exports, "DecodeLogTopicsMismatch", ({ enumerable: true, get: function () { return abi_js_1.DecodeLogTopicsMismatch; } }));
Object.defineProperty(exports, "InvalidAbiDecodingTypeError", ({ enumerable: true, get: function () { return abi_js_1.InvalidAbiDecodingTypeError; } }));
Object.defineProperty(exports, "InvalidAbiEncodingTypeError", ({ enumerable: true, get: function () { return abi_js_1.InvalidAbiEncodingTypeError; } }));
Object.defineProperty(exports, "InvalidArrayError", ({ enumerable: true, get: function () { return abi_js_1.InvalidArrayError; } }));
Object.defineProperty(exports, "InvalidDefinitionTypeError", ({ enumerable: true, get: function () { return abi_js_1.InvalidDefinitionTypeError; } }));
Object.defineProperty(exports, "UnsupportedPackedAbiType", ({ enumerable: true, get: function () { return abi_js_1.UnsupportedPackedAbiType; } }));
var address_js_2 = __webpack_require__(/*! ./errors/address.js */ "./node_modules/viem/_cjs/errors/address.js");
Object.defineProperty(exports, "InvalidAddressError", ({ enumerable: true, get: function () { return address_js_2.InvalidAddressError; } }));
var base_js_1 = __webpack_require__(/*! ./errors/base.js */ "./node_modules/viem/_cjs/errors/base.js");
Object.defineProperty(exports, "BaseError", ({ enumerable: true, get: function () { return base_js_1.BaseError; } }));
Object.defineProperty(exports, "setErrorConfig", ({ enumerable: true, get: function () { return base_js_1.setErrorConfig; } }));
var block_js_1 = __webpack_require__(/*! ./errors/block.js */ "./node_modules/viem/_cjs/errors/block.js");
Object.defineProperty(exports, "BlockNotFoundError", ({ enumerable: true, get: function () { return block_js_1.BlockNotFoundError; } }));
var calls_js_1 = __webpack_require__(/*! ./errors/calls.js */ "./node_modules/viem/_cjs/errors/calls.js");
Object.defineProperty(exports, "BundleFailedError", ({ enumerable: true, get: function () { return calls_js_1.BundleFailedError; } }));
var chain_js_1 = __webpack_require__(/*! ./errors/chain.js */ "./node_modules/viem/_cjs/errors/chain.js");
Object.defineProperty(exports, "ChainDoesNotSupportContract", ({ enumerable: true, get: function () { return chain_js_1.ChainDoesNotSupportContract; } }));
Object.defineProperty(exports, "ChainMismatchError", ({ enumerable: true, get: function () { return chain_js_1.ChainMismatchError; } }));
Object.defineProperty(exports, "ChainNotFoundError", ({ enumerable: true, get: function () { return chain_js_1.ChainNotFoundError; } }));
Object.defineProperty(exports, "ClientChainNotConfiguredError", ({ enumerable: true, get: function () { return chain_js_1.ClientChainNotConfiguredError; } }));
Object.defineProperty(exports, "InvalidChainIdError", ({ enumerable: true, get: function () { return chain_js_1.InvalidChainIdError; } }));
var contract_js_1 = __webpack_require__(/*! ./errors/contract.js */ "./node_modules/viem/_cjs/errors/contract.js");
Object.defineProperty(exports, "CallExecutionError", ({ enumerable: true, get: function () { return contract_js_1.CallExecutionError; } }));
Object.defineProperty(exports, "ContractFunctionExecutionError", ({ enumerable: true, get: function () { return contract_js_1.ContractFunctionExecutionError; } }));
Object.defineProperty(exports, "ContractFunctionRevertedError", ({ enumerable: true, get: function () { return contract_js_1.ContractFunctionRevertedError; } }));
Object.defineProperty(exports, "ContractFunctionZeroDataError", ({ enumerable: true, get: function () { return contract_js_1.ContractFunctionZeroDataError; } }));
Object.defineProperty(exports, "CounterfactualDeploymentFailedError", ({ enumerable: true, get: function () { return contract_js_1.CounterfactualDeploymentFailedError; } }));
Object.defineProperty(exports, "RawContractError", ({ enumerable: true, get: function () { return contract_js_1.RawContractError; } }));
var data_js_1 = __webpack_require__(/*! ./errors/data.js */ "./node_modules/viem/_cjs/errors/data.js");
Object.defineProperty(exports, "SizeExceedsPaddingSizeError", ({ enumerable: true, get: function () { return data_js_1.SizeExceedsPaddingSizeError; } }));
Object.defineProperty(exports, "SliceOffsetOutOfBoundsError", ({ enumerable: true, get: function () { return data_js_1.SliceOffsetOutOfBoundsError; } }));
var encoding_js_1 = __webpack_require__(/*! ./errors/encoding.js */ "./node_modules/viem/_cjs/errors/encoding.js");
Object.defineProperty(exports, "IntegerOutOfRangeError", ({ enumerable: true, get: function () { return encoding_js_1.IntegerOutOfRangeError; } }));
Object.defineProperty(exports, "InvalidBytesBooleanError", ({ enumerable: true, get: function () { return encoding_js_1.InvalidBytesBooleanError; } }));
Object.defineProperty(exports, "InvalidHexBooleanError", ({ enumerable: true, get: function () { return encoding_js_1.InvalidHexBooleanError; } }));
Object.defineProperty(exports, "InvalidHexValueError", ({ enumerable: true, get: function () { return encoding_js_1.InvalidHexValueError; } }));
Object.defineProperty(exports, "SizeOverflowError", ({ enumerable: true, get: function () { return encoding_js_1.SizeOverflowError; } }));
var ens_js_1 = __webpack_require__(/*! ./errors/ens.js */ "./node_modules/viem/_cjs/errors/ens.js");
Object.defineProperty(exports, "EnsAvatarInvalidNftUriError", ({ enumerable: true, get: function () { return ens_js_1.EnsAvatarInvalidNftUriError; } }));
Object.defineProperty(exports, "EnsAvatarUnsupportedNamespaceError", ({ enumerable: true, get: function () { return ens_js_1.EnsAvatarUnsupportedNamespaceError; } }));
Object.defineProperty(exports, "EnsAvatarUriResolutionError", ({ enumerable: true, get: function () { return ens_js_1.EnsAvatarUriResolutionError; } }));
Object.defineProperty(exports, "EnsInvalidChainIdError", ({ enumerable: true, get: function () { return ens_js_1.EnsInvalidChainIdError; } }));
var estimateGas_js_1 = __webpack_require__(/*! ./errors/estimateGas.js */ "./node_modules/viem/_cjs/errors/estimateGas.js");
Object.defineProperty(exports, "EstimateGasExecutionError", ({ enumerable: true, get: function () { return estimateGas_js_1.EstimateGasExecutionError; } }));
var fee_js_1 = __webpack_require__(/*! ./errors/fee.js */ "./node_modules/viem/_cjs/errors/fee.js");
Object.defineProperty(exports, "BaseFeeScalarError", ({ enumerable: true, get: function () { return fee_js_1.BaseFeeScalarError; } }));
Object.defineProperty(exports, "Eip1559FeesNotSupportedError", ({ enumerable: true, get: function () { return fee_js_1.Eip1559FeesNotSupportedError; } }));
Object.defineProperty(exports, "MaxFeePerGasTooLowError", ({ enumerable: true, get: function () { return fee_js_1.MaxFeePerGasTooLowError; } }));
var log_js_1 = __webpack_require__(/*! ./errors/log.js */ "./node_modules/viem/_cjs/errors/log.js");
Object.defineProperty(exports, "FilterTypeNotSupportedError", ({ enumerable: true, get: function () { return log_js_1.FilterTypeNotSupportedError; } }));
var node_js_1 = __webpack_require__(/*! ./errors/node.js */ "./node_modules/viem/_cjs/errors/node.js");
Object.defineProperty(exports, "ExecutionRevertedError", ({ enumerable: true, get: function () { return node_js_1.ExecutionRevertedError; } }));
Object.defineProperty(exports, "FeeCapTooHighError", ({ enumerable: true, get: function () { return node_js_1.FeeCapTooHighError; } }));
Object.defineProperty(exports, "FeeCapTooLowError", ({ enumerable: true, get: function () { return node_js_1.FeeCapTooLowError; } }));
Object.defineProperty(exports, "InsufficientFundsError", ({ enumerable: true, get: function () { return node_js_1.InsufficientFundsError; } }));
Object.defineProperty(exports, "IntrinsicGasTooHighError", ({ enumerable: true, get: function () { return node_js_1.IntrinsicGasTooHighError; } }));
Object.defineProperty(exports, "IntrinsicGasTooLowError", ({ enumerable: true, get: function () { return node_js_1.IntrinsicGasTooLowError; } }));
Object.defineProperty(exports, "NonceMaxValueError", ({ enumerable: true, get: function () { return node_js_1.NonceMaxValueError; } }));
Object.defineProperty(exports, "NonceTooHighError", ({ enumerable: true, get: function () { return node_js_1.NonceTooHighError; } }));
Object.defineProperty(exports, "NonceTooLowError", ({ enumerable: true, get: function () { return node_js_1.NonceTooLowError; } }));
Object.defineProperty(exports, "TipAboveFeeCapError", ({ enumerable: true, get: function () { return node_js_1.TipAboveFeeCapError; } }));
Object.defineProperty(exports, "TransactionTypeNotSupportedError", ({ enumerable: true, get: function () { return node_js_1.TransactionTypeNotSupportedError; } }));
Object.defineProperty(exports, "UnknownNodeError", ({ enumerable: true, get: function () { return node_js_1.UnknownNodeError; } }));
var request_js_1 = __webpack_require__(/*! ./errors/request.js */ "./node_modules/viem/_cjs/errors/request.js");
Object.defineProperty(exports, "HttpRequestError", ({ enumerable: true, get: function () { return request_js_1.HttpRequestError; } }));
Object.defineProperty(exports, "RpcRequestError", ({ enumerable: true, get: function () { return request_js_1.RpcRequestError; } }));
Object.defineProperty(exports, "SocketClosedError", ({ enumerable: true, get: function () { return request_js_1.SocketClosedError; } }));
Object.defineProperty(exports, "TimeoutError", ({ enumerable: true, get: function () { return request_js_1.TimeoutError; } }));
Object.defineProperty(exports, "WebSocketRequestError", ({ enumerable: true, get: function () { return request_js_1.WebSocketRequestError; } }));
var rpc_js_1 = __webpack_require__(/*! ./errors/rpc.js */ "./node_modules/viem/_cjs/errors/rpc.js");
Object.defineProperty(exports, "AtomicityNotSupportedError", ({ enumerable: true, get: function () { return rpc_js_1.AtomicityNotSupportedError; } }));
Object.defineProperty(exports, "AtomicReadyWalletRejectedUpgradeError", ({ enumerable: true, get: function () { return rpc_js_1.AtomicReadyWalletRejectedUpgradeError; } }));
Object.defineProperty(exports, "BundleTooLargeError", ({ enumerable: true, get: function () { return rpc_js_1.BundleTooLargeError; } }));
Object.defineProperty(exports, "ChainDisconnectedError", ({ enumerable: true, get: function () { return rpc_js_1.ChainDisconnectedError; } }));
Object.defineProperty(exports, "DuplicateIdError", ({ enumerable: true, get: function () { return rpc_js_1.DuplicateIdError; } }));
Object.defineProperty(exports, "InternalRpcError", ({ enumerable: true, get: function () { return rpc_js_1.InternalRpcError; } }));
Object.defineProperty(exports, "InvalidInputRpcError", ({ enumerable: true, get: function () { return rpc_js_1.InvalidInputRpcError; } }));
Object.defineProperty(exports, "InvalidParamsRpcError", ({ enumerable: true, get: function () { return rpc_js_1.InvalidParamsRpcError; } }));
Object.defineProperty(exports, "InvalidRequestRpcError", ({ enumerable: true, get: function () { return rpc_js_1.InvalidRequestRpcError; } }));
Object.defineProperty(exports, "JsonRpcVersionUnsupportedError", ({ enumerable: true, get: function () { return rpc_js_1.JsonRpcVersionUnsupportedError; } }));
Object.defineProperty(exports, "LimitExceededRpcError", ({ enumerable: true, get: function () { return rpc_js_1.LimitExceededRpcError; } }));
Object.defineProperty(exports, "MethodNotFoundRpcError", ({ enumerable: true, get: function () { return rpc_js_1.MethodNotFoundRpcError; } }));
Object.defineProperty(exports, "MethodNotSupportedRpcError", ({ enumerable: true, get: function () { return rpc_js_1.MethodNotSupportedRpcError; } }));
Object.defineProperty(exports, "ParseRpcError", ({ enumerable: true, get: function () { return rpc_js_1.ParseRpcError; } }));
Object.defineProperty(exports, "ProviderDisconnectedError", ({ enumerable: true, get: function () { return rpc_js_1.ProviderDisconnectedError; } }));
Object.defineProperty(exports, "ProviderRpcError", ({ enumerable: true, get: function () { return rpc_js_1.ProviderRpcError; } }));
Object.defineProperty(exports, "ResourceNotFoundRpcError", ({ enumerable: true, get: function () { return rpc_js_1.ResourceNotFoundRpcError; } }));
Object.defineProperty(exports, "ResourceUnavailableRpcError", ({ enumerable: true, get: function () { return rpc_js_1.ResourceUnavailableRpcError; } }));
Object.defineProperty(exports, "RpcError", ({ enumerable: true, get: function () { return rpc_js_1.RpcError; } }));
Object.defineProperty(exports, "SwitchChainError", ({ enumerable: true, get: function () { return rpc_js_1.SwitchChainError; } }));
Object.defineProperty(exports, "TransactionRejectedRpcError", ({ enumerable: true, get: function () { return rpc_js_1.TransactionRejectedRpcError; } }));
Object.defineProperty(exports, "UnauthorizedProviderError", ({ enumerable: true, get: function () { return rpc_js_1.UnauthorizedProviderError; } }));
Object.defineProperty(exports, "UnknownBundleIdError", ({ enumerable: true, get: function () { return rpc_js_1.UnknownBundleIdError; } }));
Object.defineProperty(exports, "UnknownRpcError", ({ enumerable: true, get: function () { return rpc_js_1.UnknownRpcError; } }));
Object.defineProperty(exports, "UnsupportedChainIdError", ({ enumerable: true, get: function () { return rpc_js_1.UnsupportedChainIdError; } }));
Object.defineProperty(exports, "UnsupportedNonOptionalCapabilityError", ({ enumerable: true, get: function () { return rpc_js_1.UnsupportedNonOptionalCapabilityError; } }));
Object.defineProperty(exports, "UnsupportedProviderMethodError", ({ enumerable: true, get: function () { return rpc_js_1.UnsupportedProviderMethodError; } }));
Object.defineProperty(exports, "UserRejectedRequestError", ({ enumerable: true, get: function () { return rpc_js_1.UserRejectedRequestError; } }));
var stateOverride_js_1 = __webpack_require__(/*! ./errors/stateOverride.js */ "./node_modules/viem/_cjs/errors/stateOverride.js");
Object.defineProperty(exports, "AccountStateConflictError", ({ enumerable: true, get: function () { return stateOverride_js_1.AccountStateConflictError; } }));
Object.defineProperty(exports, "StateAssignmentConflictError", ({ enumerable: true, get: function () { return stateOverride_js_1.StateAssignmentConflictError; } }));
var transaction_js_1 = __webpack_require__(/*! ./errors/transaction.js */ "./node_modules/viem/_cjs/errors/transaction.js");
Object.defineProperty(exports, "FeeConflictError", ({ enumerable: true, get: function () { return transaction_js_1.FeeConflictError; } }));
Object.defineProperty(exports, "InvalidLegacyVError", ({ enumerable: true, get: function () { return transaction_js_1.InvalidLegacyVError; } }));
Object.defineProperty(exports, "InvalidSerializableTransactionError", ({ enumerable: true, get: function () { return transaction_js_1.InvalidSerializableTransactionError; } }));
Object.defineProperty(exports, "InvalidSerializedTransactionError", ({ enumerable: true, get: function () { return transaction_js_1.InvalidSerializedTransactionError; } }));
Object.defineProperty(exports, "InvalidSerializedTransactionTypeError", ({ enumerable: true, get: function () { return transaction_js_1.InvalidSerializedTransactionTypeError; } }));
Object.defineProperty(exports, "InvalidStorageKeySizeError", ({ enumerable: true, get: function () { return transaction_js_1.InvalidStorageKeySizeError; } }));
Object.defineProperty(exports, "TransactionExecutionError", ({ enumerable: true, get: function () { return transaction_js_1.TransactionExecutionError; } }));
Object.defineProperty(exports, "TransactionNotFoundError", ({ enumerable: true, get: function () { return transaction_js_1.TransactionNotFoundError; } }));
Object.defineProperty(exports, "TransactionReceiptNotFoundError", ({ enumerable: true, get: function () { return transaction_js_1.TransactionReceiptNotFoundError; } }));
Object.defineProperty(exports, "WaitForTransactionReceiptTimeoutError", ({ enumerable: true, get: function () { return transaction_js_1.WaitForTransactionReceiptTimeoutError; } }));
var transport_js_1 = __webpack_require__(/*! ./errors/transport.js */ "./node_modules/viem/_cjs/errors/transport.js");
Object.defineProperty(exports, "UrlRequiredError", ({ enumerable: true, get: function () { return transport_js_1.UrlRequiredError; } }));
var typedData_js_1 = __webpack_require__(/*! ./errors/typedData.js */ "./node_modules/viem/_cjs/errors/typedData.js");
Object.defineProperty(exports, "InvalidDomainError", ({ enumerable: true, get: function () { return typedData_js_1.InvalidDomainError; } }));
Object.defineProperty(exports, "InvalidPrimaryTypeError", ({ enumerable: true, get: function () { return typedData_js_1.InvalidPrimaryTypeError; } }));
Object.defineProperty(exports, "InvalidStructTypeError", ({ enumerable: true, get: function () { return typedData_js_1.InvalidStructTypeError; } }));
var unit_js_2 = __webpack_require__(/*! ./errors/unit.js */ "./node_modules/viem/_cjs/errors/unit.js");
Object.defineProperty(exports, "InvalidDecimalNumberError", ({ enumerable: true, get: function () { return unit_js_2.InvalidDecimalNumberError; } }));
var eip1193_js_1 = __webpack_require__(/*! ./types/eip1193.js */ "./node_modules/viem/_cjs/types/eip1193.js");
Object.defineProperty(exports, "EIP1193ProviderRpcError", ({ enumerable: true, get: function () { return eip1193_js_1.ProviderRpcError; } }));
var decodeAbiParameters_js_1 = __webpack_require__(/*! ./utils/abi/decodeAbiParameters.js */ "./node_modules/viem/_cjs/utils/abi/decodeAbiParameters.js");
Object.defineProperty(exports, "decodeAbiParameters", ({ enumerable: true, get: function () { return decodeAbiParameters_js_1.decodeAbiParameters; } }));
var decodeDeployData_js_1 = __webpack_require__(/*! ./utils/abi/decodeDeployData.js */ "./node_modules/viem/_cjs/utils/abi/decodeDeployData.js");
Object.defineProperty(exports, "decodeDeployData", ({ enumerable: true, get: function () { return decodeDeployData_js_1.decodeDeployData; } }));
var decodeErrorResult_js_1 = __webpack_require__(/*! ./utils/abi/decodeErrorResult.js */ "./node_modules/viem/_cjs/utils/abi/decodeErrorResult.js");
Object.defineProperty(exports, "decodeErrorResult", ({ enumerable: true, get: function () { return decodeErrorResult_js_1.decodeErrorResult; } }));
var decodeEventLog_js_1 = __webpack_require__(/*! ./utils/abi/decodeEventLog.js */ "./node_modules/viem/_cjs/utils/abi/decodeEventLog.js");
Object.defineProperty(exports, "decodeEventLog", ({ enumerable: true, get: function () { return decodeEventLog_js_1.decodeEventLog; } }));
var decodeFunctionData_js_1 = __webpack_require__(/*! ./utils/abi/decodeFunctionData.js */ "./node_modules/viem/_cjs/utils/abi/decodeFunctionData.js");
Object.defineProperty(exports, "decodeFunctionData", ({ enumerable: true, get: function () { return decodeFunctionData_js_1.decodeFunctionData; } }));
var decodeFunctionResult_js_1 = __webpack_require__(/*! ./utils/abi/decodeFunctionResult.js */ "./node_modules/viem/_cjs/utils/abi/decodeFunctionResult.js");
Object.defineProperty(exports, "decodeFunctionResult", ({ enumerable: true, get: function () { return decodeFunctionResult_js_1.decodeFunctionResult; } }));
var encodeAbiParameters_js_1 = __webpack_require__(/*! ./utils/abi/encodeAbiParameters.js */ "./node_modules/viem/_cjs/utils/abi/encodeAbiParameters.js");
Object.defineProperty(exports, "encodeAbiParameters", ({ enumerable: true, get: function () { return encodeAbiParameters_js_1.encodeAbiParameters; } }));
var encodeDeployData_js_1 = __webpack_require__(/*! ./utils/abi/encodeDeployData.js */ "./node_modules/viem/_cjs/utils/abi/encodeDeployData.js");
Object.defineProperty(exports, "encodeDeployData", ({ enumerable: true, get: function () { return encodeDeployData_js_1.encodeDeployData; } }));
var encodeErrorResult_js_1 = __webpack_require__(/*! ./utils/abi/encodeErrorResult.js */ "./node_modules/viem/_cjs/utils/abi/encodeErrorResult.js");
Object.defineProperty(exports, "encodeErrorResult", ({ enumerable: true, get: function () { return encodeErrorResult_js_1.encodeErrorResult; } }));
var encodeEventTopics_js_1 = __webpack_require__(/*! ./utils/abi/encodeEventTopics.js */ "./node_modules/viem/_cjs/utils/abi/encodeEventTopics.js");
Object.defineProperty(exports, "encodeEventTopics", ({ enumerable: true, get: function () { return encodeEventTopics_js_1.encodeEventTopics; } }));
var encodeFunctionData_js_1 = __webpack_require__(/*! ./utils/abi/encodeFunctionData.js */ "./node_modules/viem/_cjs/utils/abi/encodeFunctionData.js");
Object.defineProperty(exports, "encodeFunctionData", ({ enumerable: true, get: function () { return encodeFunctionData_js_1.encodeFunctionData; } }));
var encodeFunctionResult_js_1 = __webpack_require__(/*! ./utils/abi/encodeFunctionResult.js */ "./node_modules/viem/_cjs/utils/abi/encodeFunctionResult.js");
Object.defineProperty(exports, "encodeFunctionResult", ({ enumerable: true, get: function () { return encodeFunctionResult_js_1.encodeFunctionResult; } }));
var encodePacked_js_1 = __webpack_require__(/*! ./utils/abi/encodePacked.js */ "./node_modules/viem/_cjs/utils/abi/encodePacked.js");
Object.defineProperty(exports, "encodePacked", ({ enumerable: true, get: function () { return encodePacked_js_1.encodePacked; } }));
var getAbiItem_js_1 = __webpack_require__(/*! ./utils/abi/getAbiItem.js */ "./node_modules/viem/_cjs/utils/abi/getAbiItem.js");
Object.defineProperty(exports, "getAbiItem", ({ enumerable: true, get: function () { return getAbiItem_js_1.getAbiItem; } }));
var parseEventLogs_js_1 = __webpack_require__(/*! ./utils/abi/parseEventLogs.js */ "./node_modules/viem/_cjs/utils/abi/parseEventLogs.js");
Object.defineProperty(exports, "parseEventLogs", ({ enumerable: true, get: function () { return parseEventLogs_js_1.parseEventLogs; } }));
var prepareEncodeFunctionData_js_1 = __webpack_require__(/*! ./utils/abi/prepareEncodeFunctionData.js */ "./node_modules/viem/_cjs/utils/abi/prepareEncodeFunctionData.js");
Object.defineProperty(exports, "prepareEncodeFunctionData", ({ enumerable: true, get: function () { return prepareEncodeFunctionData_js_1.prepareEncodeFunctionData; } }));
var getAddress_js_1 = __webpack_require__(/*! ./utils/address/getAddress.js */ "./node_modules/viem/_cjs/utils/address/getAddress.js");
Object.defineProperty(exports, "checksumAddress", ({ enumerable: true, get: function () { return getAddress_js_1.checksumAddress; } }));
Object.defineProperty(exports, "getAddress", ({ enumerable: true, get: function () { return getAddress_js_1.getAddress; } }));
var getContractAddress_js_1 = __webpack_require__(/*! ./utils/address/getContractAddress.js */ "./node_modules/viem/_cjs/utils/address/getContractAddress.js");
Object.defineProperty(exports, "getContractAddress", ({ enumerable: true, get: function () { return getContractAddress_js_1.getContractAddress; } }));
Object.defineProperty(exports, "getCreate2Address", ({ enumerable: true, get: function () { return getContractAddress_js_1.getCreate2Address; } }));
Object.defineProperty(exports, "getCreateAddress", ({ enumerable: true, get: function () { return getContractAddress_js_1.getCreateAddress; } }));
var isAddress_js_1 = __webpack_require__(/*! ./utils/address/isAddress.js */ "./node_modules/viem/_cjs/utils/address/isAddress.js");
Object.defineProperty(exports, "isAddress", ({ enumerable: true, get: function () { return isAddress_js_1.isAddress; } }));
var isAddressEqual_js_1 = __webpack_require__(/*! ./utils/address/isAddressEqual.js */ "./node_modules/viem/_cjs/utils/address/isAddressEqual.js");
Object.defineProperty(exports, "isAddressEqual", ({ enumerable: true, get: function () { return isAddressEqual_js_1.isAddressEqual; } }));
var blobsToCommitments_js_1 = __webpack_require__(/*! ./utils/blob/blobsToCommitments.js */ "./node_modules/viem/_cjs/utils/blob/blobsToCommitments.js");
Object.defineProperty(exports, "blobsToCommitments", ({ enumerable: true, get: function () { return blobsToCommitments_js_1.blobsToCommitments; } }));
var blobsToProofs_js_1 = __webpack_require__(/*! ./utils/blob/blobsToProofs.js */ "./node_modules/viem/_cjs/utils/blob/blobsToProofs.js");
Object.defineProperty(exports, "blobsToProofs", ({ enumerable: true, get: function () { return blobsToProofs_js_1.blobsToProofs; } }));
var commitmentsToVersionedHashes_js_1 = __webpack_require__(/*! ./utils/blob/commitmentsToVersionedHashes.js */ "./node_modules/viem/_cjs/utils/blob/commitmentsToVersionedHashes.js");
Object.defineProperty(exports, "commitmentsToVersionedHashes", ({ enumerable: true, get: function () { return commitmentsToVersionedHashes_js_1.commitmentsToVersionedHashes; } }));
var commitmentToVersionedHash_js_1 = __webpack_require__(/*! ./utils/blob/commitmentToVersionedHash.js */ "./node_modules/viem/_cjs/utils/blob/commitmentToVersionedHash.js");
Object.defineProperty(exports, "commitmentToVersionedHash", ({ enumerable: true, get: function () { return commitmentToVersionedHash_js_1.commitmentToVersionedHash; } }));
var fromBlobs_js_1 = __webpack_require__(/*! ./utils/blob/fromBlobs.js */ "./node_modules/viem/_cjs/utils/blob/fromBlobs.js");
Object.defineProperty(exports, "fromBlobs", ({ enumerable: true, get: function () { return fromBlobs_js_1.fromBlobs; } }));
var sidecarsToVersionedHashes_js_1 = __webpack_require__(/*! ./utils/blob/sidecarsToVersionedHashes.js */ "./node_modules/viem/_cjs/utils/blob/sidecarsToVersionedHashes.js");
Object.defineProperty(exports, "sidecarsToVersionedHashes", ({ enumerable: true, get: function () { return sidecarsToVersionedHashes_js_1.sidecarsToVersionedHashes; } }));
var toBlobSidecars_js_1 = __webpack_require__(/*! ./utils/blob/toBlobSidecars.js */ "./node_modules/viem/_cjs/utils/blob/toBlobSidecars.js");
Object.defineProperty(exports, "toBlobSidecars", ({ enumerable: true, get: function () { return toBlobSidecars_js_1.toBlobSidecars; } }));
var toBlobs_js_1 = __webpack_require__(/*! ./utils/blob/toBlobs.js */ "./node_modules/viem/_cjs/utils/blob/toBlobs.js");
Object.defineProperty(exports, "toBlobs", ({ enumerable: true, get: function () { return toBlobs_js_1.toBlobs; } }));
var ccip_js_1 = __webpack_require__(/*! ./utils/ccip.js */ "./node_modules/viem/_cjs/utils/ccip.js");
Object.defineProperty(exports, "ccipRequest", ({ enumerable: true, get: function () { return ccip_js_1.ccipRequest; } }));
Object.defineProperty(exports, "ccipFetch", ({ enumerable: true, get: function () { return ccip_js_1.ccipRequest; } }));
Object.defineProperty(exports, "offchainLookup", ({ enumerable: true, get: function () { return ccip_js_1.offchainLookup; } }));
Object.defineProperty(exports, "offchainLookupAbiItem", ({ enumerable: true, get: function () { return ccip_js_1.offchainLookupAbiItem; } }));
Object.defineProperty(exports, "offchainLookupSignature", ({ enumerable: true, get: function () { return ccip_js_1.offchainLookupSignature; } }));
var assertCurrentChain_js_1 = __webpack_require__(/*! ./utils/chain/assertCurrentChain.js */ "./node_modules/viem/_cjs/utils/chain/assertCurrentChain.js");
Object.defineProperty(exports, "assertCurrentChain", ({ enumerable: true, get: function () { return assertCurrentChain_js_1.assertCurrentChain; } }));
var defineChain_js_1 = __webpack_require__(/*! ./utils/chain/defineChain.js */ "./node_modules/viem/_cjs/utils/chain/defineChain.js");
Object.defineProperty(exports, "defineChain", ({ enumerable: true, get: function () { return defineChain_js_1.defineChain; } }));
var extractChain_js_1 = __webpack_require__(/*! ./utils/chain/extractChain.js */ "./node_modules/viem/_cjs/utils/chain/extractChain.js");
Object.defineProperty(exports, "extractChain", ({ enumerable: true, get: function () { return extractChain_js_1.extractChain; } }));
var getChainContractAddress_js_1 = __webpack_require__(/*! ./utils/chain/getChainContractAddress.js */ "./node_modules/viem/_cjs/utils/chain/getChainContractAddress.js");
Object.defineProperty(exports, "getChainContractAddress", ({ enumerable: true, get: function () { return getChainContractAddress_js_1.getChainContractAddress; } }));
var concat_js_1 = __webpack_require__(/*! ./utils/data/concat.js */ "./node_modules/viem/_cjs/utils/data/concat.js");
Object.defineProperty(exports, "concat", ({ enumerable: true, get: function () { return concat_js_1.concat; } }));
Object.defineProperty(exports, "concatBytes", ({ enumerable: true, get: function () { return concat_js_1.concatBytes; } }));
Object.defineProperty(exports, "concatHex", ({ enumerable: true, get: function () { return concat_js_1.concatHex; } }));
var isBytes_js_1 = __webpack_require__(/*! ./utils/data/isBytes.js */ "./node_modules/viem/_cjs/utils/data/isBytes.js");
Object.defineProperty(exports, "isBytes", ({ enumerable: true, get: function () { return isBytes_js_1.isBytes; } }));
var isHex_js_1 = __webpack_require__(/*! ./utils/data/isHex.js */ "./node_modules/viem/_cjs/utils/data/isHex.js");
Object.defineProperty(exports, "isHex", ({ enumerable: true, get: function () { return isHex_js_1.isHex; } }));
var pad_js_1 = __webpack_require__(/*! ./utils/data/pad.js */ "./node_modules/viem/_cjs/utils/data/pad.js");
Object.defineProperty(exports, "pad", ({ enumerable: true, get: function () { return pad_js_1.pad; } }));
Object.defineProperty(exports, "padBytes", ({ enumerable: true, get: function () { return pad_js_1.padBytes; } }));
Object.defineProperty(exports, "padHex", ({ enumerable: true, get: function () { return pad_js_1.padHex; } }));
var size_js_1 = __webpack_require__(/*! ./utils/data/size.js */ "./node_modules/viem/_cjs/utils/data/size.js");
Object.defineProperty(exports, "size", ({ enumerable: true, get: function () { return size_js_1.size; } }));
var slice_js_1 = __webpack_require__(/*! ./utils/data/slice.js */ "./node_modules/viem/_cjs/utils/data/slice.js");
Object.defineProperty(exports, "slice", ({ enumerable: true, get: function () { return slice_js_1.slice; } }));
Object.defineProperty(exports, "sliceBytes", ({ enumerable: true, get: function () { return slice_js_1.sliceBytes; } }));
Object.defineProperty(exports, "sliceHex", ({ enumerable: true, get: function () { return slice_js_1.sliceHex; } }));
var trim_js_1 = __webpack_require__(/*! ./utils/data/trim.js */ "./node_modules/viem/_cjs/utils/data/trim.js");
Object.defineProperty(exports, "trim", ({ enumerable: true, get: function () { return trim_js_1.trim; } }));
var fromBytes_js_1 = __webpack_require__(/*! ./utils/encoding/fromBytes.js */ "./node_modules/viem/_cjs/utils/encoding/fromBytes.js");
Object.defineProperty(exports, "bytesToBigInt", ({ enumerable: true, get: function () { return fromBytes_js_1.bytesToBigInt; } }));
Object.defineProperty(exports, "bytesToBool", ({ enumerable: true, get: function () { return fromBytes_js_1.bytesToBool; } }));
Object.defineProperty(exports, "bytesToNumber", ({ enumerable: true, get: function () { return fromBytes_js_1.bytesToNumber; } }));
Object.defineProperty(exports, "bytesToString", ({ enumerable: true, get: function () { return fromBytes_js_1.bytesToString; } }));
Object.defineProperty(exports, "fromBytes", ({ enumerable: true, get: function () { return fromBytes_js_1.fromBytes; } }));
var fromHex_js_1 = __webpack_require__(/*! ./utils/encoding/fromHex.js */ "./node_modules/viem/_cjs/utils/encoding/fromHex.js");
Object.defineProperty(exports, "fromHex", ({ enumerable: true, get: function () { return fromHex_js_1.fromHex; } }));
Object.defineProperty(exports, "hexToBigInt", ({ enumerable: true, get: function () { return fromHex_js_1.hexToBigInt; } }));
Object.defineProperty(exports, "hexToBool", ({ enumerable: true, get: function () { return fromHex_js_1.hexToBool; } }));
Object.defineProperty(exports, "hexToNumber", ({ enumerable: true, get: function () { return fromHex_js_1.hexToNumber; } }));
Object.defineProperty(exports, "hexToString", ({ enumerable: true, get: function () { return fromHex_js_1.hexToString; } }));
var fromRlp_js_1 = __webpack_require__(/*! ./utils/encoding/fromRlp.js */ "./node_modules/viem/_cjs/utils/encoding/fromRlp.js");
Object.defineProperty(exports, "fromRlp", ({ enumerable: true, get: function () { return fromRlp_js_1.fromRlp; } }));
var toBytes_js_1 = __webpack_require__(/*! ./utils/encoding/toBytes.js */ "./node_modules/viem/_cjs/utils/encoding/toBytes.js");
Object.defineProperty(exports, "boolToBytes", ({ enumerable: true, get: function () { return toBytes_js_1.boolToBytes; } }));
Object.defineProperty(exports, "hexToBytes", ({ enumerable: true, get: function () { return toBytes_js_1.hexToBytes; } }));
Object.defineProperty(exports, "numberToBytes", ({ enumerable: true, get: function () { return toBytes_js_1.numberToBytes; } }));
Object.defineProperty(exports, "stringToBytes", ({ enumerable: true, get: function () { return toBytes_js_1.stringToBytes; } }));
Object.defineProperty(exports, "toBytes", ({ enumerable: true, get: function () { return toBytes_js_1.toBytes; } }));
var toHex_js_1 = __webpack_require__(/*! ./utils/encoding/toHex.js */ "./node_modules/viem/_cjs/utils/encoding/toHex.js");
Object.defineProperty(exports, "boolToHex", ({ enumerable: true, get: function () { return toHex_js_1.boolToHex; } }));
Object.defineProperty(exports, "bytesToHex", ({ enumerable: true, get: function () { return toHex_js_1.bytesToHex; } }));
Object.defineProperty(exports, "numberToHex", ({ enumerable: true, get: function () { return toHex_js_1.numberToHex; } }));
Object.defineProperty(exports, "stringToHex", ({ enumerable: true, get: function () { return toHex_js_1.stringToHex; } }));
Object.defineProperty(exports, "toHex", ({ enumerable: true, get: function () { return toHex_js_1.toHex; } }));
var toRlp_js_1 = __webpack_require__(/*! ./utils/encoding/toRlp.js */ "./node_modules/viem/_cjs/utils/encoding/toRlp.js");
Object.defineProperty(exports, "bytesToRlp", ({ enumerable: true, get: function () { return toRlp_js_1.bytesToRlp; } }));
Object.defineProperty(exports, "hexToRlp", ({ enumerable: true, get: function () { return toRlp_js_1.hexToRlp; } }));
Object.defineProperty(exports, "toRlp", ({ enumerable: true, get: function () { return toRlp_js_1.toRlp; } }));
var labelhash_js_1 = __webpack_require__(/*! ./utils/ens/labelhash.js */ "./node_modules/viem/_cjs/utils/ens/labelhash.js");
Object.defineProperty(exports, "labelhash", ({ enumerable: true, get: function () { return labelhash_js_1.labelhash; } }));
var namehash_js_1 = __webpack_require__(/*! ./utils/ens/namehash.js */ "./node_modules/viem/_cjs/utils/ens/namehash.js");
Object.defineProperty(exports, "namehash", ({ enumerable: true, get: function () { return namehash_js_1.namehash; } }));
var toCoinType_js_1 = __webpack_require__(/*! ./utils/ens/toCoinType.js */ "./node_modules/viem/_cjs/utils/ens/toCoinType.js");
Object.defineProperty(exports, "toCoinType", ({ enumerable: true, get: function () { return toCoinType_js_1.toCoinType; } }));
var getContractError_js_1 = __webpack_require__(/*! ./utils/errors/getContractError.js */ "./node_modules/viem/_cjs/utils/errors/getContractError.js");
Object.defineProperty(exports, "getContractError", ({ enumerable: true, get: function () { return getContractError_js_1.getContractError; } }));
var block_js_2 = __webpack_require__(/*! ./utils/formatters/block.js */ "./node_modules/viem/_cjs/utils/formatters/block.js");
Object.defineProperty(exports, "defineBlock", ({ enumerable: true, get: function () { return block_js_2.defineBlock; } }));
Object.defineProperty(exports, "formatBlock", ({ enumerable: true, get: function () { return block_js_2.formatBlock; } }));
var log_js_2 = __webpack_require__(/*! ./utils/formatters/log.js */ "./node_modules/viem/_cjs/utils/formatters/log.js");
Object.defineProperty(exports, "formatLog", ({ enumerable: true, get: function () { return log_js_2.formatLog; } }));
var transaction_js_2 = __webpack_require__(/*! ./utils/formatters/transaction.js */ "./node_modules/viem/_cjs/utils/formatters/transaction.js");
Object.defineProperty(exports, "defineTransaction", ({ enumerable: true, get: function () { return transaction_js_2.defineTransaction; } }));
Object.defineProperty(exports, "formatTransaction", ({ enumerable: true, get: function () { return transaction_js_2.formatTransaction; } }));
Object.defineProperty(exports, "transactionType", ({ enumerable: true, get: function () { return transaction_js_2.transactionType; } }));
var transactionReceipt_js_1 = __webpack_require__(/*! ./utils/formatters/transactionReceipt.js */ "./node_modules/viem/_cjs/utils/formatters/transactionReceipt.js");
Object.defineProperty(exports, "defineTransactionReceipt", ({ enumerable: true, get: function () { return transactionReceipt_js_1.defineTransactionReceipt; } }));
Object.defineProperty(exports, "formatTransactionReceipt", ({ enumerable: true, get: function () { return transactionReceipt_js_1.formatTransactionReceipt; } }));
var transactionRequest_js_1 = __webpack_require__(/*! ./utils/formatters/transactionRequest.js */ "./node_modules/viem/_cjs/utils/formatters/transactionRequest.js");
Object.defineProperty(exports, "defineTransactionRequest", ({ enumerable: true, get: function () { return transactionRequest_js_1.defineTransactionRequest; } }));
Object.defineProperty(exports, "formatTransactionRequest", ({ enumerable: true, get: function () { return transactionRequest_js_1.formatTransactionRequest; } }));
Object.defineProperty(exports, "rpcTransactionType", ({ enumerable: true, get: function () { return transactionRequest_js_1.rpcTransactionType; } }));
var isHash_js_1 = __webpack_require__(/*! ./utils/hash/isHash.js */ "./node_modules/viem/_cjs/utils/hash/isHash.js");
Object.defineProperty(exports, "isHash", ({ enumerable: true, get: function () { return isHash_js_1.isHash; } }));
var keccak256_js_1 = __webpack_require__(/*! ./utils/hash/keccak256.js */ "./node_modules/viem/_cjs/utils/hash/keccak256.js");
Object.defineProperty(exports, "keccak256", ({ enumerable: true, get: function () { return keccak256_js_1.keccak256; } }));
var ripemd160_js_1 = __webpack_require__(/*! ./utils/hash/ripemd160.js */ "./node_modules/viem/_cjs/utils/hash/ripemd160.js");
Object.defineProperty(exports, "ripemd160", ({ enumerable: true, get: function () { return ripemd160_js_1.ripemd160; } }));
var sha256_js_1 = __webpack_require__(/*! ./utils/hash/sha256.js */ "./node_modules/viem/_cjs/utils/hash/sha256.js");
Object.defineProperty(exports, "sha256", ({ enumerable: true, get: function () { return sha256_js_1.sha256; } }));
var toEventHash_js_1 = __webpack_require__(/*! ./utils/hash/toEventHash.js */ "./node_modules/viem/_cjs/utils/hash/toEventHash.js");
Object.defineProperty(exports, "toEventHash", ({ enumerable: true, get: function () { return toEventHash_js_1.toEventHash; } }));
var toEventSelector_js_1 = __webpack_require__(/*! ./utils/hash/toEventSelector.js */ "./node_modules/viem/_cjs/utils/hash/toEventSelector.js");
Object.defineProperty(exports, "toEventSelector", ({ enumerable: true, get: function () { return toEventSelector_js_1.toEventSelector; } }));
Object.defineProperty(exports, "getEventSelector", ({ enumerable: true, get: function () { return toEventSelector_js_1.toEventSelector; } }));
var toEventSignature_js_1 = __webpack_require__(/*! ./utils/hash/toEventSignature.js */ "./node_modules/viem/_cjs/utils/hash/toEventSignature.js");
Object.defineProperty(exports, "toEventSignature", ({ enumerable: true, get: function () { return toEventSignature_js_1.toEventSignature; } }));
Object.defineProperty(exports, "getEventSignature", ({ enumerable: true, get: function () { return toEventSignature_js_1.toEventSignature; } }));
var toFunctionHash_js_1 = __webpack_require__(/*! ./utils/hash/toFunctionHash.js */ "./node_modules/viem/_cjs/utils/hash/toFunctionHash.js");
Object.defineProperty(exports, "toFunctionHash", ({ enumerable: true, get: function () { return toFunctionHash_js_1.toFunctionHash; } }));
var toFunctionSelector_js_1 = __webpack_require__(/*! ./utils/hash/toFunctionSelector.js */ "./node_modules/viem/_cjs/utils/hash/toFunctionSelector.js");
Object.defineProperty(exports, "toFunctionSelector", ({ enumerable: true, get: function () { return toFunctionSelector_js_1.toFunctionSelector; } }));
Object.defineProperty(exports, "getFunctionSelector", ({ enumerable: true, get: function () { return toFunctionSelector_js_1.toFunctionSelector; } }));
var toFunctionSignature_js_1 = __webpack_require__(/*! ./utils/hash/toFunctionSignature.js */ "./node_modules/viem/_cjs/utils/hash/toFunctionSignature.js");
Object.defineProperty(exports, "toFunctionSignature", ({ enumerable: true, get: function () { return toFunctionSignature_js_1.toFunctionSignature; } }));
Object.defineProperty(exports, "getFunctionSignature", ({ enumerable: true, get: function () { return toFunctionSignature_js_1.toFunctionSignature; } }));
var defineKzg_js_1 = __webpack_require__(/*! ./utils/kzg/defineKzg.js */ "./node_modules/viem/_cjs/utils/kzg/defineKzg.js");
Object.defineProperty(exports, "defineKzg", ({ enumerable: true, get: function () { return defineKzg_js_1.defineKzg; } }));
var setupKzg_js_1 = __webpack_require__(/*! ./utils/kzg/setupKzg.js */ "./node_modules/viem/_cjs/utils/kzg/setupKzg.js");
Object.defineProperty(exports, "setupKzg", ({ enumerable: true, get: function () { return setupKzg_js_1.setupKzg; } }));
var nonceManager_js_1 = __webpack_require__(/*! ./utils/nonceManager.js */ "./node_modules/viem/_cjs/utils/nonceManager.js");
Object.defineProperty(exports, "createNonceManager", ({ enumerable: true, get: function () { return nonceManager_js_1.createNonceManager; } }));
Object.defineProperty(exports, "nonceManager", ({ enumerable: true, get: function () { return nonceManager_js_1.nonceManager; } }));
var withCache_js_1 = __webpack_require__(/*! ./utils/promise/withCache.js */ "./node_modules/viem/_cjs/utils/promise/withCache.js");
Object.defineProperty(exports, "withCache", ({ enumerable: true, get: function () { return withCache_js_1.withCache; } }));
var withRetry_js_1 = __webpack_require__(/*! ./utils/promise/withRetry.js */ "./node_modules/viem/_cjs/utils/promise/withRetry.js");
Object.defineProperty(exports, "withRetry", ({ enumerable: true, get: function () { return withRetry_js_1.withRetry; } }));
var withTimeout_js_1 = __webpack_require__(/*! ./utils/promise/withTimeout.js */ "./node_modules/viem/_cjs/utils/promise/withTimeout.js");
Object.defineProperty(exports, "withTimeout", ({ enumerable: true, get: function () { return withTimeout_js_1.withTimeout; } }));
var compactSignatureToSignature_js_1 = __webpack_require__(/*! ./utils/signature/compactSignatureToSignature.js */ "./node_modules/viem/_cjs/utils/signature/compactSignatureToSignature.js");
Object.defineProperty(exports, "compactSignatureToSignature", ({ enumerable: true, get: function () { return compactSignatureToSignature_js_1.compactSignatureToSignature; } }));
var hashMessage_js_1 = __webpack_require__(/*! ./utils/signature/hashMessage.js */ "./node_modules/viem/_cjs/utils/signature/hashMessage.js");
Object.defineProperty(exports, "hashMessage", ({ enumerable: true, get: function () { return hashMessage_js_1.hashMessage; } }));
var hashTypedData_js_1 = __webpack_require__(/*! ./utils/signature/hashTypedData.js */ "./node_modules/viem/_cjs/utils/signature/hashTypedData.js");
Object.defineProperty(exports, "hashDomain", ({ enumerable: true, get: function () { return hashTypedData_js_1.hashDomain; } }));
Object.defineProperty(exports, "hashStruct", ({ enumerable: true, get: function () { return hashTypedData_js_1.hashStruct; } }));
Object.defineProperty(exports, "hashTypedData", ({ enumerable: true, get: function () { return hashTypedData_js_1.hashTypedData; } }));
var isErc6492Signature_js_1 = __webpack_require__(/*! ./utils/signature/isErc6492Signature.js */ "./node_modules/viem/_cjs/utils/signature/isErc6492Signature.js");
Object.defineProperty(exports, "isErc6492Signature", ({ enumerable: true, get: function () { return isErc6492Signature_js_1.isErc6492Signature; } }));
var parseCompactSignature_js_1 = __webpack_require__(/*! ./utils/signature/parseCompactSignature.js */ "./node_modules/viem/_cjs/utils/signature/parseCompactSignature.js");
Object.defineProperty(exports, "hexToCompactSignature", ({ enumerable: true, get: function () { return parseCompactSignature_js_1.parseCompactSignature; } }));
Object.defineProperty(exports, "parseCompactSignature", ({ enumerable: true, get: function () { return parseCompactSignature_js_1.parseCompactSignature; } }));
var parseErc6492Signature_js_1 = __webpack_require__(/*! ./utils/signature/parseErc6492Signature.js */ "./node_modules/viem/_cjs/utils/signature/parseErc6492Signature.js");
Object.defineProperty(exports, "parseErc6492Signature", ({ enumerable: true, get: function () { return parseErc6492Signature_js_1.parseErc6492Signature; } }));
var parseSignature_js_1 = __webpack_require__(/*! ./utils/signature/parseSignature.js */ "./node_modules/viem/_cjs/utils/signature/parseSignature.js");
Object.defineProperty(exports, "hexToSignature", ({ enumerable: true, get: function () { return parseSignature_js_1.parseSignature; } }));
Object.defineProperty(exports, "parseSignature", ({ enumerable: true, get: function () { return parseSignature_js_1.parseSignature; } }));
var recoverAddress_js_1 = __webpack_require__(/*! ./utils/signature/recoverAddress.js */ "./node_modules/viem/_cjs/utils/signature/recoverAddress.js");
Object.defineProperty(exports, "recoverAddress", ({ enumerable: true, get: function () { return recoverAddress_js_1.recoverAddress; } }));
var recoverMessageAddress_js_1 = __webpack_require__(/*! ./utils/signature/recoverMessageAddress.js */ "./node_modules/viem/_cjs/utils/signature/recoverMessageAddress.js");
Object.defineProperty(exports, "recoverMessageAddress", ({ enumerable: true, get: function () { return recoverMessageAddress_js_1.recoverMessageAddress; } }));
var recoverPublicKey_js_1 = __webpack_require__(/*! ./utils/signature/recoverPublicKey.js */ "./node_modules/viem/_cjs/utils/signature/recoverPublicKey.js");
Object.defineProperty(exports, "recoverPublicKey", ({ enumerable: true, get: function () { return recoverPublicKey_js_1.recoverPublicKey; } }));
var recoverTransactionAddress_js_1 = __webpack_require__(/*! ./utils/signature/recoverTransactionAddress.js */ "./node_modules/viem/_cjs/utils/signature/recoverTransactionAddress.js");
Object.defineProperty(exports, "recoverTransactionAddress", ({ enumerable: true, get: function () { return recoverTransactionAddress_js_1.recoverTransactionAddress; } }));
var recoverTypedDataAddress_js_1 = __webpack_require__(/*! ./utils/signature/recoverTypedDataAddress.js */ "./node_modules/viem/_cjs/utils/signature/recoverTypedDataAddress.js");
Object.defineProperty(exports, "recoverTypedDataAddress", ({ enumerable: true, get: function () { return recoverTypedDataAddress_js_1.recoverTypedDataAddress; } }));
var serializeCompactSignature_js_1 = __webpack_require__(/*! ./utils/signature/serializeCompactSignature.js */ "./node_modules/viem/_cjs/utils/signature/serializeCompactSignature.js");
Object.defineProperty(exports, "compactSignatureToHex", ({ enumerable: true, get: function () { return serializeCompactSignature_js_1.serializeCompactSignature; } }));
Object.defineProperty(exports, "serializeCompactSignature", ({ enumerable: true, get: function () { return serializeCompactSignature_js_1.serializeCompactSignature; } }));
var serializeErc6492Signature_js_1 = __webpack_require__(/*! ./utils/signature/serializeErc6492Signature.js */ "./node_modules/viem/_cjs/utils/signature/serializeErc6492Signature.js");
Object.defineProperty(exports, "serializeErc6492Signature", ({ enumerable: true, get: function () { return serializeErc6492Signature_js_1.serializeErc6492Signature; } }));
var serializeSignature_js_1 = __webpack_require__(/*! ./utils/signature/serializeSignature.js */ "./node_modules/viem/_cjs/utils/signature/serializeSignature.js");
Object.defineProperty(exports, "signatureToHex", ({ enumerable: true, get: function () { return serializeSignature_js_1.serializeSignature; } }));
Object.defineProperty(exports, "serializeSignature", ({ enumerable: true, get: function () { return serializeSignature_js_1.serializeSignature; } }));
var signatureToCompactSignature_js_1 = __webpack_require__(/*! ./utils/signature/signatureToCompactSignature.js */ "./node_modules/viem/_cjs/utils/signature/signatureToCompactSignature.js");
Object.defineProperty(exports, "signatureToCompactSignature", ({ enumerable: true, get: function () { return signatureToCompactSignature_js_1.signatureToCompactSignature; } }));
var toPrefixedMessage_js_1 = __webpack_require__(/*! ./utils/signature/toPrefixedMessage.js */ "./node_modules/viem/_cjs/utils/signature/toPrefixedMessage.js");
Object.defineProperty(exports, "toPrefixedMessage", ({ enumerable: true, get: function () { return toPrefixedMessage_js_1.toPrefixedMessage; } }));
var verifyHash_js_1 = __webpack_require__(/*! ./utils/signature/verifyHash.js */ "./node_modules/viem/_cjs/utils/signature/verifyHash.js");
Object.defineProperty(exports, "verifyHash", ({ enumerable: true, get: function () { return verifyHash_js_1.verifyHash; } }));
var verifyMessage_js_1 = __webpack_require__(/*! ./utils/signature/verifyMessage.js */ "./node_modules/viem/_cjs/utils/signature/verifyMessage.js");
Object.defineProperty(exports, "verifyMessage", ({ enumerable: true, get: function () { return verifyMessage_js_1.verifyMessage; } }));
var verifyTypedData_js_1 = __webpack_require__(/*! ./utils/signature/verifyTypedData.js */ "./node_modules/viem/_cjs/utils/signature/verifyTypedData.js");
Object.defineProperty(exports, "verifyTypedData", ({ enumerable: true, get: function () { return verifyTypedData_js_1.verifyTypedData; } }));
var stringify_js_1 = __webpack_require__(/*! ./utils/stringify.js */ "./node_modules/viem/_cjs/utils/stringify.js");
Object.defineProperty(exports, "stringify", ({ enumerable: true, get: function () { return stringify_js_1.stringify; } }));
var assertRequest_js_1 = __webpack_require__(/*! ./utils/transaction/assertRequest.js */ "./node_modules/viem/_cjs/utils/transaction/assertRequest.js");
Object.defineProperty(exports, "assertRequest", ({ enumerable: true, get: function () { return assertRequest_js_1.assertRequest; } }));
var assertTransaction_js_1 = __webpack_require__(/*! ./utils/transaction/assertTransaction.js */ "./node_modules/viem/_cjs/utils/transaction/assertTransaction.js");
Object.defineProperty(exports, "assertTransactionEIP1559", ({ enumerable: true, get: function () { return assertTransaction_js_1.assertTransactionEIP1559; } }));
Object.defineProperty(exports, "assertTransactionEIP2930", ({ enumerable: true, get: function () { return assertTransaction_js_1.assertTransactionEIP2930; } }));
Object.defineProperty(exports, "assertTransactionLegacy", ({ enumerable: true, get: function () { return assertTransaction_js_1.assertTransactionLegacy; } }));
var getSerializedTransactionType_js_1 = __webpack_require__(/*! ./utils/transaction/getSerializedTransactionType.js */ "./node_modules/viem/_cjs/utils/transaction/getSerializedTransactionType.js");
Object.defineProperty(exports, "getSerializedTransactionType", ({ enumerable: true, get: function () { return getSerializedTransactionType_js_1.getSerializedTransactionType; } }));
var getTransactionType_js_1 = __webpack_require__(/*! ./utils/transaction/getTransactionType.js */ "./node_modules/viem/_cjs/utils/transaction/getTransactionType.js");
Object.defineProperty(exports, "getTransactionType", ({ enumerable: true, get: function () { return getTransactionType_js_1.getTransactionType; } }));
var parseTransaction_js_1 = __webpack_require__(/*! ./utils/transaction/parseTransaction.js */ "./node_modules/viem/_cjs/utils/transaction/parseTransaction.js");
Object.defineProperty(exports, "parseTransaction", ({ enumerable: true, get: function () { return parseTransaction_js_1.parseTransaction; } }));
var serializeAccessList_js_1 = __webpack_require__(/*! ./utils/transaction/serializeAccessList.js */ "./node_modules/viem/_cjs/utils/transaction/serializeAccessList.js");
Object.defineProperty(exports, "serializeAccessList", ({ enumerable: true, get: function () { return serializeAccessList_js_1.serializeAccessList; } }));
var serializeTransaction_js_1 = __webpack_require__(/*! ./utils/transaction/serializeTransaction.js */ "./node_modules/viem/_cjs/utils/transaction/serializeTransaction.js");
Object.defineProperty(exports, "serializeTransaction", ({ enumerable: true, get: function () { return serializeTransaction_js_1.serializeTransaction; } }));
var typedData_js_2 = __webpack_require__(/*! ./utils/typedData.js */ "./node_modules/viem/_cjs/utils/typedData.js");
Object.defineProperty(exports, "domainSeparator", ({ enumerable: true, get: function () { return typedData_js_2.domainSeparator; } }));
Object.defineProperty(exports, "getTypesForEIP712Domain", ({ enumerable: true, get: function () { return typedData_js_2.getTypesForEIP712Domain; } }));
Object.defineProperty(exports, "serializeTypedData", ({ enumerable: true, get: function () { return typedData_js_2.serializeTypedData; } }));
Object.defineProperty(exports, "validateTypedData", ({ enumerable: true, get: function () { return typedData_js_2.validateTypedData; } }));
var formatEther_js_1 = __webpack_require__(/*! ./utils/unit/formatEther.js */ "./node_modules/viem/_cjs/utils/unit/formatEther.js");
Object.defineProperty(exports, "formatEther", ({ enumerable: true, get: function () { return formatEther_js_1.formatEther; } }));
var formatGwei_js_1 = __webpack_require__(/*! ./utils/unit/formatGwei.js */ "./node_modules/viem/_cjs/utils/unit/formatGwei.js");
Object.defineProperty(exports, "formatGwei", ({ enumerable: true, get: function () { return formatGwei_js_1.formatGwei; } }));
var formatUnits_js_1 = __webpack_require__(/*! ./utils/unit/formatUnits.js */ "./node_modules/viem/_cjs/utils/unit/formatUnits.js");
Object.defineProperty(exports, "formatUnits", ({ enumerable: true, get: function () { return formatUnits_js_1.formatUnits; } }));
var parseEther_js_1 = __webpack_require__(/*! ./utils/unit/parseEther.js */ "./node_modules/viem/_cjs/utils/unit/parseEther.js");
Object.defineProperty(exports, "parseEther", ({ enumerable: true, get: function () { return parseEther_js_1.parseEther; } }));
var parseGwei_js_1 = __webpack_require__(/*! ./utils/unit/parseGwei.js */ "./node_modules/viem/_cjs/utils/unit/parseGwei.js");
Object.defineProperty(exports, "parseGwei", ({ enumerable: true, get: function () { return parseGwei_js_1.parseGwei; } }));
var parseUnits_js_1 = __webpack_require__(/*! ./utils/unit/parseUnits.js */ "./node_modules/viem/_cjs/utils/unit/parseUnits.js");
Object.defineProperty(exports, "parseUnits", ({ enumerable: true, get: function () { return parseUnits_js_1.parseUnits; } }));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/types/eip1193.js":
/*!*************************************************!*\
  !*** ./node_modules/viem/_cjs/types/eip1193.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ProviderRpcError = void 0;
class ProviderRpcError extends Error {
    constructor(code, message) {
        super(message);
        Object.defineProperty(this, "code", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "details", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.code = code;
        this.details = message;
    }
}
exports.ProviderRpcError = ProviderRpcError;
//# sourceMappingURL=eip1193.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/utils/abi/decodeAbiParameters.js":
/*!*****************************************************************!*\
  !*** ./node_modules/viem/_cjs/utils/abi/decodeAbiParameters.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.decodeAbiParameters = decodeAbiParameters;
const abi_js_1 = __webpack_require__(/*! ../../errors/abi.js */ "./node_modules/viem/_cjs/errors/abi.js");
const getAddress_js_1 = __webpack_require__(/*! ../address/getAddress.js */ "./node_modules/viem/_cjs/utils/address/getAddress.js");
const cursor_js_1 = __webpack_require__(/*! ../cursor.js */ "./node_modules/viem/_cjs/utils/cursor.js");
const size_js_1 = __webpack_require__(/*! ../data/size.js */ "./node_modules/viem/_cjs/utils/data/size.js");
const slice_js_1 = __webpack_require__(/*! ../data/slice.js */ "./node_modules/viem/_cjs/utils/data/slice.js");
const trim_js_1 = __webpack_require__(/*! ../data/trim.js */ "./node_modules/viem/_cjs/utils/data/trim.js");
const fromBytes_js_1 = __webpack_require__(/*! ../encoding/fromBytes.js */ "./node_modules/viem/_cjs/utils/encoding/fromBytes.js");
const toBytes_js_1 = __webpack_require__(/*! ../encoding/toBytes.js */ "./node_modules/viem/_cjs/utils/encoding/toBytes.js");
const toHex_js_1 = __webpack_require__(/*! ../encoding/toHex.js */ "./node_modules/viem/_cjs/utils/encoding/toHex.js");
const encodeAbiParameters_js_1 = __webpack_require__(/*! ./encodeAbiParameters.js */ "./node_modules/viem/_cjs/utils/abi/encodeAbiParameters.js");
function decodeAbiParameters(params, data) {
    const bytes = typeof data === 'string' ? (0, toBytes_js_1.hexToBytes)(data) : data;
    const cursor = (0, cursor_js_1.createCursor)(bytes);
    if ((0, size_js_1.size)(bytes) === 0 && params.length > 0)
        throw new abi_js_1.AbiDecodingZeroDataError();
    if ((0, size_js_1.size)(data) && (0, size_js_1.size)(data) < 32)
        throw new abi_js_1.AbiDecodingDataSizeTooSmallError({
            data: typeof data === 'string' ? data : (0, toHex_js_1.bytesToHex)(data),
            params: params,
            size: (0, size_js_1.size)(data),
        });
    let consumed = 0;
    const values = [];
    for (let i = 0; i < params.length; ++i) {
        const param = params[i];
        cursor.setPosition(consumed);
        const [data, consumed_] = decodeParameter(cursor, param, {
            staticPosition: 0,
        });
        consumed += consumed_;
        values.push(data);
    }
    return values;
}
function decodeParameter(cursor, param, { staticPosition }) {
    const arrayComponents = (0, encodeAbiParameters_js_1.getArrayComponents)(param.type);
    if (arrayComponents) {
        const [length, type] = arrayComponents;
        return decodeArray(cursor, { ...param, type }, { length, staticPosition });
    }
    if (param.type === 'tuple')
        return decodeTuple(cursor, param, { staticPosition });
    if (param.type === 'address')
        return decodeAddress(cursor);
    if (param.type === 'bool')
        return decodeBool(cursor);
    if (param.type.startsWith('bytes'))
        return decodeBytes(cursor, param, { staticPosition });
    if (param.type.startsWith('uint') || param.type.startsWith('int'))
        return decodeNumber(cursor, param);
    if (param.type === 'string')
        return decodeString(cursor, { staticPosition });
    throw new abi_js_1.InvalidAbiDecodingTypeError(param.type, {
        docsPath: '/docs/contract/decodeAbiParameters',
    });
}
const sizeOfLength = 32;
const sizeOfOffset = 32;
function decodeAddress(cursor) {
    const value = cursor.readBytes(32);
    return [(0, getAddress_js_1.checksumAddress)((0, toHex_js_1.bytesToHex)((0, slice_js_1.sliceBytes)(value, -20))), 32];
}
function decodeArray(cursor, param, { length, staticPosition }) {
    if (!length) {
        const offset = (0, fromBytes_js_1.bytesToNumber)(cursor.readBytes(sizeOfOffset));
        const start = staticPosition + offset;
        const startOfData = start + sizeOfLength;
        cursor.setPosition(start);
        const length = (0, fromBytes_js_1.bytesToNumber)(cursor.readBytes(sizeOfLength));
        const dynamicChild = hasDynamicChild(param);
        let consumed = 0;
        const value = [];
        for (let i = 0; i < length; ++i) {
            cursor.setPosition(startOfData + (dynamicChild ? i * 32 : consumed));
            const [data, consumed_] = decodeParameter(cursor, param, {
                staticPosition: startOfData,
            });
            consumed += consumed_;
            value.push(data);
        }
        cursor.setPosition(staticPosition + 32);
        return [value, 32];
    }
    if (hasDynamicChild(param)) {
        const offset = (0, fromBytes_js_1.bytesToNumber)(cursor.readBytes(sizeOfOffset));
        const start = staticPosition + offset;
        const value = [];
        for (let i = 0; i < length; ++i) {
            cursor.setPosition(start + i * 32);
            const [data] = decodeParameter(cursor, param, {
                staticPosition: start,
            });
            value.push(data);
        }
        cursor.setPosition(staticPosition + 32);
        return [value, 32];
    }
    let consumed = 0;
    const value = [];
    for (let i = 0; i < length; ++i) {
        const [data, consumed_] = decodeParameter(cursor, param, {
            staticPosition: staticPosition + consumed,
        });
        consumed += consumed_;
        value.push(data);
    }
    return [value, consumed];
}
function decodeBool(cursor) {
    return [(0, fromBytes_js_1.bytesToBool)(cursor.readBytes(32), { size: 32 }), 32];
}
function decodeBytes(cursor, param, { staticPosition }) {
    const [_, size] = param.type.split('bytes');
    if (!size) {
        const offset = (0, fromBytes_js_1.bytesToNumber)(cursor.readBytes(32));
        cursor.setPosition(staticPosition + offset);
        const length = (0, fromBytes_js_1.bytesToNumber)(cursor.readBytes(32));
        if (length === 0) {
            cursor.setPosition(staticPosition + 32);
            return ['0x', 32];
        }
        const data = cursor.readBytes(length);
        cursor.setPosition(staticPosition + 32);
        return [(0, toHex_js_1.bytesToHex)(data), 32];
    }
    const value = (0, toHex_js_1.bytesToHex)(cursor.readBytes(Number.parseInt(size, 10), 32));
    return [value, 32];
}
function decodeNumber(cursor, param) {
    const signed = param.type.startsWith('int');
    const size = Number.parseInt(param.type.split('int')[1] || '256', 10);
    const value = cursor.readBytes(32);
    return [
        size > 48
            ? (0, fromBytes_js_1.bytesToBigInt)(value, { signed })
            : (0, fromBytes_js_1.bytesToNumber)(value, { signed }),
        32,
    ];
}
function decodeTuple(cursor, param, { staticPosition }) {
    const hasUnnamedChild = param.components.length === 0 || param.components.some(({ name }) => !name);
    const value = hasUnnamedChild ? [] : {};
    let consumed = 0;
    if (hasDynamicChild(param)) {
        const offset = (0, fromBytes_js_1.bytesToNumber)(cursor.readBytes(sizeOfOffset));
        const start = staticPosition + offset;
        for (let i = 0; i < param.components.length; ++i) {
            const component = param.components[i];
            cursor.setPosition(start + consumed);
            const [data, consumed_] = decodeParameter(cursor, component, {
                staticPosition: start,
            });
            consumed += consumed_;
            value[hasUnnamedChild ? i : component?.name] = data;
        }
        cursor.setPosition(staticPosition + 32);
        return [value, 32];
    }
    for (let i = 0; i < param.components.length; ++i) {
        const component = param.components[i];
        const [data, consumed_] = decodeParameter(cursor, component, {
            staticPosition,
        });
        value[hasUnnamedChild ? i : component?.name] = data;
        consumed += consumed_;
    }
    return [value, consumed];
}
function decodeString(cursor, { staticPosition }) {
    const offset = (0, fromBytes_js_1.bytesToNumber)(cursor.readBytes(32));
    const start = staticPosition + offset;
    cursor.setPosition(start);
    const length = (0, fromBytes_js_1.bytesToNumber)(cursor.readBytes(32));
    if (length === 0) {
        cursor.setPosition(staticPosition + 32);
        return ['', 32];
    }
    const data = cursor.readBytes(length, 32);
    const value = (0, fromBytes_js_1.bytesToString)((0, trim_js_1.trim)(data));
    cursor.setPosition(staticPosition + 32);
    return [value, 32];
}
function hasDynamicChild(param) {
    const { type } = param;
    if (type === 'string')
        return true;
    if (type === 'bytes')
        return true;
    if (type.endsWith('[]'))
        return true;
    if (type === 'tuple')
        return param.components?.some(hasDynamicChild);
    const arrayComponents = (0, encodeAbiParameters_js_1.getArrayComponents)(param.type);
    if (arrayComponents &&
        hasDynamicChild({ ...param, type: arrayComponents[1] }))
        return true;
    return false;
}
//# sourceMappingURL=decodeAbiParameters.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/utils/abi/decodeDeployData.js":
/*!**************************************************************!*\
  !*** ./node_modules/viem/_cjs/utils/abi/decodeDeployData.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.decodeDeployData = decodeDeployData;
const abi_js_1 = __webpack_require__(/*! ../../errors/abi.js */ "./node_modules/viem/_cjs/errors/abi.js");
const decodeAbiParameters_js_1 = __webpack_require__(/*! ./decodeAbiParameters.js */ "./node_modules/viem/_cjs/utils/abi/decodeAbiParameters.js");
const docsPath = '/docs/contract/decodeDeployData';
function decodeDeployData(parameters) {
    const { abi, bytecode, data } = parameters;
    if (data === bytecode)
        return { bytecode };
    const description = abi.find((x) => 'type' in x && x.type === 'constructor');
    if (!description)
        throw new abi_js_1.AbiConstructorNotFoundError({ docsPath });
    if (!('inputs' in description))
        throw new abi_js_1.AbiConstructorParamsNotFoundError({ docsPath });
    if (!description.inputs || description.inputs.length === 0)
        throw new abi_js_1.AbiConstructorParamsNotFoundError({ docsPath });
    const args = (0, decodeAbiParameters_js_1.decodeAbiParameters)(description.inputs, `0x${data.replace(bytecode, '')}`);
    return { args, bytecode };
}
//# sourceMappingURL=decodeDeployData.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/utils/abi/decodeErrorResult.js":
/*!***************************************************************!*\
  !*** ./node_modules/viem/_cjs/utils/abi/decodeErrorResult.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.decodeErrorResult = decodeErrorResult;
const solidity_js_1 = __webpack_require__(/*! ../../constants/solidity.js */ "./node_modules/viem/_cjs/constants/solidity.js");
const abi_js_1 = __webpack_require__(/*! ../../errors/abi.js */ "./node_modules/viem/_cjs/errors/abi.js");
const slice_js_1 = __webpack_require__(/*! ../data/slice.js */ "./node_modules/viem/_cjs/utils/data/slice.js");
const toFunctionSelector_js_1 = __webpack_require__(/*! ../hash/toFunctionSelector.js */ "./node_modules/viem/_cjs/utils/hash/toFunctionSelector.js");
const decodeAbiParameters_js_1 = __webpack_require__(/*! ./decodeAbiParameters.js */ "./node_modules/viem/_cjs/utils/abi/decodeAbiParameters.js");
const formatAbiItem_js_1 = __webpack_require__(/*! ./formatAbiItem.js */ "./node_modules/viem/_cjs/utils/abi/formatAbiItem.js");
function decodeErrorResult(parameters) {
    const { abi, data } = parameters;
    const signature = (0, slice_js_1.slice)(data, 0, 4);
    if (signature === '0x')
        throw new abi_js_1.AbiDecodingZeroDataError();
    const abi_ = [...(abi || []), solidity_js_1.solidityError, solidity_js_1.solidityPanic];
    const abiItem = abi_.find((x) => x.type === 'error' && signature === (0, toFunctionSelector_js_1.toFunctionSelector)((0, formatAbiItem_js_1.formatAbiItem)(x)));
    if (!abiItem)
        throw new abi_js_1.AbiErrorSignatureNotFoundError(signature, {
            docsPath: '/docs/contract/decodeErrorResult',
        });
    return {
        abiItem,
        args: 'inputs' in abiItem && abiItem.inputs && abiItem.inputs.length > 0
            ? (0, decodeAbiParameters_js_1.decodeAbiParameters)(abiItem.inputs, (0, slice_js_1.slice)(data, 4))
            : undefined,
        errorName: abiItem.name,
    };
}
//# sourceMappingURL=decodeErrorResult.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/utils/abi/decodeEventLog.js":
/*!************************************************************!*\
  !*** ./node_modules/viem/_cjs/utils/abi/decodeEventLog.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.decodeEventLog = decodeEventLog;
const abi_js_1 = __webpack_require__(/*! ../../errors/abi.js */ "./node_modules/viem/_cjs/errors/abi.js");
const cursor_js_1 = __webpack_require__(/*! ../../errors/cursor.js */ "./node_modules/viem/_cjs/errors/cursor.js");
const size_js_1 = __webpack_require__(/*! ../data/size.js */ "./node_modules/viem/_cjs/utils/data/size.js");
const toEventSelector_js_1 = __webpack_require__(/*! ../hash/toEventSelector.js */ "./node_modules/viem/_cjs/utils/hash/toEventSelector.js");
const decodeAbiParameters_js_1 = __webpack_require__(/*! ./decodeAbiParameters.js */ "./node_modules/viem/_cjs/utils/abi/decodeAbiParameters.js");
const formatAbiItem_js_1 = __webpack_require__(/*! ./formatAbiItem.js */ "./node_modules/viem/_cjs/utils/abi/formatAbiItem.js");
const docsPath = '/docs/contract/decodeEventLog';
function decodeEventLog(parameters) {
    const { abi, data, strict: strict_, topics, } = parameters;
    const strict = strict_ ?? true;
    const [signature, ...argTopics] = topics;
    if (!signature)
        throw new abi_js_1.AbiEventSignatureEmptyTopicsError({ docsPath });
    const abiItem = abi.find((x) => x.type === 'event' &&
        signature === (0, toEventSelector_js_1.toEventSelector)((0, formatAbiItem_js_1.formatAbiItem)(x)));
    if (!(abiItem && 'name' in abiItem) || abiItem.type !== 'event')
        throw new abi_js_1.AbiEventSignatureNotFoundError(signature, { docsPath });
    const { name, inputs } = abiItem;
    const isUnnamed = inputs?.some((x) => !('name' in x && x.name));
    const args = isUnnamed ? [] : {};
    const indexedInputs = inputs
        .map((x, i) => [x, i])
        .filter(([x]) => 'indexed' in x && x.indexed);
    for (let i = 0; i < indexedInputs.length; i++) {
        const [param, argIndex] = indexedInputs[i];
        const topic = argTopics[i];
        if (!topic)
            throw new abi_js_1.DecodeLogTopicsMismatch({
                abiItem,
                param: param,
            });
        args[isUnnamed ? argIndex : param.name || argIndex] = decodeTopic({
            param,
            value: topic,
        });
    }
    const nonIndexedInputs = inputs.filter((x) => !('indexed' in x && x.indexed));
    if (nonIndexedInputs.length > 0) {
        if (data && data !== '0x') {
            try {
                const decodedData = (0, decodeAbiParameters_js_1.decodeAbiParameters)(nonIndexedInputs, data);
                if (decodedData) {
                    if (isUnnamed)
                        for (let i = 0; i < inputs.length; i++)
                            args[i] = args[i] ?? decodedData.shift();
                    else
                        for (let i = 0; i < nonIndexedInputs.length; i++)
                            args[nonIndexedInputs[i].name] = decodedData[i];
                }
            }
            catch (err) {
                if (strict) {
                    if (err instanceof abi_js_1.AbiDecodingDataSizeTooSmallError ||
                        err instanceof cursor_js_1.PositionOutOfBoundsError)
                        throw new abi_js_1.DecodeLogDataMismatch({
                            abiItem,
                            data: data,
                            params: nonIndexedInputs,
                            size: (0, size_js_1.size)(data),
                        });
                    throw err;
                }
            }
        }
        else if (strict) {
            throw new abi_js_1.DecodeLogDataMismatch({
                abiItem,
                data: '0x',
                params: nonIndexedInputs,
                size: 0,
            });
        }
    }
    return {
        eventName: name,
        args: Object.values(args).length > 0 ? args : undefined,
    };
}
function decodeTopic({ param, value }) {
    if (param.type === 'string' ||
        param.type === 'bytes' ||
        param.type === 'tuple' ||
        param.type.match(/^(.*)\[(\d+)?\]$/))
        return value;
    const decodedArg = (0, decodeAbiParameters_js_1.decodeAbiParameters)([param], value) || [];
    return decodedArg[0];
}
//# sourceMappingURL=decodeEventLog.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/utils/abi/decodeFunctionData.js":
/*!****************************************************************!*\
  !*** ./node_modules/viem/_cjs/utils/abi/decodeFunctionData.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.decodeFunctionData = decodeFunctionData;
const abi_js_1 = __webpack_require__(/*! ../../errors/abi.js */ "./node_modules/viem/_cjs/errors/abi.js");
const slice_js_1 = __webpack_require__(/*! ../data/slice.js */ "./node_modules/viem/_cjs/utils/data/slice.js");
const toFunctionSelector_js_1 = __webpack_require__(/*! ../hash/toFunctionSelector.js */ "./node_modules/viem/_cjs/utils/hash/toFunctionSelector.js");
const decodeAbiParameters_js_1 = __webpack_require__(/*! ./decodeAbiParameters.js */ "./node_modules/viem/_cjs/utils/abi/decodeAbiParameters.js");
const formatAbiItem_js_1 = __webpack_require__(/*! ./formatAbiItem.js */ "./node_modules/viem/_cjs/utils/abi/formatAbiItem.js");
function decodeFunctionData(parameters) {
    const { abi, data } = parameters;
    const signature = (0, slice_js_1.slice)(data, 0, 4);
    const description = abi.find((x) => x.type === 'function' &&
        signature === (0, toFunctionSelector_js_1.toFunctionSelector)((0, formatAbiItem_js_1.formatAbiItem)(x)));
    if (!description)
        throw new abi_js_1.AbiFunctionSignatureNotFoundError(signature, {
            docsPath: '/docs/contract/decodeFunctionData',
        });
    return {
        functionName: description.name,
        args: ('inputs' in description &&
            description.inputs &&
            description.inputs.length > 0
            ? (0, decodeAbiParameters_js_1.decodeAbiParameters)(description.inputs, (0, slice_js_1.slice)(data, 4))
            : undefined),
    };
}
//# sourceMappingURL=decodeFunctionData.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/utils/abi/decodeFunctionResult.js":
/*!******************************************************************!*\
  !*** ./node_modules/viem/_cjs/utils/abi/decodeFunctionResult.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.decodeFunctionResult = decodeFunctionResult;
const abi_js_1 = __webpack_require__(/*! ../../errors/abi.js */ "./node_modules/viem/_cjs/errors/abi.js");
const decodeAbiParameters_js_1 = __webpack_require__(/*! ./decodeAbiParameters.js */ "./node_modules/viem/_cjs/utils/abi/decodeAbiParameters.js");
const getAbiItem_js_1 = __webpack_require__(/*! ./getAbiItem.js */ "./node_modules/viem/_cjs/utils/abi/getAbiItem.js");
const docsPath = '/docs/contract/decodeFunctionResult';
function decodeFunctionResult(parameters) {
    const { abi, args, functionName, data } = parameters;
    let abiItem = abi[0];
    if (functionName) {
        const item = (0, getAbiItem_js_1.getAbiItem)({ abi, args, name: functionName });
        if (!item)
            throw new abi_js_1.AbiFunctionNotFoundError(functionName, { docsPath });
        abiItem = item;
    }
    if (abiItem.type !== 'function')
        throw new abi_js_1.AbiFunctionNotFoundError(undefined, { docsPath });
    if (!abiItem.outputs)
        throw new abi_js_1.AbiFunctionOutputsNotFoundError(abiItem.name, { docsPath });
    const values = (0, decodeAbiParameters_js_1.decodeAbiParameters)(abiItem.outputs, data);
    if (values && values.length > 1)
        return values;
    if (values && values.length === 1)
        return values[0];
    return undefined;
}
//# sourceMappingURL=decodeFunctionResult.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/utils/abi/encodeAbiParameters.js":
/*!*****************************************************************!*\
  !*** ./node_modules/viem/_cjs/utils/abi/encodeAbiParameters.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.encodeAbiParameters = encodeAbiParameters;
exports.getArrayComponents = getArrayComponents;
const abi_js_1 = __webpack_require__(/*! ../../errors/abi.js */ "./node_modules/viem/_cjs/errors/abi.js");
const address_js_1 = __webpack_require__(/*! ../../errors/address.js */ "./node_modules/viem/_cjs/errors/address.js");
const base_js_1 = __webpack_require__(/*! ../../errors/base.js */ "./node_modules/viem/_cjs/errors/base.js");
const encoding_js_1 = __webpack_require__(/*! ../../errors/encoding.js */ "./node_modules/viem/_cjs/errors/encoding.js");
const isAddress_js_1 = __webpack_require__(/*! ../address/isAddress.js */ "./node_modules/viem/_cjs/utils/address/isAddress.js");
const concat_js_1 = __webpack_require__(/*! ../data/concat.js */ "./node_modules/viem/_cjs/utils/data/concat.js");
const pad_js_1 = __webpack_require__(/*! ../data/pad.js */ "./node_modules/viem/_cjs/utils/data/pad.js");
const size_js_1 = __webpack_require__(/*! ../data/size.js */ "./node_modules/viem/_cjs/utils/data/size.js");
const slice_js_1 = __webpack_require__(/*! ../data/slice.js */ "./node_modules/viem/_cjs/utils/data/slice.js");
const toHex_js_1 = __webpack_require__(/*! ../encoding/toHex.js */ "./node_modules/viem/_cjs/utils/encoding/toHex.js");
const regex_js_1 = __webpack_require__(/*! ../regex.js */ "./node_modules/viem/_cjs/utils/regex.js");
function encodeAbiParameters(params, values) {
    if (params.length !== values.length)
        throw new abi_js_1.AbiEncodingLengthMismatchError({
            expectedLength: params.length,
            givenLength: values.length,
        });
    const preparedParams = prepareParams({
        params: params,
        values: values,
    });
    const data = encodeParams(preparedParams);
    if (data.length === 0)
        return '0x';
    return data;
}
function prepareParams({ params, values, }) {
    const preparedParams = [];
    for (let i = 0; i < params.length; i++) {
        preparedParams.push(prepareParam({ param: params[i], value: values[i] }));
    }
    return preparedParams;
}
function prepareParam({ param, value, }) {
    const arrayComponents = getArrayComponents(param.type);
    if (arrayComponents) {
        const [length, type] = arrayComponents;
        return encodeArray(value, { length, param: { ...param, type } });
    }
    if (param.type === 'tuple') {
        return encodeTuple(value, {
            param: param,
        });
    }
    if (param.type === 'address') {
        return encodeAddress(value);
    }
    if (param.type === 'bool') {
        return encodeBool(value);
    }
    if (param.type.startsWith('uint') || param.type.startsWith('int')) {
        const signed = param.type.startsWith('int');
        const [, , size = '256'] = regex_js_1.integerRegex.exec(param.type) ?? [];
        return encodeNumber(value, {
            signed,
            size: Number(size),
        });
    }
    if (param.type.startsWith('bytes')) {
        return encodeBytes(value, { param });
    }
    if (param.type === 'string') {
        return encodeString(value);
    }
    throw new abi_js_1.InvalidAbiEncodingTypeError(param.type, {
        docsPath: '/docs/contract/encodeAbiParameters',
    });
}
function encodeParams(preparedParams) {
    let staticSize = 0;
    for (let i = 0; i < preparedParams.length; i++) {
        const { dynamic, encoded } = preparedParams[i];
        if (dynamic)
            staticSize += 32;
        else
            staticSize += (0, size_js_1.size)(encoded);
    }
    const staticParams = [];
    const dynamicParams = [];
    let dynamicSize = 0;
    for (let i = 0; i < preparedParams.length; i++) {
        const { dynamic, encoded } = preparedParams[i];
        if (dynamic) {
            staticParams.push((0, toHex_js_1.numberToHex)(staticSize + dynamicSize, { size: 32 }));
            dynamicParams.push(encoded);
            dynamicSize += (0, size_js_1.size)(encoded);
        }
        else {
            staticParams.push(encoded);
        }
    }
    return (0, concat_js_1.concat)([...staticParams, ...dynamicParams]);
}
function encodeAddress(value) {
    if (!(0, isAddress_js_1.isAddress)(value))
        throw new address_js_1.InvalidAddressError({ address: value });
    return { dynamic: false, encoded: (0, pad_js_1.padHex)(value.toLowerCase()) };
}
function encodeArray(value, { length, param, }) {
    const dynamic = length === null;
    if (!Array.isArray(value))
        throw new abi_js_1.InvalidArrayError(value);
    if (!dynamic && value.length !== length)
        throw new abi_js_1.AbiEncodingArrayLengthMismatchError({
            expectedLength: length,
            givenLength: value.length,
            type: `${param.type}[${length}]`,
        });
    let dynamicChild = false;
    const preparedParams = [];
    for (let i = 0; i < value.length; i++) {
        const preparedParam = prepareParam({ param, value: value[i] });
        if (preparedParam.dynamic)
            dynamicChild = true;
        preparedParams.push(preparedParam);
    }
    if (dynamic || dynamicChild) {
        const data = encodeParams(preparedParams);
        if (dynamic) {
            const length = (0, toHex_js_1.numberToHex)(preparedParams.length, { size: 32 });
            return {
                dynamic: true,
                encoded: preparedParams.length > 0 ? (0, concat_js_1.concat)([length, data]) : length,
            };
        }
        if (dynamicChild)
            return { dynamic: true, encoded: data };
    }
    return {
        dynamic: false,
        encoded: (0, concat_js_1.concat)(preparedParams.map(({ encoded }) => encoded)),
    };
}
function encodeBytes(value, { param }) {
    const [, paramSize] = param.type.split('bytes');
    const bytesSize = (0, size_js_1.size)(value);
    if (!paramSize) {
        let value_ = value;
        if (bytesSize % 32 !== 0)
            value_ = (0, pad_js_1.padHex)(value_, {
                dir: 'right',
                size: Math.ceil((value.length - 2) / 2 / 32) * 32,
            });
        return {
            dynamic: true,
            encoded: (0, concat_js_1.concat)([(0, pad_js_1.padHex)((0, toHex_js_1.numberToHex)(bytesSize, { size: 32 })), value_]),
        };
    }
    if (bytesSize !== Number.parseInt(paramSize, 10))
        throw new abi_js_1.AbiEncodingBytesSizeMismatchError({
            expectedSize: Number.parseInt(paramSize, 10),
            value,
        });
    return { dynamic: false, encoded: (0, pad_js_1.padHex)(value, { dir: 'right' }) };
}
function encodeBool(value) {
    if (typeof value !== 'boolean')
        throw new base_js_1.BaseError(`Invalid boolean value: "${value}" (type: ${typeof value}). Expected: \`true\` or \`false\`.`);
    return { dynamic: false, encoded: (0, pad_js_1.padHex)((0, toHex_js_1.boolToHex)(value)) };
}
function encodeNumber(value, { signed, size = 256 }) {
    if (typeof size === 'number') {
        const max = 2n ** (BigInt(size) - (signed ? 1n : 0n)) - 1n;
        const min = signed ? -max - 1n : 0n;
        if (value > max || value < min)
            throw new encoding_js_1.IntegerOutOfRangeError({
                max: max.toString(),
                min: min.toString(),
                signed,
                size: size / 8,
                value: value.toString(),
            });
    }
    return {
        dynamic: false,
        encoded: (0, toHex_js_1.numberToHex)(value, {
            size: 32,
            signed,
        }),
    };
}
function encodeString(value) {
    const hexValue = (0, toHex_js_1.stringToHex)(value);
    const partsLength = Math.ceil((0, size_js_1.size)(hexValue) / 32);
    const parts = [];
    for (let i = 0; i < partsLength; i++) {
        parts.push((0, pad_js_1.padHex)((0, slice_js_1.slice)(hexValue, i * 32, (i + 1) * 32), {
            dir: 'right',
        }));
    }
    return {
        dynamic: true,
        encoded: (0, concat_js_1.concat)([
            (0, pad_js_1.padHex)((0, toHex_js_1.numberToHex)((0, size_js_1.size)(hexValue), { size: 32 })),
            ...parts,
        ]),
    };
}
function encodeTuple(value, { param }) {
    let dynamic = false;
    const preparedParams = [];
    for (let i = 0; i < param.components.length; i++) {
        const param_ = param.components[i];
        const index = Array.isArray(value) ? i : param_.name;
        const preparedParam = prepareParam({
            param: param_,
            value: value[index],
        });
        preparedParams.push(preparedParam);
        if (preparedParam.dynamic)
            dynamic = true;
    }
    return {
        dynamic,
        encoded: dynamic
            ? encodeParams(preparedParams)
            : (0, concat_js_1.concat)(preparedParams.map(({ encoded }) => encoded)),
    };
}
function getArrayComponents(type) {
    const matches = type.match(/^(.*)\[(\d+)?\]$/);
    return matches
        ?
            [matches[2] ? Number(matches[2]) : null, matches[1]]
        : undefined;
}
//# sourceMappingURL=encodeAbiParameters.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/utils/abi/encodeDeployData.js":
/*!**************************************************************!*\
  !*** ./node_modules/viem/_cjs/utils/abi/encodeDeployData.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.encodeDeployData = encodeDeployData;
const abi_js_1 = __webpack_require__(/*! ../../errors/abi.js */ "./node_modules/viem/_cjs/errors/abi.js");
const concat_js_1 = __webpack_require__(/*! ../data/concat.js */ "./node_modules/viem/_cjs/utils/data/concat.js");
const encodeAbiParameters_js_1 = __webpack_require__(/*! ./encodeAbiParameters.js */ "./node_modules/viem/_cjs/utils/abi/encodeAbiParameters.js");
const docsPath = '/docs/contract/encodeDeployData';
function encodeDeployData(parameters) {
    const { abi, args, bytecode } = parameters;
    if (!args || args.length === 0)
        return bytecode;
    const description = abi.find((x) => 'type' in x && x.type === 'constructor');
    if (!description)
        throw new abi_js_1.AbiConstructorNotFoundError({ docsPath });
    if (!('inputs' in description))
        throw new abi_js_1.AbiConstructorParamsNotFoundError({ docsPath });
    if (!description.inputs || description.inputs.length === 0)
        throw new abi_js_1.AbiConstructorParamsNotFoundError({ docsPath });
    const data = (0, encodeAbiParameters_js_1.encodeAbiParameters)(description.inputs, args);
    return (0, concat_js_1.concatHex)([bytecode, data]);
}
//# sourceMappingURL=encodeDeployData.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/utils/abi/encodeErrorResult.js":
/*!***************************************************************!*\
  !*** ./node_modules/viem/_cjs/utils/abi/encodeErrorResult.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.encodeErrorResult = encodeErrorResult;
const abi_js_1 = __webpack_require__(/*! ../../errors/abi.js */ "./node_modules/viem/_cjs/errors/abi.js");
const concat_js_1 = __webpack_require__(/*! ../data/concat.js */ "./node_modules/viem/_cjs/utils/data/concat.js");
const toFunctionSelector_js_1 = __webpack_require__(/*! ../hash/toFunctionSelector.js */ "./node_modules/viem/_cjs/utils/hash/toFunctionSelector.js");
const encodeAbiParameters_js_1 = __webpack_require__(/*! ./encodeAbiParameters.js */ "./node_modules/viem/_cjs/utils/abi/encodeAbiParameters.js");
const formatAbiItem_js_1 = __webpack_require__(/*! ./formatAbiItem.js */ "./node_modules/viem/_cjs/utils/abi/formatAbiItem.js");
const getAbiItem_js_1 = __webpack_require__(/*! ./getAbiItem.js */ "./node_modules/viem/_cjs/utils/abi/getAbiItem.js");
const docsPath = '/docs/contract/encodeErrorResult';
function encodeErrorResult(parameters) {
    const { abi, errorName, args } = parameters;
    let abiItem = abi[0];
    if (errorName) {
        const item = (0, getAbiItem_js_1.getAbiItem)({ abi, args, name: errorName });
        if (!item)
            throw new abi_js_1.AbiErrorNotFoundError(errorName, { docsPath });
        abiItem = item;
    }
    if (abiItem.type !== 'error')
        throw new abi_js_1.AbiErrorNotFoundError(undefined, { docsPath });
    const definition = (0, formatAbiItem_js_1.formatAbiItem)(abiItem);
    const signature = (0, toFunctionSelector_js_1.toFunctionSelector)(definition);
    let data = '0x';
    if (args && args.length > 0) {
        if (!abiItem.inputs)
            throw new abi_js_1.AbiErrorInputsNotFoundError(abiItem.name, { docsPath });
        data = (0, encodeAbiParameters_js_1.encodeAbiParameters)(abiItem.inputs, args);
    }
    return (0, concat_js_1.concatHex)([signature, data]);
}
//# sourceMappingURL=encodeErrorResult.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/utils/abi/encodeEventTopics.js":
/*!***************************************************************!*\
  !*** ./node_modules/viem/_cjs/utils/abi/encodeEventTopics.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.encodeEventTopics = encodeEventTopics;
const abi_js_1 = __webpack_require__(/*! ../../errors/abi.js */ "./node_modules/viem/_cjs/errors/abi.js");
const log_js_1 = __webpack_require__(/*! ../../errors/log.js */ "./node_modules/viem/_cjs/errors/log.js");
const toBytes_js_1 = __webpack_require__(/*! ../encoding/toBytes.js */ "./node_modules/viem/_cjs/utils/encoding/toBytes.js");
const keccak256_js_1 = __webpack_require__(/*! ../hash/keccak256.js */ "./node_modules/viem/_cjs/utils/hash/keccak256.js");
const toEventSelector_js_1 = __webpack_require__(/*! ../hash/toEventSelector.js */ "./node_modules/viem/_cjs/utils/hash/toEventSelector.js");
const encodeAbiParameters_js_1 = __webpack_require__(/*! ./encodeAbiParameters.js */ "./node_modules/viem/_cjs/utils/abi/encodeAbiParameters.js");
const formatAbiItem_js_1 = __webpack_require__(/*! ./formatAbiItem.js */ "./node_modules/viem/_cjs/utils/abi/formatAbiItem.js");
const getAbiItem_js_1 = __webpack_require__(/*! ./getAbiItem.js */ "./node_modules/viem/_cjs/utils/abi/getAbiItem.js");
const docsPath = '/docs/contract/encodeEventTopics';
function encodeEventTopics(parameters) {
    const { abi, eventName, args } = parameters;
    let abiItem = abi[0];
    if (eventName) {
        const item = (0, getAbiItem_js_1.getAbiItem)({ abi, name: eventName });
        if (!item)
            throw new abi_js_1.AbiEventNotFoundError(eventName, { docsPath });
        abiItem = item;
    }
    if (abiItem.type !== 'event')
        throw new abi_js_1.AbiEventNotFoundError(undefined, { docsPath });
    const definition = (0, formatAbiItem_js_1.formatAbiItem)(abiItem);
    const signature = (0, toEventSelector_js_1.toEventSelector)(definition);
    let topics = [];
    if (args && 'inputs' in abiItem) {
        const indexedInputs = abiItem.inputs?.filter((param) => 'indexed' in param && param.indexed);
        const args_ = Array.isArray(args)
            ? args
            : Object.values(args).length > 0
                ? (indexedInputs?.map((x) => args[x.name]) ?? [])
                : [];
        if (args_.length > 0) {
            topics =
                indexedInputs?.map((param, i) => {
                    if (Array.isArray(args_[i]))
                        return args_[i].map((_, j) => encodeArg({ param, value: args_[i][j] }));
                    return typeof args_[i] !== 'undefined' && args_[i] !== null
                        ? encodeArg({ param, value: args_[i] })
                        : null;
                }) ?? [];
        }
    }
    return [signature, ...topics];
}
function encodeArg({ param, value, }) {
    if (param.type === 'string' || param.type === 'bytes')
        return (0, keccak256_js_1.keccak256)((0, toBytes_js_1.toBytes)(value));
    if (param.type === 'tuple' || param.type.match(/^(.*)\[(\d+)?\]$/))
        throw new log_js_1.FilterTypeNotSupportedError(param.type);
    return (0, encodeAbiParameters_js_1.encodeAbiParameters)([param], [value]);
}
//# sourceMappingURL=encodeEventTopics.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/utils/abi/encodeFunctionData.js":
/*!****************************************************************!*\
  !*** ./node_modules/viem/_cjs/utils/abi/encodeFunctionData.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.encodeFunctionData = encodeFunctionData;
const concat_js_1 = __webpack_require__(/*! ../data/concat.js */ "./node_modules/viem/_cjs/utils/data/concat.js");
const encodeAbiParameters_js_1 = __webpack_require__(/*! ./encodeAbiParameters.js */ "./node_modules/viem/_cjs/utils/abi/encodeAbiParameters.js");
const prepareEncodeFunctionData_js_1 = __webpack_require__(/*! ./prepareEncodeFunctionData.js */ "./node_modules/viem/_cjs/utils/abi/prepareEncodeFunctionData.js");
function encodeFunctionData(parameters) {
    const { args } = parameters;
    const { abi, functionName } = (() => {
        if (parameters.abi.length === 1 &&
            parameters.functionName?.startsWith('0x'))
            return parameters;
        return (0, prepareEncodeFunctionData_js_1.prepareEncodeFunctionData)(parameters);
    })();
    const abiItem = abi[0];
    const signature = functionName;
    const data = 'inputs' in abiItem && abiItem.inputs
        ? (0, encodeAbiParameters_js_1.encodeAbiParameters)(abiItem.inputs, args ?? [])
        : undefined;
    return (0, concat_js_1.concatHex)([signature, data ?? '0x']);
}
//# sourceMappingURL=encodeFunctionData.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/utils/abi/encodeFunctionResult.js":
/*!******************************************************************!*\
  !*** ./node_modules/viem/_cjs/utils/abi/encodeFunctionResult.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.encodeFunctionResult = encodeFunctionResult;
const abi_js_1 = __webpack_require__(/*! ../../errors/abi.js */ "./node_modules/viem/_cjs/errors/abi.js");
const encodeAbiParameters_js_1 = __webpack_require__(/*! ./encodeAbiParameters.js */ "./node_modules/viem/_cjs/utils/abi/encodeAbiParameters.js");
const getAbiItem_js_1 = __webpack_require__(/*! ./getAbiItem.js */ "./node_modules/viem/_cjs/utils/abi/getAbiItem.js");
const docsPath = '/docs/contract/encodeFunctionResult';
function encodeFunctionResult(parameters) {
    const { abi, functionName, result } = parameters;
    let abiItem = abi[0];
    if (functionName) {
        const item = (0, getAbiItem_js_1.getAbiItem)({ abi, name: functionName });
        if (!item)
            throw new abi_js_1.AbiFunctionNotFoundError(functionName, { docsPath });
        abiItem = item;
    }
    if (abiItem.type !== 'function')
        throw new abi_js_1.AbiFunctionNotFoundError(undefined, { docsPath });
    if (!abiItem.outputs)
        throw new abi_js_1.AbiFunctionOutputsNotFoundError(abiItem.name, { docsPath });
    const values = (() => {
        if (abiItem.outputs.length === 0)
            return [];
        if (abiItem.outputs.length === 1)
            return [result];
        if (Array.isArray(result))
            return result;
        throw new abi_js_1.InvalidArrayError(result);
    })();
    return (0, encodeAbiParameters_js_1.encodeAbiParameters)(abiItem.outputs, values);
}
//# sourceMappingURL=encodeFunctionResult.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/utils/abi/encodePacked.js":
/*!**********************************************************!*\
  !*** ./node_modules/viem/_cjs/utils/abi/encodePacked.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.encodePacked = encodePacked;
const abi_js_1 = __webpack_require__(/*! ../../errors/abi.js */ "./node_modules/viem/_cjs/errors/abi.js");
const address_js_1 = __webpack_require__(/*! ../../errors/address.js */ "./node_modules/viem/_cjs/errors/address.js");
const isAddress_js_1 = __webpack_require__(/*! ../address/isAddress.js */ "./node_modules/viem/_cjs/utils/address/isAddress.js");
const concat_js_1 = __webpack_require__(/*! ../data/concat.js */ "./node_modules/viem/_cjs/utils/data/concat.js");
const pad_js_1 = __webpack_require__(/*! ../data/pad.js */ "./node_modules/viem/_cjs/utils/data/pad.js");
const toHex_js_1 = __webpack_require__(/*! ../encoding/toHex.js */ "./node_modules/viem/_cjs/utils/encoding/toHex.js");
const regex_js_1 = __webpack_require__(/*! ../regex.js */ "./node_modules/viem/_cjs/utils/regex.js");
function encodePacked(types, values) {
    if (types.length !== values.length)
        throw new abi_js_1.AbiEncodingLengthMismatchError({
            expectedLength: types.length,
            givenLength: values.length,
        });
    const data = [];
    for (let i = 0; i < types.length; i++) {
        const type = types[i];
        const value = values[i];
        data.push(encode(type, value));
    }
    return (0, concat_js_1.concatHex)(data);
}
function encode(type, value, isArray = false) {
    if (type === 'address') {
        const address = value;
        if (!(0, isAddress_js_1.isAddress)(address))
            throw new address_js_1.InvalidAddressError({ address });
        return (0, pad_js_1.pad)(address.toLowerCase(), {
            size: isArray ? 32 : null,
        });
    }
    if (type === 'string')
        return (0, toHex_js_1.stringToHex)(value);
    if (type === 'bytes')
        return value;
    if (type === 'bool')
        return (0, pad_js_1.pad)((0, toHex_js_1.boolToHex)(value), { size: isArray ? 32 : 1 });
    const intMatch = type.match(regex_js_1.integerRegex);
    if (intMatch) {
        const [_type, baseType, bits = '256'] = intMatch;
        const size = Number.parseInt(bits, 10) / 8;
        return (0, toHex_js_1.numberToHex)(value, {
            size: isArray ? 32 : size,
            signed: baseType === 'int',
        });
    }
    const bytesMatch = type.match(regex_js_1.bytesRegex);
    if (bytesMatch) {
        const [_type, size] = bytesMatch;
        if (Number.parseInt(size, 10) !== (value.length - 2) / 2)
            throw new abi_js_1.BytesSizeMismatchError({
                expectedSize: Number.parseInt(size, 10),
                givenSize: (value.length - 2) / 2,
            });
        return (0, pad_js_1.pad)(value, { dir: 'right', size: isArray ? 32 : null });
    }
    const arrayMatch = type.match(regex_js_1.arrayRegex);
    if (arrayMatch && Array.isArray(value)) {
        const [_type, childType] = arrayMatch;
        const data = [];
        for (let i = 0; i < value.length; i++) {
            data.push(encode(childType, value[i], true));
        }
        if (data.length === 0)
            return '0x';
        return (0, concat_js_1.concatHex)(data);
    }
    throw new abi_js_1.UnsupportedPackedAbiType(type);
}
//# sourceMappingURL=encodePacked.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/utils/abi/formatAbiItem.js":
/*!***********************************************************!*\
  !*** ./node_modules/viem/_cjs/utils/abi/formatAbiItem.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.formatAbiItem = formatAbiItem;
exports.formatAbiParams = formatAbiParams;
const abi_js_1 = __webpack_require__(/*! ../../errors/abi.js */ "./node_modules/viem/_cjs/errors/abi.js");
function formatAbiItem(abiItem, { includeName = false } = {}) {
    if (abiItem.type !== 'function' &&
        abiItem.type !== 'event' &&
        abiItem.type !== 'error')
        throw new abi_js_1.InvalidDefinitionTypeError(abiItem.type);
    return `${abiItem.name}(${formatAbiParams(abiItem.inputs, { includeName })})`;
}
function formatAbiParams(params, { includeName = false } = {}) {
    if (!params)
        return '';
    return params
        .map((param) => formatAbiParam(param, { includeName }))
        .join(includeName ? ', ' : ',');
}
function formatAbiParam(param, { includeName }) {
    if (param.type.startsWith('tuple')) {
        return `(${formatAbiParams(param.components, { includeName })})${param.type.slice('tuple'.length)}`;
    }
    return param.type + (includeName && param.name ? ` ${param.name}` : '');
}
//# sourceMappingURL=formatAbiItem.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/utils/abi/formatAbiItemWithArgs.js":
/*!*******************************************************************!*\
  !*** ./node_modules/viem/_cjs/utils/abi/formatAbiItemWithArgs.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.formatAbiItemWithArgs = formatAbiItemWithArgs;
const stringify_js_1 = __webpack_require__(/*! ../stringify.js */ "./node_modules/viem/_cjs/utils/stringify.js");
function formatAbiItemWithArgs({ abiItem, args, includeFunctionName = true, includeName = false, }) {
    if (!('name' in abiItem))
        return;
    if (!('inputs' in abiItem))
        return;
    if (!abiItem.inputs)
        return;
    return `${includeFunctionName ? abiItem.name : ''}(${abiItem.inputs
        .map((input, i) => `${includeName && input.name ? `${input.name}: ` : ''}${typeof args[i] === 'object' ? (0, stringify_js_1.stringify)(args[i]) : args[i]}`)
        .join(', ')})`;
}
//# sourceMappingURL=formatAbiItemWithArgs.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/utils/abi/getAbiItem.js":
/*!********************************************************!*\
  !*** ./node_modules/viem/_cjs/utils/abi/getAbiItem.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getAbiItem = getAbiItem;
exports.isArgOfType = isArgOfType;
exports.getAmbiguousTypes = getAmbiguousTypes;
const abi_js_1 = __webpack_require__(/*! ../../errors/abi.js */ "./node_modules/viem/_cjs/errors/abi.js");
const isHex_js_1 = __webpack_require__(/*! ../../utils/data/isHex.js */ "./node_modules/viem/_cjs/utils/data/isHex.js");
const isAddress_js_1 = __webpack_require__(/*! ../address/isAddress.js */ "./node_modules/viem/_cjs/utils/address/isAddress.js");
const toEventSelector_js_1 = __webpack_require__(/*! ../hash/toEventSelector.js */ "./node_modules/viem/_cjs/utils/hash/toEventSelector.js");
const toFunctionSelector_js_1 = __webpack_require__(/*! ../hash/toFunctionSelector.js */ "./node_modules/viem/_cjs/utils/hash/toFunctionSelector.js");
function getAbiItem(parameters) {
    const { abi, args = [], name } = parameters;
    const isSelector = (0, isHex_js_1.isHex)(name, { strict: false });
    const abiItems = abi.filter((abiItem) => {
        if (isSelector) {
            if (abiItem.type === 'function')
                return (0, toFunctionSelector_js_1.toFunctionSelector)(abiItem) === name;
            if (abiItem.type === 'event')
                return (0, toEventSelector_js_1.toEventSelector)(abiItem) === name;
            return false;
        }
        return 'name' in abiItem && abiItem.name === name;
    });
    if (abiItems.length === 0)
        return undefined;
    if (abiItems.length === 1)
        return abiItems[0];
    let matchedAbiItem;
    for (const abiItem of abiItems) {
        if (!('inputs' in abiItem))
            continue;
        if (!args || args.length === 0) {
            if (!abiItem.inputs || abiItem.inputs.length === 0)
                return abiItem;
            continue;
        }
        if (!abiItem.inputs)
            continue;
        if (abiItem.inputs.length === 0)
            continue;
        if (abiItem.inputs.length !== args.length)
            continue;
        const matched = args.every((arg, index) => {
            const abiParameter = 'inputs' in abiItem && abiItem.inputs[index];
            if (!abiParameter)
                return false;
            return isArgOfType(arg, abiParameter);
        });
        if (matched) {
            if (matchedAbiItem &&
                'inputs' in matchedAbiItem &&
                matchedAbiItem.inputs) {
                const ambiguousTypes = getAmbiguousTypes(abiItem.inputs, matchedAbiItem.inputs, args);
                if (ambiguousTypes)
                    throw new abi_js_1.AbiItemAmbiguityError({
                        abiItem,
                        type: ambiguousTypes[0],
                    }, {
                        abiItem: matchedAbiItem,
                        type: ambiguousTypes[1],
                    });
            }
            matchedAbiItem = abiItem;
        }
    }
    if (matchedAbiItem)
        return matchedAbiItem;
    return abiItems[0];
}
function isArgOfType(arg, abiParameter) {
    const argType = typeof arg;
    const abiParameterType = abiParameter.type;
    switch (abiParameterType) {
        case 'address':
            return (0, isAddress_js_1.isAddress)(arg, { strict: false });
        case 'bool':
            return argType === 'boolean';
        case 'function':
            return argType === 'string';
        case 'string':
            return argType === 'string';
        default: {
            if (abiParameterType === 'tuple' && 'components' in abiParameter)
                return Object.values(abiParameter.components).every((component, index) => {
                    return isArgOfType(Object.values(arg)[index], component);
                });
            if (/^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/.test(abiParameterType))
                return argType === 'number' || argType === 'bigint';
            if (/^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/.test(abiParameterType))
                return argType === 'string' || arg instanceof Uint8Array;
            if (/[a-z]+[1-9]{0,3}(\[[0-9]{0,}\])+$/.test(abiParameterType)) {
                return (Array.isArray(arg) &&
                    arg.every((x) => isArgOfType(x, {
                        ...abiParameter,
                        type: abiParameterType.replace(/(\[[0-9]{0,}\])$/, ''),
                    })));
            }
            return false;
        }
    }
}
function getAmbiguousTypes(sourceParameters, targetParameters, args) {
    for (const parameterIndex in sourceParameters) {
        const sourceParameter = sourceParameters[parameterIndex];
        const targetParameter = targetParameters[parameterIndex];
        if (sourceParameter.type === 'tuple' &&
            targetParameter.type === 'tuple' &&
            'components' in sourceParameter &&
            'components' in targetParameter)
            return getAmbiguousTypes(sourceParameter.components, targetParameter.components, args[parameterIndex]);
        const types = [sourceParameter.type, targetParameter.type];
        const ambiguous = (() => {
            if (types.includes('address') && types.includes('bytes20'))
                return true;
            if (types.includes('address') && types.includes('string'))
                return (0, isAddress_js_1.isAddress)(args[parameterIndex], { strict: false });
            if (types.includes('address') && types.includes('bytes'))
                return (0, isAddress_js_1.isAddress)(args[parameterIndex], { strict: false });
            return false;
        })();
        if (ambiguous)
            return types;
    }
    return;
}
//# sourceMappingURL=getAbiItem.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/utils/abi/parseEventLogs.js":
/*!************************************************************!*\
  !*** ./node_modules/viem/_cjs/utils/abi/parseEventLogs.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.parseEventLogs = parseEventLogs;
const abi_js_1 = __webpack_require__(/*! ../../errors/abi.js */ "./node_modules/viem/_cjs/errors/abi.js");
const isAddressEqual_js_1 = __webpack_require__(/*! ../address/isAddressEqual.js */ "./node_modules/viem/_cjs/utils/address/isAddressEqual.js");
const toBytes_js_1 = __webpack_require__(/*! ../encoding/toBytes.js */ "./node_modules/viem/_cjs/utils/encoding/toBytes.js");
const keccak256_js_1 = __webpack_require__(/*! ../hash/keccak256.js */ "./node_modules/viem/_cjs/utils/hash/keccak256.js");
const toEventSelector_js_1 = __webpack_require__(/*! ../hash/toEventSelector.js */ "./node_modules/viem/_cjs/utils/hash/toEventSelector.js");
const decodeEventLog_js_1 = __webpack_require__(/*! ./decodeEventLog.js */ "./node_modules/viem/_cjs/utils/abi/decodeEventLog.js");
function parseEventLogs(parameters) {
    const { abi, args, logs, strict = true } = parameters;
    const eventName = (() => {
        if (!parameters.eventName)
            return undefined;
        if (Array.isArray(parameters.eventName))
            return parameters.eventName;
        return [parameters.eventName];
    })();
    return logs
        .map((log) => {
        try {
            const abiItem = abi.find((abiItem) => abiItem.type === 'event' &&
                log.topics[0] === (0, toEventSelector_js_1.toEventSelector)(abiItem));
            if (!abiItem)
                return null;
            const event = (0, decodeEventLog_js_1.decodeEventLog)({
                ...log,
                abi: [abiItem],
                strict,
            });
            if (eventName && !eventName.includes(event.eventName))
                return null;
            if (!includesArgs({
                args: event.args,
                inputs: abiItem.inputs,
                matchArgs: args,
            }))
                return null;
            return { ...event, ...log };
        }
        catch (err) {
            let eventName;
            let isUnnamed;
            if (err instanceof abi_js_1.AbiEventSignatureNotFoundError)
                return null;
            if (err instanceof abi_js_1.DecodeLogDataMismatch ||
                err instanceof abi_js_1.DecodeLogTopicsMismatch) {
                if (strict)
                    return null;
                eventName = err.abiItem.name;
                isUnnamed = err.abiItem.inputs?.some((x) => !('name' in x && x.name));
            }
            return { ...log, args: isUnnamed ? [] : {}, eventName };
        }
    })
        .filter(Boolean);
}
function includesArgs(parameters) {
    const { args, inputs, matchArgs } = parameters;
    if (!matchArgs)
        return true;
    if (!args)
        return false;
    function isEqual(input, value, arg) {
        try {
            if (input.type === 'address')
                return (0, isAddressEqual_js_1.isAddressEqual)(value, arg);
            if (input.type === 'string' || input.type === 'bytes')
                return (0, keccak256_js_1.keccak256)((0, toBytes_js_1.toBytes)(value)) === arg;
            return value === arg;
        }
        catch {
            return false;
        }
    }
    if (Array.isArray(args) && Array.isArray(matchArgs)) {
        return matchArgs.every((value, index) => {
            if (value === null || value === undefined)
                return true;
            const input = inputs[index];
            if (!input)
                return false;
            const value_ = Array.isArray(value) ? value : [value];
            return value_.some((value) => isEqual(input, value, args[index]));
        });
    }
    if (typeof args === 'object' &&
        !Array.isArray(args) &&
        typeof matchArgs === 'object' &&
        !Array.isArray(matchArgs))
        return Object.entries(matchArgs).every(([key, value]) => {
            if (value === null || value === undefined)
                return true;
            const input = inputs.find((input) => input.name === key);
            if (!input)
                return false;
            const value_ = Array.isArray(value) ? value : [value];
            return value_.some((value) => isEqual(input, value, args[key]));
        });
    return false;
}
//# sourceMappingURL=parseEventLogs.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/utils/abi/prepareEncodeFunctionData.js":
/*!***********************************************************************!*\
  !*** ./node_modules/viem/_cjs/utils/abi/prepareEncodeFunctionData.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.prepareEncodeFunctionData = prepareEncodeFunctionData;
const abi_js_1 = __webpack_require__(/*! ../../errors/abi.js */ "./node_modules/viem/_cjs/errors/abi.js");
const toFunctionSelector_js_1 = __webpack_require__(/*! ../hash/toFunctionSelector.js */ "./node_modules/viem/_cjs/utils/hash/toFunctionSelector.js");
const formatAbiItem_js_1 = __webpack_require__(/*! ./formatAbiItem.js */ "./node_modules/viem/_cjs/utils/abi/formatAbiItem.js");
const getAbiItem_js_1 = __webpack_require__(/*! ./getAbiItem.js */ "./node_modules/viem/_cjs/utils/abi/getAbiItem.js");
const docsPath = '/docs/contract/encodeFunctionData';
function prepareEncodeFunctionData(parameters) {
    const { abi, args, functionName } = parameters;
    let abiItem = abi[0];
    if (functionName) {
        const item = (0, getAbiItem_js_1.getAbiItem)({
            abi,
            args,
            name: functionName,
        });
        if (!item)
            throw new abi_js_1.AbiFunctionNotFoundError(functionName, { docsPath });
        abiItem = item;
    }
    if (abiItem.type !== 'function')
        throw new abi_js_1.AbiFunctionNotFoundError(undefined, { docsPath });
    return {
        abi: [abiItem],
        functionName: (0, toFunctionSelector_js_1.toFunctionSelector)((0, formatAbiItem_js_1.formatAbiItem)(abiItem)),
    };
}
//# sourceMappingURL=prepareEncodeFunctionData.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/utils/address/getAddress.js":
/*!************************************************************!*\
  !*** ./node_modules/viem/_cjs/utils/address/getAddress.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.checksumAddress = checksumAddress;
exports.getAddress = getAddress;
const address_js_1 = __webpack_require__(/*! ../../errors/address.js */ "./node_modules/viem/_cjs/errors/address.js");
const toBytes_js_1 = __webpack_require__(/*! ../encoding/toBytes.js */ "./node_modules/viem/_cjs/utils/encoding/toBytes.js");
const keccak256_js_1 = __webpack_require__(/*! ../hash/keccak256.js */ "./node_modules/viem/_cjs/utils/hash/keccak256.js");
const lru_js_1 = __webpack_require__(/*! ../lru.js */ "./node_modules/viem/_cjs/utils/lru.js");
const isAddress_js_1 = __webpack_require__(/*! ./isAddress.js */ "./node_modules/viem/_cjs/utils/address/isAddress.js");
const checksumAddressCache = new lru_js_1.LruMap(8192);
function checksumAddress(address_, chainId) {
    if (checksumAddressCache.has(`${address_}.${chainId}`))
        return checksumAddressCache.get(`${address_}.${chainId}`);
    const hexAddress = chainId
        ? `${chainId}${address_.toLowerCase()}`
        : address_.substring(2).toLowerCase();
    const hash = (0, keccak256_js_1.keccak256)((0, toBytes_js_1.stringToBytes)(hexAddress), 'bytes');
    const address = (chainId ? hexAddress.substring(`${chainId}0x`.length) : hexAddress).split('');
    for (let i = 0; i < 40; i += 2) {
        if (hash[i >> 1] >> 4 >= 8 && address[i]) {
            address[i] = address[i].toUpperCase();
        }
        if ((hash[i >> 1] & 0x0f) >= 8 && address[i + 1]) {
            address[i + 1] = address[i + 1].toUpperCase();
        }
    }
    const result = `0x${address.join('')}`;
    checksumAddressCache.set(`${address_}.${chainId}`, result);
    return result;
}
function getAddress(address, chainId) {
    if (!(0, isAddress_js_1.isAddress)(address, { strict: false }))
        throw new address_js_1.InvalidAddressError({ address });
    return checksumAddress(address, chainId);
}
//# sourceMappingURL=getAddress.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/utils/address/getContractAddress.js":
/*!********************************************************************!*\
  !*** ./node_modules/viem/_cjs/utils/address/getContractAddress.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getContractAddress = getContractAddress;
exports.getCreateAddress = getCreateAddress;
exports.getCreate2Address = getCreate2Address;
const concat_js_1 = __webpack_require__(/*! ../data/concat.js */ "./node_modules/viem/_cjs/utils/data/concat.js");
const isBytes_js_1 = __webpack_require__(/*! ../data/isBytes.js */ "./node_modules/viem/_cjs/utils/data/isBytes.js");
const pad_js_1 = __webpack_require__(/*! ../data/pad.js */ "./node_modules/viem/_cjs/utils/data/pad.js");
const slice_js_1 = __webpack_require__(/*! ../data/slice.js */ "./node_modules/viem/_cjs/utils/data/slice.js");
const toBytes_js_1 = __webpack_require__(/*! ../encoding/toBytes.js */ "./node_modules/viem/_cjs/utils/encoding/toBytes.js");
const toRlp_js_1 = __webpack_require__(/*! ../encoding/toRlp.js */ "./node_modules/viem/_cjs/utils/encoding/toRlp.js");
const keccak256_js_1 = __webpack_require__(/*! ../hash/keccak256.js */ "./node_modules/viem/_cjs/utils/hash/keccak256.js");
const getAddress_js_1 = __webpack_require__(/*! ./getAddress.js */ "./node_modules/viem/_cjs/utils/address/getAddress.js");
function getContractAddress(opts) {
    if (opts.opcode === 'CREATE2')
        return getCreate2Address(opts);
    return getCreateAddress(opts);
}
function getCreateAddress(opts) {
    const from = (0, toBytes_js_1.toBytes)((0, getAddress_js_1.getAddress)(opts.from));
    let nonce = (0, toBytes_js_1.toBytes)(opts.nonce);
    if (nonce[0] === 0)
        nonce = new Uint8Array([]);
    return (0, getAddress_js_1.getAddress)(`0x${(0, keccak256_js_1.keccak256)((0, toRlp_js_1.toRlp)([from, nonce], 'bytes')).slice(26)}`);
}
function getCreate2Address(opts) {
    const from = (0, toBytes_js_1.toBytes)((0, getAddress_js_1.getAddress)(opts.from));
    const salt = (0, pad_js_1.pad)((0, isBytes_js_1.isBytes)(opts.salt) ? opts.salt : (0, toBytes_js_1.toBytes)(opts.salt), {
        size: 32,
    });
    const bytecodeHash = (() => {
        if ('bytecodeHash' in opts) {
            if ((0, isBytes_js_1.isBytes)(opts.bytecodeHash))
                return opts.bytecodeHash;
            return (0, toBytes_js_1.toBytes)(opts.bytecodeHash);
        }
        return (0, keccak256_js_1.keccak256)(opts.bytecode, 'bytes');
    })();
    return (0, getAddress_js_1.getAddress)((0, slice_js_1.slice)((0, keccak256_js_1.keccak256)((0, concat_js_1.concat)([(0, toBytes_js_1.toBytes)('0xff'), from, salt, bytecodeHash])), 12));
}
//# sourceMappingURL=getContractAddress.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/utils/address/isAddress.js":
/*!***********************************************************!*\
  !*** ./node_modules/viem/_cjs/utils/address/isAddress.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isAddressCache = void 0;
exports.isAddress = isAddress;
const lru_js_1 = __webpack_require__(/*! ../lru.js */ "./node_modules/viem/_cjs/utils/lru.js");
const getAddress_js_1 = __webpack_require__(/*! ./getAddress.js */ "./node_modules/viem/_cjs/utils/address/getAddress.js");
const addressRegex = /^0x[a-fA-F0-9]{40}$/;
exports.isAddressCache = new lru_js_1.LruMap(8192);
function isAddress(address, options) {
    const { strict = true } = options ?? {};
    const cacheKey = `${address}.${strict}`;
    if (exports.isAddressCache.has(cacheKey))
        return exports.isAddressCache.get(cacheKey);
    const result = (() => {
        if (!addressRegex.test(address))
            return false;
        if (address.toLowerCase() === address)
            return true;
        if (strict)
            return (0, getAddress_js_1.checksumAddress)(address) === address;
        return true;
    })();
    exports.isAddressCache.set(cacheKey, result);
    return result;
}
//# sourceMappingURL=isAddress.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/utils/address/isAddressEqual.js":
/*!****************************************************************!*\
  !*** ./node_modules/viem/_cjs/utils/address/isAddressEqual.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isAddressEqual = isAddressEqual;
const address_js_1 = __webpack_require__(/*! ../../errors/address.js */ "./node_modules/viem/_cjs/errors/address.js");
const isAddress_js_1 = __webpack_require__(/*! ./isAddress.js */ "./node_modules/viem/_cjs/utils/address/isAddress.js");
function isAddressEqual(a, b) {
    if (!(0, isAddress_js_1.isAddress)(a, { strict: false }))
        throw new address_js_1.InvalidAddressError({ address: a });
    if (!(0, isAddress_js_1.isAddress)(b, { strict: false }))
        throw new address_js_1.InvalidAddressError({ address: b });
    return a.toLowerCase() === b.toLowerCase();
}
//# sourceMappingURL=isAddressEqual.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/utils/authorization/hashAuthorization.js":
/*!*************************************************************************!*\
  !*** ./node_modules/viem/_cjs/utils/authorization/hashAuthorization.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.hashAuthorization = hashAuthorization;
const concat_js_1 = __webpack_require__(/*! ../data/concat.js */ "./node_modules/viem/_cjs/utils/data/concat.js");
const toBytes_js_1 = __webpack_require__(/*! ../encoding/toBytes.js */ "./node_modules/viem/_cjs/utils/encoding/toBytes.js");
const toHex_js_1 = __webpack_require__(/*! ../encoding/toHex.js */ "./node_modules/viem/_cjs/utils/encoding/toHex.js");
const toRlp_js_1 = __webpack_require__(/*! ../encoding/toRlp.js */ "./node_modules/viem/_cjs/utils/encoding/toRlp.js");
const keccak256_js_1 = __webpack_require__(/*! ../hash/keccak256.js */ "./node_modules/viem/_cjs/utils/hash/keccak256.js");
function hashAuthorization(parameters) {
    const { chainId, nonce, to } = parameters;
    const address = parameters.contractAddress ?? parameters.address;
    const hash = (0, keccak256_js_1.keccak256)((0, concat_js_1.concatHex)([
        '0x05',
        (0, toRlp_js_1.toRlp)([
            chainId ? (0, toHex_js_1.numberToHex)(chainId) : '0x',
            address,
            nonce ? (0, toHex_js_1.numberToHex)(nonce) : '0x',
        ]),
    ]));
    if (to === 'bytes')
        return (0, toBytes_js_1.hexToBytes)(hash);
    return hash;
}
//# sourceMappingURL=hashAuthorization.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/utils/authorization/recoverAuthorizationAddress.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/viem/_cjs/utils/authorization/recoverAuthorizationAddress.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.recoverAuthorizationAddress = recoverAuthorizationAddress;
const recoverAddress_js_1 = __webpack_require__(/*! ../signature/recoverAddress.js */ "./node_modules/viem/_cjs/utils/signature/recoverAddress.js");
const hashAuthorization_js_1 = __webpack_require__(/*! ./hashAuthorization.js */ "./node_modules/viem/_cjs/utils/authorization/hashAuthorization.js");
async function recoverAuthorizationAddress(parameters) {
    const { authorization, signature } = parameters;
    return (0, recoverAddress_js_1.recoverAddress)({
        hash: (0, hashAuthorization_js_1.hashAuthorization)(authorization),
        signature: (signature ?? authorization),
    });
}
//# sourceMappingURL=recoverAuthorizationAddress.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/utils/authorization/serializeAuthorizationList.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/viem/_cjs/utils/authorization/serializeAuthorizationList.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.serializeAuthorizationList = serializeAuthorizationList;
const toHex_js_1 = __webpack_require__(/*! ../encoding/toHex.js */ "./node_modules/viem/_cjs/utils/encoding/toHex.js");
const serializeTransaction_js_1 = __webpack_require__(/*! ../transaction/serializeTransaction.js */ "./node_modules/viem/_cjs/utils/transaction/serializeTransaction.js");
function serializeAuthorizationList(authorizationList) {
    if (!authorizationList || authorizationList.length === 0)
        return [];
    const serializedAuthorizationList = [];
    for (const authorization of authorizationList) {
        const { chainId, nonce, ...signature } = authorization;
        const contractAddress = authorization.address;
        serializedAuthorizationList.push([
            chainId ? (0, toHex_js_1.toHex)(chainId) : '0x',
            contractAddress,
            nonce ? (0, toHex_js_1.toHex)(nonce) : '0x',
            ...(0, serializeTransaction_js_1.toYParitySignatureArray)({}, signature),
        ]);
    }
    return serializedAuthorizationList;
}
//# sourceMappingURL=serializeAuthorizationList.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/utils/authorization/verifyAuthorization.js":
/*!***************************************************************************!*\
  !*** ./node_modules/viem/_cjs/utils/authorization/verifyAuthorization.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.verifyAuthorization = verifyAuthorization;
const getAddress_js_1 = __webpack_require__(/*! ../address/getAddress.js */ "./node_modules/viem/_cjs/utils/address/getAddress.js");
const isAddressEqual_js_1 = __webpack_require__(/*! ../address/isAddressEqual.js */ "./node_modules/viem/_cjs/utils/address/isAddressEqual.js");
const recoverAuthorizationAddress_js_1 = __webpack_require__(/*! ./recoverAuthorizationAddress.js */ "./node_modules/viem/_cjs/utils/authorization/recoverAuthorizationAddress.js");
async function verifyAuthorization({ address, authorization, signature, }) {
    return (0, isAddressEqual_js_1.isAddressEqual)((0, getAddress_js_1.getAddress)(address), await (0, recoverAuthorizationAddress_js_1.recoverAuthorizationAddress)({
        authorization,
        signature,
    }));
}
//# sourceMappingURL=verifyAuthorization.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/utils/blob/blobsToCommitments.js":
/*!*****************************************************************!*\
  !*** ./node_modules/viem/_cjs/utils/blob/blobsToCommitments.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.blobsToCommitments = blobsToCommitments;
const toBytes_js_1 = __webpack_require__(/*! ../encoding/toBytes.js */ "./node_modules/viem/_cjs/utils/encoding/toBytes.js");
const toHex_js_1 = __webpack_require__(/*! ../encoding/toHex.js */ "./node_modules/viem/_cjs/utils/encoding/toHex.js");
function blobsToCommitments(parameters) {
    const { kzg } = parameters;
    const to = parameters.to ?? (typeof parameters.blobs[0] === 'string' ? 'hex' : 'bytes');
    const blobs = (typeof parameters.blobs[0] === 'string'
        ? parameters.blobs.map((x) => (0, toBytes_js_1.hexToBytes)(x))
        : parameters.blobs);
    const commitments = [];
    for (const blob of blobs)
        commitments.push(Uint8Array.from(kzg.blobToKzgCommitment(blob)));
    return (to === 'bytes'
        ? commitments
        : commitments.map((x) => (0, toHex_js_1.bytesToHex)(x)));
}
//# sourceMappingURL=blobsToCommitments.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/utils/blob/blobsToProofs.js":
/*!************************************************************!*\
  !*** ./node_modules/viem/_cjs/utils/blob/blobsToProofs.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.blobsToProofs = blobsToProofs;
const toBytes_js_1 = __webpack_require__(/*! ../encoding/toBytes.js */ "./node_modules/viem/_cjs/utils/encoding/toBytes.js");
const toHex_js_1 = __webpack_require__(/*! ../encoding/toHex.js */ "./node_modules/viem/_cjs/utils/encoding/toHex.js");
function blobsToProofs(parameters) {
    const { kzg } = parameters;
    const to = parameters.to ?? (typeof parameters.blobs[0] === 'string' ? 'hex' : 'bytes');
    const blobs = (typeof parameters.blobs[0] === 'string'
        ? parameters.blobs.map((x) => (0, toBytes_js_1.hexToBytes)(x))
        : parameters.blobs);
    const commitments = (typeof parameters.commitments[0] === 'string'
        ? parameters.commitments.map((x) => (0, toBytes_js_1.hexToBytes)(x))
        : parameters.commitments);
    const proofs = [];
    for (let i = 0; i < blobs.length; i++) {
        const blob = blobs[i];
        const commitment = commitments[i];
        proofs.push(Uint8Array.from(kzg.computeBlobKzgProof(blob, commitment)));
    }
    return (to === 'bytes'
        ? proofs
        : proofs.map((x) => (0, toHex_js_1.bytesToHex)(x)));
}
//# sourceMappingURL=blobsToProofs.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/utils/blob/commitmentToVersionedHash.js":
/*!************************************************************************!*\
  !*** ./node_modules/viem/_cjs/utils/blob/commitmentToVersionedHash.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.commitmentToVersionedHash = commitmentToVersionedHash;
const toHex_js_1 = __webpack_require__(/*! ../encoding/toHex.js */ "./node_modules/viem/_cjs/utils/encoding/toHex.js");
const sha256_js_1 = __webpack_require__(/*! ../hash/sha256.js */ "./node_modules/viem/_cjs/utils/hash/sha256.js");
function commitmentToVersionedHash(parameters) {
    const { commitment, version = 1 } = parameters;
    const to = parameters.to ?? (typeof commitment === 'string' ? 'hex' : 'bytes');
    const versionedHash = (0, sha256_js_1.sha256)(commitment, 'bytes');
    versionedHash.set([version], 0);
    return (to === 'bytes' ? versionedHash : (0, toHex_js_1.bytesToHex)(versionedHash));
}
//# sourceMappingURL=commitmentToVersionedHash.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/utils/blob/commitmentsToVersionedHashes.js":
/*!***************************************************************************!*\
  !*** ./node_modules/viem/_cjs/utils/blob/commitmentsToVersionedHashes.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.commitmentsToVersionedHashes = commitmentsToVersionedHashes;
const commitmentToVersionedHash_js_1 = __webpack_require__(/*! ./commitmentToVersionedHash.js */ "./node_modules/viem/_cjs/utils/blob/commitmentToVersionedHash.js");
function commitmentsToVersionedHashes(parameters) {
    const { commitments, version } = parameters;
    const to = parameters.to ?? (typeof commitments[0] === 'string' ? 'hex' : 'bytes');
    const hashes = [];
    for (const commitment of commitments) {
        hashes.push((0, commitmentToVersionedHash_js_1.commitmentToVersionedHash)({
            commitment,
            to,
            version,
        }));
    }
    return hashes;
}
//# sourceMappingURL=commitmentsToVersionedHashes.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/utils/blob/fromBlobs.js":
/*!********************************************************!*\
  !*** ./node_modules/viem/_cjs/utils/blob/fromBlobs.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.fromBlobs = fromBlobs;
const cursor_js_1 = __webpack_require__(/*! ../cursor.js */ "./node_modules/viem/_cjs/utils/cursor.js");
const toBytes_js_1 = __webpack_require__(/*! ../encoding/toBytes.js */ "./node_modules/viem/_cjs/utils/encoding/toBytes.js");
const toHex_js_1 = __webpack_require__(/*! ../encoding/toHex.js */ "./node_modules/viem/_cjs/utils/encoding/toHex.js");
function fromBlobs(parameters) {
    const to = parameters.to ?? (typeof parameters.blobs[0] === 'string' ? 'hex' : 'bytes');
    const blobs = (typeof parameters.blobs[0] === 'string'
        ? parameters.blobs.map((x) => (0, toBytes_js_1.hexToBytes)(x))
        : parameters.blobs);
    const length = blobs.reduce((length, blob) => length + blob.length, 0);
    const data = (0, cursor_js_1.createCursor)(new Uint8Array(length));
    let active = true;
    for (const blob of blobs) {
        const cursor = (0, cursor_js_1.createCursor)(blob);
        while (active && cursor.position < blob.length) {
            cursor.incrementPosition(1);
            let consume = 31;
            if (blob.length - cursor.position < 31)
                consume = blob.length - cursor.position;
            for (const _ in Array.from({ length: consume })) {
                const byte = cursor.readByte();
                const isTerminator = byte === 0x80 && !cursor.inspectBytes(cursor.remaining).includes(0x80);
                if (isTerminator) {
                    active = false;
                    break;
                }
                data.pushByte(byte);
            }
        }
    }
    const trimmedData = data.bytes.slice(0, data.position);
    return (to === 'hex' ? (0, toHex_js_1.bytesToHex)(trimmedData) : trimmedData);
}
//# sourceMappingURL=fromBlobs.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/utils/blob/sidecarsToVersionedHashes.js":
/*!************************************************************************!*\
  !*** ./node_modules/viem/_cjs/utils/blob/sidecarsToVersionedHashes.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.sidecarsToVersionedHashes = sidecarsToVersionedHashes;
const commitmentToVersionedHash_js_1 = __webpack_require__(/*! ./commitmentToVersionedHash.js */ "./node_modules/viem/_cjs/utils/blob/commitmentToVersionedHash.js");
function sidecarsToVersionedHashes(parameters) {
    const { sidecars, version } = parameters;
    const to = parameters.to ?? (typeof sidecars[0].blob === 'string' ? 'hex' : 'bytes');
    const hashes = [];
    for (const { commitment } of sidecars) {
        hashes.push((0, commitmentToVersionedHash_js_1.commitmentToVersionedHash)({
            commitment,
            to,
            version,
        }));
    }
    return hashes;
}
//# sourceMappingURL=sidecarsToVersionedHashes.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/utils/blob/toBlobSidecars.js":
/*!*************************************************************!*\
  !*** ./node_modules/viem/_cjs/utils/blob/toBlobSidecars.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.toBlobSidecars = toBlobSidecars;
const blobsToCommitments_js_1 = __webpack_require__(/*! ./blobsToCommitments.js */ "./node_modules/viem/_cjs/utils/blob/blobsToCommitments.js");
const blobsToProofs_js_1 = __webpack_require__(/*! ./blobsToProofs.js */ "./node_modules/viem/_cjs/utils/blob/blobsToProofs.js");
const toBlobs_js_1 = __webpack_require__(/*! ./toBlobs.js */ "./node_modules/viem/_cjs/utils/blob/toBlobs.js");
function toBlobSidecars(parameters) {
    const { data, kzg, to } = parameters;
    const blobs = parameters.blobs ?? (0, toBlobs_js_1.toBlobs)({ data: data, to });
    const commitments = parameters.commitments ?? (0, blobsToCommitments_js_1.blobsToCommitments)({ blobs, kzg: kzg, to });
    const proofs = parameters.proofs ?? (0, blobsToProofs_js_1.blobsToProofs)({ blobs, commitments, kzg: kzg, to });
    const sidecars = [];
    for (let i = 0; i < blobs.length; i++)
        sidecars.push({
            blob: blobs[i],
            commitment: commitments[i],
            proof: proofs[i],
        });
    return sidecars;
}
//# sourceMappingURL=toBlobSidecars.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/utils/blob/toBlobs.js":
/*!******************************************************!*\
  !*** ./node_modules/viem/_cjs/utils/blob/toBlobs.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.toBlobs = toBlobs;
const blob_js_1 = __webpack_require__(/*! ../../constants/blob.js */ "./node_modules/viem/_cjs/constants/blob.js");
const blob_js_2 = __webpack_require__(/*! ../../errors/blob.js */ "./node_modules/viem/_cjs/errors/blob.js");
const cursor_js_1 = __webpack_require__(/*! ../cursor.js */ "./node_modules/viem/_cjs/utils/cursor.js");
const size_js_1 = __webpack_require__(/*! ../data/size.js */ "./node_modules/viem/_cjs/utils/data/size.js");
const toBytes_js_1 = __webpack_require__(/*! ../encoding/toBytes.js */ "./node_modules/viem/_cjs/utils/encoding/toBytes.js");
const toHex_js_1 = __webpack_require__(/*! ../encoding/toHex.js */ "./node_modules/viem/_cjs/utils/encoding/toHex.js");
function toBlobs(parameters) {
    const to = parameters.to ?? (typeof parameters.data === 'string' ? 'hex' : 'bytes');
    const data = (typeof parameters.data === 'string'
        ? (0, toBytes_js_1.hexToBytes)(parameters.data)
        : parameters.data);
    const size_ = (0, size_js_1.size)(data);
    if (!size_)
        throw new blob_js_2.EmptyBlobError();
    if (size_ > blob_js_1.maxBytesPerTransaction)
        throw new blob_js_2.BlobSizeTooLargeError({
            maxSize: blob_js_1.maxBytesPerTransaction,
            size: size_,
        });
    const blobs = [];
    let active = true;
    let position = 0;
    while (active) {
        const blob = (0, cursor_js_1.createCursor)(new Uint8Array(blob_js_1.bytesPerBlob));
        let size = 0;
        while (size < blob_js_1.fieldElementsPerBlob) {
            const bytes = data.slice(position, position + (blob_js_1.bytesPerFieldElement - 1));
            blob.pushByte(0x00);
            blob.pushBytes(bytes);
            if (bytes.length < 31) {
                blob.pushByte(0x80);
                active = false;
                break;
            }
            size++;
            position += 31;
        }
        blobs.push(blob);
    }
    return (to === 'bytes'
        ? blobs.map((x) => x.bytes)
        : blobs.map((x) => (0, toHex_js_1.bytesToHex)(x.bytes)));
}
//# sourceMappingURL=toBlobs.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/utils/buildRequest.js":
/*!******************************************************!*\
  !*** ./node_modules/viem/_cjs/utils/buildRequest.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.buildRequest = buildRequest;
exports.shouldRetry = shouldRetry;
const base_js_1 = __webpack_require__(/*! ../errors/base.js */ "./node_modules/viem/_cjs/errors/base.js");
const request_js_1 = __webpack_require__(/*! ../errors/request.js */ "./node_modules/viem/_cjs/errors/request.js");
const rpc_js_1 = __webpack_require__(/*! ../errors/rpc.js */ "./node_modules/viem/_cjs/errors/rpc.js");
const toHex_js_1 = __webpack_require__(/*! ./encoding/toHex.js */ "./node_modules/viem/_cjs/utils/encoding/toHex.js");
const withDedupe_js_1 = __webpack_require__(/*! ./promise/withDedupe.js */ "./node_modules/viem/_cjs/utils/promise/withDedupe.js");
const withRetry_js_1 = __webpack_require__(/*! ./promise/withRetry.js */ "./node_modules/viem/_cjs/utils/promise/withRetry.js");
const stringify_js_1 = __webpack_require__(/*! ./stringify.js */ "./node_modules/viem/_cjs/utils/stringify.js");
function buildRequest(request, options = {}) {
    return async (args, overrideOptions = {}) => {
        const { dedupe = false, methods, retryDelay = 150, retryCount = 3, uid, } = {
            ...options,
            ...overrideOptions,
        };
        const { method } = args;
        if (methods?.exclude?.includes(method))
            throw new rpc_js_1.MethodNotSupportedRpcError(new Error('method not supported'), {
                method,
            });
        if (methods?.include && !methods.include.includes(method))
            throw new rpc_js_1.MethodNotSupportedRpcError(new Error('method not supported'), {
                method,
            });
        const requestId = dedupe
            ? (0, toHex_js_1.stringToHex)(`${uid}.${(0, stringify_js_1.stringify)(args)}`)
            : undefined;
        return (0, withDedupe_js_1.withDedupe)(() => (0, withRetry_js_1.withRetry)(async () => {
            try {
                return await request(args);
            }
            catch (err_) {
                const err = err_;
                switch (err.code) {
                    case rpc_js_1.ParseRpcError.code:
                        throw new rpc_js_1.ParseRpcError(err);
                    case rpc_js_1.InvalidRequestRpcError.code:
                        throw new rpc_js_1.InvalidRequestRpcError(err);
                    case rpc_js_1.MethodNotFoundRpcError.code:
                        throw new rpc_js_1.MethodNotFoundRpcError(err, { method: args.method });
                    case rpc_js_1.InvalidParamsRpcError.code:
                        throw new rpc_js_1.InvalidParamsRpcError(err);
                    case rpc_js_1.InternalRpcError.code:
                        throw new rpc_js_1.InternalRpcError(err);
                    case rpc_js_1.InvalidInputRpcError.code:
                        throw new rpc_js_1.InvalidInputRpcError(err);
                    case rpc_js_1.ResourceNotFoundRpcError.code:
                        throw new rpc_js_1.ResourceNotFoundRpcError(err);
                    case rpc_js_1.ResourceUnavailableRpcError.code:
                        throw new rpc_js_1.ResourceUnavailableRpcError(err);
                    case rpc_js_1.TransactionRejectedRpcError.code:
                        throw new rpc_js_1.TransactionRejectedRpcError(err);
                    case rpc_js_1.MethodNotSupportedRpcError.code:
                        throw new rpc_js_1.MethodNotSupportedRpcError(err, {
                            method: args.method,
                        });
                    case rpc_js_1.LimitExceededRpcError.code:
                        throw new rpc_js_1.LimitExceededRpcError(err);
                    case rpc_js_1.JsonRpcVersionUnsupportedError.code:
                        throw new rpc_js_1.JsonRpcVersionUnsupportedError(err);
                    case rpc_js_1.UserRejectedRequestError.code:
                        throw new rpc_js_1.UserRejectedRequestError(err);
                    case rpc_js_1.UnauthorizedProviderError.code:
                        throw new rpc_js_1.UnauthorizedProviderError(err);
                    case rpc_js_1.UnsupportedProviderMethodError.code:
                        throw new rpc_js_1.UnsupportedProviderMethodError(err);
                    case rpc_js_1.ProviderDisconnectedError.code:
                        throw new rpc_js_1.ProviderDisconnectedError(err);
                    case rpc_js_1.ChainDisconnectedError.code:
                        throw new rpc_js_1.ChainDisconnectedError(err);
                    case rpc_js_1.SwitchChainError.code:
                        throw new rpc_js_1.SwitchChainError(err);
                    case rpc_js_1.UnsupportedNonOptionalCapabilityError.code:
                        throw new rpc_js_1.UnsupportedNonOptionalCapabilityError(err);
                    case rpc_js_1.UnsupportedChainIdError.code:
                        throw new rpc_js_1.UnsupportedChainIdError(err);
                    case rpc_js_1.DuplicateIdError.code:
                        throw new rpc_js_1.DuplicateIdError(err);
                    case rpc_js_1.UnknownBundleIdError.code:
                        throw new rpc_js_1.UnknownBundleIdError(err);
                    case rpc_js_1.BundleTooLargeError.code:
                        throw new rpc_js_1.BundleTooLargeError(err);
                    case rpc_js_1.AtomicReadyWalletRejectedUpgradeError.code:
                        throw new rpc_js_1.AtomicReadyWalletRejectedUpgradeError(err);
                    case rpc_js_1.AtomicityNotSupportedError.code:
                        throw new rpc_js_1.AtomicityNotSupportedError(err);
                    case 5000:
                        throw new rpc_js_1.UserRejectedRequestError(err);
                    default:
                        if (err_ instanceof base_js_1.BaseError)
                            throw err_;
                        throw new rpc_js_1.UnknownRpcError(err);
                }
            }
        }, {
            delay: ({ count, error }) => {
                if (error && error instanceof request_js_1.HttpRequestError) {
                    const retryAfter = error?.headers?.get('Retry-After');
                    if (retryAfter?.match(/\d/))
                        return Number.parseInt(retryAfter, 10) * 1000;
                }
                return ~~(1 << count) * retryDelay;
            },
            retryCount,
            shouldRetry: ({ error }) => shouldRetry(error),
        }), { enabled: dedupe, id: requestId });
    };
}
function shouldRetry(error) {
    if ('code' in error && typeof error.code === 'number') {
        if (error.code === -1)
            return true;
        if (error.code === rpc_js_1.LimitExceededRpcError.code)
            return true;
        if (error.code === rpc_js_1.InternalRpcError.code)
            return true;
        return false;
    }
    if (error instanceof request_js_1.HttpRequestError && error.status) {
        if (error.status === 403)
            return true;
        if (error.status === 408)
            return true;
        if (error.status === 413)
            return true;
        if (error.status === 429)
            return true;
        if (error.status === 500)
            return true;
        if (error.status === 502)
            return true;
        if (error.status === 503)
            return true;
        if (error.status === 504)
            return true;
        return false;
    }
    return true;
}
//# sourceMappingURL=buildRequest.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/utils/ccip.js":
/*!**********************************************!*\
  !*** ./node_modules/viem/_cjs/utils/ccip.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.offchainLookupAbiItem = exports.offchainLookupSignature = void 0;
exports.offchainLookup = offchainLookup;
exports.ccipRequest = ccipRequest;
const call_js_1 = __webpack_require__(/*! ../actions/public/call.js */ "./node_modules/viem/_cjs/actions/public/call.js");
const ccip_js_1 = __webpack_require__(/*! ../errors/ccip.js */ "./node_modules/viem/_cjs/errors/ccip.js");
const request_js_1 = __webpack_require__(/*! ../errors/request.js */ "./node_modules/viem/_cjs/errors/request.js");
const decodeErrorResult_js_1 = __webpack_require__(/*! ./abi/decodeErrorResult.js */ "./node_modules/viem/_cjs/utils/abi/decodeErrorResult.js");
const encodeAbiParameters_js_1 = __webpack_require__(/*! ./abi/encodeAbiParameters.js */ "./node_modules/viem/_cjs/utils/abi/encodeAbiParameters.js");
const isAddressEqual_js_1 = __webpack_require__(/*! ./address/isAddressEqual.js */ "./node_modules/viem/_cjs/utils/address/isAddressEqual.js");
const concat_js_1 = __webpack_require__(/*! ./data/concat.js */ "./node_modules/viem/_cjs/utils/data/concat.js");
const isHex_js_1 = __webpack_require__(/*! ./data/isHex.js */ "./node_modules/viem/_cjs/utils/data/isHex.js");
const localBatchGatewayRequest_js_1 = __webpack_require__(/*! ./ens/localBatchGatewayRequest.js */ "./node_modules/viem/_cjs/utils/ens/localBatchGatewayRequest.js");
const stringify_js_1 = __webpack_require__(/*! ./stringify.js */ "./node_modules/viem/_cjs/utils/stringify.js");
exports.offchainLookupSignature = '0x556f1830';
exports.offchainLookupAbiItem = {
    name: 'OffchainLookup',
    type: 'error',
    inputs: [
        {
            name: 'sender',
            type: 'address',
        },
        {
            name: 'urls',
            type: 'string[]',
        },
        {
            name: 'callData',
            type: 'bytes',
        },
        {
            name: 'callbackFunction',
            type: 'bytes4',
        },
        {
            name: 'extraData',
            type: 'bytes',
        },
    ],
};
async function offchainLookup(client, { blockNumber, blockTag, data, to, }) {
    const { args } = (0, decodeErrorResult_js_1.decodeErrorResult)({
        data,
        abi: [exports.offchainLookupAbiItem],
    });
    const [sender, urls, callData, callbackSelector, extraData] = args;
    const { ccipRead } = client;
    const ccipRequest_ = ccipRead && typeof ccipRead?.request === 'function'
        ? ccipRead.request
        : ccipRequest;
    try {
        if (!(0, isAddressEqual_js_1.isAddressEqual)(to, sender))
            throw new ccip_js_1.OffchainLookupSenderMismatchError({ sender, to });
        const result = urls.includes(localBatchGatewayRequest_js_1.localBatchGatewayUrl)
            ? await (0, localBatchGatewayRequest_js_1.localBatchGatewayRequest)({
                data: callData,
                ccipRequest: ccipRequest_,
            })
            : await ccipRequest_({ data: callData, sender, urls });
        const { data: data_ } = await (0, call_js_1.call)(client, {
            blockNumber,
            blockTag,
            data: (0, concat_js_1.concat)([
                callbackSelector,
                (0, encodeAbiParameters_js_1.encodeAbiParameters)([{ type: 'bytes' }, { type: 'bytes' }], [result, extraData]),
            ]),
            to,
        });
        return data_;
    }
    catch (err) {
        throw new ccip_js_1.OffchainLookupError({
            callbackSelector,
            cause: err,
            data,
            extraData,
            sender,
            urls,
        });
    }
}
async function ccipRequest({ data, sender, urls, }) {
    let error = new Error('An unknown error occurred.');
    for (let i = 0; i < urls.length; i++) {
        const url = urls[i];
        const method = url.includes('{data}') ? 'GET' : 'POST';
        const body = method === 'POST' ? { data, sender } : undefined;
        const headers = method === 'POST' ? { 'Content-Type': 'application/json' } : {};
        try {
            const response = await fetch(url.replace('{sender}', sender.toLowerCase()).replace('{data}', data), {
                body: JSON.stringify(body),
                headers,
                method,
            });
            let result;
            if (response.headers.get('Content-Type')?.startsWith('application/json')) {
                result = (await response.json()).data;
            }
            else {
                result = (await response.text());
            }
            if (!response.ok) {
                error = new request_js_1.HttpRequestError({
                    body,
                    details: result?.error
                        ? (0, stringify_js_1.stringify)(result.error)
                        : response.statusText,
                    headers: response.headers,
                    status: response.status,
                    url,
                });
                continue;
            }
            if (!(0, isHex_js_1.isHex)(result)) {
                error = new ccip_js_1.OffchainLookupResponseMalformedError({
                    result,
                    url,
                });
                continue;
            }
            return result;
        }
        catch (err) {
            error = new request_js_1.HttpRequestError({
                body,
                details: err.message,
                url,
            });
        }
    }
    throw error;
}
//# sourceMappingURL=ccip.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/utils/chain/assertCurrentChain.js":
/*!******************************************************************!*\
  !*** ./node_modules/viem/_cjs/utils/chain/assertCurrentChain.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.assertCurrentChain = assertCurrentChain;
const chain_js_1 = __webpack_require__(/*! ../../errors/chain.js */ "./node_modules/viem/_cjs/errors/chain.js");
function assertCurrentChain({ chain, currentChainId, }) {
    if (!chain)
        throw new chain_js_1.ChainNotFoundError();
    if (currentChainId !== chain.id)
        throw new chain_js_1.ChainMismatchError({ chain, currentChainId });
}
//# sourceMappingURL=assertCurrentChain.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/utils/chain/defineChain.js":
/*!***********************************************************!*\
  !*** ./node_modules/viem/_cjs/utils/chain/defineChain.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.defineChain = defineChain;
function defineChain(chain) {
    return {
        formatters: undefined,
        fees: undefined,
        serializers: undefined,
        ...chain,
    };
}
//# sourceMappingURL=defineChain.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/utils/chain/extractChain.js":
/*!************************************************************!*\
  !*** ./node_modules/viem/_cjs/utils/chain/extractChain.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.extractChain = extractChain;
function extractChain({ chains, id, }) {
    return chains.find((chain) => chain.id === id);
}
//# sourceMappingURL=extractChain.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/utils/chain/getChainContractAddress.js":
/*!***********************************************************************!*\
  !*** ./node_modules/viem/_cjs/utils/chain/getChainContractAddress.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getChainContractAddress = getChainContractAddress;
const chain_js_1 = __webpack_require__(/*! ../../errors/chain.js */ "./node_modules/viem/_cjs/errors/chain.js");
function getChainContractAddress({ blockNumber, chain, contract: name, }) {
    const contract = chain?.contracts?.[name];
    if (!contract)
        throw new chain_js_1.ChainDoesNotSupportContract({
            chain,
            contract: { name },
        });
    if (blockNumber &&
        contract.blockCreated &&
        contract.blockCreated > blockNumber)
        throw new chain_js_1.ChainDoesNotSupportContract({
            blockNumber,
            chain,
            contract: {
                name,
                blockCreated: contract.blockCreated,
            },
        });
    return contract.address;
}
//# sourceMappingURL=getChainContractAddress.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/utils/cursor.js":
/*!************************************************!*\
  !*** ./node_modules/viem/_cjs/utils/cursor.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createCursor = createCursor;
const cursor_js_1 = __webpack_require__(/*! ../errors/cursor.js */ "./node_modules/viem/_cjs/errors/cursor.js");
const staticCursor = {
    bytes: new Uint8Array(),
    dataView: new DataView(new ArrayBuffer(0)),
    position: 0,
    positionReadCount: new Map(),
    recursiveReadCount: 0,
    recursiveReadLimit: Number.POSITIVE_INFINITY,
    assertReadLimit() {
        if (this.recursiveReadCount >= this.recursiveReadLimit)
            throw new cursor_js_1.RecursiveReadLimitExceededError({
                count: this.recursiveReadCount + 1,
                limit: this.recursiveReadLimit,
            });
    },
    assertPosition(position) {
        if (position < 0 || position > this.bytes.length - 1)
            throw new cursor_js_1.PositionOutOfBoundsError({
                length: this.bytes.length,
                position,
            });
    },
    decrementPosition(offset) {
        if (offset < 0)
            throw new cursor_js_1.NegativeOffsetError({ offset });
        const position = this.position - offset;
        this.assertPosition(position);
        this.position = position;
    },
    getReadCount(position) {
        return this.positionReadCount.get(position || this.position) || 0;
    },
    incrementPosition(offset) {
        if (offset < 0)
            throw new cursor_js_1.NegativeOffsetError({ offset });
        const position = this.position + offset;
        this.assertPosition(position);
        this.position = position;
    },
    inspectByte(position_) {
        const position = position_ ?? this.position;
        this.assertPosition(position);
        return this.bytes[position];
    },
    inspectBytes(length, position_) {
        const position = position_ ?? this.position;
        this.assertPosition(position + length - 1);
        return this.bytes.subarray(position, position + length);
    },
    inspectUint8(position_) {
        const position = position_ ?? this.position;
        this.assertPosition(position);
        return this.bytes[position];
    },
    inspectUint16(position_) {
        const position = position_ ?? this.position;
        this.assertPosition(position + 1);
        return this.dataView.getUint16(position);
    },
    inspectUint24(position_) {
        const position = position_ ?? this.position;
        this.assertPosition(position + 2);
        return ((this.dataView.getUint16(position) << 8) +
            this.dataView.getUint8(position + 2));
    },
    inspectUint32(position_) {
        const position = position_ ?? this.position;
        this.assertPosition(position + 3);
        return this.dataView.getUint32(position);
    },
    pushByte(byte) {
        this.assertPosition(this.position);
        this.bytes[this.position] = byte;
        this.position++;
    },
    pushBytes(bytes) {
        this.assertPosition(this.position + bytes.length - 1);
        this.bytes.set(bytes, this.position);
        this.position += bytes.length;
    },
    pushUint8(value) {
        this.assertPosition(this.position);
        this.bytes[this.position] = value;
        this.position++;
    },
    pushUint16(value) {
        this.assertPosition(this.position + 1);
        this.dataView.setUint16(this.position, value);
        this.position += 2;
    },
    pushUint24(value) {
        this.assertPosition(this.position + 2);
        this.dataView.setUint16(this.position, value >> 8);
        this.dataView.setUint8(this.position + 2, value & ~4294967040);
        this.position += 3;
    },
    pushUint32(value) {
        this.assertPosition(this.position + 3);
        this.dataView.setUint32(this.position, value);
        this.position += 4;
    },
    readByte() {
        this.assertReadLimit();
        this._touch();
        const value = this.inspectByte();
        this.position++;
        return value;
    },
    readBytes(length, size) {
        this.assertReadLimit();
        this._touch();
        const value = this.inspectBytes(length);
        this.position += size ?? length;
        return value;
    },
    readUint8() {
        this.assertReadLimit();
        this._touch();
        const value = this.inspectUint8();
        this.position += 1;
        return value;
    },
    readUint16() {
        this.assertReadLimit();
        this._touch();
        const value = this.inspectUint16();
        this.position += 2;
        return value;
    },
    readUint24() {
        this.assertReadLimit();
        this._touch();
        const value = this.inspectUint24();
        this.position += 3;
        return value;
    },
    readUint32() {
        this.assertReadLimit();
        this._touch();
        const value = this.inspectUint32();
        this.position += 4;
        return value;
    },
    get remaining() {
        return this.bytes.length - this.position;
    },
    setPosition(position) {
        const oldPosition = this.position;
        this.assertPosition(position);
        this.position = position;
        return () => (this.position = oldPosition);
    },
    _touch() {
        if (this.recursiveReadLimit === Number.POSITIVE_INFINITY)
            return;
        const count = this.getReadCount();
        this.positionReadCount.set(this.position, count + 1);
        if (count > 0)
            this.recursiveReadCount++;
    },
};
function createCursor(bytes, { recursiveReadLimit = 8_192 } = {}) {
    const cursor = Object.create(staticCursor);
    cursor.bytes = bytes;
    cursor.dataView = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);
    cursor.positionReadCount = new Map();
    cursor.recursiveReadLimit = recursiveReadLimit;
    return cursor;
}
//# sourceMappingURL=cursor.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/utils/data/concat.js":
/*!*****************************************************!*\
  !*** ./node_modules/viem/_cjs/utils/data/concat.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.concat = concat;
exports.concatBytes = concatBytes;
exports.concatHex = concatHex;
function concat(values) {
    if (typeof values[0] === 'string')
        return concatHex(values);
    return concatBytes(values);
}
function concatBytes(values) {
    let length = 0;
    for (const arr of values) {
        length += arr.length;
    }
    const result = new Uint8Array(length);
    let offset = 0;
    for (const arr of values) {
        result.set(arr, offset);
        offset += arr.length;
    }
    return result;
}
function concatHex(values) {
    return `0x${values.reduce((acc, x) => acc + x.replace('0x', ''), '')}`;
}
//# sourceMappingURL=concat.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/utils/data/isBytes.js":
/*!******************************************************!*\
  !*** ./node_modules/viem/_cjs/utils/data/isBytes.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isBytes = isBytes;
function isBytes(value) {
    if (!value)
        return false;
    if (typeof value !== 'object')
        return false;
    if (!('BYTES_PER_ELEMENT' in value))
        return false;
    return (value.BYTES_PER_ELEMENT === 1 && value.constructor.name === 'Uint8Array');
}
//# sourceMappingURL=isBytes.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/utils/data/isHex.js":
/*!****************************************************!*\
  !*** ./node_modules/viem/_cjs/utils/data/isHex.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isHex = isHex;
function isHex(value, { strict = true } = {}) {
    if (!value)
        return false;
    if (typeof value !== 'string')
        return false;
    return strict ? /^0x[0-9a-fA-F]*$/.test(value) : value.startsWith('0x');
}
//# sourceMappingURL=isHex.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/utils/data/pad.js":
/*!**************************************************!*\
  !*** ./node_modules/viem/_cjs/utils/data/pad.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.pad = pad;
exports.padHex = padHex;
exports.padBytes = padBytes;
const data_js_1 = __webpack_require__(/*! ../../errors/data.js */ "./node_modules/viem/_cjs/errors/data.js");
function pad(hexOrBytes, { dir, size = 32 } = {}) {
    if (typeof hexOrBytes === 'string')
        return padHex(hexOrBytes, { dir, size });
    return padBytes(hexOrBytes, { dir, size });
}
function padHex(hex_, { dir, size = 32 } = {}) {
    if (size === null)
        return hex_;
    const hex = hex_.replace('0x', '');
    if (hex.length > size * 2)
        throw new data_js_1.SizeExceedsPaddingSizeError({
            size: Math.ceil(hex.length / 2),
            targetSize: size,
            type: 'hex',
        });
    return `0x${hex[dir === 'right' ? 'padEnd' : 'padStart'](size * 2, '0')}`;
}
function padBytes(bytes, { dir, size = 32 } = {}) {
    if (size === null)
        return bytes;
    if (bytes.length > size)
        throw new data_js_1.SizeExceedsPaddingSizeError({
            size: bytes.length,
            targetSize: size,
            type: 'bytes',
        });
    const paddedBytes = new Uint8Array(size);
    for (let i = 0; i < size; i++) {
        const padEnd = dir === 'right';
        paddedBytes[padEnd ? i : size - i - 1] =
            bytes[padEnd ? i : bytes.length - i - 1];
    }
    return paddedBytes;
}
//# sourceMappingURL=pad.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/utils/data/size.js":
/*!***************************************************!*\
  !*** ./node_modules/viem/_cjs/utils/data/size.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.size = size;
const isHex_js_1 = __webpack_require__(/*! ./isHex.js */ "./node_modules/viem/_cjs/utils/data/isHex.js");
function size(value) {
    if ((0, isHex_js_1.isHex)(value, { strict: false }))
        return Math.ceil((value.length - 2) / 2);
    return value.length;
}
//# sourceMappingURL=size.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/utils/data/slice.js":
/*!****************************************************!*\
  !*** ./node_modules/viem/_cjs/utils/data/slice.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.slice = slice;
exports.sliceBytes = sliceBytes;
exports.sliceHex = sliceHex;
const data_js_1 = __webpack_require__(/*! ../../errors/data.js */ "./node_modules/viem/_cjs/errors/data.js");
const isHex_js_1 = __webpack_require__(/*! ./isHex.js */ "./node_modules/viem/_cjs/utils/data/isHex.js");
const size_js_1 = __webpack_require__(/*! ./size.js */ "./node_modules/viem/_cjs/utils/data/size.js");
function slice(value, start, end, { strict } = {}) {
    if ((0, isHex_js_1.isHex)(value, { strict: false }))
        return sliceHex(value, start, end, {
            strict,
        });
    return sliceBytes(value, start, end, {
        strict,
    });
}
function assertStartOffset(value, start) {
    if (typeof start === 'number' && start > 0 && start > (0, size_js_1.size)(value) - 1)
        throw new data_js_1.SliceOffsetOutOfBoundsError({
            offset: start,
            position: 'start',
            size: (0, size_js_1.size)(value),
        });
}
function assertEndOffset(value, start, end) {
    if (typeof start === 'number' &&
        typeof end === 'number' &&
        (0, size_js_1.size)(value) !== end - start) {
        throw new data_js_1.SliceOffsetOutOfBoundsError({
            offset: end,
            position: 'end',
            size: (0, size_js_1.size)(value),
        });
    }
}
function sliceBytes(value_, start, end, { strict } = {}) {
    assertStartOffset(value_, start);
    const value = value_.slice(start, end);
    if (strict)
        assertEndOffset(value, start, end);
    return value;
}
function sliceHex(value_, start, end, { strict } = {}) {
    assertStartOffset(value_, start);
    const value = `0x${value_
        .replace('0x', '')
        .slice((start ?? 0) * 2, (end ?? value_.length) * 2)}`;
    if (strict)
        assertEndOffset(value, start, end);
    return value;
}
//# sourceMappingURL=slice.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/utils/data/trim.js":
/*!***************************************************!*\
  !*** ./node_modules/viem/_cjs/utils/data/trim.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.trim = trim;
function trim(hexOrBytes, { dir = 'left' } = {}) {
    let data = typeof hexOrBytes === 'string' ? hexOrBytes.replace('0x', '') : hexOrBytes;
    let sliceLength = 0;
    for (let i = 0; i < data.length - 1; i++) {
        if (data[dir === 'left' ? i : data.length - i - 1].toString() === '0')
            sliceLength++;
        else
            break;
    }
    data =
        dir === 'left'
            ? data.slice(sliceLength)
            : data.slice(0, data.length - sliceLength);
    if (typeof hexOrBytes === 'string') {
        if (data.length === 1 && dir === 'right')
            data = `${data}0`;
        return `0x${data.length % 2 === 1 ? `0${data}` : data}`;
    }
    return data;
}
//# sourceMappingURL=trim.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/utils/encoding/fromBytes.js":
/*!************************************************************!*\
  !*** ./node_modules/viem/_cjs/utils/encoding/fromBytes.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.fromBytes = fromBytes;
exports.bytesToBigInt = bytesToBigInt;
exports.bytesToBool = bytesToBool;
exports.bytesToNumber = bytesToNumber;
exports.bytesToString = bytesToString;
const encoding_js_1 = __webpack_require__(/*! ../../errors/encoding.js */ "./node_modules/viem/_cjs/errors/encoding.js");
const trim_js_1 = __webpack_require__(/*! ../data/trim.js */ "./node_modules/viem/_cjs/utils/data/trim.js");
const fromHex_js_1 = __webpack_require__(/*! ./fromHex.js */ "./node_modules/viem/_cjs/utils/encoding/fromHex.js");
const toHex_js_1 = __webpack_require__(/*! ./toHex.js */ "./node_modules/viem/_cjs/utils/encoding/toHex.js");
function fromBytes(bytes, toOrOpts) {
    const opts = typeof toOrOpts === 'string' ? { to: toOrOpts } : toOrOpts;
    const to = opts.to;
    if (to === 'number')
        return bytesToNumber(bytes, opts);
    if (to === 'bigint')
        return bytesToBigInt(bytes, opts);
    if (to === 'boolean')
        return bytesToBool(bytes, opts);
    if (to === 'string')
        return bytesToString(bytes, opts);
    return (0, toHex_js_1.bytesToHex)(bytes, opts);
}
function bytesToBigInt(bytes, opts = {}) {
    if (typeof opts.size !== 'undefined')
        (0, fromHex_js_1.assertSize)(bytes, { size: opts.size });
    const hex = (0, toHex_js_1.bytesToHex)(bytes, opts);
    return (0, fromHex_js_1.hexToBigInt)(hex, opts);
}
function bytesToBool(bytes_, opts = {}) {
    let bytes = bytes_;
    if (typeof opts.size !== 'undefined') {
        (0, fromHex_js_1.assertSize)(bytes, { size: opts.size });
        bytes = (0, trim_js_1.trim)(bytes);
    }
    if (bytes.length > 1 || bytes[0] > 1)
        throw new encoding_js_1.InvalidBytesBooleanError(bytes);
    return Boolean(bytes[0]);
}
function bytesToNumber(bytes, opts = {}) {
    if (typeof opts.size !== 'undefined')
        (0, fromHex_js_1.assertSize)(bytes, { size: opts.size });
    const hex = (0, toHex_js_1.bytesToHex)(bytes, opts);
    return (0, fromHex_js_1.hexToNumber)(hex, opts);
}
function bytesToString(bytes_, opts = {}) {
    let bytes = bytes_;
    if (typeof opts.size !== 'undefined') {
        (0, fromHex_js_1.assertSize)(bytes, { size: opts.size });
        bytes = (0, trim_js_1.trim)(bytes, { dir: 'right' });
    }
    return new TextDecoder().decode(bytes);
}
//# sourceMappingURL=fromBytes.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/utils/encoding/fromHex.js":
/*!**********************************************************!*\
  !*** ./node_modules/viem/_cjs/utils/encoding/fromHex.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.assertSize = assertSize;
exports.fromHex = fromHex;
exports.hexToBigInt = hexToBigInt;
exports.hexToBool = hexToBool;
exports.hexToNumber = hexToNumber;
exports.hexToString = hexToString;
const encoding_js_1 = __webpack_require__(/*! ../../errors/encoding.js */ "./node_modules/viem/_cjs/errors/encoding.js");
const size_js_1 = __webpack_require__(/*! ../data/size.js */ "./node_modules/viem/_cjs/utils/data/size.js");
const trim_js_1 = __webpack_require__(/*! ../data/trim.js */ "./node_modules/viem/_cjs/utils/data/trim.js");
const toBytes_js_1 = __webpack_require__(/*! ./toBytes.js */ "./node_modules/viem/_cjs/utils/encoding/toBytes.js");
function assertSize(hexOrBytes, { size }) {
    if ((0, size_js_1.size)(hexOrBytes) > size)
        throw new encoding_js_1.SizeOverflowError({
            givenSize: (0, size_js_1.size)(hexOrBytes),
            maxSize: size,
        });
}
function fromHex(hex, toOrOpts) {
    const opts = typeof toOrOpts === 'string' ? { to: toOrOpts } : toOrOpts;
    const to = opts.to;
    if (to === 'number')
        return hexToNumber(hex, opts);
    if (to === 'bigint')
        return hexToBigInt(hex, opts);
    if (to === 'string')
        return hexToString(hex, opts);
    if (to === 'boolean')
        return hexToBool(hex, opts);
    return (0, toBytes_js_1.hexToBytes)(hex, opts);
}
function hexToBigInt(hex, opts = {}) {
    const { signed } = opts;
    if (opts.size)
        assertSize(hex, { size: opts.size });
    const value = BigInt(hex);
    if (!signed)
        return value;
    const size = (hex.length - 2) / 2;
    const max = (1n << (BigInt(size) * 8n - 1n)) - 1n;
    if (value <= max)
        return value;
    return value - BigInt(`0x${'f'.padStart(size * 2, 'f')}`) - 1n;
}
function hexToBool(hex_, opts = {}) {
    let hex = hex_;
    if (opts.size) {
        assertSize(hex, { size: opts.size });
        hex = (0, trim_js_1.trim)(hex);
    }
    if ((0, trim_js_1.trim)(hex) === '0x00')
        return false;
    if ((0, trim_js_1.trim)(hex) === '0x01')
        return true;
    throw new encoding_js_1.InvalidHexBooleanError(hex);
}
function hexToNumber(hex, opts = {}) {
    return Number(hexToBigInt(hex, opts));
}
function hexToString(hex, opts = {}) {
    let bytes = (0, toBytes_js_1.hexToBytes)(hex);
    if (opts.size) {
        assertSize(bytes, { size: opts.size });
        bytes = (0, trim_js_1.trim)(bytes, { dir: 'right' });
    }
    return new TextDecoder().decode(bytes);
}
//# sourceMappingURL=fromHex.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/utils/encoding/fromRlp.js":
/*!**********************************************************!*\
  !*** ./node_modules/viem/_cjs/utils/encoding/fromRlp.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.fromRlp = fromRlp;
const base_js_1 = __webpack_require__(/*! ../../errors/base.js */ "./node_modules/viem/_cjs/errors/base.js");
const encoding_js_1 = __webpack_require__(/*! ../../errors/encoding.js */ "./node_modules/viem/_cjs/errors/encoding.js");
const cursor_js_1 = __webpack_require__(/*! ../cursor.js */ "./node_modules/viem/_cjs/utils/cursor.js");
const toBytes_js_1 = __webpack_require__(/*! ./toBytes.js */ "./node_modules/viem/_cjs/utils/encoding/toBytes.js");
const toHex_js_1 = __webpack_require__(/*! ./toHex.js */ "./node_modules/viem/_cjs/utils/encoding/toHex.js");
function fromRlp(value, to = 'hex') {
    const bytes = (() => {
        if (typeof value === 'string') {
            if (value.length > 3 && value.length % 2 !== 0)
                throw new encoding_js_1.InvalidHexValueError(value);
            return (0, toBytes_js_1.hexToBytes)(value);
        }
        return value;
    })();
    const cursor = (0, cursor_js_1.createCursor)(bytes, {
        recursiveReadLimit: Number.POSITIVE_INFINITY,
    });
    const result = fromRlpCursor(cursor, to);
    return result;
}
function fromRlpCursor(cursor, to = 'hex') {
    if (cursor.bytes.length === 0)
        return (to === 'hex' ? (0, toHex_js_1.bytesToHex)(cursor.bytes) : cursor.bytes);
    const prefix = cursor.readByte();
    if (prefix < 0x80)
        cursor.decrementPosition(1);
    if (prefix < 0xc0) {
        const length = readLength(cursor, prefix, 0x80);
        const bytes = cursor.readBytes(length);
        return (to === 'hex' ? (0, toHex_js_1.bytesToHex)(bytes) : bytes);
    }
    const length = readLength(cursor, prefix, 0xc0);
    return readList(cursor, length, to);
}
function readLength(cursor, prefix, offset) {
    if (offset === 0x80 && prefix < 0x80)
        return 1;
    if (prefix <= offset + 55)
        return prefix - offset;
    if (prefix === offset + 55 + 1)
        return cursor.readUint8();
    if (prefix === offset + 55 + 2)
        return cursor.readUint16();
    if (prefix === offset + 55 + 3)
        return cursor.readUint24();
    if (prefix === offset + 55 + 4)
        return cursor.readUint32();
    throw new base_js_1.BaseError('Invalid RLP prefix');
}
function readList(cursor, length, to) {
    const position = cursor.position;
    const value = [];
    while (cursor.position - position < length)
        value.push(fromRlpCursor(cursor, to));
    return value;
}
//# sourceMappingURL=fromRlp.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/utils/encoding/toBytes.js":
/*!**********************************************************!*\
  !*** ./node_modules/viem/_cjs/utils/encoding/toBytes.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.toBytes = toBytes;
exports.boolToBytes = boolToBytes;
exports.hexToBytes = hexToBytes;
exports.numberToBytes = numberToBytes;
exports.stringToBytes = stringToBytes;
const base_js_1 = __webpack_require__(/*! ../../errors/base.js */ "./node_modules/viem/_cjs/errors/base.js");
const isHex_js_1 = __webpack_require__(/*! ../data/isHex.js */ "./node_modules/viem/_cjs/utils/data/isHex.js");
const pad_js_1 = __webpack_require__(/*! ../data/pad.js */ "./node_modules/viem/_cjs/utils/data/pad.js");
const fromHex_js_1 = __webpack_require__(/*! ./fromHex.js */ "./node_modules/viem/_cjs/utils/encoding/fromHex.js");
const toHex_js_1 = __webpack_require__(/*! ./toHex.js */ "./node_modules/viem/_cjs/utils/encoding/toHex.js");
const encoder = new TextEncoder();
function toBytes(value, opts = {}) {
    if (typeof value === 'number' || typeof value === 'bigint')
        return numberToBytes(value, opts);
    if (typeof value === 'boolean')
        return boolToBytes(value, opts);
    if ((0, isHex_js_1.isHex)(value))
        return hexToBytes(value, opts);
    return stringToBytes(value, opts);
}
function boolToBytes(value, opts = {}) {
    const bytes = new Uint8Array(1);
    bytes[0] = Number(value);
    if (typeof opts.size === 'number') {
        (0, fromHex_js_1.assertSize)(bytes, { size: opts.size });
        return (0, pad_js_1.pad)(bytes, { size: opts.size });
    }
    return bytes;
}
const charCodeMap = {
    zero: 48,
    nine: 57,
    A: 65,
    F: 70,
    a: 97,
    f: 102,
};
function charCodeToBase16(char) {
    if (char >= charCodeMap.zero && char <= charCodeMap.nine)
        return char - charCodeMap.zero;
    if (char >= charCodeMap.A && char <= charCodeMap.F)
        return char - (charCodeMap.A - 10);
    if (char >= charCodeMap.a && char <= charCodeMap.f)
        return char - (charCodeMap.a - 10);
    return undefined;
}
function hexToBytes(hex_, opts = {}) {
    let hex = hex_;
    if (opts.size) {
        (0, fromHex_js_1.assertSize)(hex, { size: opts.size });
        hex = (0, pad_js_1.pad)(hex, { dir: 'right', size: opts.size });
    }
    let hexString = hex.slice(2);
    if (hexString.length % 2)
        hexString = `0${hexString}`;
    const length = hexString.length / 2;
    const bytes = new Uint8Array(length);
    for (let index = 0, j = 0; index < length; index++) {
        const nibbleLeft = charCodeToBase16(hexString.charCodeAt(j++));
        const nibbleRight = charCodeToBase16(hexString.charCodeAt(j++));
        if (nibbleLeft === undefined || nibbleRight === undefined) {
            throw new base_js_1.BaseError(`Invalid byte sequence ("${hexString[j - 2]}${hexString[j - 1]}" in "${hexString}").`);
        }
        bytes[index] = nibbleLeft * 16 + nibbleRight;
    }
    return bytes;
}
function numberToBytes(value, opts) {
    const hex = (0, toHex_js_1.numberToHex)(value, opts);
    return hexToBytes(hex);
}
function stringToBytes(value, opts = {}) {
    const bytes = encoder.encode(value);
    if (typeof opts.size === 'number') {
        (0, fromHex_js_1.assertSize)(bytes, { size: opts.size });
        return (0, pad_js_1.pad)(bytes, { dir: 'right', size: opts.size });
    }
    return bytes;
}
//# sourceMappingURL=toBytes.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/utils/encoding/toHex.js":
/*!********************************************************!*\
  !*** ./node_modules/viem/_cjs/utils/encoding/toHex.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.toHex = toHex;
exports.boolToHex = boolToHex;
exports.bytesToHex = bytesToHex;
exports.numberToHex = numberToHex;
exports.stringToHex = stringToHex;
const encoding_js_1 = __webpack_require__(/*! ../../errors/encoding.js */ "./node_modules/viem/_cjs/errors/encoding.js");
const pad_js_1 = __webpack_require__(/*! ../data/pad.js */ "./node_modules/viem/_cjs/utils/data/pad.js");
const fromHex_js_1 = __webpack_require__(/*! ./fromHex.js */ "./node_modules/viem/_cjs/utils/encoding/fromHex.js");
const hexes = Array.from({ length: 256 }, (_v, i) => i.toString(16).padStart(2, '0'));
function toHex(value, opts = {}) {
    if (typeof value === 'number' || typeof value === 'bigint')
        return numberToHex(value, opts);
    if (typeof value === 'string') {
        return stringToHex(value, opts);
    }
    if (typeof value === 'boolean')
        return boolToHex(value, opts);
    return bytesToHex(value, opts);
}
function boolToHex(value, opts = {}) {
    const hex = `0x${Number(value)}`;
    if (typeof opts.size === 'number') {
        (0, fromHex_js_1.assertSize)(hex, { size: opts.size });
        return (0, pad_js_1.pad)(hex, { size: opts.size });
    }
    return hex;
}
function bytesToHex(value, opts = {}) {
    let string = '';
    for (let i = 0; i < value.length; i++) {
        string += hexes[value[i]];
    }
    const hex = `0x${string}`;
    if (typeof opts.size === 'number') {
        (0, fromHex_js_1.assertSize)(hex, { size: opts.size });
        return (0, pad_js_1.pad)(hex, { dir: 'right', size: opts.size });
    }
    return hex;
}
function numberToHex(value_, opts = {}) {
    const { signed, size } = opts;
    const value = BigInt(value_);
    let maxValue;
    if (size) {
        if (signed)
            maxValue = (1n << (BigInt(size) * 8n - 1n)) - 1n;
        else
            maxValue = 2n ** (BigInt(size) * 8n) - 1n;
    }
    else if (typeof value_ === 'number') {
        maxValue = BigInt(Number.MAX_SAFE_INTEGER);
    }
    const minValue = typeof maxValue === 'bigint' && signed ? -maxValue - 1n : 0;
    if ((maxValue && value > maxValue) || value < minValue) {
        const suffix = typeof value_ === 'bigint' ? 'n' : '';
        throw new encoding_js_1.IntegerOutOfRangeError({
            max: maxValue ? `${maxValue}${suffix}` : undefined,
            min: `${minValue}${suffix}`,
            signed,
            size,
            value: `${value_}${suffix}`,
        });
    }
    const hex = `0x${(signed && value < 0 ? (1n << BigInt(size * 8)) + BigInt(value) : value).toString(16)}`;
    if (size)
        return (0, pad_js_1.pad)(hex, { size });
    return hex;
}
const encoder = new TextEncoder();
function stringToHex(value_, opts = {}) {
    const value = encoder.encode(value_);
    return bytesToHex(value, opts);
}
//# sourceMappingURL=toHex.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/utils/encoding/toRlp.js":
/*!********************************************************!*\
  !*** ./node_modules/viem/_cjs/utils/encoding/toRlp.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.toRlp = toRlp;
exports.bytesToRlp = bytesToRlp;
exports.hexToRlp = hexToRlp;
const base_js_1 = __webpack_require__(/*! ../../errors/base.js */ "./node_modules/viem/_cjs/errors/base.js");
const cursor_js_1 = __webpack_require__(/*! ../cursor.js */ "./node_modules/viem/_cjs/utils/cursor.js");
const toBytes_js_1 = __webpack_require__(/*! ./toBytes.js */ "./node_modules/viem/_cjs/utils/encoding/toBytes.js");
const toHex_js_1 = __webpack_require__(/*! ./toHex.js */ "./node_modules/viem/_cjs/utils/encoding/toHex.js");
function toRlp(bytes, to = 'hex') {
    const encodable = getEncodable(bytes);
    const cursor = (0, cursor_js_1.createCursor)(new Uint8Array(encodable.length));
    encodable.encode(cursor);
    if (to === 'hex')
        return (0, toHex_js_1.bytesToHex)(cursor.bytes);
    return cursor.bytes;
}
function bytesToRlp(bytes, to = 'bytes') {
    return toRlp(bytes, to);
}
function hexToRlp(hex, to = 'hex') {
    return toRlp(hex, to);
}
function getEncodable(bytes) {
    if (Array.isArray(bytes))
        return getEncodableList(bytes.map((x) => getEncodable(x)));
    return getEncodableBytes(bytes);
}
function getEncodableList(list) {
    const bodyLength = list.reduce((acc, x) => acc + x.length, 0);
    const sizeOfBodyLength = getSizeOfLength(bodyLength);
    const length = (() => {
        if (bodyLength <= 55)
            return 1 + bodyLength;
        return 1 + sizeOfBodyLength + bodyLength;
    })();
    return {
        length,
        encode(cursor) {
            if (bodyLength <= 55) {
                cursor.pushByte(0xc0 + bodyLength);
            }
            else {
                cursor.pushByte(0xc0 + 55 + sizeOfBodyLength);
                if (sizeOfBodyLength === 1)
                    cursor.pushUint8(bodyLength);
                else if (sizeOfBodyLength === 2)
                    cursor.pushUint16(bodyLength);
                else if (sizeOfBodyLength === 3)
                    cursor.pushUint24(bodyLength);
                else
                    cursor.pushUint32(bodyLength);
            }
            for (const { encode } of list) {
                encode(cursor);
            }
        },
    };
}
function getEncodableBytes(bytesOrHex) {
    const bytes = typeof bytesOrHex === 'string' ? (0, toBytes_js_1.hexToBytes)(bytesOrHex) : bytesOrHex;
    const sizeOfBytesLength = getSizeOfLength(bytes.length);
    const length = (() => {
        if (bytes.length === 1 && bytes[0] < 0x80)
            return 1;
        if (bytes.length <= 55)
            return 1 + bytes.length;
        return 1 + sizeOfBytesLength + bytes.length;
    })();
    return {
        length,
        encode(cursor) {
            if (bytes.length === 1 && bytes[0] < 0x80) {
                cursor.pushBytes(bytes);
            }
            else if (bytes.length <= 55) {
                cursor.pushByte(0x80 + bytes.length);
                cursor.pushBytes(bytes);
            }
            else {
                cursor.pushByte(0x80 + 55 + sizeOfBytesLength);
                if (sizeOfBytesLength === 1)
                    cursor.pushUint8(bytes.length);
                else if (sizeOfBytesLength === 2)
                    cursor.pushUint16(bytes.length);
                else if (sizeOfBytesLength === 3)
                    cursor.pushUint24(bytes.length);
                else
                    cursor.pushUint32(bytes.length);
                cursor.pushBytes(bytes);
            }
        },
    };
}
function getSizeOfLength(length) {
    if (length < 2 ** 8)
        return 1;
    if (length < 2 ** 16)
        return 2;
    if (length < 2 ** 24)
        return 3;
    if (length < 2 ** 32)
        return 4;
    throw new base_js_1.BaseError('Length is too large.');
}
//# sourceMappingURL=toRlp.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/utils/ens/avatar/parseAvatarRecord.js":
/*!**********************************************************************!*\
  !*** ./node_modules/viem/_cjs/utils/ens/avatar/parseAvatarRecord.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.parseAvatarRecord = parseAvatarRecord;
const utils_js_1 = __webpack_require__(/*! ./utils.js */ "./node_modules/viem/_cjs/utils/ens/avatar/utils.js");
async function parseAvatarRecord(client, { gatewayUrls, record, }) {
    if (/eip155:/i.test(record))
        return parseNftAvatarUri(client, { gatewayUrls, record });
    return (0, utils_js_1.parseAvatarUri)({ uri: record, gatewayUrls });
}
async function parseNftAvatarUri(client, { gatewayUrls, record, }) {
    const nft = (0, utils_js_1.parseNftUri)(record);
    const nftUri = await (0, utils_js_1.getNftTokenUri)(client, { nft });
    const { uri: resolvedNftUri, isOnChain, isEncoded, } = (0, utils_js_1.resolveAvatarUri)({ uri: nftUri, gatewayUrls });
    if (isOnChain &&
        (resolvedNftUri.includes('data:application/json;base64,') ||
            resolvedNftUri.startsWith('{'))) {
        const encodedJson = isEncoded
            ?
                atob(resolvedNftUri.replace('data:application/json;base64,', ''))
            :
                resolvedNftUri;
        const decoded = JSON.parse(encodedJson);
        return (0, utils_js_1.parseAvatarUri)({ uri: (0, utils_js_1.getJsonImage)(decoded), gatewayUrls });
    }
    let uriTokenId = nft.tokenID;
    if (nft.namespace === 'erc1155')
        uriTokenId = uriTokenId.replace('0x', '').padStart(64, '0');
    return (0, utils_js_1.getMetadataAvatarUri)({
        gatewayUrls,
        uri: resolvedNftUri.replace(/(?:0x)?{id}/, uriTokenId),
    });
}
//# sourceMappingURL=parseAvatarRecord.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/utils/ens/avatar/utils.js":
/*!**********************************************************!*\
  !*** ./node_modules/viem/_cjs/utils/ens/avatar/utils.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isImageUri = isImageUri;
exports.getGateway = getGateway;
exports.resolveAvatarUri = resolveAvatarUri;
exports.getJsonImage = getJsonImage;
exports.getMetadataAvatarUri = getMetadataAvatarUri;
exports.parseAvatarUri = parseAvatarUri;
exports.parseNftUri = parseNftUri;
exports.getNftTokenUri = getNftTokenUri;
const readContract_js_1 = __webpack_require__(/*! ../../../actions/public/readContract.js */ "./node_modules/viem/_cjs/actions/public/readContract.js");
const ens_js_1 = __webpack_require__(/*! ../../../errors/ens.js */ "./node_modules/viem/_cjs/errors/ens.js");
const networkRegex = /(?<protocol>https?:\/\/[^/]*|ipfs:\/|ipns:\/|ar:\/)?(?<root>\/)?(?<subpath>ipfs\/|ipns\/)?(?<target>[\w\-.]+)(?<subtarget>\/.*)?/;
const ipfsHashRegex = /^(Qm[1-9A-HJ-NP-Za-km-z]{44,}|b[A-Za-z2-7]{58,}|B[A-Z2-7]{58,}|z[1-9A-HJ-NP-Za-km-z]{48,}|F[0-9A-F]{50,})(\/(?<target>[\w\-.]+))?(?<subtarget>\/.*)?$/;
const base64Regex = /^data:([a-zA-Z\-/+]*);base64,([^"].*)/;
const dataURIRegex = /^data:([a-zA-Z\-/+]*)?(;[a-zA-Z0-9].*?)?(,)/;
async function isImageUri(uri) {
    try {
        const res = await fetch(uri, { method: 'HEAD' });
        if (res.status === 200) {
            const contentType = res.headers.get('content-type');
            return contentType?.startsWith('image/');
        }
        return false;
    }
    catch (error) {
        if (typeof error === 'object' && typeof error.response !== 'undefined') {
            return false;
        }
        if (!Object.hasOwn(globalThis, 'Image'))
            return false;
        return new Promise((resolve) => {
            const img = new Image();
            img.onload = () => {
                resolve(true);
            };
            img.onerror = () => {
                resolve(false);
            };
            img.src = uri;
        });
    }
}
function getGateway(custom, defaultGateway) {
    if (!custom)
        return defaultGateway;
    if (custom.endsWith('/'))
        return custom.slice(0, -1);
    return custom;
}
function resolveAvatarUri({ uri, gatewayUrls, }) {
    const isEncoded = base64Regex.test(uri);
    if (isEncoded)
        return { uri, isOnChain: true, isEncoded };
    const ipfsGateway = getGateway(gatewayUrls?.ipfs, 'https://ipfs.io');
    const arweaveGateway = getGateway(gatewayUrls?.arweave, 'https://arweave.net');
    const networkRegexMatch = uri.match(networkRegex);
    const { protocol, subpath, target, subtarget = '', } = networkRegexMatch?.groups || {};
    const isIPNS = protocol === 'ipns:/' || subpath === 'ipns/';
    const isIPFS = protocol === 'ipfs:/' || subpath === 'ipfs/' || ipfsHashRegex.test(uri);
    if (uri.startsWith('http') && !isIPNS && !isIPFS) {
        let replacedUri = uri;
        if (gatewayUrls?.arweave)
            replacedUri = uri.replace(/https:\/\/arweave.net/g, gatewayUrls?.arweave);
        return { uri: replacedUri, isOnChain: false, isEncoded: false };
    }
    if ((isIPNS || isIPFS) && target) {
        return {
            uri: `${ipfsGateway}/${isIPNS ? 'ipns' : 'ipfs'}/${target}${subtarget}`,
            isOnChain: false,
            isEncoded: false,
        };
    }
    if (protocol === 'ar:/' && target) {
        return {
            uri: `${arweaveGateway}/${target}${subtarget || ''}`,
            isOnChain: false,
            isEncoded: false,
        };
    }
    let parsedUri = uri.replace(dataURIRegex, '');
    if (parsedUri.startsWith('<svg')) {
        parsedUri = `data:image/svg+xml;base64,${btoa(parsedUri)}`;
    }
    if (parsedUri.startsWith('data:') || parsedUri.startsWith('{')) {
        return {
            uri: parsedUri,
            isOnChain: true,
            isEncoded: false,
        };
    }
    throw new ens_js_1.EnsAvatarUriResolutionError({ uri });
}
function getJsonImage(data) {
    if (typeof data !== 'object' ||
        (!('image' in data) && !('image_url' in data) && !('image_data' in data))) {
        throw new ens_js_1.EnsAvatarInvalidMetadataError({ data });
    }
    return data.image || data.image_url || data.image_data;
}
async function getMetadataAvatarUri({ gatewayUrls, uri, }) {
    try {
        const res = await fetch(uri).then((res) => res.json());
        const image = await parseAvatarUri({
            gatewayUrls,
            uri: getJsonImage(res),
        });
        return image;
    }
    catch {
        throw new ens_js_1.EnsAvatarUriResolutionError({ uri });
    }
}
async function parseAvatarUri({ gatewayUrls, uri, }) {
    const { uri: resolvedURI, isOnChain } = resolveAvatarUri({ uri, gatewayUrls });
    if (isOnChain)
        return resolvedURI;
    const isImage = await isImageUri(resolvedURI);
    if (isImage)
        return resolvedURI;
    throw new ens_js_1.EnsAvatarUriResolutionError({ uri });
}
function parseNftUri(uri_) {
    let uri = uri_;
    if (uri.startsWith('did:nft:')) {
        uri = uri.replace('did:nft:', '').replace(/_/g, '/');
    }
    const [reference, asset_namespace, tokenID] = uri.split('/');
    const [eip_namespace, chainID] = reference.split(':');
    const [erc_namespace, contractAddress] = asset_namespace.split(':');
    if (!eip_namespace || eip_namespace.toLowerCase() !== 'eip155')
        throw new ens_js_1.EnsAvatarInvalidNftUriError({ reason: 'Only EIP-155 supported' });
    if (!chainID)
        throw new ens_js_1.EnsAvatarInvalidNftUriError({ reason: 'Chain ID not found' });
    if (!contractAddress)
        throw new ens_js_1.EnsAvatarInvalidNftUriError({
            reason: 'Contract address not found',
        });
    if (!tokenID)
        throw new ens_js_1.EnsAvatarInvalidNftUriError({ reason: 'Token ID not found' });
    if (!erc_namespace)
        throw new ens_js_1.EnsAvatarInvalidNftUriError({ reason: 'ERC namespace not found' });
    return {
        chainID: Number.parseInt(chainID, 10),
        namespace: erc_namespace.toLowerCase(),
        contractAddress: contractAddress,
        tokenID,
    };
}
async function getNftTokenUri(client, { nft }) {
    if (nft.namespace === 'erc721') {
        return (0, readContract_js_1.readContract)(client, {
            address: nft.contractAddress,
            abi: [
                {
                    name: 'tokenURI',
                    type: 'function',
                    stateMutability: 'view',
                    inputs: [{ name: 'tokenId', type: 'uint256' }],
                    outputs: [{ name: '', type: 'string' }],
                },
            ],
            functionName: 'tokenURI',
            args: [BigInt(nft.tokenID)],
        });
    }
    if (nft.namespace === 'erc1155') {
        return (0, readContract_js_1.readContract)(client, {
            address: nft.contractAddress,
            abi: [
                {
                    name: 'uri',
                    type: 'function',
                    stateMutability: 'view',
                    inputs: [{ name: '_id', type: 'uint256' }],
                    outputs: [{ name: '', type: 'string' }],
                },
            ],
            functionName: 'uri',
            args: [BigInt(nft.tokenID)],
        });
    }
    throw new ens_js_1.EnsAvatarUnsupportedNamespaceError({ namespace: nft.namespace });
}
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/utils/ens/encodeLabelhash.js":
/*!*************************************************************!*\
  !*** ./node_modules/viem/_cjs/utils/ens/encodeLabelhash.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.encodeLabelhash = encodeLabelhash;
function encodeLabelhash(hash) {
    return `[${hash.slice(2)}]`;
}
//# sourceMappingURL=encodeLabelhash.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/utils/ens/encodedLabelToLabelhash.js":
/*!*********************************************************************!*\
  !*** ./node_modules/viem/_cjs/utils/ens/encodedLabelToLabelhash.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.encodedLabelToLabelhash = encodedLabelToLabelhash;
const isHex_js_1 = __webpack_require__(/*! ../data/isHex.js */ "./node_modules/viem/_cjs/utils/data/isHex.js");
function encodedLabelToLabelhash(label) {
    if (label.length !== 66)
        return null;
    if (label.indexOf('[') !== 0)
        return null;
    if (label.indexOf(']') !== 65)
        return null;
    const hash = `0x${label.slice(1, 65)}`;
    if (!(0, isHex_js_1.isHex)(hash))
        return null;
    return hash;
}
//# sourceMappingURL=encodedLabelToLabelhash.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/utils/ens/errors.js":
/*!****************************************************!*\
  !*** ./node_modules/viem/_cjs/utils/ens/errors.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isNullUniversalResolverError = isNullUniversalResolverError;
const base_js_1 = __webpack_require__(/*! ../../errors/base.js */ "./node_modules/viem/_cjs/errors/base.js");
const contract_js_1 = __webpack_require__(/*! ../../errors/contract.js */ "./node_modules/viem/_cjs/errors/contract.js");
function isNullUniversalResolverError(err) {
    if (!(err instanceof base_js_1.BaseError))
        return false;
    const cause = err.walk((e) => e instanceof contract_js_1.ContractFunctionRevertedError);
    if (!(cause instanceof contract_js_1.ContractFunctionRevertedError))
        return false;
    if (cause.data?.errorName === 'HttpError')
        return true;
    if (cause.data?.errorName === 'ResolverError')
        return true;
    if (cause.data?.errorName === 'ResolverNotContract')
        return true;
    if (cause.data?.errorName === 'ResolverNotFound')
        return true;
    if (cause.data?.errorName === 'ReverseAddressMismatch')
        return true;
    if (cause.data?.errorName === 'UnsupportedResolverProfile')
        return true;
    return false;
}
//# sourceMappingURL=errors.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/utils/ens/labelhash.js":
/*!*******************************************************!*\
  !*** ./node_modules/viem/_cjs/utils/ens/labelhash.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.labelhash = labelhash;
const toBytes_js_1 = __webpack_require__(/*! ../encoding/toBytes.js */ "./node_modules/viem/_cjs/utils/encoding/toBytes.js");
const toHex_js_1 = __webpack_require__(/*! ../encoding/toHex.js */ "./node_modules/viem/_cjs/utils/encoding/toHex.js");
const keccak256_js_1 = __webpack_require__(/*! ../hash/keccak256.js */ "./node_modules/viem/_cjs/utils/hash/keccak256.js");
const encodedLabelToLabelhash_js_1 = __webpack_require__(/*! ./encodedLabelToLabelhash.js */ "./node_modules/viem/_cjs/utils/ens/encodedLabelToLabelhash.js");
function labelhash(label) {
    const result = new Uint8Array(32).fill(0);
    if (!label)
        return (0, toHex_js_1.bytesToHex)(result);
    return (0, encodedLabelToLabelhash_js_1.encodedLabelToLabelhash)(label) || (0, keccak256_js_1.keccak256)((0, toBytes_js_1.stringToBytes)(label));
}
//# sourceMappingURL=labelhash.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/utils/ens/localBatchGatewayRequest.js":
/*!**********************************************************************!*\
  !*** ./node_modules/viem/_cjs/utils/ens/localBatchGatewayRequest.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.localBatchGatewayUrl = void 0;
exports.localBatchGatewayRequest = localBatchGatewayRequest;
const abis_js_1 = __webpack_require__(/*! ../../constants/abis.js */ "./node_modules/viem/_cjs/constants/abis.js");
const solidity_js_1 = __webpack_require__(/*! ../../constants/solidity.js */ "./node_modules/viem/_cjs/constants/solidity.js");
const decodeFunctionData_js_1 = __webpack_require__(/*! ../abi/decodeFunctionData.js */ "./node_modules/viem/_cjs/utils/abi/decodeFunctionData.js");
const encodeErrorResult_js_1 = __webpack_require__(/*! ../abi/encodeErrorResult.js */ "./node_modules/viem/_cjs/utils/abi/encodeErrorResult.js");
const encodeFunctionResult_js_1 = __webpack_require__(/*! ../abi/encodeFunctionResult.js */ "./node_modules/viem/_cjs/utils/abi/encodeFunctionResult.js");
exports.localBatchGatewayUrl = 'x-batch-gateway:true';
async function localBatchGatewayRequest(parameters) {
    const { data, ccipRequest } = parameters;
    const { args: [queries], } = (0, decodeFunctionData_js_1.decodeFunctionData)({ abi: abis_js_1.batchGatewayAbi, data });
    const failures = [];
    const responses = [];
    await Promise.all(queries.map(async (query, i) => {
        try {
            responses[i] = query.urls.includes(exports.localBatchGatewayUrl)
                ? await localBatchGatewayRequest({ data: query.data, ccipRequest })
                : await ccipRequest(query);
            failures[i] = false;
        }
        catch (err) {
            failures[i] = true;
            responses[i] = encodeError(err);
        }
    }));
    return (0, encodeFunctionResult_js_1.encodeFunctionResult)({
        abi: abis_js_1.batchGatewayAbi,
        functionName: 'query',
        result: [failures, responses],
    });
}
function encodeError(error) {
    if (error.name === 'HttpRequestError' && error.status)
        return (0, encodeErrorResult_js_1.encodeErrorResult)({
            abi: abis_js_1.batchGatewayAbi,
            errorName: 'HttpError',
            args: [error.status, error.shortMessage],
        });
    return (0, encodeErrorResult_js_1.encodeErrorResult)({
        abi: [solidity_js_1.solidityError],
        errorName: 'Error',
        args: ['shortMessage' in error ? error.shortMessage : error.message],
    });
}
//# sourceMappingURL=localBatchGatewayRequest.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/utils/ens/namehash.js":
/*!******************************************************!*\
  !*** ./node_modules/viem/_cjs/utils/ens/namehash.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.namehash = namehash;
const concat_js_1 = __webpack_require__(/*! ../data/concat.js */ "./node_modules/viem/_cjs/utils/data/concat.js");
const toBytes_js_1 = __webpack_require__(/*! ../encoding/toBytes.js */ "./node_modules/viem/_cjs/utils/encoding/toBytes.js");
const toHex_js_1 = __webpack_require__(/*! ../encoding/toHex.js */ "./node_modules/viem/_cjs/utils/encoding/toHex.js");
const keccak256_js_1 = __webpack_require__(/*! ../hash/keccak256.js */ "./node_modules/viem/_cjs/utils/hash/keccak256.js");
const encodedLabelToLabelhash_js_1 = __webpack_require__(/*! ./encodedLabelToLabelhash.js */ "./node_modules/viem/_cjs/utils/ens/encodedLabelToLabelhash.js");
function namehash(name) {
    let result = new Uint8Array(32).fill(0);
    if (!name)
        return (0, toHex_js_1.bytesToHex)(result);
    const labels = name.split('.');
    for (let i = labels.length - 1; i >= 0; i -= 1) {
        const hashFromEncodedLabel = (0, encodedLabelToLabelhash_js_1.encodedLabelToLabelhash)(labels[i]);
        const hashed = hashFromEncodedLabel
            ? (0, toBytes_js_1.toBytes)(hashFromEncodedLabel)
            : (0, keccak256_js_1.keccak256)((0, toBytes_js_1.stringToBytes)(labels[i]), 'bytes');
        result = (0, keccak256_js_1.keccak256)((0, concat_js_1.concat)([result, hashed]), 'bytes');
    }
    return (0, toHex_js_1.bytesToHex)(result);
}
//# sourceMappingURL=namehash.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/utils/ens/packetToBytes.js":
/*!***********************************************************!*\
  !*** ./node_modules/viem/_cjs/utils/ens/packetToBytes.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.packetToBytes = packetToBytes;
const toBytes_js_1 = __webpack_require__(/*! ../encoding/toBytes.js */ "./node_modules/viem/_cjs/utils/encoding/toBytes.js");
const encodeLabelhash_js_1 = __webpack_require__(/*! ./encodeLabelhash.js */ "./node_modules/viem/_cjs/utils/ens/encodeLabelhash.js");
const labelhash_js_1 = __webpack_require__(/*! ./labelhash.js */ "./node_modules/viem/_cjs/utils/ens/labelhash.js");
function packetToBytes(packet) {
    const value = packet.replace(/^\.|\.$/gm, '');
    if (value.length === 0)
        return new Uint8Array(1);
    const bytes = new Uint8Array((0, toBytes_js_1.stringToBytes)(value).byteLength + 2);
    let offset = 0;
    const list = value.split('.');
    for (let i = 0; i < list.length; i++) {
        let encoded = (0, toBytes_js_1.stringToBytes)(list[i]);
        if (encoded.byteLength > 255)
            encoded = (0, toBytes_js_1.stringToBytes)((0, encodeLabelhash_js_1.encodeLabelhash)((0, labelhash_js_1.labelhash)(list[i])));
        bytes[offset] = encoded.length;
        bytes.set(encoded, offset + 1);
        offset += encoded.length + 1;
    }
    if (bytes.byteLength !== offset + 1)
        return bytes.slice(0, offset + 1);
    return bytes;
}
//# sourceMappingURL=packetToBytes.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/utils/ens/toCoinType.js":
/*!********************************************************!*\
  !*** ./node_modules/viem/_cjs/utils/ens/toCoinType.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.toCoinType = toCoinType;
const ens_js_1 = __webpack_require__(/*! ../../errors/ens.js */ "./node_modules/viem/_cjs/errors/ens.js");
const SLIP44_MSB = 0x80000000;
function toCoinType(chainId) {
    if (chainId === 1)
        return 60n;
    if (chainId >= SLIP44_MSB || chainId < 0)
        throw new ens_js_1.EnsInvalidChainIdError({ chainId });
    return BigInt((0x80000000 | chainId) >>> 0);
}
//# sourceMappingURL=toCoinType.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/utils/errors/getCallError.js":
/*!*************************************************************!*\
  !*** ./node_modules/viem/_cjs/utils/errors/getCallError.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getCallError = getCallError;
const contract_js_1 = __webpack_require__(/*! ../../errors/contract.js */ "./node_modules/viem/_cjs/errors/contract.js");
const node_js_1 = __webpack_require__(/*! ../../errors/node.js */ "./node_modules/viem/_cjs/errors/node.js");
const getNodeError_js_1 = __webpack_require__(/*! ./getNodeError.js */ "./node_modules/viem/_cjs/utils/errors/getNodeError.js");
function getCallError(err, { docsPath, ...args }) {
    const cause = (() => {
        const cause = (0, getNodeError_js_1.getNodeError)(err, args);
        if (cause instanceof node_js_1.UnknownNodeError)
            return err;
        return cause;
    })();
    return new contract_js_1.CallExecutionError(cause, {
        docsPath,
        ...args,
    });
}
//# sourceMappingURL=getCallError.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/utils/errors/getContractError.js":
/*!*****************************************************************!*\
  !*** ./node_modules/viem/_cjs/utils/errors/getContractError.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getContractError = getContractError;
const abi_js_1 = __webpack_require__(/*! ../../errors/abi.js */ "./node_modules/viem/_cjs/errors/abi.js");
const base_js_1 = __webpack_require__(/*! ../../errors/base.js */ "./node_modules/viem/_cjs/errors/base.js");
const contract_js_1 = __webpack_require__(/*! ../../errors/contract.js */ "./node_modules/viem/_cjs/errors/contract.js");
const request_js_1 = __webpack_require__(/*! ../../errors/request.js */ "./node_modules/viem/_cjs/errors/request.js");
const rpc_js_1 = __webpack_require__(/*! ../../errors/rpc.js */ "./node_modules/viem/_cjs/errors/rpc.js");
const EXECUTION_REVERTED_ERROR_CODE = 3;
function getContractError(err, { abi, address, args, docsPath, functionName, sender, }) {
    const error = (err instanceof contract_js_1.RawContractError
        ? err
        : err instanceof base_js_1.BaseError
            ? err.walk((err) => 'data' in err) || err.walk()
            : {});
    const { code, data, details, message, shortMessage } = error;
    const cause = (() => {
        if (err instanceof abi_js_1.AbiDecodingZeroDataError)
            return new contract_js_1.ContractFunctionZeroDataError({ functionName });
        if ([EXECUTION_REVERTED_ERROR_CODE, rpc_js_1.InternalRpcError.code].includes(code) &&
            (data || details || message || shortMessage)) {
            return new contract_js_1.ContractFunctionRevertedError({
                abi,
                data: typeof data === 'object' ? data.data : data,
                functionName,
                message: error instanceof request_js_1.RpcRequestError
                    ? details
                    : (shortMessage ?? message),
            });
        }
        return err;
    })();
    return new contract_js_1.ContractFunctionExecutionError(cause, {
        abi,
        args,
        contractAddress: address,
        docsPath,
        functionName,
        sender,
    });
}
//# sourceMappingURL=getContractError.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/utils/errors/getEstimateGasError.js":
/*!********************************************************************!*\
  !*** ./node_modules/viem/_cjs/utils/errors/getEstimateGasError.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getEstimateGasError = getEstimateGasError;
const estimateGas_js_1 = __webpack_require__(/*! ../../errors/estimateGas.js */ "./node_modules/viem/_cjs/errors/estimateGas.js");
const node_js_1 = __webpack_require__(/*! ../../errors/node.js */ "./node_modules/viem/_cjs/errors/node.js");
const getNodeError_js_1 = __webpack_require__(/*! ./getNodeError.js */ "./node_modules/viem/_cjs/utils/errors/getNodeError.js");
function getEstimateGasError(err, { docsPath, ...args }) {
    const cause = (() => {
        const cause = (0, getNodeError_js_1.getNodeError)(err, args);
        if (cause instanceof node_js_1.UnknownNodeError)
            return err;
        return cause;
    })();
    return new estimateGas_js_1.EstimateGasExecutionError(cause, {
        docsPath,
        ...args,
    });
}
//# sourceMappingURL=getEstimateGasError.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/utils/errors/getNodeError.js":
/*!*************************************************************!*\
  !*** ./node_modules/viem/_cjs/utils/errors/getNodeError.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.containsNodeError = containsNodeError;
exports.getNodeError = getNodeError;
const base_js_1 = __webpack_require__(/*! ../../errors/base.js */ "./node_modules/viem/_cjs/errors/base.js");
const node_js_1 = __webpack_require__(/*! ../../errors/node.js */ "./node_modules/viem/_cjs/errors/node.js");
const request_js_1 = __webpack_require__(/*! ../../errors/request.js */ "./node_modules/viem/_cjs/errors/request.js");
const rpc_js_1 = __webpack_require__(/*! ../../errors/rpc.js */ "./node_modules/viem/_cjs/errors/rpc.js");
function containsNodeError(err) {
    return (err instanceof rpc_js_1.TransactionRejectedRpcError ||
        err instanceof rpc_js_1.InvalidInputRpcError ||
        (err instanceof request_js_1.RpcRequestError && err.code === node_js_1.ExecutionRevertedError.code));
}
function getNodeError(err, args) {
    const message = (err.details || '').toLowerCase();
    const executionRevertedError = err instanceof base_js_1.BaseError
        ? err.walk((e) => e?.code ===
            node_js_1.ExecutionRevertedError.code)
        : err;
    if (executionRevertedError instanceof base_js_1.BaseError)
        return new node_js_1.ExecutionRevertedError({
            cause: err,
            message: executionRevertedError.details,
        });
    if (node_js_1.ExecutionRevertedError.nodeMessage.test(message))
        return new node_js_1.ExecutionRevertedError({
            cause: err,
            message: err.details,
        });
    if (node_js_1.FeeCapTooHighError.nodeMessage.test(message))
        return new node_js_1.FeeCapTooHighError({
            cause: err,
            maxFeePerGas: args?.maxFeePerGas,
        });
    if (node_js_1.FeeCapTooLowError.nodeMessage.test(message))
        return new node_js_1.FeeCapTooLowError({
            cause: err,
            maxFeePerGas: args?.maxFeePerGas,
        });
    if (node_js_1.NonceTooHighError.nodeMessage.test(message))
        return new node_js_1.NonceTooHighError({ cause: err, nonce: args?.nonce });
    if (node_js_1.NonceTooLowError.nodeMessage.test(message))
        return new node_js_1.NonceTooLowError({ cause: err, nonce: args?.nonce });
    if (node_js_1.NonceMaxValueError.nodeMessage.test(message))
        return new node_js_1.NonceMaxValueError({ cause: err, nonce: args?.nonce });
    if (node_js_1.InsufficientFundsError.nodeMessage.test(message))
        return new node_js_1.InsufficientFundsError({ cause: err });
    if (node_js_1.IntrinsicGasTooHighError.nodeMessage.test(message))
        return new node_js_1.IntrinsicGasTooHighError({ cause: err, gas: args?.gas });
    if (node_js_1.IntrinsicGasTooLowError.nodeMessage.test(message))
        return new node_js_1.IntrinsicGasTooLowError({ cause: err, gas: args?.gas });
    if (node_js_1.TransactionTypeNotSupportedError.nodeMessage.test(message))
        return new node_js_1.TransactionTypeNotSupportedError({ cause: err });
    if (node_js_1.TipAboveFeeCapError.nodeMessage.test(message))
        return new node_js_1.TipAboveFeeCapError({
            cause: err,
            maxFeePerGas: args?.maxFeePerGas,
            maxPriorityFeePerGas: args?.maxPriorityFeePerGas,
        });
    return new node_js_1.UnknownNodeError({
        cause: err,
    });
}
//# sourceMappingURL=getNodeError.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/utils/errors/getTransactionError.js":
/*!********************************************************************!*\
  !*** ./node_modules/viem/_cjs/utils/errors/getTransactionError.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getTransactionError = getTransactionError;
const node_js_1 = __webpack_require__(/*! ../../errors/node.js */ "./node_modules/viem/_cjs/errors/node.js");
const transaction_js_1 = __webpack_require__(/*! ../../errors/transaction.js */ "./node_modules/viem/_cjs/errors/transaction.js");
const getNodeError_js_1 = __webpack_require__(/*! ./getNodeError.js */ "./node_modules/viem/_cjs/utils/errors/getNodeError.js");
function getTransactionError(err, { docsPath, ...args }) {
    const cause = (() => {
        const cause = (0, getNodeError_js_1.getNodeError)(err, args);
        if (cause instanceof node_js_1.UnknownNodeError)
            return err;
        return cause;
    })();
    return new transaction_js_1.TransactionExecutionError(cause, {
        docsPath,
        ...args,
    });
}
//# sourceMappingURL=getTransactionError.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/utils/filters/createFilterRequestScope.js":
/*!**************************************************************************!*\
  !*** ./node_modules/viem/_cjs/utils/filters/createFilterRequestScope.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createFilterRequestScope = createFilterRequestScope;
function createFilterRequestScope(client, { method }) {
    const requestMap = {};
    if (client.transport.type === 'fallback')
        client.transport.onResponse?.(({ method: method_, response: id, status, transport, }) => {
            if (status === 'success' && method === method_)
                requestMap[id] = transport.request;
        });
    return ((id) => requestMap[id] || client.request);
}
//# sourceMappingURL=createFilterRequestScope.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/utils/formatters/block.js":
/*!**********************************************************!*\
  !*** ./node_modules/viem/_cjs/utils/formatters/block.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.defineBlock = void 0;
exports.formatBlock = formatBlock;
const formatter_js_1 = __webpack_require__(/*! ./formatter.js */ "./node_modules/viem/_cjs/utils/formatters/formatter.js");
const transaction_js_1 = __webpack_require__(/*! ./transaction.js */ "./node_modules/viem/_cjs/utils/formatters/transaction.js");
function formatBlock(block) {
    const transactions = (block.transactions ?? []).map((transaction) => {
        if (typeof transaction === 'string')
            return transaction;
        return (0, transaction_js_1.formatTransaction)(transaction);
    });
    return {
        ...block,
        baseFeePerGas: block.baseFeePerGas ? BigInt(block.baseFeePerGas) : null,
        blobGasUsed: block.blobGasUsed ? BigInt(block.blobGasUsed) : undefined,
        difficulty: block.difficulty ? BigInt(block.difficulty) : undefined,
        excessBlobGas: block.excessBlobGas
            ? BigInt(block.excessBlobGas)
            : undefined,
        gasLimit: block.gasLimit ? BigInt(block.gasLimit) : undefined,
        gasUsed: block.gasUsed ? BigInt(block.gasUsed) : undefined,
        hash: block.hash ? block.hash : null,
        logsBloom: block.logsBloom ? block.logsBloom : null,
        nonce: block.nonce ? block.nonce : null,
        number: block.number ? BigInt(block.number) : null,
        size: block.size ? BigInt(block.size) : undefined,
        timestamp: block.timestamp ? BigInt(block.timestamp) : undefined,
        transactions,
        totalDifficulty: block.totalDifficulty
            ? BigInt(block.totalDifficulty)
            : null,
    };
}
exports.defineBlock = (0, formatter_js_1.defineFormatter)('block', formatBlock);
//# sourceMappingURL=block.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/utils/formatters/extract.js":
/*!************************************************************!*\
  !*** ./node_modules/viem/_cjs/utils/formatters/extract.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.extract = extract;
function extract(value_, { format }) {
    if (!format)
        return {};
    const value = {};
    function extract_(formatted) {
        const keys = Object.keys(formatted);
        for (const key of keys) {
            if (key in value_)
                value[key] = value_[key];
            if (formatted[key] &&
                typeof formatted[key] === 'object' &&
                !Array.isArray(formatted[key]))
                extract_(formatted[key]);
        }
    }
    const formatted = format(value_ || {});
    extract_(formatted);
    return value;
}
//# sourceMappingURL=extract.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/utils/formatters/feeHistory.js":
/*!***************************************************************!*\
  !*** ./node_modules/viem/_cjs/utils/formatters/feeHistory.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.formatFeeHistory = formatFeeHistory;
function formatFeeHistory(feeHistory) {
    return {
        baseFeePerGas: feeHistory.baseFeePerGas.map((value) => BigInt(value)),
        gasUsedRatio: feeHistory.gasUsedRatio,
        oldestBlock: BigInt(feeHistory.oldestBlock),
        reward: feeHistory.reward?.map((reward) => reward.map((value) => BigInt(value))),
    };
}
//# sourceMappingURL=feeHistory.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/utils/formatters/formatter.js":
/*!**************************************************************!*\
  !*** ./node_modules/viem/_cjs/utils/formatters/formatter.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.defineFormatter = defineFormatter;
function defineFormatter(type, format) {
    return ({ exclude, format: overrides, }) => {
        return {
            exclude,
            format: (args) => {
                const formatted = format(args);
                if (exclude) {
                    for (const key of exclude) {
                        delete formatted[key];
                    }
                }
                return {
                    ...formatted,
                    ...overrides(args),
                };
            },
            type,
        };
    };
}
//# sourceMappingURL=formatter.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/utils/formatters/log.js":
/*!********************************************************!*\
  !*** ./node_modules/viem/_cjs/utils/formatters/log.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.formatLog = formatLog;
function formatLog(log, { args, eventName, } = {}) {
    return {
        ...log,
        blockHash: log.blockHash ? log.blockHash : null,
        blockNumber: log.blockNumber ? BigInt(log.blockNumber) : null,
        logIndex: log.logIndex ? Number(log.logIndex) : null,
        transactionHash: log.transactionHash ? log.transactionHash : null,
        transactionIndex: log.transactionIndex
            ? Number(log.transactionIndex)
            : null,
        ...(eventName ? { args, eventName } : {}),
    };
}
//# sourceMappingURL=log.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/utils/formatters/proof.js":
/*!**********************************************************!*\
  !*** ./node_modules/viem/_cjs/utils/formatters/proof.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.formatProof = formatProof;
const index_js_1 = __webpack_require__(/*! ../index.js */ "./node_modules/viem/_cjs/utils/index.js");
function formatStorageProof(storageProof) {
    return storageProof.map((proof) => ({
        ...proof,
        value: BigInt(proof.value),
    }));
}
function formatProof(proof) {
    return {
        ...proof,
        balance: proof.balance ? BigInt(proof.balance) : undefined,
        nonce: proof.nonce ? (0, index_js_1.hexToNumber)(proof.nonce) : undefined,
        storageProof: proof.storageProof
            ? formatStorageProof(proof.storageProof)
            : undefined,
    };
}
//# sourceMappingURL=proof.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/utils/formatters/transaction.js":
/*!****************************************************************!*\
  !*** ./node_modules/viem/_cjs/utils/formatters/transaction.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.defineTransaction = exports.transactionType = void 0;
exports.formatTransaction = formatTransaction;
const fromHex_js_1 = __webpack_require__(/*! ../encoding/fromHex.js */ "./node_modules/viem/_cjs/utils/encoding/fromHex.js");
const formatter_js_1 = __webpack_require__(/*! ./formatter.js */ "./node_modules/viem/_cjs/utils/formatters/formatter.js");
exports.transactionType = {
    '0x0': 'legacy',
    '0x1': 'eip2930',
    '0x2': 'eip1559',
    '0x3': 'eip4844',
    '0x4': 'eip7702',
};
function formatTransaction(transaction) {
    const transaction_ = {
        ...transaction,
        blockHash: transaction.blockHash ? transaction.blockHash : null,
        blockNumber: transaction.blockNumber
            ? BigInt(transaction.blockNumber)
            : null,
        chainId: transaction.chainId ? (0, fromHex_js_1.hexToNumber)(transaction.chainId) : undefined,
        gas: transaction.gas ? BigInt(transaction.gas) : undefined,
        gasPrice: transaction.gasPrice ? BigInt(transaction.gasPrice) : undefined,
        maxFeePerBlobGas: transaction.maxFeePerBlobGas
            ? BigInt(transaction.maxFeePerBlobGas)
            : undefined,
        maxFeePerGas: transaction.maxFeePerGas
            ? BigInt(transaction.maxFeePerGas)
            : undefined,
        maxPriorityFeePerGas: transaction.maxPriorityFeePerGas
            ? BigInt(transaction.maxPriorityFeePerGas)
            : undefined,
        nonce: transaction.nonce ? (0, fromHex_js_1.hexToNumber)(transaction.nonce) : undefined,
        to: transaction.to ? transaction.to : null,
        transactionIndex: transaction.transactionIndex
            ? Number(transaction.transactionIndex)
            : null,
        type: transaction.type
            ? exports.transactionType[transaction.type]
            : undefined,
        typeHex: transaction.type ? transaction.type : undefined,
        value: transaction.value ? BigInt(transaction.value) : undefined,
        v: transaction.v ? BigInt(transaction.v) : undefined,
    };
    if (transaction.authorizationList)
        transaction_.authorizationList = formatAuthorizationList(transaction.authorizationList);
    transaction_.yParity = (() => {
        if (transaction.yParity)
            return Number(transaction.yParity);
        if (typeof transaction_.v === 'bigint') {
            if (transaction_.v === 0n || transaction_.v === 27n)
                return 0;
            if (transaction_.v === 1n || transaction_.v === 28n)
                return 1;
            if (transaction_.v >= 35n)
                return transaction_.v % 2n === 0n ? 1 : 0;
        }
        return undefined;
    })();
    if (transaction_.type === 'legacy') {
        delete transaction_.accessList;
        delete transaction_.maxFeePerBlobGas;
        delete transaction_.maxFeePerGas;
        delete transaction_.maxPriorityFeePerGas;
        delete transaction_.yParity;
    }
    if (transaction_.type === 'eip2930') {
        delete transaction_.maxFeePerBlobGas;
        delete transaction_.maxFeePerGas;
        delete transaction_.maxPriorityFeePerGas;
    }
    if (transaction_.type === 'eip1559') {
        delete transaction_.maxFeePerBlobGas;
    }
    return transaction_;
}
exports.defineTransaction = (0, formatter_js_1.defineFormatter)('transaction', formatTransaction);
function formatAuthorizationList(authorizationList) {
    return authorizationList.map((authorization) => ({
        address: authorization.address,
        chainId: Number(authorization.chainId),
        nonce: Number(authorization.nonce),
        r: authorization.r,
        s: authorization.s,
        yParity: Number(authorization.yParity),
    }));
}
//# sourceMappingURL=transaction.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/utils/formatters/transactionReceipt.js":
/*!***********************************************************************!*\
  !*** ./node_modules/viem/_cjs/utils/formatters/transactionReceipt.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.defineTransactionReceipt = exports.receiptStatuses = void 0;
exports.formatTransactionReceipt = formatTransactionReceipt;
const fromHex_js_1 = __webpack_require__(/*! ../encoding/fromHex.js */ "./node_modules/viem/_cjs/utils/encoding/fromHex.js");
const formatter_js_1 = __webpack_require__(/*! ./formatter.js */ "./node_modules/viem/_cjs/utils/formatters/formatter.js");
const log_js_1 = __webpack_require__(/*! ./log.js */ "./node_modules/viem/_cjs/utils/formatters/log.js");
const transaction_js_1 = __webpack_require__(/*! ./transaction.js */ "./node_modules/viem/_cjs/utils/formatters/transaction.js");
exports.receiptStatuses = {
    '0x0': 'reverted',
    '0x1': 'success',
};
function formatTransactionReceipt(transactionReceipt) {
    const receipt = {
        ...transactionReceipt,
        blockNumber: transactionReceipt.blockNumber
            ? BigInt(transactionReceipt.blockNumber)
            : null,
        contractAddress: transactionReceipt.contractAddress
            ? transactionReceipt.contractAddress
            : null,
        cumulativeGasUsed: transactionReceipt.cumulativeGasUsed
            ? BigInt(transactionReceipt.cumulativeGasUsed)
            : null,
        effectiveGasPrice: transactionReceipt.effectiveGasPrice
            ? BigInt(transactionReceipt.effectiveGasPrice)
            : null,
        gasUsed: transactionReceipt.gasUsed
            ? BigInt(transactionReceipt.gasUsed)
            : null,
        logs: transactionReceipt.logs
            ? transactionReceipt.logs.map((log) => (0, log_js_1.formatLog)(log))
            : null,
        to: transactionReceipt.to ? transactionReceipt.to : null,
        transactionIndex: transactionReceipt.transactionIndex
            ? (0, fromHex_js_1.hexToNumber)(transactionReceipt.transactionIndex)
            : null,
        status: transactionReceipt.status
            ? exports.receiptStatuses[transactionReceipt.status]
            : null,
        type: transactionReceipt.type
            ? transaction_js_1.transactionType[transactionReceipt.type] || transactionReceipt.type
            : null,
    };
    if (transactionReceipt.blobGasPrice)
        receipt.blobGasPrice = BigInt(transactionReceipt.blobGasPrice);
    if (transactionReceipt.blobGasUsed)
        receipt.blobGasUsed = BigInt(transactionReceipt.blobGasUsed);
    return receipt;
}
exports.defineTransactionReceipt = (0, formatter_js_1.defineFormatter)('transactionReceipt', formatTransactionReceipt);
//# sourceMappingURL=transactionReceipt.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/utils/formatters/transactionRequest.js":
/*!***********************************************************************!*\
  !*** ./node_modules/viem/_cjs/utils/formatters/transactionRequest.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.defineTransactionRequest = exports.rpcTransactionType = void 0;
exports.formatTransactionRequest = formatTransactionRequest;
const toHex_js_1 = __webpack_require__(/*! ../encoding/toHex.js */ "./node_modules/viem/_cjs/utils/encoding/toHex.js");
const formatter_js_1 = __webpack_require__(/*! ./formatter.js */ "./node_modules/viem/_cjs/utils/formatters/formatter.js");
exports.rpcTransactionType = {
    legacy: '0x0',
    eip2930: '0x1',
    eip1559: '0x2',
    eip4844: '0x3',
    eip7702: '0x4',
};
function formatTransactionRequest(request) {
    const rpcRequest = {};
    if (typeof request.authorizationList !== 'undefined')
        rpcRequest.authorizationList = formatAuthorizationList(request.authorizationList);
    if (typeof request.accessList !== 'undefined')
        rpcRequest.accessList = request.accessList;
    if (typeof request.blobVersionedHashes !== 'undefined')
        rpcRequest.blobVersionedHashes = request.blobVersionedHashes;
    if (typeof request.blobs !== 'undefined') {
        if (typeof request.blobs[0] !== 'string')
            rpcRequest.blobs = request.blobs.map((x) => (0, toHex_js_1.bytesToHex)(x));
        else
            rpcRequest.blobs = request.blobs;
    }
    if (typeof request.data !== 'undefined')
        rpcRequest.data = request.data;
    if (typeof request.from !== 'undefined')
        rpcRequest.from = request.from;
    if (typeof request.gas !== 'undefined')
        rpcRequest.gas = (0, toHex_js_1.numberToHex)(request.gas);
    if (typeof request.gasPrice !== 'undefined')
        rpcRequest.gasPrice = (0, toHex_js_1.numberToHex)(request.gasPrice);
    if (typeof request.maxFeePerBlobGas !== 'undefined')
        rpcRequest.maxFeePerBlobGas = (0, toHex_js_1.numberToHex)(request.maxFeePerBlobGas);
    if (typeof request.maxFeePerGas !== 'undefined')
        rpcRequest.maxFeePerGas = (0, toHex_js_1.numberToHex)(request.maxFeePerGas);
    if (typeof request.maxPriorityFeePerGas !== 'undefined')
        rpcRequest.maxPriorityFeePerGas = (0, toHex_js_1.numberToHex)(request.maxPriorityFeePerGas);
    if (typeof request.nonce !== 'undefined')
        rpcRequest.nonce = (0, toHex_js_1.numberToHex)(request.nonce);
    if (typeof request.to !== 'undefined')
        rpcRequest.to = request.to;
    if (typeof request.type !== 'undefined')
        rpcRequest.type = exports.rpcTransactionType[request.type];
    if (typeof request.value !== 'undefined')
        rpcRequest.value = (0, toHex_js_1.numberToHex)(request.value);
    return rpcRequest;
}
exports.defineTransactionRequest = (0, formatter_js_1.defineFormatter)('transactionRequest', formatTransactionRequest);
function formatAuthorizationList(authorizationList) {
    return authorizationList.map((authorization) => ({
        address: authorization.address,
        r: authorization.r
            ? (0, toHex_js_1.numberToHex)(BigInt(authorization.r))
            : authorization.r,
        s: authorization.s
            ? (0, toHex_js_1.numberToHex)(BigInt(authorization.s))
            : authorization.s,
        chainId: (0, toHex_js_1.numberToHex)(authorization.chainId),
        nonce: (0, toHex_js_1.numberToHex)(authorization.nonce),
        ...(typeof authorization.yParity !== 'undefined'
            ? { yParity: (0, toHex_js_1.numberToHex)(authorization.yParity) }
            : {}),
        ...(typeof authorization.v !== 'undefined' &&
            typeof authorization.yParity === 'undefined'
            ? { v: (0, toHex_js_1.numberToHex)(authorization.v) }
            : {}),
    }));
}
//# sourceMappingURL=transactionRequest.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/utils/getAction.js":
/*!***************************************************!*\
  !*** ./node_modules/viem/_cjs/utils/getAction.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getAction = getAction;
function getAction(client, actionFn, name) {
    const action_implicit = client[actionFn.name];
    if (typeof action_implicit === 'function')
        return action_implicit;
    const action_explicit = client[name];
    if (typeof action_explicit === 'function')
        return action_explicit;
    return (params) => actionFn(client, params);
}
//# sourceMappingURL=getAction.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/utils/hash/hashSignature.js":
/*!************************************************************!*\
  !*** ./node_modules/viem/_cjs/utils/hash/hashSignature.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.hashSignature = hashSignature;
const toBytes_js_1 = __webpack_require__(/*! ../encoding/toBytes.js */ "./node_modules/viem/_cjs/utils/encoding/toBytes.js");
const keccak256_js_1 = __webpack_require__(/*! ./keccak256.js */ "./node_modules/viem/_cjs/utils/hash/keccak256.js");
const hash = (value) => (0, keccak256_js_1.keccak256)((0, toBytes_js_1.toBytes)(value));
function hashSignature(sig) {
    return hash(sig);
}
//# sourceMappingURL=hashSignature.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/utils/hash/isHash.js":
/*!*****************************************************!*\
  !*** ./node_modules/viem/_cjs/utils/hash/isHash.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isHash = isHash;
const isHex_js_1 = __webpack_require__(/*! ../data/isHex.js */ "./node_modules/viem/_cjs/utils/data/isHex.js");
const size_js_1 = __webpack_require__(/*! ../data/size.js */ "./node_modules/viem/_cjs/utils/data/size.js");
function isHash(hash) {
    return (0, isHex_js_1.isHex)(hash) && (0, size_js_1.size)(hash) === 32;
}
//# sourceMappingURL=isHash.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/utils/hash/keccak256.js":
/*!********************************************************!*\
  !*** ./node_modules/viem/_cjs/utils/hash/keccak256.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.keccak256 = keccak256;
const sha3_1 = __webpack_require__(/*! @noble/hashes/sha3 */ "./node_modules/@noble/hashes/sha3.js");
const isHex_js_1 = __webpack_require__(/*! ../data/isHex.js */ "./node_modules/viem/_cjs/utils/data/isHex.js");
const toBytes_js_1 = __webpack_require__(/*! ../encoding/toBytes.js */ "./node_modules/viem/_cjs/utils/encoding/toBytes.js");
const toHex_js_1 = __webpack_require__(/*! ../encoding/toHex.js */ "./node_modules/viem/_cjs/utils/encoding/toHex.js");
function keccak256(value, to_) {
    const to = to_ || 'hex';
    const bytes = (0, sha3_1.keccak_256)((0, isHex_js_1.isHex)(value, { strict: false }) ? (0, toBytes_js_1.toBytes)(value) : value);
    if (to === 'bytes')
        return bytes;
    return (0, toHex_js_1.toHex)(bytes);
}
//# sourceMappingURL=keccak256.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/utils/hash/normalizeSignature.js":
/*!*****************************************************************!*\
  !*** ./node_modules/viem/_cjs/utils/hash/normalizeSignature.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.normalizeSignature = normalizeSignature;
const base_js_1 = __webpack_require__(/*! ../../errors/base.js */ "./node_modules/viem/_cjs/errors/base.js");
function normalizeSignature(signature) {
    let active = true;
    let current = '';
    let level = 0;
    let result = '';
    let valid = false;
    for (let i = 0; i < signature.length; i++) {
        const char = signature[i];
        if (['(', ')', ','].includes(char))
            active = true;
        if (char === '(')
            level++;
        if (char === ')')
            level--;
        if (!active)
            continue;
        if (level === 0) {
            if (char === ' ' && ['event', 'function', ''].includes(result))
                result = '';
            else {
                result += char;
                if (char === ')') {
                    valid = true;
                    break;
                }
            }
            continue;
        }
        if (char === ' ') {
            if (signature[i - 1] !== ',' && current !== ',' && current !== ',(') {
                current = '';
                active = false;
            }
            continue;
        }
        result += char;
        current += char;
    }
    if (!valid)
        throw new base_js_1.BaseError('Unable to normalize signature.');
    return result;
}
//# sourceMappingURL=normalizeSignature.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/utils/hash/ripemd160.js":
/*!********************************************************!*\
  !*** ./node_modules/viem/_cjs/utils/hash/ripemd160.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ripemd160 = ripemd160;
const ripemd160_1 = __webpack_require__(/*! @noble/hashes/ripemd160 */ "./node_modules/@noble/hashes/ripemd160.js");
const isHex_js_1 = __webpack_require__(/*! ../data/isHex.js */ "./node_modules/viem/_cjs/utils/data/isHex.js");
const toBytes_js_1 = __webpack_require__(/*! ../encoding/toBytes.js */ "./node_modules/viem/_cjs/utils/encoding/toBytes.js");
const toHex_js_1 = __webpack_require__(/*! ../encoding/toHex.js */ "./node_modules/viem/_cjs/utils/encoding/toHex.js");
function ripemd160(value, to_) {
    const to = to_ || 'hex';
    const bytes = (0, ripemd160_1.ripemd160)((0, isHex_js_1.isHex)(value, { strict: false }) ? (0, toBytes_js_1.toBytes)(value) : value);
    if (to === 'bytes')
        return bytes;
    return (0, toHex_js_1.toHex)(bytes);
}
//# sourceMappingURL=ripemd160.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/utils/hash/sha256.js":
/*!*****************************************************!*\
  !*** ./node_modules/viem/_cjs/utils/hash/sha256.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.sha256 = sha256;
const sha256_1 = __webpack_require__(/*! @noble/hashes/sha256 */ "./node_modules/@noble/hashes/sha256.js");
const isHex_js_1 = __webpack_require__(/*! ../data/isHex.js */ "./node_modules/viem/_cjs/utils/data/isHex.js");
const toBytes_js_1 = __webpack_require__(/*! ../encoding/toBytes.js */ "./node_modules/viem/_cjs/utils/encoding/toBytes.js");
const toHex_js_1 = __webpack_require__(/*! ../encoding/toHex.js */ "./node_modules/viem/_cjs/utils/encoding/toHex.js");
function sha256(value, to_) {
    const to = to_ || 'hex';
    const bytes = (0, sha256_1.sha256)((0, isHex_js_1.isHex)(value, { strict: false }) ? (0, toBytes_js_1.toBytes)(value) : value);
    if (to === 'bytes')
        return bytes;
    return (0, toHex_js_1.toHex)(bytes);
}
//# sourceMappingURL=sha256.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/utils/hash/toEventHash.js":
/*!**********************************************************!*\
  !*** ./node_modules/viem/_cjs/utils/hash/toEventHash.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.toEventHash = void 0;
var toSignatureHash_js_1 = __webpack_require__(/*! ./toSignatureHash.js */ "./node_modules/viem/_cjs/utils/hash/toSignatureHash.js");
Object.defineProperty(exports, "toEventHash", ({ enumerable: true, get: function () { return toSignatureHash_js_1.toSignatureHash; } }));
//# sourceMappingURL=toEventHash.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/utils/hash/toEventSelector.js":
/*!**************************************************************!*\
  !*** ./node_modules/viem/_cjs/utils/hash/toEventSelector.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.toEventSelector = void 0;
const toSignatureHash_js_1 = __webpack_require__(/*! ./toSignatureHash.js */ "./node_modules/viem/_cjs/utils/hash/toSignatureHash.js");
exports.toEventSelector = toSignatureHash_js_1.toSignatureHash;
//# sourceMappingURL=toEventSelector.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/utils/hash/toEventSignature.js":
/*!***************************************************************!*\
  !*** ./node_modules/viem/_cjs/utils/hash/toEventSignature.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.toEventSignature = void 0;
var toSignature_js_1 = __webpack_require__(/*! ./toSignature.js */ "./node_modules/viem/_cjs/utils/hash/toSignature.js");
Object.defineProperty(exports, "toEventSignature", ({ enumerable: true, get: function () { return toSignature_js_1.toSignature; } }));
//# sourceMappingURL=toEventSignature.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/utils/hash/toFunctionHash.js":
/*!*************************************************************!*\
  !*** ./node_modules/viem/_cjs/utils/hash/toFunctionHash.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.toFunctionHash = void 0;
var toSignatureHash_js_1 = __webpack_require__(/*! ./toSignatureHash.js */ "./node_modules/viem/_cjs/utils/hash/toSignatureHash.js");
Object.defineProperty(exports, "toFunctionHash", ({ enumerable: true, get: function () { return toSignatureHash_js_1.toSignatureHash; } }));
//# sourceMappingURL=toFunctionHash.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/utils/hash/toFunctionSelector.js":
/*!*****************************************************************!*\
  !*** ./node_modules/viem/_cjs/utils/hash/toFunctionSelector.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.toFunctionSelector = void 0;
const slice_js_1 = __webpack_require__(/*! ../data/slice.js */ "./node_modules/viem/_cjs/utils/data/slice.js");
const toSignatureHash_js_1 = __webpack_require__(/*! ./toSignatureHash.js */ "./node_modules/viem/_cjs/utils/hash/toSignatureHash.js");
const toFunctionSelector = (fn) => (0, slice_js_1.slice)((0, toSignatureHash_js_1.toSignatureHash)(fn), 0, 4);
exports.toFunctionSelector = toFunctionSelector;
//# sourceMappingURL=toFunctionSelector.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/utils/hash/toFunctionSignature.js":
/*!******************************************************************!*\
  !*** ./node_modules/viem/_cjs/utils/hash/toFunctionSignature.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.toFunctionSignature = void 0;
var toSignature_js_1 = __webpack_require__(/*! ./toSignature.js */ "./node_modules/viem/_cjs/utils/hash/toSignature.js");
Object.defineProperty(exports, "toFunctionSignature", ({ enumerable: true, get: function () { return toSignature_js_1.toSignature; } }));
//# sourceMappingURL=toFunctionSignature.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/utils/hash/toSignature.js":
/*!**********************************************************!*\
  !*** ./node_modules/viem/_cjs/utils/hash/toSignature.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.toSignature = void 0;
const abitype_1 = __webpack_require__(/*! abitype */ "./node_modules/abitype/dist/cjs/exports/index.js");
const normalizeSignature_js_1 = __webpack_require__(/*! ./normalizeSignature.js */ "./node_modules/viem/_cjs/utils/hash/normalizeSignature.js");
const toSignature = (def) => {
    const def_ = (() => {
        if (typeof def === 'string')
            return def;
        return (0, abitype_1.formatAbiItem)(def);
    })();
    return (0, normalizeSignature_js_1.normalizeSignature)(def_);
};
exports.toSignature = toSignature;
//# sourceMappingURL=toSignature.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/utils/hash/toSignatureHash.js":
/*!**************************************************************!*\
  !*** ./node_modules/viem/_cjs/utils/hash/toSignatureHash.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.toSignatureHash = toSignatureHash;
const hashSignature_js_1 = __webpack_require__(/*! ./hashSignature.js */ "./node_modules/viem/_cjs/utils/hash/hashSignature.js");
const toSignature_js_1 = __webpack_require__(/*! ./toSignature.js */ "./node_modules/viem/_cjs/utils/hash/toSignature.js");
function toSignatureHash(fn) {
    return (0, hashSignature_js_1.hashSignature)((0, toSignature_js_1.toSignature)(fn));
}
//# sourceMappingURL=toSignatureHash.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/utils/index.js":
/*!***********************************************!*\
  !*** ./node_modules/viem/_cjs/utils/index.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.padBytes = exports.pad = exports.isHex = exports.isBytes = exports.concatHex = exports.concatBytes = exports.concat = exports.getChainContractAddress = exports.extractChain = exports.defineChain = exports.assertCurrentChain = exports.offchainLookupSignature = exports.offchainLookupAbiItem = exports.offchainLookup = exports.ccipFetch = exports.ccipRequest = exports.buildRequest = exports.verifyAuthorization = exports.serializeAuthorizationList = exports.recoverAuthorizationAddress = exports.hashAuthorization = exports.isAddressEqual = exports.isAddress = exports.getCreateAddress = exports.getCreate2Address = exports.getContractAddress = exports.getAddress = exports.parseEventLogs = exports.getAbiItem = exports.formatAbiItemWithArgs = exports.formatAbiParams = exports.formatAbiItem = exports.encodePacked = exports.encodeFunctionResult = exports.encodeFunctionData = exports.encodeEventTopics = exports.encodeErrorResult = exports.encodeDeployData = exports.encodeAbiParameters = exports.decodeFunctionResult = exports.decodeFunctionData = exports.decodeEventLog = exports.decodeErrorResult = exports.decodeAbiParameters = exports.publicKeyToAddress = exports.parseAccount = exports.parseAbiParameters = exports.parseAbiParameter = exports.parseAbiItem = exports.parseAbi = void 0;
exports.ripemd160 = exports.keccak256 = exports.isHash = exports.getAction = exports.formatTransactionRequest = exports.defineTransactionRequest = exports.defineTransactionReceipt = exports.transactionType = exports.formatTransaction = exports.defineTransaction = exports.formatLog = exports.defineFormatter = exports.extract = exports.formatBlock = exports.defineBlock = exports.getTransactionError = exports.getNodeError = exports.containsNodeError = exports.getEstimateGasError = exports.getContractError = exports.getCallError = exports.toRlp = exports.toHex = exports.stringToHex = exports.numberToHex = exports.bytesToHex = exports.boolToHex = exports.toBytes = exports.stringToBytes = exports.numberToBytes = exports.hexToBytes = exports.boolToBytes = exports.fromRlp = exports.hexToString = exports.hexToNumber = exports.hexToBool = exports.hexToBigInt = exports.fromHex = exports.fromBytes = exports.bytesToString = exports.bytesToNumber = exports.bytesToBool = exports.bytesToBigint = exports.bytesToBigInt = exports.trim = exports.sliceHex = exports.sliceBytes = exports.slice = exports.size = exports.padHex = void 0;
exports.formatUnits = exports.formatGwei = exports.formatEther = exports.validateTypedData = exports.serializeTypedData = exports.serializeTransaction = exports.serializeAccessList = exports.parseTransaction = exports.getTransactionType = exports.getSerializedTransactionType = exports.assertTransactionLegacy = exports.assertTransactionEIP2930 = exports.assertTransactionEIP1559 = exports.assertRequest = exports.stringify = exports.verifyTypedData = exports.verifyMessage = exports.verifyHash = exports.serializeErc6492Signature = exports.recoverTypedDataAddress = exports.recoverPublicKey = exports.recoverMessageAddress = exports.recoverAddress = exports.parseErc6492Signature = exports.isErc6492Signature = exports.hashTypedData = exports.hashStruct = exports.hashMessage = exports.getWebSocketRpcClient = exports.socketClientCache = exports.getSocketRpcClient = exports.getHttpRpcClient = exports.rpc = exports.getSocket = exports.integerRegex = exports.bytesRegex = exports.arrayRegex = exports.nonceManager = exports.createNonceManager = exports.getFunctionSignature = exports.toFunctionSignature = exports.getFunctionSelector = exports.toFunctionSelector = exports.toFunctionHash = exports.getEventSignature = exports.toEventSignature = exports.getEventSelector = exports.toEventSelector = exports.toEventHash = exports.sha256 = void 0;
exports.parseUnits = exports.parseGwei = exports.parseEther = void 0;
var abitype_1 = __webpack_require__(/*! abitype */ "./node_modules/abitype/dist/cjs/exports/index.js");
Object.defineProperty(exports, "parseAbi", ({ enumerable: true, get: function () { return abitype_1.parseAbi; } }));
Object.defineProperty(exports, "parseAbiItem", ({ enumerable: true, get: function () { return abitype_1.parseAbiItem; } }));
Object.defineProperty(exports, "parseAbiParameter", ({ enumerable: true, get: function () { return abitype_1.parseAbiParameter; } }));
Object.defineProperty(exports, "parseAbiParameters", ({ enumerable: true, get: function () { return abitype_1.parseAbiParameters; } }));
var parseAccount_js_1 = __webpack_require__(/*! ../accounts/utils/parseAccount.js */ "./node_modules/viem/_cjs/accounts/utils/parseAccount.js");
Object.defineProperty(exports, "parseAccount", ({ enumerable: true, get: function () { return parseAccount_js_1.parseAccount; } }));
var publicKeyToAddress_js_1 = __webpack_require__(/*! ../accounts/utils/publicKeyToAddress.js */ "./node_modules/viem/_cjs/accounts/utils/publicKeyToAddress.js");
Object.defineProperty(exports, "publicKeyToAddress", ({ enumerable: true, get: function () { return publicKeyToAddress_js_1.publicKeyToAddress; } }));
var decodeAbiParameters_js_1 = __webpack_require__(/*! ./abi/decodeAbiParameters.js */ "./node_modules/viem/_cjs/utils/abi/decodeAbiParameters.js");
Object.defineProperty(exports, "decodeAbiParameters", ({ enumerable: true, get: function () { return decodeAbiParameters_js_1.decodeAbiParameters; } }));
var decodeErrorResult_js_1 = __webpack_require__(/*! ./abi/decodeErrorResult.js */ "./node_modules/viem/_cjs/utils/abi/decodeErrorResult.js");
Object.defineProperty(exports, "decodeErrorResult", ({ enumerable: true, get: function () { return decodeErrorResult_js_1.decodeErrorResult; } }));
var decodeEventLog_js_1 = __webpack_require__(/*! ./abi/decodeEventLog.js */ "./node_modules/viem/_cjs/utils/abi/decodeEventLog.js");
Object.defineProperty(exports, "decodeEventLog", ({ enumerable: true, get: function () { return decodeEventLog_js_1.decodeEventLog; } }));
var decodeFunctionData_js_1 = __webpack_require__(/*! ./abi/decodeFunctionData.js */ "./node_modules/viem/_cjs/utils/abi/decodeFunctionData.js");
Object.defineProperty(exports, "decodeFunctionData", ({ enumerable: true, get: function () { return decodeFunctionData_js_1.decodeFunctionData; } }));
var decodeFunctionResult_js_1 = __webpack_require__(/*! ./abi/decodeFunctionResult.js */ "./node_modules/viem/_cjs/utils/abi/decodeFunctionResult.js");
Object.defineProperty(exports, "decodeFunctionResult", ({ enumerable: true, get: function () { return decodeFunctionResult_js_1.decodeFunctionResult; } }));
var encodeAbiParameters_js_1 = __webpack_require__(/*! ./abi/encodeAbiParameters.js */ "./node_modules/viem/_cjs/utils/abi/encodeAbiParameters.js");
Object.defineProperty(exports, "encodeAbiParameters", ({ enumerable: true, get: function () { return encodeAbiParameters_js_1.encodeAbiParameters; } }));
var encodeDeployData_js_1 = __webpack_require__(/*! ./abi/encodeDeployData.js */ "./node_modules/viem/_cjs/utils/abi/encodeDeployData.js");
Object.defineProperty(exports, "encodeDeployData", ({ enumerable: true, get: function () { return encodeDeployData_js_1.encodeDeployData; } }));
var encodeErrorResult_js_1 = __webpack_require__(/*! ./abi/encodeErrorResult.js */ "./node_modules/viem/_cjs/utils/abi/encodeErrorResult.js");
Object.defineProperty(exports, "encodeErrorResult", ({ enumerable: true, get: function () { return encodeErrorResult_js_1.encodeErrorResult; } }));
var encodeEventTopics_js_1 = __webpack_require__(/*! ./abi/encodeEventTopics.js */ "./node_modules/viem/_cjs/utils/abi/encodeEventTopics.js");
Object.defineProperty(exports, "encodeEventTopics", ({ enumerable: true, get: function () { return encodeEventTopics_js_1.encodeEventTopics; } }));
var encodeFunctionData_js_1 = __webpack_require__(/*! ./abi/encodeFunctionData.js */ "./node_modules/viem/_cjs/utils/abi/encodeFunctionData.js");
Object.defineProperty(exports, "encodeFunctionData", ({ enumerable: true, get: function () { return encodeFunctionData_js_1.encodeFunctionData; } }));
var encodeFunctionResult_js_1 = __webpack_require__(/*! ./abi/encodeFunctionResult.js */ "./node_modules/viem/_cjs/utils/abi/encodeFunctionResult.js");
Object.defineProperty(exports, "encodeFunctionResult", ({ enumerable: true, get: function () { return encodeFunctionResult_js_1.encodeFunctionResult; } }));
var encodePacked_js_1 = __webpack_require__(/*! ./abi/encodePacked.js */ "./node_modules/viem/_cjs/utils/abi/encodePacked.js");
Object.defineProperty(exports, "encodePacked", ({ enumerable: true, get: function () { return encodePacked_js_1.encodePacked; } }));
var formatAbiItem_js_1 = __webpack_require__(/*! ./abi/formatAbiItem.js */ "./node_modules/viem/_cjs/utils/abi/formatAbiItem.js");
Object.defineProperty(exports, "formatAbiItem", ({ enumerable: true, get: function () { return formatAbiItem_js_1.formatAbiItem; } }));
Object.defineProperty(exports, "formatAbiParams", ({ enumerable: true, get: function () { return formatAbiItem_js_1.formatAbiParams; } }));
var formatAbiItemWithArgs_js_1 = __webpack_require__(/*! ./abi/formatAbiItemWithArgs.js */ "./node_modules/viem/_cjs/utils/abi/formatAbiItemWithArgs.js");
Object.defineProperty(exports, "formatAbiItemWithArgs", ({ enumerable: true, get: function () { return formatAbiItemWithArgs_js_1.formatAbiItemWithArgs; } }));
var getAbiItem_js_1 = __webpack_require__(/*! ./abi/getAbiItem.js */ "./node_modules/viem/_cjs/utils/abi/getAbiItem.js");
Object.defineProperty(exports, "getAbiItem", ({ enumerable: true, get: function () { return getAbiItem_js_1.getAbiItem; } }));
var parseEventLogs_js_1 = __webpack_require__(/*! ./abi/parseEventLogs.js */ "./node_modules/viem/_cjs/utils/abi/parseEventLogs.js");
Object.defineProperty(exports, "parseEventLogs", ({ enumerable: true, get: function () { return parseEventLogs_js_1.parseEventLogs; } }));
var getAddress_js_1 = __webpack_require__(/*! ./address/getAddress.js */ "./node_modules/viem/_cjs/utils/address/getAddress.js");
Object.defineProperty(exports, "getAddress", ({ enumerable: true, get: function () { return getAddress_js_1.getAddress; } }));
var getContractAddress_js_1 = __webpack_require__(/*! ./address/getContractAddress.js */ "./node_modules/viem/_cjs/utils/address/getContractAddress.js");
Object.defineProperty(exports, "getContractAddress", ({ enumerable: true, get: function () { return getContractAddress_js_1.getContractAddress; } }));
Object.defineProperty(exports, "getCreate2Address", ({ enumerable: true, get: function () { return getContractAddress_js_1.getCreate2Address; } }));
Object.defineProperty(exports, "getCreateAddress", ({ enumerable: true, get: function () { return getContractAddress_js_1.getCreateAddress; } }));
var isAddress_js_1 = __webpack_require__(/*! ./address/isAddress.js */ "./node_modules/viem/_cjs/utils/address/isAddress.js");
Object.defineProperty(exports, "isAddress", ({ enumerable: true, get: function () { return isAddress_js_1.isAddress; } }));
var isAddressEqual_js_1 = __webpack_require__(/*! ./address/isAddressEqual.js */ "./node_modules/viem/_cjs/utils/address/isAddressEqual.js");
Object.defineProperty(exports, "isAddressEqual", ({ enumerable: true, get: function () { return isAddressEqual_js_1.isAddressEqual; } }));
var hashAuthorization_js_1 = __webpack_require__(/*! ./authorization/hashAuthorization.js */ "./node_modules/viem/_cjs/utils/authorization/hashAuthorization.js");
Object.defineProperty(exports, "hashAuthorization", ({ enumerable: true, get: function () { return hashAuthorization_js_1.hashAuthorization; } }));
var recoverAuthorizationAddress_js_1 = __webpack_require__(/*! ./authorization/recoverAuthorizationAddress.js */ "./node_modules/viem/_cjs/utils/authorization/recoverAuthorizationAddress.js");
Object.defineProperty(exports, "recoverAuthorizationAddress", ({ enumerable: true, get: function () { return recoverAuthorizationAddress_js_1.recoverAuthorizationAddress; } }));
var serializeAuthorizationList_js_1 = __webpack_require__(/*! ./authorization/serializeAuthorizationList.js */ "./node_modules/viem/_cjs/utils/authorization/serializeAuthorizationList.js");
Object.defineProperty(exports, "serializeAuthorizationList", ({ enumerable: true, get: function () { return serializeAuthorizationList_js_1.serializeAuthorizationList; } }));
var verifyAuthorization_js_1 = __webpack_require__(/*! ./authorization/verifyAuthorization.js */ "./node_modules/viem/_cjs/utils/authorization/verifyAuthorization.js");
Object.defineProperty(exports, "verifyAuthorization", ({ enumerable: true, get: function () { return verifyAuthorization_js_1.verifyAuthorization; } }));
var buildRequest_js_1 = __webpack_require__(/*! ./buildRequest.js */ "./node_modules/viem/_cjs/utils/buildRequest.js");
Object.defineProperty(exports, "buildRequest", ({ enumerable: true, get: function () { return buildRequest_js_1.buildRequest; } }));
var ccip_js_1 = __webpack_require__(/*! ./ccip.js */ "./node_modules/viem/_cjs/utils/ccip.js");
Object.defineProperty(exports, "ccipRequest", ({ enumerable: true, get: function () { return ccip_js_1.ccipRequest; } }));
Object.defineProperty(exports, "ccipFetch", ({ enumerable: true, get: function () { return ccip_js_1.ccipRequest; } }));
Object.defineProperty(exports, "offchainLookup", ({ enumerable: true, get: function () { return ccip_js_1.offchainLookup; } }));
Object.defineProperty(exports, "offchainLookupAbiItem", ({ enumerable: true, get: function () { return ccip_js_1.offchainLookupAbiItem; } }));
Object.defineProperty(exports, "offchainLookupSignature", ({ enumerable: true, get: function () { return ccip_js_1.offchainLookupSignature; } }));
var assertCurrentChain_js_1 = __webpack_require__(/*! ./chain/assertCurrentChain.js */ "./node_modules/viem/_cjs/utils/chain/assertCurrentChain.js");
Object.defineProperty(exports, "assertCurrentChain", ({ enumerable: true, get: function () { return assertCurrentChain_js_1.assertCurrentChain; } }));
var defineChain_js_1 = __webpack_require__(/*! ./chain/defineChain.js */ "./node_modules/viem/_cjs/utils/chain/defineChain.js");
Object.defineProperty(exports, "defineChain", ({ enumerable: true, get: function () { return defineChain_js_1.defineChain; } }));
var extractChain_js_1 = __webpack_require__(/*! ./chain/extractChain.js */ "./node_modules/viem/_cjs/utils/chain/extractChain.js");
Object.defineProperty(exports, "extractChain", ({ enumerable: true, get: function () { return extractChain_js_1.extractChain; } }));
var getChainContractAddress_js_1 = __webpack_require__(/*! ./chain/getChainContractAddress.js */ "./node_modules/viem/_cjs/utils/chain/getChainContractAddress.js");
Object.defineProperty(exports, "getChainContractAddress", ({ enumerable: true, get: function () { return getChainContractAddress_js_1.getChainContractAddress; } }));
var concat_js_1 = __webpack_require__(/*! ./data/concat.js */ "./node_modules/viem/_cjs/utils/data/concat.js");
Object.defineProperty(exports, "concat", ({ enumerable: true, get: function () { return concat_js_1.concat; } }));
Object.defineProperty(exports, "concatBytes", ({ enumerable: true, get: function () { return concat_js_1.concatBytes; } }));
Object.defineProperty(exports, "concatHex", ({ enumerable: true, get: function () { return concat_js_1.concatHex; } }));
var isBytes_js_1 = __webpack_require__(/*! ./data/isBytes.js */ "./node_modules/viem/_cjs/utils/data/isBytes.js");
Object.defineProperty(exports, "isBytes", ({ enumerable: true, get: function () { return isBytes_js_1.isBytes; } }));
var isHex_js_1 = __webpack_require__(/*! ./data/isHex.js */ "./node_modules/viem/_cjs/utils/data/isHex.js");
Object.defineProperty(exports, "isHex", ({ enumerable: true, get: function () { return isHex_js_1.isHex; } }));
var pad_js_1 = __webpack_require__(/*! ./data/pad.js */ "./node_modules/viem/_cjs/utils/data/pad.js");
Object.defineProperty(exports, "pad", ({ enumerable: true, get: function () { return pad_js_1.pad; } }));
Object.defineProperty(exports, "padBytes", ({ enumerable: true, get: function () { return pad_js_1.padBytes; } }));
Object.defineProperty(exports, "padHex", ({ enumerable: true, get: function () { return pad_js_1.padHex; } }));
var size_js_1 = __webpack_require__(/*! ./data/size.js */ "./node_modules/viem/_cjs/utils/data/size.js");
Object.defineProperty(exports, "size", ({ enumerable: true, get: function () { return size_js_1.size; } }));
var slice_js_1 = __webpack_require__(/*! ./data/slice.js */ "./node_modules/viem/_cjs/utils/data/slice.js");
Object.defineProperty(exports, "slice", ({ enumerable: true, get: function () { return slice_js_1.slice; } }));
Object.defineProperty(exports, "sliceBytes", ({ enumerable: true, get: function () { return slice_js_1.sliceBytes; } }));
Object.defineProperty(exports, "sliceHex", ({ enumerable: true, get: function () { return slice_js_1.sliceHex; } }));
var trim_js_1 = __webpack_require__(/*! ./data/trim.js */ "./node_modules/viem/_cjs/utils/data/trim.js");
Object.defineProperty(exports, "trim", ({ enumerable: true, get: function () { return trim_js_1.trim; } }));
var fromBytes_js_1 = __webpack_require__(/*! ./encoding/fromBytes.js */ "./node_modules/viem/_cjs/utils/encoding/fromBytes.js");
Object.defineProperty(exports, "bytesToBigInt", ({ enumerable: true, get: function () { return fromBytes_js_1.bytesToBigInt; } }));
Object.defineProperty(exports, "bytesToBigint", ({ enumerable: true, get: function () { return fromBytes_js_1.bytesToBigInt; } }));
Object.defineProperty(exports, "bytesToBool", ({ enumerable: true, get: function () { return fromBytes_js_1.bytesToBool; } }));
Object.defineProperty(exports, "bytesToNumber", ({ enumerable: true, get: function () { return fromBytes_js_1.bytesToNumber; } }));
Object.defineProperty(exports, "bytesToString", ({ enumerable: true, get: function () { return fromBytes_js_1.bytesToString; } }));
Object.defineProperty(exports, "fromBytes", ({ enumerable: true, get: function () { return fromBytes_js_1.fromBytes; } }));
var fromHex_js_1 = __webpack_require__(/*! ./encoding/fromHex.js */ "./node_modules/viem/_cjs/utils/encoding/fromHex.js");
Object.defineProperty(exports, "fromHex", ({ enumerable: true, get: function () { return fromHex_js_1.fromHex; } }));
Object.defineProperty(exports, "hexToBigInt", ({ enumerable: true, get: function () { return fromHex_js_1.hexToBigInt; } }));
Object.defineProperty(exports, "hexToBool", ({ enumerable: true, get: function () { return fromHex_js_1.hexToBool; } }));
Object.defineProperty(exports, "hexToNumber", ({ enumerable: true, get: function () { return fromHex_js_1.hexToNumber; } }));
Object.defineProperty(exports, "hexToString", ({ enumerable: true, get: function () { return fromHex_js_1.hexToString; } }));
var fromRlp_js_1 = __webpack_require__(/*! ./encoding/fromRlp.js */ "./node_modules/viem/_cjs/utils/encoding/fromRlp.js");
Object.defineProperty(exports, "fromRlp", ({ enumerable: true, get: function () { return fromRlp_js_1.fromRlp; } }));
var toBytes_js_1 = __webpack_require__(/*! ./encoding/toBytes.js */ "./node_modules/viem/_cjs/utils/encoding/toBytes.js");
Object.defineProperty(exports, "boolToBytes", ({ enumerable: true, get: function () { return toBytes_js_1.boolToBytes; } }));
Object.defineProperty(exports, "hexToBytes", ({ enumerable: true, get: function () { return toBytes_js_1.hexToBytes; } }));
Object.defineProperty(exports, "numberToBytes", ({ enumerable: true, get: function () { return toBytes_js_1.numberToBytes; } }));
Object.defineProperty(exports, "stringToBytes", ({ enumerable: true, get: function () { return toBytes_js_1.stringToBytes; } }));
Object.defineProperty(exports, "toBytes", ({ enumerable: true, get: function () { return toBytes_js_1.toBytes; } }));
var toHex_js_1 = __webpack_require__(/*! ./encoding/toHex.js */ "./node_modules/viem/_cjs/utils/encoding/toHex.js");
Object.defineProperty(exports, "boolToHex", ({ enumerable: true, get: function () { return toHex_js_1.boolToHex; } }));
Object.defineProperty(exports, "bytesToHex", ({ enumerable: true, get: function () { return toHex_js_1.bytesToHex; } }));
Object.defineProperty(exports, "numberToHex", ({ enumerable: true, get: function () { return toHex_js_1.numberToHex; } }));
Object.defineProperty(exports, "stringToHex", ({ enumerable: true, get: function () { return toHex_js_1.stringToHex; } }));
Object.defineProperty(exports, "toHex", ({ enumerable: true, get: function () { return toHex_js_1.toHex; } }));
var toRlp_js_1 = __webpack_require__(/*! ./encoding/toRlp.js */ "./node_modules/viem/_cjs/utils/encoding/toRlp.js");
Object.defineProperty(exports, "toRlp", ({ enumerable: true, get: function () { return toRlp_js_1.toRlp; } }));
var getCallError_js_1 = __webpack_require__(/*! ./errors/getCallError.js */ "./node_modules/viem/_cjs/utils/errors/getCallError.js");
Object.defineProperty(exports, "getCallError", ({ enumerable: true, get: function () { return getCallError_js_1.getCallError; } }));
var getContractError_js_1 = __webpack_require__(/*! ./errors/getContractError.js */ "./node_modules/viem/_cjs/utils/errors/getContractError.js");
Object.defineProperty(exports, "getContractError", ({ enumerable: true, get: function () { return getContractError_js_1.getContractError; } }));
var getEstimateGasError_js_1 = __webpack_require__(/*! ./errors/getEstimateGasError.js */ "./node_modules/viem/_cjs/utils/errors/getEstimateGasError.js");
Object.defineProperty(exports, "getEstimateGasError", ({ enumerable: true, get: function () { return getEstimateGasError_js_1.getEstimateGasError; } }));
var getNodeError_js_1 = __webpack_require__(/*! ./errors/getNodeError.js */ "./node_modules/viem/_cjs/utils/errors/getNodeError.js");
Object.defineProperty(exports, "containsNodeError", ({ enumerable: true, get: function () { return getNodeError_js_1.containsNodeError; } }));
Object.defineProperty(exports, "getNodeError", ({ enumerable: true, get: function () { return getNodeError_js_1.getNodeError; } }));
var getTransactionError_js_1 = __webpack_require__(/*! ./errors/getTransactionError.js */ "./node_modules/viem/_cjs/utils/errors/getTransactionError.js");
Object.defineProperty(exports, "getTransactionError", ({ enumerable: true, get: function () { return getTransactionError_js_1.getTransactionError; } }));
var block_js_1 = __webpack_require__(/*! ./formatters/block.js */ "./node_modules/viem/_cjs/utils/formatters/block.js");
Object.defineProperty(exports, "defineBlock", ({ enumerable: true, get: function () { return block_js_1.defineBlock; } }));
Object.defineProperty(exports, "formatBlock", ({ enumerable: true, get: function () { return block_js_1.formatBlock; } }));
var extract_js_1 = __webpack_require__(/*! ./formatters/extract.js */ "./node_modules/viem/_cjs/utils/formatters/extract.js");
Object.defineProperty(exports, "extract", ({ enumerable: true, get: function () { return extract_js_1.extract; } }));
var formatter_js_1 = __webpack_require__(/*! ./formatters/formatter.js */ "./node_modules/viem/_cjs/utils/formatters/formatter.js");
Object.defineProperty(exports, "defineFormatter", ({ enumerable: true, get: function () { return formatter_js_1.defineFormatter; } }));
var log_js_1 = __webpack_require__(/*! ./formatters/log.js */ "./node_modules/viem/_cjs/utils/formatters/log.js");
Object.defineProperty(exports, "formatLog", ({ enumerable: true, get: function () { return log_js_1.formatLog; } }));
var transaction_js_1 = __webpack_require__(/*! ./formatters/transaction.js */ "./node_modules/viem/_cjs/utils/formatters/transaction.js");
Object.defineProperty(exports, "defineTransaction", ({ enumerable: true, get: function () { return transaction_js_1.defineTransaction; } }));
Object.defineProperty(exports, "formatTransaction", ({ enumerable: true, get: function () { return transaction_js_1.formatTransaction; } }));
Object.defineProperty(exports, "transactionType", ({ enumerable: true, get: function () { return transaction_js_1.transactionType; } }));
var transactionReceipt_js_1 = __webpack_require__(/*! ./formatters/transactionReceipt.js */ "./node_modules/viem/_cjs/utils/formatters/transactionReceipt.js");
Object.defineProperty(exports, "defineTransactionReceipt", ({ enumerable: true, get: function () { return transactionReceipt_js_1.defineTransactionReceipt; } }));
var transactionRequest_js_1 = __webpack_require__(/*! ./formatters/transactionRequest.js */ "./node_modules/viem/_cjs/utils/formatters/transactionRequest.js");
Object.defineProperty(exports, "defineTransactionRequest", ({ enumerable: true, get: function () { return transactionRequest_js_1.defineTransactionRequest; } }));
Object.defineProperty(exports, "formatTransactionRequest", ({ enumerable: true, get: function () { return transactionRequest_js_1.formatTransactionRequest; } }));
var getAction_js_1 = __webpack_require__(/*! ./getAction.js */ "./node_modules/viem/_cjs/utils/getAction.js");
Object.defineProperty(exports, "getAction", ({ enumerable: true, get: function () { return getAction_js_1.getAction; } }));
var isHash_js_1 = __webpack_require__(/*! ./hash/isHash.js */ "./node_modules/viem/_cjs/utils/hash/isHash.js");
Object.defineProperty(exports, "isHash", ({ enumerable: true, get: function () { return isHash_js_1.isHash; } }));
var keccak256_js_1 = __webpack_require__(/*! ./hash/keccak256.js */ "./node_modules/viem/_cjs/utils/hash/keccak256.js");
Object.defineProperty(exports, "keccak256", ({ enumerable: true, get: function () { return keccak256_js_1.keccak256; } }));
var ripemd160_js_1 = __webpack_require__(/*! ./hash/ripemd160.js */ "./node_modules/viem/_cjs/utils/hash/ripemd160.js");
Object.defineProperty(exports, "ripemd160", ({ enumerable: true, get: function () { return ripemd160_js_1.ripemd160; } }));
var sha256_js_1 = __webpack_require__(/*! ./hash/sha256.js */ "./node_modules/viem/_cjs/utils/hash/sha256.js");
Object.defineProperty(exports, "sha256", ({ enumerable: true, get: function () { return sha256_js_1.sha256; } }));
var toEventHash_js_1 = __webpack_require__(/*! ./hash/toEventHash.js */ "./node_modules/viem/_cjs/utils/hash/toEventHash.js");
Object.defineProperty(exports, "toEventHash", ({ enumerable: true, get: function () { return toEventHash_js_1.toEventHash; } }));
var toEventSelector_js_1 = __webpack_require__(/*! ./hash/toEventSelector.js */ "./node_modules/viem/_cjs/utils/hash/toEventSelector.js");
Object.defineProperty(exports, "toEventSelector", ({ enumerable: true, get: function () { return toEventSelector_js_1.toEventSelector; } }));
Object.defineProperty(exports, "getEventSelector", ({ enumerable: true, get: function () { return toEventSelector_js_1.toEventSelector; } }));
var toEventSignature_js_1 = __webpack_require__(/*! ./hash/toEventSignature.js */ "./node_modules/viem/_cjs/utils/hash/toEventSignature.js");
Object.defineProperty(exports, "toEventSignature", ({ enumerable: true, get: function () { return toEventSignature_js_1.toEventSignature; } }));
Object.defineProperty(exports, "getEventSignature", ({ enumerable: true, get: function () { return toEventSignature_js_1.toEventSignature; } }));
var toFunctionHash_js_1 = __webpack_require__(/*! ./hash/toFunctionHash.js */ "./node_modules/viem/_cjs/utils/hash/toFunctionHash.js");
Object.defineProperty(exports, "toFunctionHash", ({ enumerable: true, get: function () { return toFunctionHash_js_1.toFunctionHash; } }));
var toFunctionSelector_js_1 = __webpack_require__(/*! ./hash/toFunctionSelector.js */ "./node_modules/viem/_cjs/utils/hash/toFunctionSelector.js");
Object.defineProperty(exports, "toFunctionSelector", ({ enumerable: true, get: function () { return toFunctionSelector_js_1.toFunctionSelector; } }));
Object.defineProperty(exports, "getFunctionSelector", ({ enumerable: true, get: function () { return toFunctionSelector_js_1.toFunctionSelector; } }));
var toFunctionSignature_js_1 = __webpack_require__(/*! ./hash/toFunctionSignature.js */ "./node_modules/viem/_cjs/utils/hash/toFunctionSignature.js");
Object.defineProperty(exports, "toFunctionSignature", ({ enumerable: true, get: function () { return toFunctionSignature_js_1.toFunctionSignature; } }));
Object.defineProperty(exports, "getFunctionSignature", ({ enumerable: true, get: function () { return toFunctionSignature_js_1.toFunctionSignature; } }));
var nonceManager_js_1 = __webpack_require__(/*! ./nonceManager.js */ "./node_modules/viem/_cjs/utils/nonceManager.js");
Object.defineProperty(exports, "createNonceManager", ({ enumerable: true, get: function () { return nonceManager_js_1.createNonceManager; } }));
Object.defineProperty(exports, "nonceManager", ({ enumerable: true, get: function () { return nonceManager_js_1.nonceManager; } }));
var regex_js_1 = __webpack_require__(/*! ./regex.js */ "./node_modules/viem/_cjs/utils/regex.js");
Object.defineProperty(exports, "arrayRegex", ({ enumerable: true, get: function () { return regex_js_1.arrayRegex; } }));
Object.defineProperty(exports, "bytesRegex", ({ enumerable: true, get: function () { return regex_js_1.bytesRegex; } }));
Object.defineProperty(exports, "integerRegex", ({ enumerable: true, get: function () { return regex_js_1.integerRegex; } }));
var compat_js_1 = __webpack_require__(/*! ./rpc/compat.js */ "./node_modules/viem/_cjs/utils/rpc/compat.js");
Object.defineProperty(exports, "getSocket", ({ enumerable: true, get: function () { return compat_js_1.getSocket; } }));
Object.defineProperty(exports, "rpc", ({ enumerable: true, get: function () { return compat_js_1.rpc; } }));
var http_js_1 = __webpack_require__(/*! ./rpc/http.js */ "./node_modules/viem/_cjs/utils/rpc/http.js");
Object.defineProperty(exports, "getHttpRpcClient", ({ enumerable: true, get: function () { return http_js_1.getHttpRpcClient; } }));
var socket_js_1 = __webpack_require__(/*! ./rpc/socket.js */ "./node_modules/viem/_cjs/utils/rpc/socket.js");
Object.defineProperty(exports, "getSocketRpcClient", ({ enumerable: true, get: function () { return socket_js_1.getSocketRpcClient; } }));
Object.defineProperty(exports, "socketClientCache", ({ enumerable: true, get: function () { return socket_js_1.socketClientCache; } }));
var webSocket_js_1 = __webpack_require__(/*! ./rpc/webSocket.js */ "./node_modules/viem/_cjs/utils/rpc/webSocket.js");
Object.defineProperty(exports, "getWebSocketRpcClient", ({ enumerable: true, get: function () { return webSocket_js_1.getWebSocketRpcClient; } }));
var hashMessage_js_1 = __webpack_require__(/*! ./signature/hashMessage.js */ "./node_modules/viem/_cjs/utils/signature/hashMessage.js");
Object.defineProperty(exports, "hashMessage", ({ enumerable: true, get: function () { return hashMessage_js_1.hashMessage; } }));
var hashTypedData_js_1 = __webpack_require__(/*! ./signature/hashTypedData.js */ "./node_modules/viem/_cjs/utils/signature/hashTypedData.js");
Object.defineProperty(exports, "hashStruct", ({ enumerable: true, get: function () { return hashTypedData_js_1.hashStruct; } }));
Object.defineProperty(exports, "hashTypedData", ({ enumerable: true, get: function () { return hashTypedData_js_1.hashTypedData; } }));
var isErc6492Signature_js_1 = __webpack_require__(/*! ./signature/isErc6492Signature.js */ "./node_modules/viem/_cjs/utils/signature/isErc6492Signature.js");
Object.defineProperty(exports, "isErc6492Signature", ({ enumerable: true, get: function () { return isErc6492Signature_js_1.isErc6492Signature; } }));
var parseErc6492Signature_js_1 = __webpack_require__(/*! ./signature/parseErc6492Signature.js */ "./node_modules/viem/_cjs/utils/signature/parseErc6492Signature.js");
Object.defineProperty(exports, "parseErc6492Signature", ({ enumerable: true, get: function () { return parseErc6492Signature_js_1.parseErc6492Signature; } }));
var recoverAddress_js_1 = __webpack_require__(/*! ./signature/recoverAddress.js */ "./node_modules/viem/_cjs/utils/signature/recoverAddress.js");
Object.defineProperty(exports, "recoverAddress", ({ enumerable: true, get: function () { return recoverAddress_js_1.recoverAddress; } }));
var recoverMessageAddress_js_1 = __webpack_require__(/*! ./signature/recoverMessageAddress.js */ "./node_modules/viem/_cjs/utils/signature/recoverMessageAddress.js");
Object.defineProperty(exports, "recoverMessageAddress", ({ enumerable: true, get: function () { return recoverMessageAddress_js_1.recoverMessageAddress; } }));
var recoverPublicKey_js_1 = __webpack_require__(/*! ./signature/recoverPublicKey.js */ "./node_modules/viem/_cjs/utils/signature/recoverPublicKey.js");
Object.defineProperty(exports, "recoverPublicKey", ({ enumerable: true, get: function () { return recoverPublicKey_js_1.recoverPublicKey; } }));
var recoverTypedDataAddress_js_1 = __webpack_require__(/*! ./signature/recoverTypedDataAddress.js */ "./node_modules/viem/_cjs/utils/signature/recoverTypedDataAddress.js");
Object.defineProperty(exports, "recoverTypedDataAddress", ({ enumerable: true, get: function () { return recoverTypedDataAddress_js_1.recoverTypedDataAddress; } }));
var serializeErc6492Signature_js_1 = __webpack_require__(/*! ./signature/serializeErc6492Signature.js */ "./node_modules/viem/_cjs/utils/signature/serializeErc6492Signature.js");
Object.defineProperty(exports, "serializeErc6492Signature", ({ enumerable: true, get: function () { return serializeErc6492Signature_js_1.serializeErc6492Signature; } }));
var verifyHash_js_1 = __webpack_require__(/*! ./signature/verifyHash.js */ "./node_modules/viem/_cjs/utils/signature/verifyHash.js");
Object.defineProperty(exports, "verifyHash", ({ enumerable: true, get: function () { return verifyHash_js_1.verifyHash; } }));
var verifyMessage_js_1 = __webpack_require__(/*! ./signature/verifyMessage.js */ "./node_modules/viem/_cjs/utils/signature/verifyMessage.js");
Object.defineProperty(exports, "verifyMessage", ({ enumerable: true, get: function () { return verifyMessage_js_1.verifyMessage; } }));
var verifyTypedData_js_1 = __webpack_require__(/*! ./signature/verifyTypedData.js */ "./node_modules/viem/_cjs/utils/signature/verifyTypedData.js");
Object.defineProperty(exports, "verifyTypedData", ({ enumerable: true, get: function () { return verifyTypedData_js_1.verifyTypedData; } }));
var stringify_js_1 = __webpack_require__(/*! ./stringify.js */ "./node_modules/viem/_cjs/utils/stringify.js");
Object.defineProperty(exports, "stringify", ({ enumerable: true, get: function () { return stringify_js_1.stringify; } }));
var assertRequest_js_1 = __webpack_require__(/*! ./transaction/assertRequest.js */ "./node_modules/viem/_cjs/utils/transaction/assertRequest.js");
Object.defineProperty(exports, "assertRequest", ({ enumerable: true, get: function () { return assertRequest_js_1.assertRequest; } }));
var assertTransaction_js_1 = __webpack_require__(/*! ./transaction/assertTransaction.js */ "./node_modules/viem/_cjs/utils/transaction/assertTransaction.js");
Object.defineProperty(exports, "assertTransactionEIP1559", ({ enumerable: true, get: function () { return assertTransaction_js_1.assertTransactionEIP1559; } }));
Object.defineProperty(exports, "assertTransactionEIP2930", ({ enumerable: true, get: function () { return assertTransaction_js_1.assertTransactionEIP2930; } }));
Object.defineProperty(exports, "assertTransactionLegacy", ({ enumerable: true, get: function () { return assertTransaction_js_1.assertTransactionLegacy; } }));
var getSerializedTransactionType_js_1 = __webpack_require__(/*! ./transaction/getSerializedTransactionType.js */ "./node_modules/viem/_cjs/utils/transaction/getSerializedTransactionType.js");
Object.defineProperty(exports, "getSerializedTransactionType", ({ enumerable: true, get: function () { return getSerializedTransactionType_js_1.getSerializedTransactionType; } }));
var getTransactionType_js_1 = __webpack_require__(/*! ./transaction/getTransactionType.js */ "./node_modules/viem/_cjs/utils/transaction/getTransactionType.js");
Object.defineProperty(exports, "getTransactionType", ({ enumerable: true, get: function () { return getTransactionType_js_1.getTransactionType; } }));
var parseTransaction_js_1 = __webpack_require__(/*! ./transaction/parseTransaction.js */ "./node_modules/viem/_cjs/utils/transaction/parseTransaction.js");
Object.defineProperty(exports, "parseTransaction", ({ enumerable: true, get: function () { return parseTransaction_js_1.parseTransaction; } }));
var serializeAccessList_js_1 = __webpack_require__(/*! ./transaction/serializeAccessList.js */ "./node_modules/viem/_cjs/utils/transaction/serializeAccessList.js");
Object.defineProperty(exports, "serializeAccessList", ({ enumerable: true, get: function () { return serializeAccessList_js_1.serializeAccessList; } }));
var serializeTransaction_js_1 = __webpack_require__(/*! ./transaction/serializeTransaction.js */ "./node_modules/viem/_cjs/utils/transaction/serializeTransaction.js");
Object.defineProperty(exports, "serializeTransaction", ({ enumerable: true, get: function () { return serializeTransaction_js_1.serializeTransaction; } }));
var typedData_js_1 = __webpack_require__(/*! ./typedData.js */ "./node_modules/viem/_cjs/utils/typedData.js");
Object.defineProperty(exports, "serializeTypedData", ({ enumerable: true, get: function () { return typedData_js_1.serializeTypedData; } }));
Object.defineProperty(exports, "validateTypedData", ({ enumerable: true, get: function () { return typedData_js_1.validateTypedData; } }));
var formatEther_js_1 = __webpack_require__(/*! ./unit/formatEther.js */ "./node_modules/viem/_cjs/utils/unit/formatEther.js");
Object.defineProperty(exports, "formatEther", ({ enumerable: true, get: function () { return formatEther_js_1.formatEther; } }));
var formatGwei_js_1 = __webpack_require__(/*! ./unit/formatGwei.js */ "./node_modules/viem/_cjs/utils/unit/formatGwei.js");
Object.defineProperty(exports, "formatGwei", ({ enumerable: true, get: function () { return formatGwei_js_1.formatGwei; } }));
var formatUnits_js_1 = __webpack_require__(/*! ./unit/formatUnits.js */ "./node_modules/viem/_cjs/utils/unit/formatUnits.js");
Object.defineProperty(exports, "formatUnits", ({ enumerable: true, get: function () { return formatUnits_js_1.formatUnits; } }));
var parseEther_js_1 = __webpack_require__(/*! ./unit/parseEther.js */ "./node_modules/viem/_cjs/utils/unit/parseEther.js");
Object.defineProperty(exports, "parseEther", ({ enumerable: true, get: function () { return parseEther_js_1.parseEther; } }));
var parseGwei_js_1 = __webpack_require__(/*! ./unit/parseGwei.js */ "./node_modules/viem/_cjs/utils/unit/parseGwei.js");
Object.defineProperty(exports, "parseGwei", ({ enumerable: true, get: function () { return parseGwei_js_1.parseGwei; } }));
var parseUnits_js_1 = __webpack_require__(/*! ./unit/parseUnits.js */ "./node_modules/viem/_cjs/utils/unit/parseUnits.js");
Object.defineProperty(exports, "parseUnits", ({ enumerable: true, get: function () { return parseUnits_js_1.parseUnits; } }));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/utils/kzg/defineKzg.js":
/*!*******************************************************!*\
  !*** ./node_modules/viem/_cjs/utils/kzg/defineKzg.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.defineKzg = defineKzg;
function defineKzg({ blobToKzgCommitment, computeBlobKzgProof, }) {
    return {
        blobToKzgCommitment,
        computeBlobKzgProof,
    };
}
//# sourceMappingURL=defineKzg.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/utils/kzg/setupKzg.js":
/*!******************************************************!*\
  !*** ./node_modules/viem/_cjs/utils/kzg/setupKzg.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.setupKzg = setupKzg;
const defineKzg_js_1 = __webpack_require__(/*! ./defineKzg.js */ "./node_modules/viem/_cjs/utils/kzg/defineKzg.js");
function setupKzg(parameters, path) {
    try {
        parameters.loadTrustedSetup(path);
    }
    catch (e) {
        const error = e;
        if (!error.message.includes('trusted setup is already loaded'))
            throw error;
    }
    return (0, defineKzg_js_1.defineKzg)(parameters);
}
//# sourceMappingURL=setupKzg.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/utils/lru.js":
/*!*********************************************!*\
  !*** ./node_modules/viem/_cjs/utils/lru.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LruMap = void 0;
class LruMap extends Map {
    constructor(size) {
        super();
        Object.defineProperty(this, "maxSize", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.maxSize = size;
    }
    get(key) {
        const value = super.get(key);
        if (super.has(key) && value !== undefined) {
            this.delete(key);
            super.set(key, value);
        }
        return value;
    }
    set(key, value) {
        super.set(key, value);
        if (this.maxSize && this.size > this.maxSize) {
            const firstKey = this.keys().next().value;
            if (firstKey)
                this.delete(firstKey);
        }
        return this;
    }
}
exports.LruMap = LruMap;
//# sourceMappingURL=lru.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/utils/nonceManager.js":
/*!******************************************************!*\
  !*** ./node_modules/viem/_cjs/utils/nonceManager.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.nonceManager = void 0;
exports.createNonceManager = createNonceManager;
exports.jsonRpc = jsonRpc;
const getTransactionCount_js_1 = __webpack_require__(/*! ../actions/public/getTransactionCount.js */ "./node_modules/viem/_cjs/actions/public/getTransactionCount.js");
const lru_js_1 = __webpack_require__(/*! ./lru.js */ "./node_modules/viem/_cjs/utils/lru.js");
function createNonceManager(parameters) {
    const { source } = parameters;
    const deltaMap = new Map();
    const nonceMap = new lru_js_1.LruMap(8192);
    const promiseMap = new Map();
    const getKey = ({ address, chainId }) => `${address}.${chainId}`;
    return {
        async consume({ address, chainId, client }) {
            const key = getKey({ address, chainId });
            const promise = this.get({ address, chainId, client });
            this.increment({ address, chainId });
            const nonce = await promise;
            await source.set({ address, chainId }, nonce);
            nonceMap.set(key, nonce);
            return nonce;
        },
        async increment({ address, chainId }) {
            const key = getKey({ address, chainId });
            const delta = deltaMap.get(key) ?? 0;
            deltaMap.set(key, delta + 1);
        },
        async get({ address, chainId, client }) {
            const key = getKey({ address, chainId });
            let promise = promiseMap.get(key);
            if (!promise) {
                promise = (async () => {
                    try {
                        const nonce = await source.get({ address, chainId, client });
                        const previousNonce = nonceMap.get(key) ?? 0;
                        if (previousNonce > 0 && nonce <= previousNonce)
                            return previousNonce + 1;
                        nonceMap.delete(key);
                        return nonce;
                    }
                    finally {
                        this.reset({ address, chainId });
                    }
                })();
                promiseMap.set(key, promise);
            }
            const delta = deltaMap.get(key) ?? 0;
            return delta + (await promise);
        },
        reset({ address, chainId }) {
            const key = getKey({ address, chainId });
            deltaMap.delete(key);
            promiseMap.delete(key);
        },
    };
}
function jsonRpc() {
    return {
        async get(parameters) {
            const { address, client } = parameters;
            return (0, getTransactionCount_js_1.getTransactionCount)(client, {
                address,
                blockTag: 'pending',
            });
        },
        set() { },
    };
}
exports.nonceManager = createNonceManager({
    source: jsonRpc(),
});
//# sourceMappingURL=nonceManager.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/utils/observe.js":
/*!*************************************************!*\
  !*** ./node_modules/viem/_cjs/utils/observe.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.cleanupCache = exports.listenersCache = void 0;
exports.observe = observe;
exports.listenersCache = new Map();
exports.cleanupCache = new Map();
let callbackCount = 0;
function observe(observerId, callbacks, fn) {
    const callbackId = ++callbackCount;
    const getListeners = () => exports.listenersCache.get(observerId) || [];
    const unsubscribe = () => {
        const listeners = getListeners();
        exports.listenersCache.set(observerId, listeners.filter((cb) => cb.id !== callbackId));
    };
    const unwatch = () => {
        const listeners = getListeners();
        if (!listeners.some((cb) => cb.id === callbackId))
            return;
        const cleanup = exports.cleanupCache.get(observerId);
        if (listeners.length === 1 && cleanup) {
            const p = cleanup();
            if (p instanceof Promise)
                p.catch(() => { });
        }
        unsubscribe();
    };
    const listeners = getListeners();
    exports.listenersCache.set(observerId, [
        ...listeners,
        { id: callbackId, fns: callbacks },
    ]);
    if (listeners && listeners.length > 0)
        return unwatch;
    const emit = {};
    for (const key in callbacks) {
        emit[key] = ((...args) => {
            const listeners = getListeners();
            if (listeners.length === 0)
                return;
            for (const listener of listeners)
                listener.fns[key]?.(...args);
        });
    }
    const cleanup = fn(emit);
    if (typeof cleanup === 'function')
        exports.cleanupCache.set(observerId, cleanup);
    return unwatch;
}
//# sourceMappingURL=observe.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/utils/poll.js":
/*!**********************************************!*\
  !*** ./node_modules/viem/_cjs/utils/poll.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.poll = poll;
const wait_js_1 = __webpack_require__(/*! ./wait.js */ "./node_modules/viem/_cjs/utils/wait.js");
function poll(fn, { emitOnBegin, initialWaitTime, interval }) {
    let active = true;
    const unwatch = () => (active = false);
    const watch = async () => {
        let data;
        if (emitOnBegin)
            data = await fn({ unpoll: unwatch });
        const initialWait = (await initialWaitTime?.(data)) ?? interval;
        await (0, wait_js_1.wait)(initialWait);
        const poll = async () => {
            if (!active)
                return;
            await fn({ unpoll: unwatch });
            await (0, wait_js_1.wait)(interval);
            poll();
        };
        poll();
    };
    watch();
    return unwatch;
}
//# sourceMappingURL=poll.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/utils/promise/createBatchScheduler.js":
/*!**********************************************************************!*\
  !*** ./node_modules/viem/_cjs/utils/promise/createBatchScheduler.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createBatchScheduler = createBatchScheduler;
const withResolvers_js_1 = __webpack_require__(/*! ./withResolvers.js */ "./node_modules/viem/_cjs/utils/promise/withResolvers.js");
const schedulerCache = new Map();
function createBatchScheduler({ fn, id, shouldSplitBatch, wait = 0, sort, }) {
    const exec = async () => {
        const scheduler = getScheduler();
        flush();
        const args = scheduler.map(({ args }) => args);
        if (args.length === 0)
            return;
        fn(args)
            .then((data) => {
            if (sort && Array.isArray(data))
                data.sort(sort);
            for (let i = 0; i < scheduler.length; i++) {
                const { resolve } = scheduler[i];
                resolve?.([data[i], data]);
            }
        })
            .catch((err) => {
            for (let i = 0; i < scheduler.length; i++) {
                const { reject } = scheduler[i];
                reject?.(err);
            }
        });
    };
    const flush = () => schedulerCache.delete(id);
    const getBatchedArgs = () => getScheduler().map(({ args }) => args);
    const getScheduler = () => schedulerCache.get(id) || [];
    const setScheduler = (item) => schedulerCache.set(id, [...getScheduler(), item]);
    return {
        flush,
        async schedule(args) {
            const { promise, resolve, reject } = (0, withResolvers_js_1.withResolvers)();
            const split = shouldSplitBatch?.([...getBatchedArgs(), args]);
            if (split)
                exec();
            const hasActiveScheduler = getScheduler().length > 0;
            if (hasActiveScheduler) {
                setScheduler({ args, resolve, reject });
                return promise;
            }
            setScheduler({ args, resolve, reject });
            setTimeout(exec, wait);
            return promise;
        },
    };
}
//# sourceMappingURL=createBatchScheduler.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/utils/promise/withCache.js":
/*!***********************************************************!*\
  !*** ./node_modules/viem/_cjs/utils/promise/withCache.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.responseCache = exports.promiseCache = void 0;
exports.getCache = getCache;
exports.withCache = withCache;
exports.promiseCache = new Map();
exports.responseCache = new Map();
function getCache(cacheKey) {
    const buildCache = (cacheKey, cache) => ({
        clear: () => cache.delete(cacheKey),
        get: () => cache.get(cacheKey),
        set: (data) => cache.set(cacheKey, data),
    });
    const promise = buildCache(cacheKey, exports.promiseCache);
    const response = buildCache(cacheKey, exports.responseCache);
    return {
        clear: () => {
            promise.clear();
            response.clear();
        },
        promise,
        response,
    };
}
async function withCache(fn, { cacheKey, cacheTime = Number.POSITIVE_INFINITY }) {
    const cache = getCache(cacheKey);
    const response = cache.response.get();
    if (response && cacheTime > 0) {
        const age = Date.now() - response.created.getTime();
        if (age < cacheTime)
            return response.data;
    }
    let promise = cache.promise.get();
    if (!promise) {
        promise = fn();
        cache.promise.set(promise);
    }
    try {
        const data = await promise;
        cache.response.set({ created: new Date(), data });
        return data;
    }
    finally {
        cache.promise.clear();
    }
}
//# sourceMappingURL=withCache.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/utils/promise/withDedupe.js":
/*!************************************************************!*\
  !*** ./node_modules/viem/_cjs/utils/promise/withDedupe.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.promiseCache = void 0;
exports.withDedupe = withDedupe;
const lru_js_1 = __webpack_require__(/*! ../lru.js */ "./node_modules/viem/_cjs/utils/lru.js");
exports.promiseCache = new lru_js_1.LruMap(8192);
function withDedupe(fn, { enabled = true, id }) {
    if (!enabled || !id)
        return fn();
    if (exports.promiseCache.get(id))
        return exports.promiseCache.get(id);
    const promise = fn().finally(() => exports.promiseCache.delete(id));
    exports.promiseCache.set(id, promise);
    return promise;
}
//# sourceMappingURL=withDedupe.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/utils/promise/withResolvers.js":
/*!***************************************************************!*\
  !*** ./node_modules/viem/_cjs/utils/promise/withResolvers.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.withResolvers = withResolvers;
function withResolvers() {
    let resolve = () => undefined;
    let reject = () => undefined;
    const promise = new Promise((resolve_, reject_) => {
        resolve = resolve_;
        reject = reject_;
    });
    return { promise, resolve, reject };
}
//# sourceMappingURL=withResolvers.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/utils/promise/withRetry.js":
/*!***********************************************************!*\
  !*** ./node_modules/viem/_cjs/utils/promise/withRetry.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.withRetry = withRetry;
const wait_js_1 = __webpack_require__(/*! ../wait.js */ "./node_modules/viem/_cjs/utils/wait.js");
function withRetry(fn, { delay: delay_ = 100, retryCount = 2, shouldRetry = () => true, } = {}) {
    return new Promise((resolve, reject) => {
        const attemptRetry = async ({ count = 0 } = {}) => {
            const retry = async ({ error }) => {
                const delay = typeof delay_ === 'function' ? delay_({ count, error }) : delay_;
                if (delay)
                    await (0, wait_js_1.wait)(delay);
                attemptRetry({ count: count + 1 });
            };
            try {
                const data = await fn();
                resolve(data);
            }
            catch (err) {
                if (count < retryCount &&
                    (await shouldRetry({ count, error: err })))
                    return retry({ error: err });
                reject(err);
            }
        };
        attemptRetry();
    });
}
//# sourceMappingURL=withRetry.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/utils/promise/withTimeout.js":
/*!*************************************************************!*\
  !*** ./node_modules/viem/_cjs/utils/promise/withTimeout.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.withTimeout = withTimeout;
function withTimeout(fn, { errorInstance = new Error('timed out'), timeout, signal, }) {
    return new Promise((resolve, reject) => {
        ;
        (async () => {
            let timeoutId;
            try {
                const controller = new AbortController();
                if (timeout > 0) {
                    timeoutId = setTimeout(() => {
                        if (signal) {
                            controller.abort();
                        }
                        else {
                            reject(errorInstance);
                        }
                    }, timeout);
                }
                resolve(await fn({ signal: controller?.signal || null }));
            }
            catch (err) {
                if (err?.name === 'AbortError')
                    reject(errorInstance);
                reject(err);
            }
            finally {
                clearTimeout(timeoutId);
            }
        })();
    });
}
//# sourceMappingURL=withTimeout.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/utils/regex.js":
/*!***********************************************!*\
  !*** ./node_modules/viem/_cjs/utils/regex.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.integerRegex = exports.bytesRegex = exports.arrayRegex = void 0;
exports.arrayRegex = /^(.*)\[([0-9]*)\]$/;
exports.bytesRegex = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/;
exports.integerRegex = /^(u?int)(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/;
//# sourceMappingURL=regex.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/utils/rpc/compat.js":
/*!****************************************************!*\
  !*** ./node_modules/viem/_cjs/utils/rpc/compat.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.rpc = void 0;
exports.getSocket = getSocket;
const http_js_1 = __webpack_require__(/*! ./http.js */ "./node_modules/viem/_cjs/utils/rpc/http.js");
const webSocket_js_1 = __webpack_require__(/*! ./webSocket.js */ "./node_modules/viem/_cjs/utils/rpc/webSocket.js");
function webSocket(socketClient, { body, onError, onResponse }) {
    socketClient.request({
        body,
        onError,
        onResponse,
    });
    return socketClient;
}
async function webSocketAsync(socketClient, { body, timeout = 10_000 }) {
    return socketClient.requestAsync({
        body,
        timeout,
    });
}
async function getSocket(url) {
    const client = await (0, webSocket_js_1.getWebSocketRpcClient)(url);
    return Object.assign(client.socket, {
        requests: client.requests,
        subscriptions: client.subscriptions,
    });
}
exports.rpc = {
    http(url, params) {
        return (0, http_js_1.getHttpRpcClient)(url).request(params);
    },
    webSocket,
    webSocketAsync,
};
//# sourceMappingURL=compat.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/utils/rpc/http.js":
/*!**************************************************!*\
  !*** ./node_modules/viem/_cjs/utils/rpc/http.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getHttpRpcClient = getHttpRpcClient;
const request_js_1 = __webpack_require__(/*! ../../errors/request.js */ "./node_modules/viem/_cjs/errors/request.js");
const withTimeout_js_1 = __webpack_require__(/*! ../promise/withTimeout.js */ "./node_modules/viem/_cjs/utils/promise/withTimeout.js");
const stringify_js_1 = __webpack_require__(/*! ../stringify.js */ "./node_modules/viem/_cjs/utils/stringify.js");
const id_js_1 = __webpack_require__(/*! ./id.js */ "./node_modules/viem/_cjs/utils/rpc/id.js");
function getHttpRpcClient(url, options = {}) {
    return {
        async request(params) {
            const { body, onRequest = options.onRequest, onResponse = options.onResponse, timeout = options.timeout ?? 10_000, } = params;
            const fetchOptions = {
                ...(options.fetchOptions ?? {}),
                ...(params.fetchOptions ?? {}),
            };
            const { headers, method, signal: signal_ } = fetchOptions;
            try {
                const response = await (0, withTimeout_js_1.withTimeout)(async ({ signal }) => {
                    const init = {
                        ...fetchOptions,
                        body: Array.isArray(body)
                            ? (0, stringify_js_1.stringify)(body.map((body) => ({
                                jsonrpc: '2.0',
                                id: body.id ?? id_js_1.idCache.take(),
                                ...body,
                            })))
                            : (0, stringify_js_1.stringify)({
                                jsonrpc: '2.0',
                                id: body.id ?? id_js_1.idCache.take(),
                                ...body,
                            }),
                        headers: {
                            'Content-Type': 'application/json',
                            ...headers,
                        },
                        method: method || 'POST',
                        signal: signal_ || (timeout > 0 ? signal : null),
                    };
                    const request = new Request(url, init);
                    const args = (await onRequest?.(request, init)) ?? { ...init, url };
                    const response = await fetch(args.url ?? url, args);
                    return response;
                }, {
                    errorInstance: new request_js_1.TimeoutError({ body, url }),
                    timeout,
                    signal: true,
                });
                if (onResponse)
                    await onResponse(response);
                let data;
                if (response.headers.get('Content-Type')?.startsWith('application/json'))
                    data = await response.json();
                else {
                    data = await response.text();
                    try {
                        data = JSON.parse(data || '{}');
                    }
                    catch (err) {
                        if (response.ok)
                            throw err;
                        data = { error: data };
                    }
                }
                if (!response.ok) {
                    throw new request_js_1.HttpRequestError({
                        body,
                        details: (0, stringify_js_1.stringify)(data.error) || response.statusText,
                        headers: response.headers,
                        status: response.status,
                        url,
                    });
                }
                return data;
            }
            catch (err) {
                if (err instanceof request_js_1.HttpRequestError)
                    throw err;
                if (err instanceof request_js_1.TimeoutError)
                    throw err;
                throw new request_js_1.HttpRequestError({
                    body,
                    cause: err,
                    url,
                });
            }
        },
    };
}
//# sourceMappingURL=http.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/utils/rpc/id.js":
/*!************************************************!*\
  !*** ./node_modules/viem/_cjs/utils/rpc/id.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.idCache = void 0;
function createIdStore() {
    return {
        current: 0,
        take() {
            return this.current++;
        },
        reset() {
            this.current = 0;
        },
    };
}
exports.idCache = createIdStore();
//# sourceMappingURL=id.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/utils/rpc/socket.js":
/*!****************************************************!*\
  !*** ./node_modules/viem/_cjs/utils/rpc/socket.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.socketClientCache = void 0;
exports.getSocketRpcClient = getSocketRpcClient;
const request_js_1 = __webpack_require__(/*! ../../errors/request.js */ "./node_modules/viem/_cjs/errors/request.js");
const createBatchScheduler_js_1 = __webpack_require__(/*! ../promise/createBatchScheduler.js */ "./node_modules/viem/_cjs/utils/promise/createBatchScheduler.js");
const withTimeout_js_1 = __webpack_require__(/*! ../promise/withTimeout.js */ "./node_modules/viem/_cjs/utils/promise/withTimeout.js");
const id_js_1 = __webpack_require__(/*! ./id.js */ "./node_modules/viem/_cjs/utils/rpc/id.js");
exports.socketClientCache = new Map();
async function getSocketRpcClient(parameters) {
    const { getSocket, keepAlive = true, key = 'socket', reconnect = true, url, } = parameters;
    const { interval: keepAliveInterval = 30_000 } = typeof keepAlive === 'object' ? keepAlive : {};
    const { attempts = 5, delay = 2_000 } = typeof reconnect === 'object' ? reconnect : {};
    const id = JSON.stringify({ keepAlive, key, url, reconnect });
    let socketClient = exports.socketClientCache.get(id);
    if (socketClient)
        return socketClient;
    let reconnectCount = 0;
    const { schedule } = (0, createBatchScheduler_js_1.createBatchScheduler)({
        id,
        fn: async () => {
            const requests = new Map();
            const subscriptions = new Map();
            let error;
            let socket;
            let keepAliveTimer;
            let reconnectInProgress = false;
            function attemptReconnect() {
                if (reconnect && reconnectCount < attempts) {
                    if (reconnectInProgress)
                        return;
                    reconnectInProgress = true;
                    reconnectCount++;
                    socket?.close();
                    setTimeout(async () => {
                        await setup().catch(console.error);
                        reconnectInProgress = false;
                    }, delay);
                }
                else {
                    requests.clear();
                    subscriptions.clear();
                }
            }
            async function setup() {
                const result = await getSocket({
                    onClose() {
                        for (const request of requests.values())
                            request.onError?.(new request_js_1.SocketClosedError({ url }));
                        for (const subscription of subscriptions.values())
                            subscription.onError?.(new request_js_1.SocketClosedError({ url }));
                        attemptReconnect();
                    },
                    onError(error_) {
                        error = error_;
                        for (const request of requests.values())
                            request.onError?.(error);
                        for (const subscription of subscriptions.values())
                            subscription.onError?.(error);
                        attemptReconnect();
                    },
                    onOpen() {
                        error = undefined;
                        reconnectCount = 0;
                    },
                    onResponse(data) {
                        const isSubscription = data.method === 'eth_subscription';
                        const id = isSubscription ? data.params.subscription : data.id;
                        const cache = isSubscription ? subscriptions : requests;
                        const callback = cache.get(id);
                        if (callback)
                            callback.onResponse(data);
                        if (!isSubscription)
                            cache.delete(id);
                    },
                });
                socket = result;
                if (keepAlive) {
                    if (keepAliveTimer)
                        clearInterval(keepAliveTimer);
                    keepAliveTimer = setInterval(() => socket.ping?.(), keepAliveInterval);
                }
                if (reconnect && subscriptions.size > 0) {
                    const subscriptionEntries = subscriptions.entries();
                    for (const [key, { onResponse, body, onError },] of subscriptionEntries) {
                        if (!body)
                            continue;
                        subscriptions.delete(key);
                        socketClient?.request({ body, onResponse, onError });
                    }
                }
                return result;
            }
            await setup();
            error = undefined;
            socketClient = {
                close() {
                    keepAliveTimer && clearInterval(keepAliveTimer);
                    socket.close();
                    exports.socketClientCache.delete(id);
                },
                get socket() {
                    return socket;
                },
                request({ body, onError, onResponse }) {
                    if (error && onError)
                        onError(error);
                    const id = body.id ?? id_js_1.idCache.take();
                    const callback = (response) => {
                        if (typeof response.id === 'number' && id !== response.id)
                            return;
                        if (body.method === 'eth_subscribe' &&
                            typeof response.result === 'string')
                            subscriptions.set(response.result, {
                                onResponse: callback,
                                onError,
                                body,
                            });
                        if (body.method === 'eth_unsubscribe')
                            subscriptions.delete(body.params?.[0]);
                        onResponse(response);
                    };
                    requests.set(id, { onResponse: callback, onError });
                    try {
                        socket.request({
                            body: {
                                jsonrpc: '2.0',
                                id,
                                ...body,
                            },
                        });
                    }
                    catch (error) {
                        onError?.(error);
                    }
                },
                requestAsync({ body, timeout = 10_000 }) {
                    return (0, withTimeout_js_1.withTimeout)(() => new Promise((onResponse, onError) => this.request({
                        body,
                        onError,
                        onResponse,
                    })), {
                        errorInstance: new request_js_1.TimeoutError({ body, url }),
                        timeout,
                    });
                },
                requests,
                subscriptions,
                url,
            };
            exports.socketClientCache.set(id, socketClient);
            return [socketClient];
        },
    });
    const [_, [socketClient_]] = await schedule();
    return socketClient_;
}
//# sourceMappingURL=socket.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/utils/rpc/webSocket.js":
/*!*******************************************************!*\
  !*** ./node_modules/viem/_cjs/utils/rpc/webSocket.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getWebSocketRpcClient = getWebSocketRpcClient;
const request_js_1 = __webpack_require__(/*! ../../errors/request.js */ "./node_modules/viem/_cjs/errors/request.js");
const socket_js_1 = __webpack_require__(/*! ./socket.js */ "./node_modules/viem/_cjs/utils/rpc/socket.js");
async function getWebSocketRpcClient(url, options = {}) {
    const { keepAlive, reconnect } = options;
    return (0, socket_js_1.getSocketRpcClient)({
        async getSocket({ onClose, onError, onOpen, onResponse }) {
            const WebSocket = await Promise.resolve().then(() => __webpack_require__(/*! isows */ "./node_modules/isows/_esm/native.js")).then((module) => module.WebSocket);
            const socket = new WebSocket(url);
            function onClose_() {
                socket.removeEventListener('close', onClose_);
                socket.removeEventListener('message', onMessage);
                socket.removeEventListener('error', onError);
                socket.removeEventListener('open', onOpen);
                onClose();
            }
            function onMessage({ data }) {
                try {
                    const _data = JSON.parse(data);
                    onResponse(_data);
                }
                catch (error) {
                    onError(error);
                }
            }
            socket.addEventListener('close', onClose_);
            socket.addEventListener('message', onMessage);
            socket.addEventListener('error', onError);
            socket.addEventListener('open', onOpen);
            if (socket.readyState === WebSocket.CONNECTING) {
                await new Promise((resolve, reject) => {
                    if (!socket)
                        return;
                    socket.onopen = resolve;
                    socket.onerror = reject;
                });
            }
            const { close: close_ } = socket;
            return Object.assign(socket, {
                close() {
                    close_.bind(socket)();
                    onClose_();
                },
                ping() {
                    try {
                        if (socket.readyState === socket.CLOSED ||
                            socket.readyState === socket.CLOSING)
                            throw new request_js_1.WebSocketRequestError({
                                url: socket.url,
                                cause: new request_js_1.SocketClosedError({ url: socket.url }),
                            });
                        const body = {
                            jsonrpc: '2.0',
                            method: 'net_version',
                            params: [],
                        };
                        socket.send(JSON.stringify(body));
                    }
                    catch (error) {
                        onError(error);
                    }
                },
                request({ body }) {
                    if (socket.readyState === socket.CLOSED ||
                        socket.readyState === socket.CLOSING)
                        throw new request_js_1.WebSocketRequestError({
                            body,
                            url: socket.url,
                            cause: new request_js_1.SocketClosedError({ url: socket.url }),
                        });
                    return socket.send(JSON.stringify(body));
                },
            });
        },
        keepAlive,
        reconnect,
        url,
    });
}
//# sourceMappingURL=webSocket.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/utils/signature/compactSignatureToSignature.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/viem/_cjs/utils/signature/compactSignatureToSignature.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.compactSignatureToSignature = compactSignatureToSignature;
const toBytes_js_1 = __webpack_require__(/*! ../encoding/toBytes.js */ "./node_modules/viem/_cjs/utils/encoding/toBytes.js");
const toHex_js_1 = __webpack_require__(/*! ../encoding/toHex.js */ "./node_modules/viem/_cjs/utils/encoding/toHex.js");
function compactSignatureToSignature({ r, yParityAndS, }) {
    const yParityAndS_bytes = (0, toBytes_js_1.hexToBytes)(yParityAndS);
    const yParity = yParityAndS_bytes[0] & 0x80 ? 1 : 0;
    const s = yParityAndS_bytes;
    if (yParity === 1)
        s[0] &= 0x7f;
    return { r, s: (0, toHex_js_1.bytesToHex)(s), yParity };
}
//# sourceMappingURL=compactSignatureToSignature.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/utils/signature/hashMessage.js":
/*!***************************************************************!*\
  !*** ./node_modules/viem/_cjs/utils/signature/hashMessage.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.hashMessage = hashMessage;
const keccak256_js_1 = __webpack_require__(/*! ../hash/keccak256.js */ "./node_modules/viem/_cjs/utils/hash/keccak256.js");
const toPrefixedMessage_js_1 = __webpack_require__(/*! ./toPrefixedMessage.js */ "./node_modules/viem/_cjs/utils/signature/toPrefixedMessage.js");
function hashMessage(message, to_) {
    return (0, keccak256_js_1.keccak256)((0, toPrefixedMessage_js_1.toPrefixedMessage)(message), to_);
}
//# sourceMappingURL=hashMessage.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/utils/signature/hashTypedData.js":
/*!*****************************************************************!*\
  !*** ./node_modules/viem/_cjs/utils/signature/hashTypedData.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.hashTypedData = hashTypedData;
exports.hashDomain = hashDomain;
exports.hashStruct = hashStruct;
exports.encodeType = encodeType;
const encodeAbiParameters_js_1 = __webpack_require__(/*! ../abi/encodeAbiParameters.js */ "./node_modules/viem/_cjs/utils/abi/encodeAbiParameters.js");
const concat_js_1 = __webpack_require__(/*! ../data/concat.js */ "./node_modules/viem/_cjs/utils/data/concat.js");
const toHex_js_1 = __webpack_require__(/*! ../encoding/toHex.js */ "./node_modules/viem/_cjs/utils/encoding/toHex.js");
const keccak256_js_1 = __webpack_require__(/*! ../hash/keccak256.js */ "./node_modules/viem/_cjs/utils/hash/keccak256.js");
const typedData_js_1 = __webpack_require__(/*! ../typedData.js */ "./node_modules/viem/_cjs/utils/typedData.js");
function hashTypedData(parameters) {
    const { domain = {}, message, primaryType, } = parameters;
    const types = {
        EIP712Domain: (0, typedData_js_1.getTypesForEIP712Domain)({ domain }),
        ...parameters.types,
    };
    (0, typedData_js_1.validateTypedData)({
        domain,
        message,
        primaryType,
        types,
    });
    const parts = ['0x1901'];
    if (domain)
        parts.push(hashDomain({
            domain,
            types: types,
        }));
    if (primaryType !== 'EIP712Domain')
        parts.push(hashStruct({
            data: message,
            primaryType,
            types: types,
        }));
    return (0, keccak256_js_1.keccak256)((0, concat_js_1.concat)(parts));
}
function hashDomain({ domain, types, }) {
    return hashStruct({
        data: domain,
        primaryType: 'EIP712Domain',
        types,
    });
}
function hashStruct({ data, primaryType, types, }) {
    const encoded = encodeData({
        data,
        primaryType,
        types,
    });
    return (0, keccak256_js_1.keccak256)(encoded);
}
function encodeData({ data, primaryType, types, }) {
    const encodedTypes = [{ type: 'bytes32' }];
    const encodedValues = [hashType({ primaryType, types })];
    for (const field of types[primaryType]) {
        const [type, value] = encodeField({
            types,
            name: field.name,
            type: field.type,
            value: data[field.name],
        });
        encodedTypes.push(type);
        encodedValues.push(value);
    }
    return (0, encodeAbiParameters_js_1.encodeAbiParameters)(encodedTypes, encodedValues);
}
function hashType({ primaryType, types, }) {
    const encodedHashType = (0, toHex_js_1.toHex)(encodeType({ primaryType, types }));
    return (0, keccak256_js_1.keccak256)(encodedHashType);
}
function encodeType({ primaryType, types, }) {
    let result = '';
    const unsortedDeps = findTypeDependencies({ primaryType, types });
    unsortedDeps.delete(primaryType);
    const deps = [primaryType, ...Array.from(unsortedDeps).sort()];
    for (const type of deps) {
        result += `${type}(${types[type]
            .map(({ name, type: t }) => `${t} ${name}`)
            .join(',')})`;
    }
    return result;
}
function findTypeDependencies({ primaryType: primaryType_, types, }, results = new Set()) {
    const match = primaryType_.match(/^\w*/u);
    const primaryType = match?.[0];
    if (results.has(primaryType) || types[primaryType] === undefined) {
        return results;
    }
    results.add(primaryType);
    for (const field of types[primaryType]) {
        findTypeDependencies({ primaryType: field.type, types }, results);
    }
    return results;
}
function encodeField({ types, name, type, value, }) {
    if (types[type] !== undefined) {
        return [
            { type: 'bytes32' },
            (0, keccak256_js_1.keccak256)(encodeData({ data: value, primaryType: type, types })),
        ];
    }
    if (type === 'bytes') {
        const prepend = value.length % 2 ? '0' : '';
        value = `0x${prepend + value.slice(2)}`;
        return [{ type: 'bytes32' }, (0, keccak256_js_1.keccak256)(value)];
    }
    if (type === 'string')
        return [{ type: 'bytes32' }, (0, keccak256_js_1.keccak256)((0, toHex_js_1.toHex)(value))];
    if (type.lastIndexOf(']') === type.length - 1) {
        const parsedType = type.slice(0, type.lastIndexOf('['));
        const typeValuePairs = value.map((item) => encodeField({
            name,
            type: parsedType,
            types,
            value: item,
        }));
        return [
            { type: 'bytes32' },
            (0, keccak256_js_1.keccak256)((0, encodeAbiParameters_js_1.encodeAbiParameters)(typeValuePairs.map(([t]) => t), typeValuePairs.map(([, v]) => v))),
        ];
    }
    return [{ type }, value];
}
//# sourceMappingURL=hashTypedData.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/utils/signature/isErc6492Signature.js":
/*!**********************************************************************!*\
  !*** ./node_modules/viem/_cjs/utils/signature/isErc6492Signature.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isErc6492Signature = isErc6492Signature;
const bytes_js_1 = __webpack_require__(/*! ../../constants/bytes.js */ "./node_modules/viem/_cjs/constants/bytes.js");
const slice_js_1 = __webpack_require__(/*! ../data/slice.js */ "./node_modules/viem/_cjs/utils/data/slice.js");
function isErc6492Signature(signature) {
    return (0, slice_js_1.sliceHex)(signature, -32) === bytes_js_1.erc6492MagicBytes;
}
//# sourceMappingURL=isErc6492Signature.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/utils/signature/parseCompactSignature.js":
/*!*************************************************************************!*\
  !*** ./node_modules/viem/_cjs/utils/signature/parseCompactSignature.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.parseCompactSignature = parseCompactSignature;
const secp256k1_1 = __webpack_require__(/*! @noble/curves/secp256k1 */ "./node_modules/viem/node_modules/@noble/curves/secp256k1.js");
const toHex_js_1 = __webpack_require__(/*! ../encoding/toHex.js */ "./node_modules/viem/_cjs/utils/encoding/toHex.js");
function parseCompactSignature(signatureHex) {
    const { r, s } = secp256k1_1.secp256k1.Signature.fromCompact(signatureHex.slice(2, 130));
    return {
        r: (0, toHex_js_1.numberToHex)(r, { size: 32 }),
        yParityAndS: (0, toHex_js_1.numberToHex)(s, { size: 32 }),
    };
}
//# sourceMappingURL=parseCompactSignature.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/utils/signature/parseErc6492Signature.js":
/*!*************************************************************************!*\
  !*** ./node_modules/viem/_cjs/utils/signature/parseErc6492Signature.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.parseErc6492Signature = parseErc6492Signature;
const decodeAbiParameters_js_1 = __webpack_require__(/*! ../abi/decodeAbiParameters.js */ "./node_modules/viem/_cjs/utils/abi/decodeAbiParameters.js");
const isErc6492Signature_js_1 = __webpack_require__(/*! ./isErc6492Signature.js */ "./node_modules/viem/_cjs/utils/signature/isErc6492Signature.js");
function parseErc6492Signature(signature) {
    if (!(0, isErc6492Signature_js_1.isErc6492Signature)(signature))
        return { signature };
    const [address, data, signature_] = (0, decodeAbiParameters_js_1.decodeAbiParameters)([{ type: 'address' }, { type: 'bytes' }, { type: 'bytes' }], signature);
    return { address, data, signature: signature_ };
}
//# sourceMappingURL=parseErc6492Signature.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/utils/signature/parseSignature.js":
/*!******************************************************************!*\
  !*** ./node_modules/viem/_cjs/utils/signature/parseSignature.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.parseSignature = parseSignature;
const secp256k1_1 = __webpack_require__(/*! @noble/curves/secp256k1 */ "./node_modules/viem/node_modules/@noble/curves/secp256k1.js");
const toHex_js_1 = __webpack_require__(/*! ../../utils/encoding/toHex.js */ "./node_modules/viem/_cjs/utils/encoding/toHex.js");
function parseSignature(signatureHex) {
    const { r, s } = secp256k1_1.secp256k1.Signature.fromCompact(signatureHex.slice(2, 130));
    const yParityOrV = Number(`0x${signatureHex.slice(130)}`);
    const [v, yParity] = (() => {
        if (yParityOrV === 0 || yParityOrV === 1)
            return [undefined, yParityOrV];
        if (yParityOrV === 27)
            return [BigInt(yParityOrV), 0];
        if (yParityOrV === 28)
            return [BigInt(yParityOrV), 1];
        throw new Error('Invalid yParityOrV value');
    })();
    if (typeof v !== 'undefined')
        return {
            r: (0, toHex_js_1.numberToHex)(r, { size: 32 }),
            s: (0, toHex_js_1.numberToHex)(s, { size: 32 }),
            v,
            yParity,
        };
    return {
        r: (0, toHex_js_1.numberToHex)(r, { size: 32 }),
        s: (0, toHex_js_1.numberToHex)(s, { size: 32 }),
        yParity,
    };
}
//# sourceMappingURL=parseSignature.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/utils/signature/recoverAddress.js":
/*!******************************************************************!*\
  !*** ./node_modules/viem/_cjs/utils/signature/recoverAddress.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.recoverAddress = recoverAddress;
const publicKeyToAddress_js_1 = __webpack_require__(/*! ../../accounts/utils/publicKeyToAddress.js */ "./node_modules/viem/_cjs/accounts/utils/publicKeyToAddress.js");
const recoverPublicKey_js_1 = __webpack_require__(/*! ./recoverPublicKey.js */ "./node_modules/viem/_cjs/utils/signature/recoverPublicKey.js");
async function recoverAddress({ hash, signature, }) {
    return (0, publicKeyToAddress_js_1.publicKeyToAddress)(await (0, recoverPublicKey_js_1.recoverPublicKey)({ hash, signature }));
}
//# sourceMappingURL=recoverAddress.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/utils/signature/recoverMessageAddress.js":
/*!*************************************************************************!*\
  !*** ./node_modules/viem/_cjs/utils/signature/recoverMessageAddress.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.recoverMessageAddress = recoverMessageAddress;
const hashMessage_js_1 = __webpack_require__(/*! ./hashMessage.js */ "./node_modules/viem/_cjs/utils/signature/hashMessage.js");
const recoverAddress_js_1 = __webpack_require__(/*! ./recoverAddress.js */ "./node_modules/viem/_cjs/utils/signature/recoverAddress.js");
async function recoverMessageAddress({ message, signature, }) {
    return (0, recoverAddress_js_1.recoverAddress)({ hash: (0, hashMessage_js_1.hashMessage)(message), signature });
}
//# sourceMappingURL=recoverMessageAddress.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/utils/signature/recoverPublicKey.js":
/*!********************************************************************!*\
  !*** ./node_modules/viem/_cjs/utils/signature/recoverPublicKey.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.recoverPublicKey = recoverPublicKey;
const isHex_js_1 = __webpack_require__(/*! ../data/isHex.js */ "./node_modules/viem/_cjs/utils/data/isHex.js");
const size_js_1 = __webpack_require__(/*! ../data/size.js */ "./node_modules/viem/_cjs/utils/data/size.js");
const fromHex_js_1 = __webpack_require__(/*! ../encoding/fromHex.js */ "./node_modules/viem/_cjs/utils/encoding/fromHex.js");
const toHex_js_1 = __webpack_require__(/*! ../encoding/toHex.js */ "./node_modules/viem/_cjs/utils/encoding/toHex.js");
async function recoverPublicKey({ hash, signature, }) {
    const hashHex = (0, isHex_js_1.isHex)(hash) ? hash : (0, toHex_js_1.toHex)(hash);
    const { secp256k1 } = await Promise.resolve().then(() => __webpack_require__(/*! @noble/curves/secp256k1 */ "./node_modules/viem/node_modules/@noble/curves/secp256k1.js"));
    const signature_ = (() => {
        if (typeof signature === 'object' && 'r' in signature && 's' in signature) {
            const { r, s, v, yParity } = signature;
            const yParityOrV = Number(yParity ?? v);
            const recoveryBit = toRecoveryBit(yParityOrV);
            return new secp256k1.Signature((0, fromHex_js_1.hexToBigInt)(r), (0, fromHex_js_1.hexToBigInt)(s)).addRecoveryBit(recoveryBit);
        }
        const signatureHex = (0, isHex_js_1.isHex)(signature) ? signature : (0, toHex_js_1.toHex)(signature);
        if ((0, size_js_1.size)(signatureHex) !== 65)
            throw new Error('invalid signature length');
        const yParityOrV = (0, fromHex_js_1.hexToNumber)(`0x${signatureHex.slice(130)}`);
        const recoveryBit = toRecoveryBit(yParityOrV);
        return secp256k1.Signature.fromCompact(signatureHex.substring(2, 130)).addRecoveryBit(recoveryBit);
    })();
    const publicKey = signature_
        .recoverPublicKey(hashHex.substring(2))
        .toHex(false);
    return `0x${publicKey}`;
}
function toRecoveryBit(yParityOrV) {
    if (yParityOrV === 0 || yParityOrV === 1)
        return yParityOrV;
    if (yParityOrV === 27)
        return 0;
    if (yParityOrV === 28)
        return 1;
    throw new Error('Invalid yParityOrV value');
}
//# sourceMappingURL=recoverPublicKey.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/utils/signature/recoverTransactionAddress.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/viem/_cjs/utils/signature/recoverTransactionAddress.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.recoverTransactionAddress = recoverTransactionAddress;
const keccak256_js_1 = __webpack_require__(/*! ../hash/keccak256.js */ "./node_modules/viem/_cjs/utils/hash/keccak256.js");
const parseTransaction_js_1 = __webpack_require__(/*! ../transaction/parseTransaction.js */ "./node_modules/viem/_cjs/utils/transaction/parseTransaction.js");
const serializeTransaction_js_1 = __webpack_require__(/*! ../transaction/serializeTransaction.js */ "./node_modules/viem/_cjs/utils/transaction/serializeTransaction.js");
const recoverAddress_js_1 = __webpack_require__(/*! ./recoverAddress.js */ "./node_modules/viem/_cjs/utils/signature/recoverAddress.js");
async function recoverTransactionAddress(parameters) {
    const { serializedTransaction, signature: signature_ } = parameters;
    const transaction = (0, parseTransaction_js_1.parseTransaction)(serializedTransaction);
    const signature = signature_ ?? {
        r: transaction.r,
        s: transaction.s,
        v: transaction.v,
        yParity: transaction.yParity,
    };
    const serialized = (0, serializeTransaction_js_1.serializeTransaction)({
        ...transaction,
        r: undefined,
        s: undefined,
        v: undefined,
        yParity: undefined,
        sidecars: undefined,
    });
    return await (0, recoverAddress_js_1.recoverAddress)({
        hash: (0, keccak256_js_1.keccak256)(serialized),
        signature,
    });
}
//# sourceMappingURL=recoverTransactionAddress.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/utils/signature/recoverTypedDataAddress.js":
/*!***************************************************************************!*\
  !*** ./node_modules/viem/_cjs/utils/signature/recoverTypedDataAddress.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.recoverTypedDataAddress = recoverTypedDataAddress;
const hashTypedData_js_1 = __webpack_require__(/*! ./hashTypedData.js */ "./node_modules/viem/_cjs/utils/signature/hashTypedData.js");
const recoverAddress_js_1 = __webpack_require__(/*! ./recoverAddress.js */ "./node_modules/viem/_cjs/utils/signature/recoverAddress.js");
async function recoverTypedDataAddress(parameters) {
    const { domain, message, primaryType, signature, types } = parameters;
    return (0, recoverAddress_js_1.recoverAddress)({
        hash: (0, hashTypedData_js_1.hashTypedData)({
            domain,
            message,
            primaryType,
            types,
        }),
        signature,
    });
}
//# sourceMappingURL=recoverTypedDataAddress.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/utils/signature/serializeCompactSignature.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/viem/_cjs/utils/signature/serializeCompactSignature.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.serializeCompactSignature = serializeCompactSignature;
const secp256k1_1 = __webpack_require__(/*! @noble/curves/secp256k1 */ "./node_modules/viem/node_modules/@noble/curves/secp256k1.js");
const fromHex_js_1 = __webpack_require__(/*! ../encoding/fromHex.js */ "./node_modules/viem/_cjs/utils/encoding/fromHex.js");
function serializeCompactSignature({ r, yParityAndS, }) {
    return `0x${new secp256k1_1.secp256k1.Signature((0, fromHex_js_1.hexToBigInt)(r), (0, fromHex_js_1.hexToBigInt)(yParityAndS)).toCompactHex()}`;
}
//# sourceMappingURL=serializeCompactSignature.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/utils/signature/serializeErc6492Signature.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/viem/_cjs/utils/signature/serializeErc6492Signature.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.serializeErc6492Signature = serializeErc6492Signature;
const bytes_js_1 = __webpack_require__(/*! ../../constants/bytes.js */ "./node_modules/viem/_cjs/constants/bytes.js");
const encodeAbiParameters_js_1 = __webpack_require__(/*! ../abi/encodeAbiParameters.js */ "./node_modules/viem/_cjs/utils/abi/encodeAbiParameters.js");
const concat_js_1 = __webpack_require__(/*! ../data/concat.js */ "./node_modules/viem/_cjs/utils/data/concat.js");
const toBytes_js_1 = __webpack_require__(/*! ../encoding/toBytes.js */ "./node_modules/viem/_cjs/utils/encoding/toBytes.js");
function serializeErc6492Signature(parameters) {
    const { address, data, signature, to = 'hex' } = parameters;
    const signature_ = (0, concat_js_1.concatHex)([
        (0, encodeAbiParameters_js_1.encodeAbiParameters)([{ type: 'address' }, { type: 'bytes' }, { type: 'bytes' }], [address, data, signature]),
        bytes_js_1.erc6492MagicBytes,
    ]);
    if (to === 'hex')
        return signature_;
    return (0, toBytes_js_1.hexToBytes)(signature_);
}
//# sourceMappingURL=serializeErc6492Signature.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/utils/signature/serializeSignature.js":
/*!**********************************************************************!*\
  !*** ./node_modules/viem/_cjs/utils/signature/serializeSignature.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.serializeSignature = serializeSignature;
const secp256k1_1 = __webpack_require__(/*! @noble/curves/secp256k1 */ "./node_modules/viem/node_modules/@noble/curves/secp256k1.js");
const fromHex_js_1 = __webpack_require__(/*! ../encoding/fromHex.js */ "./node_modules/viem/_cjs/utils/encoding/fromHex.js");
const toBytes_js_1 = __webpack_require__(/*! ../encoding/toBytes.js */ "./node_modules/viem/_cjs/utils/encoding/toBytes.js");
function serializeSignature({ r, s, to = 'hex', v, yParity, }) {
    const yParity_ = (() => {
        if (yParity === 0 || yParity === 1)
            return yParity;
        if (v && (v === 27n || v === 28n || v >= 35n))
            return v % 2n === 0n ? 1 : 0;
        throw new Error('Invalid `v` or `yParity` value');
    })();
    const signature = `0x${new secp256k1_1.secp256k1.Signature((0, fromHex_js_1.hexToBigInt)(r), (0, fromHex_js_1.hexToBigInt)(s)).toCompactHex()}${yParity_ === 0 ? '1b' : '1c'}`;
    if (to === 'hex')
        return signature;
    return (0, toBytes_js_1.hexToBytes)(signature);
}
//# sourceMappingURL=serializeSignature.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/utils/signature/signatureToCompactSignature.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/viem/_cjs/utils/signature/signatureToCompactSignature.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.signatureToCompactSignature = signatureToCompactSignature;
const toBytes_js_1 = __webpack_require__(/*! ../encoding/toBytes.js */ "./node_modules/viem/_cjs/utils/encoding/toBytes.js");
const toHex_js_1 = __webpack_require__(/*! ../encoding/toHex.js */ "./node_modules/viem/_cjs/utils/encoding/toHex.js");
function signatureToCompactSignature(signature) {
    const { r, s, v, yParity } = signature;
    const yParity_ = Number(yParity ?? v - 27n);
    let yParityAndS = s;
    if (yParity_ === 1) {
        const bytes = (0, toBytes_js_1.hexToBytes)(s);
        bytes[0] |= 0x80;
        yParityAndS = (0, toHex_js_1.bytesToHex)(bytes);
    }
    return { r, yParityAndS };
}
//# sourceMappingURL=signatureToCompactSignature.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/utils/signature/toPrefixedMessage.js":
/*!*********************************************************************!*\
  !*** ./node_modules/viem/_cjs/utils/signature/toPrefixedMessage.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.toPrefixedMessage = toPrefixedMessage;
const strings_js_1 = __webpack_require__(/*! ../../constants/strings.js */ "./node_modules/viem/_cjs/constants/strings.js");
const concat_js_1 = __webpack_require__(/*! ../data/concat.js */ "./node_modules/viem/_cjs/utils/data/concat.js");
const size_js_1 = __webpack_require__(/*! ../data/size.js */ "./node_modules/viem/_cjs/utils/data/size.js");
const toHex_js_1 = __webpack_require__(/*! ../encoding/toHex.js */ "./node_modules/viem/_cjs/utils/encoding/toHex.js");
function toPrefixedMessage(message_) {
    const message = (() => {
        if (typeof message_ === 'string')
            return (0, toHex_js_1.stringToHex)(message_);
        if (typeof message_.raw === 'string')
            return message_.raw;
        return (0, toHex_js_1.bytesToHex)(message_.raw);
    })();
    const prefix = (0, toHex_js_1.stringToHex)(`${strings_js_1.presignMessagePrefix}${(0, size_js_1.size)(message)}`);
    return (0, concat_js_1.concat)([prefix, message]);
}
//# sourceMappingURL=toPrefixedMessage.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/utils/signature/verifyHash.js":
/*!**************************************************************!*\
  !*** ./node_modules/viem/_cjs/utils/signature/verifyHash.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.verifyHash = verifyHash;
const getAddress_js_1 = __webpack_require__(/*! ../address/getAddress.js */ "./node_modules/viem/_cjs/utils/address/getAddress.js");
const isAddressEqual_js_1 = __webpack_require__(/*! ../address/isAddressEqual.js */ "./node_modules/viem/_cjs/utils/address/isAddressEqual.js");
const recoverAddress_js_1 = __webpack_require__(/*! ./recoverAddress.js */ "./node_modules/viem/_cjs/utils/signature/recoverAddress.js");
async function verifyHash({ address, hash, signature, }) {
    return (0, isAddressEqual_js_1.isAddressEqual)((0, getAddress_js_1.getAddress)(address), await (0, recoverAddress_js_1.recoverAddress)({ hash, signature }));
}
//# sourceMappingURL=verifyHash.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/utils/signature/verifyMessage.js":
/*!*****************************************************************!*\
  !*** ./node_modules/viem/_cjs/utils/signature/verifyMessage.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.verifyMessage = verifyMessage;
const getAddress_js_1 = __webpack_require__(/*! ../address/getAddress.js */ "./node_modules/viem/_cjs/utils/address/getAddress.js");
const isAddressEqual_js_1 = __webpack_require__(/*! ../address/isAddressEqual.js */ "./node_modules/viem/_cjs/utils/address/isAddressEqual.js");
const recoverMessageAddress_js_1 = __webpack_require__(/*! ./recoverMessageAddress.js */ "./node_modules/viem/_cjs/utils/signature/recoverMessageAddress.js");
async function verifyMessage({ address, message, signature, }) {
    return (0, isAddressEqual_js_1.isAddressEqual)((0, getAddress_js_1.getAddress)(address), await (0, recoverMessageAddress_js_1.recoverMessageAddress)({ message, signature }));
}
//# sourceMappingURL=verifyMessage.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/utils/signature/verifyTypedData.js":
/*!*******************************************************************!*\
  !*** ./node_modules/viem/_cjs/utils/signature/verifyTypedData.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.verifyTypedData = verifyTypedData;
const getAddress_js_1 = __webpack_require__(/*! ../address/getAddress.js */ "./node_modules/viem/_cjs/utils/address/getAddress.js");
const isAddressEqual_js_1 = __webpack_require__(/*! ../address/isAddressEqual.js */ "./node_modules/viem/_cjs/utils/address/isAddressEqual.js");
const recoverTypedDataAddress_js_1 = __webpack_require__(/*! ./recoverTypedDataAddress.js */ "./node_modules/viem/_cjs/utils/signature/recoverTypedDataAddress.js");
async function verifyTypedData(parameters) {
    const { address, domain, message, primaryType, signature, types } = parameters;
    return (0, isAddressEqual_js_1.isAddressEqual)((0, getAddress_js_1.getAddress)(address), await (0, recoverTypedDataAddress_js_1.recoverTypedDataAddress)({
        domain,
        message,
        primaryType,
        signature,
        types,
    }));
}
//# sourceMappingURL=verifyTypedData.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/utils/siwe/parseSiweMessage.js":
/*!***************************************************************!*\
  !*** ./node_modules/viem/_cjs/utils/siwe/parseSiweMessage.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.parseSiweMessage = parseSiweMessage;
function parseSiweMessage(message) {
    const { scheme, statement, ...prefix } = (message.match(prefixRegex)
        ?.groups ?? {});
    const { chainId, expirationTime, issuedAt, notBefore, requestId, ...suffix } = (message.match(suffixRegex)?.groups ?? {});
    const resources = message.split('Resources:')[1]?.split('\n- ').slice(1);
    return {
        ...prefix,
        ...suffix,
        ...(chainId ? { chainId: Number(chainId) } : {}),
        ...(expirationTime ? { expirationTime: new Date(expirationTime) } : {}),
        ...(issuedAt ? { issuedAt: new Date(issuedAt) } : {}),
        ...(notBefore ? { notBefore: new Date(notBefore) } : {}),
        ...(requestId ? { requestId } : {}),
        ...(resources ? { resources } : {}),
        ...(scheme ? { scheme } : {}),
        ...(statement ? { statement } : {}),
    };
}
const prefixRegex = /^(?:(?<scheme>[a-zA-Z][a-zA-Z0-9+-.]*):\/\/)?(?<domain>[a-zA-Z0-9+-.]*(?::[0-9]{1,5})?) (?:wants you to sign in with your Ethereum account:\n)(?<address>0x[a-fA-F0-9]{40})\n\n(?:(?<statement>.*)\n\n)?/;
const suffixRegex = /(?:URI: (?<uri>.+))\n(?:Version: (?<version>.+))\n(?:Chain ID: (?<chainId>\d+))\n(?:Nonce: (?<nonce>[a-zA-Z0-9]+))\n(?:Issued At: (?<issuedAt>.+))(?:\nExpiration Time: (?<expirationTime>.+))?(?:\nNot Before: (?<notBefore>.+))?(?:\nRequest ID: (?<requestId>.+))?/;
//# sourceMappingURL=parseSiweMessage.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/utils/siwe/validateSiweMessage.js":
/*!******************************************************************!*\
  !*** ./node_modules/viem/_cjs/utils/siwe/validateSiweMessage.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.validateSiweMessage = validateSiweMessage;
const isAddress_js_1 = __webpack_require__(/*! ../address/isAddress.js */ "./node_modules/viem/_cjs/utils/address/isAddress.js");
const isAddressEqual_js_1 = __webpack_require__(/*! ../address/isAddressEqual.js */ "./node_modules/viem/_cjs/utils/address/isAddressEqual.js");
function validateSiweMessage(parameters) {
    const { address, domain, message, nonce, scheme, time = new Date(), } = parameters;
    if (domain && message.domain !== domain)
        return false;
    if (nonce && message.nonce !== nonce)
        return false;
    if (scheme && message.scheme !== scheme)
        return false;
    if (message.expirationTime && time >= message.expirationTime)
        return false;
    if (message.notBefore && time < message.notBefore)
        return false;
    try {
        if (!message.address)
            return false;
        if (!(0, isAddress_js_1.isAddress)(message.address, { strict: false }))
            return false;
        if (address && !(0, isAddressEqual_js_1.isAddressEqual)(message.address, address))
            return false;
    }
    catch {
        return false;
    }
    return true;
}
//# sourceMappingURL=validateSiweMessage.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/utils/stateOverride.js":
/*!*******************************************************!*\
  !*** ./node_modules/viem/_cjs/utils/stateOverride.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.serializeStateMapping = serializeStateMapping;
exports.serializeAccountStateOverride = serializeAccountStateOverride;
exports.serializeStateOverride = serializeStateOverride;
const address_js_1 = __webpack_require__(/*! ../errors/address.js */ "./node_modules/viem/_cjs/errors/address.js");
const data_js_1 = __webpack_require__(/*! ../errors/data.js */ "./node_modules/viem/_cjs/errors/data.js");
const stateOverride_js_1 = __webpack_require__(/*! ../errors/stateOverride.js */ "./node_modules/viem/_cjs/errors/stateOverride.js");
const isAddress_js_1 = __webpack_require__(/*! ./address/isAddress.js */ "./node_modules/viem/_cjs/utils/address/isAddress.js");
const toHex_js_1 = __webpack_require__(/*! ./encoding/toHex.js */ "./node_modules/viem/_cjs/utils/encoding/toHex.js");
function serializeStateMapping(stateMapping) {
    if (!stateMapping || stateMapping.length === 0)
        return undefined;
    return stateMapping.reduce((acc, { slot, value }) => {
        if (slot.length !== 66)
            throw new data_js_1.InvalidBytesLengthError({
                size: slot.length,
                targetSize: 66,
                type: 'hex',
            });
        if (value.length !== 66)
            throw new data_js_1.InvalidBytesLengthError({
                size: value.length,
                targetSize: 66,
                type: 'hex',
            });
        acc[slot] = value;
        return acc;
    }, {});
}
function serializeAccountStateOverride(parameters) {
    const { balance, nonce, state, stateDiff, code } = parameters;
    const rpcAccountStateOverride = {};
    if (code !== undefined)
        rpcAccountStateOverride.code = code;
    if (balance !== undefined)
        rpcAccountStateOverride.balance = (0, toHex_js_1.numberToHex)(balance);
    if (nonce !== undefined)
        rpcAccountStateOverride.nonce = (0, toHex_js_1.numberToHex)(nonce);
    if (state !== undefined)
        rpcAccountStateOverride.state = serializeStateMapping(state);
    if (stateDiff !== undefined) {
        if (rpcAccountStateOverride.state)
            throw new stateOverride_js_1.StateAssignmentConflictError();
        rpcAccountStateOverride.stateDiff = serializeStateMapping(stateDiff);
    }
    return rpcAccountStateOverride;
}
function serializeStateOverride(parameters) {
    if (!parameters)
        return undefined;
    const rpcStateOverride = {};
    for (const { address, ...accountState } of parameters) {
        if (!(0, isAddress_js_1.isAddress)(address, { strict: false }))
            throw new address_js_1.InvalidAddressError({ address });
        if (rpcStateOverride[address])
            throw new stateOverride_js_1.AccountStateConflictError({ address: address });
        rpcStateOverride[address] = serializeAccountStateOverride(accountState);
    }
    return rpcStateOverride;
}
//# sourceMappingURL=stateOverride.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/utils/stringify.js":
/*!***************************************************!*\
  !*** ./node_modules/viem/_cjs/utils/stringify.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.stringify = void 0;
const stringify = (value, replacer, space) => JSON.stringify(value, (key, value_) => {
    const value = typeof value_ === 'bigint' ? value_.toString() : value_;
    return typeof replacer === 'function' ? replacer(key, value) : value;
}, space);
exports.stringify = stringify;
//# sourceMappingURL=stringify.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/utils/transaction/assertRequest.js":
/*!*******************************************************************!*\
  !*** ./node_modules/viem/_cjs/utils/transaction/assertRequest.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.assertRequest = assertRequest;
const parseAccount_js_1 = __webpack_require__(/*! ../../accounts/utils/parseAccount.js */ "./node_modules/viem/_cjs/accounts/utils/parseAccount.js");
const number_js_1 = __webpack_require__(/*! ../../constants/number.js */ "./node_modules/viem/_cjs/constants/number.js");
const address_js_1 = __webpack_require__(/*! ../../errors/address.js */ "./node_modules/viem/_cjs/errors/address.js");
const node_js_1 = __webpack_require__(/*! ../../errors/node.js */ "./node_modules/viem/_cjs/errors/node.js");
const transaction_js_1 = __webpack_require__(/*! ../../errors/transaction.js */ "./node_modules/viem/_cjs/errors/transaction.js");
const isAddress_js_1 = __webpack_require__(/*! ../address/isAddress.js */ "./node_modules/viem/_cjs/utils/address/isAddress.js");
function assertRequest(args) {
    const { account: account_, gasPrice, maxFeePerGas, maxPriorityFeePerGas, to, } = args;
    const account = account_ ? (0, parseAccount_js_1.parseAccount)(account_) : undefined;
    if (account && !(0, isAddress_js_1.isAddress)(account.address))
        throw new address_js_1.InvalidAddressError({ address: account.address });
    if (to && !(0, isAddress_js_1.isAddress)(to))
        throw new address_js_1.InvalidAddressError({ address: to });
    if (typeof gasPrice !== 'undefined' &&
        (typeof maxFeePerGas !== 'undefined' ||
            typeof maxPriorityFeePerGas !== 'undefined'))
        throw new transaction_js_1.FeeConflictError();
    if (maxFeePerGas && maxFeePerGas > number_js_1.maxUint256)
        throw new node_js_1.FeeCapTooHighError({ maxFeePerGas });
    if (maxPriorityFeePerGas &&
        maxFeePerGas &&
        maxPriorityFeePerGas > maxFeePerGas)
        throw new node_js_1.TipAboveFeeCapError({ maxFeePerGas, maxPriorityFeePerGas });
}
//# sourceMappingURL=assertRequest.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/utils/transaction/assertTransaction.js":
/*!***********************************************************************!*\
  !*** ./node_modules/viem/_cjs/utils/transaction/assertTransaction.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.assertTransactionEIP7702 = assertTransactionEIP7702;
exports.assertTransactionEIP4844 = assertTransactionEIP4844;
exports.assertTransactionEIP1559 = assertTransactionEIP1559;
exports.assertTransactionEIP2930 = assertTransactionEIP2930;
exports.assertTransactionLegacy = assertTransactionLegacy;
const kzg_js_1 = __webpack_require__(/*! ../../constants/kzg.js */ "./node_modules/viem/_cjs/constants/kzg.js");
const number_js_1 = __webpack_require__(/*! ../../constants/number.js */ "./node_modules/viem/_cjs/constants/number.js");
const address_js_1 = __webpack_require__(/*! ../../errors/address.js */ "./node_modules/viem/_cjs/errors/address.js");
const base_js_1 = __webpack_require__(/*! ../../errors/base.js */ "./node_modules/viem/_cjs/errors/base.js");
const blob_js_1 = __webpack_require__(/*! ../../errors/blob.js */ "./node_modules/viem/_cjs/errors/blob.js");
const chain_js_1 = __webpack_require__(/*! ../../errors/chain.js */ "./node_modules/viem/_cjs/errors/chain.js");
const node_js_1 = __webpack_require__(/*! ../../errors/node.js */ "./node_modules/viem/_cjs/errors/node.js");
const isAddress_js_1 = __webpack_require__(/*! ../address/isAddress.js */ "./node_modules/viem/_cjs/utils/address/isAddress.js");
const size_js_1 = __webpack_require__(/*! ../data/size.js */ "./node_modules/viem/_cjs/utils/data/size.js");
const slice_js_1 = __webpack_require__(/*! ../data/slice.js */ "./node_modules/viem/_cjs/utils/data/slice.js");
const fromHex_js_1 = __webpack_require__(/*! ../encoding/fromHex.js */ "./node_modules/viem/_cjs/utils/encoding/fromHex.js");
function assertTransactionEIP7702(transaction) {
    const { authorizationList } = transaction;
    if (authorizationList) {
        for (const authorization of authorizationList) {
            const { chainId } = authorization;
            const address = authorization.address;
            if (!(0, isAddress_js_1.isAddress)(address))
                throw new address_js_1.InvalidAddressError({ address });
            if (chainId < 0)
                throw new chain_js_1.InvalidChainIdError({ chainId });
        }
    }
    assertTransactionEIP1559(transaction);
}
function assertTransactionEIP4844(transaction) {
    const { blobVersionedHashes } = transaction;
    if (blobVersionedHashes) {
        if (blobVersionedHashes.length === 0)
            throw new blob_js_1.EmptyBlobError();
        for (const hash of blobVersionedHashes) {
            const size_ = (0, size_js_1.size)(hash);
            const version = (0, fromHex_js_1.hexToNumber)((0, slice_js_1.slice)(hash, 0, 1));
            if (size_ !== 32)
                throw new blob_js_1.InvalidVersionedHashSizeError({ hash, size: size_ });
            if (version !== kzg_js_1.versionedHashVersionKzg)
                throw new blob_js_1.InvalidVersionedHashVersionError({
                    hash,
                    version,
                });
        }
    }
    assertTransactionEIP1559(transaction);
}
function assertTransactionEIP1559(transaction) {
    const { chainId, maxPriorityFeePerGas, maxFeePerGas, to } = transaction;
    if (chainId <= 0)
        throw new chain_js_1.InvalidChainIdError({ chainId });
    if (to && !(0, isAddress_js_1.isAddress)(to))
        throw new address_js_1.InvalidAddressError({ address: to });
    if (maxFeePerGas && maxFeePerGas > number_js_1.maxUint256)
        throw new node_js_1.FeeCapTooHighError({ maxFeePerGas });
    if (maxPriorityFeePerGas &&
        maxFeePerGas &&
        maxPriorityFeePerGas > maxFeePerGas)
        throw new node_js_1.TipAboveFeeCapError({ maxFeePerGas, maxPriorityFeePerGas });
}
function assertTransactionEIP2930(transaction) {
    const { chainId, maxPriorityFeePerGas, gasPrice, maxFeePerGas, to } = transaction;
    if (chainId <= 0)
        throw new chain_js_1.InvalidChainIdError({ chainId });
    if (to && !(0, isAddress_js_1.isAddress)(to))
        throw new address_js_1.InvalidAddressError({ address: to });
    if (maxPriorityFeePerGas || maxFeePerGas)
        throw new base_js_1.BaseError('`maxFeePerGas`/`maxPriorityFeePerGas` is not a valid EIP-2930 Transaction attribute.');
    if (gasPrice && gasPrice > number_js_1.maxUint256)
        throw new node_js_1.FeeCapTooHighError({ maxFeePerGas: gasPrice });
}
function assertTransactionLegacy(transaction) {
    const { chainId, maxPriorityFeePerGas, gasPrice, maxFeePerGas, to } = transaction;
    if (to && !(0, isAddress_js_1.isAddress)(to))
        throw new address_js_1.InvalidAddressError({ address: to });
    if (typeof chainId !== 'undefined' && chainId <= 0)
        throw new chain_js_1.InvalidChainIdError({ chainId });
    if (maxPriorityFeePerGas || maxFeePerGas)
        throw new base_js_1.BaseError('`maxFeePerGas`/`maxPriorityFeePerGas` is not a valid Legacy Transaction attribute.');
    if (gasPrice && gasPrice > number_js_1.maxUint256)
        throw new node_js_1.FeeCapTooHighError({ maxFeePerGas: gasPrice });
}
//# sourceMappingURL=assertTransaction.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/utils/transaction/getSerializedTransactionType.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/viem/_cjs/utils/transaction/getSerializedTransactionType.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getSerializedTransactionType = getSerializedTransactionType;
const transaction_js_1 = __webpack_require__(/*! ../../errors/transaction.js */ "./node_modules/viem/_cjs/errors/transaction.js");
const slice_js_1 = __webpack_require__(/*! ../data/slice.js */ "./node_modules/viem/_cjs/utils/data/slice.js");
const fromHex_js_1 = __webpack_require__(/*! ../encoding/fromHex.js */ "./node_modules/viem/_cjs/utils/encoding/fromHex.js");
function getSerializedTransactionType(serializedTransaction) {
    const serializedType = (0, slice_js_1.sliceHex)(serializedTransaction, 0, 1);
    if (serializedType === '0x04')
        return 'eip7702';
    if (serializedType === '0x03')
        return 'eip4844';
    if (serializedType === '0x02')
        return 'eip1559';
    if (serializedType === '0x01')
        return 'eip2930';
    if (serializedType !== '0x' && (0, fromHex_js_1.hexToNumber)(serializedType) >= 0xc0)
        return 'legacy';
    throw new transaction_js_1.InvalidSerializedTransactionTypeError({ serializedType });
}
//# sourceMappingURL=getSerializedTransactionType.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/utils/transaction/getTransactionType.js":
/*!************************************************************************!*\
  !*** ./node_modules/viem/_cjs/utils/transaction/getTransactionType.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getTransactionType = getTransactionType;
const transaction_js_1 = __webpack_require__(/*! ../../errors/transaction.js */ "./node_modules/viem/_cjs/errors/transaction.js");
function getTransactionType(transaction) {
    if (transaction.type)
        return transaction.type;
    if (typeof transaction.authorizationList !== 'undefined')
        return 'eip7702';
    if (typeof transaction.blobs !== 'undefined' ||
        typeof transaction.blobVersionedHashes !== 'undefined' ||
        typeof transaction.maxFeePerBlobGas !== 'undefined' ||
        typeof transaction.sidecars !== 'undefined')
        return 'eip4844';
    if (typeof transaction.maxFeePerGas !== 'undefined' ||
        typeof transaction.maxPriorityFeePerGas !== 'undefined') {
        return 'eip1559';
    }
    if (typeof transaction.gasPrice !== 'undefined') {
        if (typeof transaction.accessList !== 'undefined')
            return 'eip2930';
        return 'legacy';
    }
    throw new transaction_js_1.InvalidSerializableTransactionError({ transaction });
}
//# sourceMappingURL=getTransactionType.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/utils/transaction/parseTransaction.js":
/*!**********************************************************************!*\
  !*** ./node_modules/viem/_cjs/utils/transaction/parseTransaction.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.parseTransaction = parseTransaction;
exports.toTransactionArray = toTransactionArray;
exports.parseAccessList = parseAccessList;
const address_js_1 = __webpack_require__(/*! ../../errors/address.js */ "./node_modules/viem/_cjs/errors/address.js");
const transaction_js_1 = __webpack_require__(/*! ../../errors/transaction.js */ "./node_modules/viem/_cjs/errors/transaction.js");
const isAddress_js_1 = __webpack_require__(/*! ../address/isAddress.js */ "./node_modules/viem/_cjs/utils/address/isAddress.js");
const toBlobSidecars_js_1 = __webpack_require__(/*! ../blob/toBlobSidecars.js */ "./node_modules/viem/_cjs/utils/blob/toBlobSidecars.js");
const isHex_js_1 = __webpack_require__(/*! ../data/isHex.js */ "./node_modules/viem/_cjs/utils/data/isHex.js");
const pad_js_1 = __webpack_require__(/*! ../data/pad.js */ "./node_modules/viem/_cjs/utils/data/pad.js");
const trim_js_1 = __webpack_require__(/*! ../data/trim.js */ "./node_modules/viem/_cjs/utils/data/trim.js");
const fromHex_js_1 = __webpack_require__(/*! ../encoding/fromHex.js */ "./node_modules/viem/_cjs/utils/encoding/fromHex.js");
const fromRlp_js_1 = __webpack_require__(/*! ../encoding/fromRlp.js */ "./node_modules/viem/_cjs/utils/encoding/fromRlp.js");
const isHash_js_1 = __webpack_require__(/*! ../hash/isHash.js */ "./node_modules/viem/_cjs/utils/hash/isHash.js");
const assertTransaction_js_1 = __webpack_require__(/*! ./assertTransaction.js */ "./node_modules/viem/_cjs/utils/transaction/assertTransaction.js");
const getSerializedTransactionType_js_1 = __webpack_require__(/*! ./getSerializedTransactionType.js */ "./node_modules/viem/_cjs/utils/transaction/getSerializedTransactionType.js");
function parseTransaction(serializedTransaction) {
    const type = (0, getSerializedTransactionType_js_1.getSerializedTransactionType)(serializedTransaction);
    if (type === 'eip1559')
        return parseTransactionEIP1559(serializedTransaction);
    if (type === 'eip2930')
        return parseTransactionEIP2930(serializedTransaction);
    if (type === 'eip4844')
        return parseTransactionEIP4844(serializedTransaction);
    if (type === 'eip7702')
        return parseTransactionEIP7702(serializedTransaction);
    return parseTransactionLegacy(serializedTransaction);
}
function parseTransactionEIP7702(serializedTransaction) {
    const transactionArray = toTransactionArray(serializedTransaction);
    const [chainId, nonce, maxPriorityFeePerGas, maxFeePerGas, gas, to, value, data, accessList, authorizationList, v, r, s,] = transactionArray;
    if (transactionArray.length !== 10 && transactionArray.length !== 13)
        throw new transaction_js_1.InvalidSerializedTransactionError({
            attributes: {
                chainId,
                nonce,
                maxPriorityFeePerGas,
                maxFeePerGas,
                gas,
                to,
                value,
                data,
                accessList,
                authorizationList,
                ...(transactionArray.length > 9
                    ? {
                        v,
                        r,
                        s,
                    }
                    : {}),
            },
            serializedTransaction,
            type: 'eip7702',
        });
    const transaction = {
        chainId: (0, fromHex_js_1.hexToNumber)(chainId),
        type: 'eip7702',
    };
    if ((0, isHex_js_1.isHex)(to) && to !== '0x')
        transaction.to = to;
    if ((0, isHex_js_1.isHex)(gas) && gas !== '0x')
        transaction.gas = (0, fromHex_js_1.hexToBigInt)(gas);
    if ((0, isHex_js_1.isHex)(data) && data !== '0x')
        transaction.data = data;
    if ((0, isHex_js_1.isHex)(nonce))
        transaction.nonce = nonce === '0x' ? 0 : (0, fromHex_js_1.hexToNumber)(nonce);
    if ((0, isHex_js_1.isHex)(value) && value !== '0x')
        transaction.value = (0, fromHex_js_1.hexToBigInt)(value);
    if ((0, isHex_js_1.isHex)(maxFeePerGas) && maxFeePerGas !== '0x')
        transaction.maxFeePerGas = (0, fromHex_js_1.hexToBigInt)(maxFeePerGas);
    if ((0, isHex_js_1.isHex)(maxPriorityFeePerGas) && maxPriorityFeePerGas !== '0x')
        transaction.maxPriorityFeePerGas = (0, fromHex_js_1.hexToBigInt)(maxPriorityFeePerGas);
    if (accessList.length !== 0 && accessList !== '0x')
        transaction.accessList = parseAccessList(accessList);
    if (authorizationList.length !== 0 && authorizationList !== '0x')
        transaction.authorizationList = parseAuthorizationList(authorizationList);
    (0, assertTransaction_js_1.assertTransactionEIP7702)(transaction);
    const signature = transactionArray.length === 13
        ? parseEIP155Signature(transactionArray)
        : undefined;
    return { ...signature, ...transaction };
}
function parseTransactionEIP4844(serializedTransaction) {
    const transactionOrWrapperArray = toTransactionArray(serializedTransaction);
    const hasNetworkWrapper = transactionOrWrapperArray.length === 4;
    const transactionArray = hasNetworkWrapper
        ? transactionOrWrapperArray[0]
        : transactionOrWrapperArray;
    const wrapperArray = hasNetworkWrapper
        ? transactionOrWrapperArray.slice(1)
        : [];
    const [chainId, nonce, maxPriorityFeePerGas, maxFeePerGas, gas, to, value, data, accessList, maxFeePerBlobGas, blobVersionedHashes, v, r, s,] = transactionArray;
    const [blobs, commitments, proofs] = wrapperArray;
    if (!(transactionArray.length === 11 || transactionArray.length === 14))
        throw new transaction_js_1.InvalidSerializedTransactionError({
            attributes: {
                chainId,
                nonce,
                maxPriorityFeePerGas,
                maxFeePerGas,
                gas,
                to,
                value,
                data,
                accessList,
                ...(transactionArray.length > 9
                    ? {
                        v,
                        r,
                        s,
                    }
                    : {}),
            },
            serializedTransaction,
            type: 'eip4844',
        });
    const transaction = {
        blobVersionedHashes: blobVersionedHashes,
        chainId: (0, fromHex_js_1.hexToNumber)(chainId),
        type: 'eip4844',
    };
    if ((0, isHex_js_1.isHex)(to) && to !== '0x')
        transaction.to = to;
    if ((0, isHex_js_1.isHex)(gas) && gas !== '0x')
        transaction.gas = (0, fromHex_js_1.hexToBigInt)(gas);
    if ((0, isHex_js_1.isHex)(data) && data !== '0x')
        transaction.data = data;
    if ((0, isHex_js_1.isHex)(nonce))
        transaction.nonce = nonce === '0x' ? 0 : (0, fromHex_js_1.hexToNumber)(nonce);
    if ((0, isHex_js_1.isHex)(value) && value !== '0x')
        transaction.value = (0, fromHex_js_1.hexToBigInt)(value);
    if ((0, isHex_js_1.isHex)(maxFeePerBlobGas) && maxFeePerBlobGas !== '0x')
        transaction.maxFeePerBlobGas = (0, fromHex_js_1.hexToBigInt)(maxFeePerBlobGas);
    if ((0, isHex_js_1.isHex)(maxFeePerGas) && maxFeePerGas !== '0x')
        transaction.maxFeePerGas = (0, fromHex_js_1.hexToBigInt)(maxFeePerGas);
    if ((0, isHex_js_1.isHex)(maxPriorityFeePerGas) && maxPriorityFeePerGas !== '0x')
        transaction.maxPriorityFeePerGas = (0, fromHex_js_1.hexToBigInt)(maxPriorityFeePerGas);
    if (accessList.length !== 0 && accessList !== '0x')
        transaction.accessList = parseAccessList(accessList);
    if (blobs && commitments && proofs)
        transaction.sidecars = (0, toBlobSidecars_js_1.toBlobSidecars)({
            blobs: blobs,
            commitments: commitments,
            proofs: proofs,
        });
    (0, assertTransaction_js_1.assertTransactionEIP4844)(transaction);
    const signature = transactionArray.length === 14
        ? parseEIP155Signature(transactionArray)
        : undefined;
    return { ...signature, ...transaction };
}
function parseTransactionEIP1559(serializedTransaction) {
    const transactionArray = toTransactionArray(serializedTransaction);
    const [chainId, nonce, maxPriorityFeePerGas, maxFeePerGas, gas, to, value, data, accessList, v, r, s,] = transactionArray;
    if (!(transactionArray.length === 9 || transactionArray.length === 12))
        throw new transaction_js_1.InvalidSerializedTransactionError({
            attributes: {
                chainId,
                nonce,
                maxPriorityFeePerGas,
                maxFeePerGas,
                gas,
                to,
                value,
                data,
                accessList,
                ...(transactionArray.length > 9
                    ? {
                        v,
                        r,
                        s,
                    }
                    : {}),
            },
            serializedTransaction,
            type: 'eip1559',
        });
    const transaction = {
        chainId: (0, fromHex_js_1.hexToNumber)(chainId),
        type: 'eip1559',
    };
    if ((0, isHex_js_1.isHex)(to) && to !== '0x')
        transaction.to = to;
    if ((0, isHex_js_1.isHex)(gas) && gas !== '0x')
        transaction.gas = (0, fromHex_js_1.hexToBigInt)(gas);
    if ((0, isHex_js_1.isHex)(data) && data !== '0x')
        transaction.data = data;
    if ((0, isHex_js_1.isHex)(nonce))
        transaction.nonce = nonce === '0x' ? 0 : (0, fromHex_js_1.hexToNumber)(nonce);
    if ((0, isHex_js_1.isHex)(value) && value !== '0x')
        transaction.value = (0, fromHex_js_1.hexToBigInt)(value);
    if ((0, isHex_js_1.isHex)(maxFeePerGas) && maxFeePerGas !== '0x')
        transaction.maxFeePerGas = (0, fromHex_js_1.hexToBigInt)(maxFeePerGas);
    if ((0, isHex_js_1.isHex)(maxPriorityFeePerGas) && maxPriorityFeePerGas !== '0x')
        transaction.maxPriorityFeePerGas = (0, fromHex_js_1.hexToBigInt)(maxPriorityFeePerGas);
    if (accessList.length !== 0 && accessList !== '0x')
        transaction.accessList = parseAccessList(accessList);
    (0, assertTransaction_js_1.assertTransactionEIP1559)(transaction);
    const signature = transactionArray.length === 12
        ? parseEIP155Signature(transactionArray)
        : undefined;
    return { ...signature, ...transaction };
}
function parseTransactionEIP2930(serializedTransaction) {
    const transactionArray = toTransactionArray(serializedTransaction);
    const [chainId, nonce, gasPrice, gas, to, value, data, accessList, v, r, s] = transactionArray;
    if (!(transactionArray.length === 8 || transactionArray.length === 11))
        throw new transaction_js_1.InvalidSerializedTransactionError({
            attributes: {
                chainId,
                nonce,
                gasPrice,
                gas,
                to,
                value,
                data,
                accessList,
                ...(transactionArray.length > 8
                    ? {
                        v,
                        r,
                        s,
                    }
                    : {}),
            },
            serializedTransaction,
            type: 'eip2930',
        });
    const transaction = {
        chainId: (0, fromHex_js_1.hexToNumber)(chainId),
        type: 'eip2930',
    };
    if ((0, isHex_js_1.isHex)(to) && to !== '0x')
        transaction.to = to;
    if ((0, isHex_js_1.isHex)(gas) && gas !== '0x')
        transaction.gas = (0, fromHex_js_1.hexToBigInt)(gas);
    if ((0, isHex_js_1.isHex)(data) && data !== '0x')
        transaction.data = data;
    if ((0, isHex_js_1.isHex)(nonce))
        transaction.nonce = nonce === '0x' ? 0 : (0, fromHex_js_1.hexToNumber)(nonce);
    if ((0, isHex_js_1.isHex)(value) && value !== '0x')
        transaction.value = (0, fromHex_js_1.hexToBigInt)(value);
    if ((0, isHex_js_1.isHex)(gasPrice) && gasPrice !== '0x')
        transaction.gasPrice = (0, fromHex_js_1.hexToBigInt)(gasPrice);
    if (accessList.length !== 0 && accessList !== '0x')
        transaction.accessList = parseAccessList(accessList);
    (0, assertTransaction_js_1.assertTransactionEIP2930)(transaction);
    const signature = transactionArray.length === 11
        ? parseEIP155Signature(transactionArray)
        : undefined;
    return { ...signature, ...transaction };
}
function parseTransactionLegacy(serializedTransaction) {
    const transactionArray = (0, fromRlp_js_1.fromRlp)(serializedTransaction, 'hex');
    const [nonce, gasPrice, gas, to, value, data, chainIdOrV_, r, s] = transactionArray;
    if (!(transactionArray.length === 6 || transactionArray.length === 9))
        throw new transaction_js_1.InvalidSerializedTransactionError({
            attributes: {
                nonce,
                gasPrice,
                gas,
                to,
                value,
                data,
                ...(transactionArray.length > 6
                    ? {
                        v: chainIdOrV_,
                        r,
                        s,
                    }
                    : {}),
            },
            serializedTransaction,
            type: 'legacy',
        });
    const transaction = {
        type: 'legacy',
    };
    if ((0, isHex_js_1.isHex)(to) && to !== '0x')
        transaction.to = to;
    if ((0, isHex_js_1.isHex)(gas) && gas !== '0x')
        transaction.gas = (0, fromHex_js_1.hexToBigInt)(gas);
    if ((0, isHex_js_1.isHex)(data) && data !== '0x')
        transaction.data = data;
    if ((0, isHex_js_1.isHex)(nonce))
        transaction.nonce = nonce === '0x' ? 0 : (0, fromHex_js_1.hexToNumber)(nonce);
    if ((0, isHex_js_1.isHex)(value) && value !== '0x')
        transaction.value = (0, fromHex_js_1.hexToBigInt)(value);
    if ((0, isHex_js_1.isHex)(gasPrice) && gasPrice !== '0x')
        transaction.gasPrice = (0, fromHex_js_1.hexToBigInt)(gasPrice);
    (0, assertTransaction_js_1.assertTransactionLegacy)(transaction);
    if (transactionArray.length === 6)
        return transaction;
    const chainIdOrV = (0, isHex_js_1.isHex)(chainIdOrV_) && chainIdOrV_ !== '0x'
        ? (0, fromHex_js_1.hexToBigInt)(chainIdOrV_)
        : 0n;
    if (s === '0x' && r === '0x') {
        if (chainIdOrV > 0)
            transaction.chainId = Number(chainIdOrV);
        return transaction;
    }
    const v = chainIdOrV;
    const chainId = Number((v - 35n) / 2n);
    if (chainId > 0)
        transaction.chainId = chainId;
    else if (v !== 27n && v !== 28n)
        throw new transaction_js_1.InvalidLegacyVError({ v });
    transaction.v = v;
    transaction.s = s;
    transaction.r = r;
    transaction.yParity = v % 2n === 0n ? 1 : 0;
    return transaction;
}
function toTransactionArray(serializedTransaction) {
    return (0, fromRlp_js_1.fromRlp)(`0x${serializedTransaction.slice(4)}`, 'hex');
}
function parseAccessList(accessList_) {
    const accessList = [];
    for (let i = 0; i < accessList_.length; i++) {
        const [address, storageKeys] = accessList_[i];
        if (!(0, isAddress_js_1.isAddress)(address, { strict: false }))
            throw new address_js_1.InvalidAddressError({ address });
        accessList.push({
            address: address,
            storageKeys: storageKeys.map((key) => ((0, isHash_js_1.isHash)(key) ? key : (0, trim_js_1.trim)(key))),
        });
    }
    return accessList;
}
function parseAuthorizationList(serializedAuthorizationList) {
    const authorizationList = [];
    for (let i = 0; i < serializedAuthorizationList.length; i++) {
        const [chainId, address, nonce, yParity, r, s] = serializedAuthorizationList[i];
        authorizationList.push({
            address,
            chainId: chainId === '0x' ? 0 : (0, fromHex_js_1.hexToNumber)(chainId),
            nonce: nonce === '0x' ? 0 : (0, fromHex_js_1.hexToNumber)(nonce),
            ...parseEIP155Signature([yParity, r, s]),
        });
    }
    return authorizationList;
}
function parseEIP155Signature(transactionArray) {
    const signature = transactionArray.slice(-3);
    const v = signature[0] === '0x' || (0, fromHex_js_1.hexToBigInt)(signature[0]) === 0n ? 27n : 28n;
    return {
        r: (0, pad_js_1.padHex)(signature[1], { size: 32 }),
        s: (0, pad_js_1.padHex)(signature[2], { size: 32 }),
        v,
        yParity: v === 27n ? 0 : 1,
    };
}
//# sourceMappingURL=parseTransaction.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/utils/transaction/serializeAccessList.js":
/*!*************************************************************************!*\
  !*** ./node_modules/viem/_cjs/utils/transaction/serializeAccessList.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.serializeAccessList = serializeAccessList;
const address_js_1 = __webpack_require__(/*! ../../errors/address.js */ "./node_modules/viem/_cjs/errors/address.js");
const transaction_js_1 = __webpack_require__(/*! ../../errors/transaction.js */ "./node_modules/viem/_cjs/errors/transaction.js");
const isAddress_js_1 = __webpack_require__(/*! ../address/isAddress.js */ "./node_modules/viem/_cjs/utils/address/isAddress.js");
function serializeAccessList(accessList) {
    if (!accessList || accessList.length === 0)
        return [];
    const serializedAccessList = [];
    for (let i = 0; i < accessList.length; i++) {
        const { address, storageKeys } = accessList[i];
        for (let j = 0; j < storageKeys.length; j++) {
            if (storageKeys[j].length - 2 !== 64) {
                throw new transaction_js_1.InvalidStorageKeySizeError({ storageKey: storageKeys[j] });
            }
        }
        if (!(0, isAddress_js_1.isAddress)(address, { strict: false })) {
            throw new address_js_1.InvalidAddressError({ address });
        }
        serializedAccessList.push([address, storageKeys]);
    }
    return serializedAccessList;
}
//# sourceMappingURL=serializeAccessList.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/utils/transaction/serializeTransaction.js":
/*!**************************************************************************!*\
  !*** ./node_modules/viem/_cjs/utils/transaction/serializeTransaction.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.serializeTransaction = serializeTransaction;
exports.toYParitySignatureArray = toYParitySignatureArray;
const transaction_js_1 = __webpack_require__(/*! ../../errors/transaction.js */ "./node_modules/viem/_cjs/errors/transaction.js");
const serializeAuthorizationList_js_1 = __webpack_require__(/*! ../authorization/serializeAuthorizationList.js */ "./node_modules/viem/_cjs/utils/authorization/serializeAuthorizationList.js");
const blobsToCommitments_js_1 = __webpack_require__(/*! ../blob/blobsToCommitments.js */ "./node_modules/viem/_cjs/utils/blob/blobsToCommitments.js");
const blobsToProofs_js_1 = __webpack_require__(/*! ../blob/blobsToProofs.js */ "./node_modules/viem/_cjs/utils/blob/blobsToProofs.js");
const commitmentsToVersionedHashes_js_1 = __webpack_require__(/*! ../blob/commitmentsToVersionedHashes.js */ "./node_modules/viem/_cjs/utils/blob/commitmentsToVersionedHashes.js");
const toBlobSidecars_js_1 = __webpack_require__(/*! ../blob/toBlobSidecars.js */ "./node_modules/viem/_cjs/utils/blob/toBlobSidecars.js");
const concat_js_1 = __webpack_require__(/*! ../data/concat.js */ "./node_modules/viem/_cjs/utils/data/concat.js");
const trim_js_1 = __webpack_require__(/*! ../data/trim.js */ "./node_modules/viem/_cjs/utils/data/trim.js");
const toHex_js_1 = __webpack_require__(/*! ../encoding/toHex.js */ "./node_modules/viem/_cjs/utils/encoding/toHex.js");
const toRlp_js_1 = __webpack_require__(/*! ../encoding/toRlp.js */ "./node_modules/viem/_cjs/utils/encoding/toRlp.js");
const assertTransaction_js_1 = __webpack_require__(/*! ./assertTransaction.js */ "./node_modules/viem/_cjs/utils/transaction/assertTransaction.js");
const getTransactionType_js_1 = __webpack_require__(/*! ./getTransactionType.js */ "./node_modules/viem/_cjs/utils/transaction/getTransactionType.js");
const serializeAccessList_js_1 = __webpack_require__(/*! ./serializeAccessList.js */ "./node_modules/viem/_cjs/utils/transaction/serializeAccessList.js");
function serializeTransaction(transaction, signature) {
    const type = (0, getTransactionType_js_1.getTransactionType)(transaction);
    if (type === 'eip1559')
        return serializeTransactionEIP1559(transaction, signature);
    if (type === 'eip2930')
        return serializeTransactionEIP2930(transaction, signature);
    if (type === 'eip4844')
        return serializeTransactionEIP4844(transaction, signature);
    if (type === 'eip7702')
        return serializeTransactionEIP7702(transaction, signature);
    return serializeTransactionLegacy(transaction, signature);
}
function serializeTransactionEIP7702(transaction, signature) {
    const { authorizationList, chainId, gas, nonce, to, value, maxFeePerGas, maxPriorityFeePerGas, accessList, data, } = transaction;
    (0, assertTransaction_js_1.assertTransactionEIP7702)(transaction);
    const serializedAccessList = (0, serializeAccessList_js_1.serializeAccessList)(accessList);
    const serializedAuthorizationList = (0, serializeAuthorizationList_js_1.serializeAuthorizationList)(authorizationList);
    return (0, concat_js_1.concatHex)([
        '0x04',
        (0, toRlp_js_1.toRlp)([
            (0, toHex_js_1.numberToHex)(chainId),
            nonce ? (0, toHex_js_1.numberToHex)(nonce) : '0x',
            maxPriorityFeePerGas ? (0, toHex_js_1.numberToHex)(maxPriorityFeePerGas) : '0x',
            maxFeePerGas ? (0, toHex_js_1.numberToHex)(maxFeePerGas) : '0x',
            gas ? (0, toHex_js_1.numberToHex)(gas) : '0x',
            to ?? '0x',
            value ? (0, toHex_js_1.numberToHex)(value) : '0x',
            data ?? '0x',
            serializedAccessList,
            serializedAuthorizationList,
            ...toYParitySignatureArray(transaction, signature),
        ]),
    ]);
}
function serializeTransactionEIP4844(transaction, signature) {
    const { chainId, gas, nonce, to, value, maxFeePerBlobGas, maxFeePerGas, maxPriorityFeePerGas, accessList, data, } = transaction;
    (0, assertTransaction_js_1.assertTransactionEIP4844)(transaction);
    let blobVersionedHashes = transaction.blobVersionedHashes;
    let sidecars = transaction.sidecars;
    if (transaction.blobs &&
        (typeof blobVersionedHashes === 'undefined' ||
            typeof sidecars === 'undefined')) {
        const blobs = (typeof transaction.blobs[0] === 'string'
            ? transaction.blobs
            : transaction.blobs.map((x) => (0, toHex_js_1.bytesToHex)(x)));
        const kzg = transaction.kzg;
        const commitments = (0, blobsToCommitments_js_1.blobsToCommitments)({
            blobs,
            kzg,
        });
        if (typeof blobVersionedHashes === 'undefined')
            blobVersionedHashes = (0, commitmentsToVersionedHashes_js_1.commitmentsToVersionedHashes)({
                commitments,
            });
        if (typeof sidecars === 'undefined') {
            const proofs = (0, blobsToProofs_js_1.blobsToProofs)({ blobs, commitments, kzg });
            sidecars = (0, toBlobSidecars_js_1.toBlobSidecars)({ blobs, commitments, proofs });
        }
    }
    const serializedAccessList = (0, serializeAccessList_js_1.serializeAccessList)(accessList);
    const serializedTransaction = [
        (0, toHex_js_1.numberToHex)(chainId),
        nonce ? (0, toHex_js_1.numberToHex)(nonce) : '0x',
        maxPriorityFeePerGas ? (0, toHex_js_1.numberToHex)(maxPriorityFeePerGas) : '0x',
        maxFeePerGas ? (0, toHex_js_1.numberToHex)(maxFeePerGas) : '0x',
        gas ? (0, toHex_js_1.numberToHex)(gas) : '0x',
        to ?? '0x',
        value ? (0, toHex_js_1.numberToHex)(value) : '0x',
        data ?? '0x',
        serializedAccessList,
        maxFeePerBlobGas ? (0, toHex_js_1.numberToHex)(maxFeePerBlobGas) : '0x',
        blobVersionedHashes ?? [],
        ...toYParitySignatureArray(transaction, signature),
    ];
    const blobs = [];
    const commitments = [];
    const proofs = [];
    if (sidecars)
        for (let i = 0; i < sidecars.length; i++) {
            const { blob, commitment, proof } = sidecars[i];
            blobs.push(blob);
            commitments.push(commitment);
            proofs.push(proof);
        }
    return (0, concat_js_1.concatHex)([
        '0x03',
        sidecars
            ?
                (0, toRlp_js_1.toRlp)([serializedTransaction, blobs, commitments, proofs])
            :
                (0, toRlp_js_1.toRlp)(serializedTransaction),
    ]);
}
function serializeTransactionEIP1559(transaction, signature) {
    const { chainId, gas, nonce, to, value, maxFeePerGas, maxPriorityFeePerGas, accessList, data, } = transaction;
    (0, assertTransaction_js_1.assertTransactionEIP1559)(transaction);
    const serializedAccessList = (0, serializeAccessList_js_1.serializeAccessList)(accessList);
    const serializedTransaction = [
        (0, toHex_js_1.numberToHex)(chainId),
        nonce ? (0, toHex_js_1.numberToHex)(nonce) : '0x',
        maxPriorityFeePerGas ? (0, toHex_js_1.numberToHex)(maxPriorityFeePerGas) : '0x',
        maxFeePerGas ? (0, toHex_js_1.numberToHex)(maxFeePerGas) : '0x',
        gas ? (0, toHex_js_1.numberToHex)(gas) : '0x',
        to ?? '0x',
        value ? (0, toHex_js_1.numberToHex)(value) : '0x',
        data ?? '0x',
        serializedAccessList,
        ...toYParitySignatureArray(transaction, signature),
    ];
    return (0, concat_js_1.concatHex)([
        '0x02',
        (0, toRlp_js_1.toRlp)(serializedTransaction),
    ]);
}
function serializeTransactionEIP2930(transaction, signature) {
    const { chainId, gas, data, nonce, to, value, accessList, gasPrice } = transaction;
    (0, assertTransaction_js_1.assertTransactionEIP2930)(transaction);
    const serializedAccessList = (0, serializeAccessList_js_1.serializeAccessList)(accessList);
    const serializedTransaction = [
        (0, toHex_js_1.numberToHex)(chainId),
        nonce ? (0, toHex_js_1.numberToHex)(nonce) : '0x',
        gasPrice ? (0, toHex_js_1.numberToHex)(gasPrice) : '0x',
        gas ? (0, toHex_js_1.numberToHex)(gas) : '0x',
        to ?? '0x',
        value ? (0, toHex_js_1.numberToHex)(value) : '0x',
        data ?? '0x',
        serializedAccessList,
        ...toYParitySignatureArray(transaction, signature),
    ];
    return (0, concat_js_1.concatHex)([
        '0x01',
        (0, toRlp_js_1.toRlp)(serializedTransaction),
    ]);
}
function serializeTransactionLegacy(transaction, signature) {
    const { chainId = 0, gas, data, nonce, to, value, gasPrice } = transaction;
    (0, assertTransaction_js_1.assertTransactionLegacy)(transaction);
    let serializedTransaction = [
        nonce ? (0, toHex_js_1.numberToHex)(nonce) : '0x',
        gasPrice ? (0, toHex_js_1.numberToHex)(gasPrice) : '0x',
        gas ? (0, toHex_js_1.numberToHex)(gas) : '0x',
        to ?? '0x',
        value ? (0, toHex_js_1.numberToHex)(value) : '0x',
        data ?? '0x',
    ];
    if (signature) {
        const v = (() => {
            if (signature.v >= 35n) {
                const inferredChainId = (signature.v - 35n) / 2n;
                if (inferredChainId > 0)
                    return signature.v;
                return 27n + (signature.v === 35n ? 0n : 1n);
            }
            if (chainId > 0)
                return BigInt(chainId * 2) + BigInt(35n + signature.v - 27n);
            const v = 27n + (signature.v === 27n ? 0n : 1n);
            if (signature.v !== v)
                throw new transaction_js_1.InvalidLegacyVError({ v: signature.v });
            return v;
        })();
        const r = (0, trim_js_1.trim)(signature.r);
        const s = (0, trim_js_1.trim)(signature.s);
        serializedTransaction = [
            ...serializedTransaction,
            (0, toHex_js_1.numberToHex)(v),
            r === '0x00' ? '0x' : r,
            s === '0x00' ? '0x' : s,
        ];
    }
    else if (chainId > 0) {
        serializedTransaction = [
            ...serializedTransaction,
            (0, toHex_js_1.numberToHex)(chainId),
            '0x',
            '0x',
        ];
    }
    return (0, toRlp_js_1.toRlp)(serializedTransaction);
}
function toYParitySignatureArray(transaction, signature_) {
    const signature = signature_ ?? transaction;
    const { v, yParity } = signature;
    if (typeof signature.r === 'undefined')
        return [];
    if (typeof signature.s === 'undefined')
        return [];
    if (typeof v === 'undefined' && typeof yParity === 'undefined')
        return [];
    const r = (0, trim_js_1.trim)(signature.r);
    const s = (0, trim_js_1.trim)(signature.s);
    const yParity_ = (() => {
        if (typeof yParity === 'number')
            return yParity ? (0, toHex_js_1.numberToHex)(1) : '0x';
        if (v === 0n)
            return '0x';
        if (v === 1n)
            return (0, toHex_js_1.numberToHex)(1);
        return v === 27n ? '0x' : (0, toHex_js_1.numberToHex)(1);
    })();
    return [yParity_, r === '0x00' ? '0x' : r, s === '0x00' ? '0x' : s];
}
//# sourceMappingURL=serializeTransaction.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/utils/typedData.js":
/*!***************************************************!*\
  !*** ./node_modules/viem/_cjs/utils/typedData.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.serializeTypedData = serializeTypedData;
exports.validateTypedData = validateTypedData;
exports.getTypesForEIP712Domain = getTypesForEIP712Domain;
exports.domainSeparator = domainSeparator;
const abi_js_1 = __webpack_require__(/*! ../errors/abi.js */ "./node_modules/viem/_cjs/errors/abi.js");
const address_js_1 = __webpack_require__(/*! ../errors/address.js */ "./node_modules/viem/_cjs/errors/address.js");
const typedData_js_1 = __webpack_require__(/*! ../errors/typedData.js */ "./node_modules/viem/_cjs/errors/typedData.js");
const isAddress_js_1 = __webpack_require__(/*! ./address/isAddress.js */ "./node_modules/viem/_cjs/utils/address/isAddress.js");
const size_js_1 = __webpack_require__(/*! ./data/size.js */ "./node_modules/viem/_cjs/utils/data/size.js");
const toHex_js_1 = __webpack_require__(/*! ./encoding/toHex.js */ "./node_modules/viem/_cjs/utils/encoding/toHex.js");
const regex_js_1 = __webpack_require__(/*! ./regex.js */ "./node_modules/viem/_cjs/utils/regex.js");
const hashTypedData_js_1 = __webpack_require__(/*! ./signature/hashTypedData.js */ "./node_modules/viem/_cjs/utils/signature/hashTypedData.js");
const stringify_js_1 = __webpack_require__(/*! ./stringify.js */ "./node_modules/viem/_cjs/utils/stringify.js");
function serializeTypedData(parameters) {
    const { domain: domain_, message: message_, primaryType, types, } = parameters;
    const normalizeData = (struct, data_) => {
        const data = { ...data_ };
        for (const param of struct) {
            const { name, type } = param;
            if (type === 'address')
                data[name] = data[name].toLowerCase();
        }
        return data;
    };
    const domain = (() => {
        if (!types.EIP712Domain)
            return {};
        if (!domain_)
            return {};
        return normalizeData(types.EIP712Domain, domain_);
    })();
    const message = (() => {
        if (primaryType === 'EIP712Domain')
            return undefined;
        return normalizeData(types[primaryType], message_);
    })();
    return (0, stringify_js_1.stringify)({ domain, message, primaryType, types });
}
function validateTypedData(parameters) {
    const { domain, message, primaryType, types } = parameters;
    const validateData = (struct, data) => {
        for (const param of struct) {
            const { name, type } = param;
            const value = data[name];
            const integerMatch = type.match(regex_js_1.integerRegex);
            if (integerMatch &&
                (typeof value === 'number' || typeof value === 'bigint')) {
                const [_type, base, size_] = integerMatch;
                (0, toHex_js_1.numberToHex)(value, {
                    signed: base === 'int',
                    size: Number.parseInt(size_, 10) / 8,
                });
            }
            if (type === 'address' && typeof value === 'string' && !(0, isAddress_js_1.isAddress)(value))
                throw new address_js_1.InvalidAddressError({ address: value });
            const bytesMatch = type.match(regex_js_1.bytesRegex);
            if (bytesMatch) {
                const [_type, size_] = bytesMatch;
                if (size_ && (0, size_js_1.size)(value) !== Number.parseInt(size_, 10))
                    throw new abi_js_1.BytesSizeMismatchError({
                        expectedSize: Number.parseInt(size_, 10),
                        givenSize: (0, size_js_1.size)(value),
                    });
            }
            const struct = types[type];
            if (struct) {
                validateReference(type);
                validateData(struct, value);
            }
        }
    };
    if (types.EIP712Domain && domain) {
        if (typeof domain !== 'object')
            throw new typedData_js_1.InvalidDomainError({ domain });
        validateData(types.EIP712Domain, domain);
    }
    if (primaryType !== 'EIP712Domain') {
        if (types[primaryType])
            validateData(types[primaryType], message);
        else
            throw new typedData_js_1.InvalidPrimaryTypeError({ primaryType, types });
    }
}
function getTypesForEIP712Domain({ domain, }) {
    return [
        typeof domain?.name === 'string' && { name: 'name', type: 'string' },
        domain?.version && { name: 'version', type: 'string' },
        (typeof domain?.chainId === 'number' ||
            typeof domain?.chainId === 'bigint') && {
            name: 'chainId',
            type: 'uint256',
        },
        domain?.verifyingContract && {
            name: 'verifyingContract',
            type: 'address',
        },
        domain?.salt && { name: 'salt', type: 'bytes32' },
    ].filter(Boolean);
}
function domainSeparator({ domain }) {
    return (0, hashTypedData_js_1.hashDomain)({
        domain,
        types: {
            EIP712Domain: getTypesForEIP712Domain({ domain }),
        },
    });
}
function validateReference(type) {
    if (type === 'address' ||
        type === 'bool' ||
        type === 'string' ||
        type.startsWith('bytes') ||
        type.startsWith('uint') ||
        type.startsWith('int'))
        throw new typedData_js_1.InvalidStructTypeError({ type });
}
//# sourceMappingURL=typedData.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/utils/uid.js":
/*!*********************************************!*\
  !*** ./node_modules/viem/_cjs/utils/uid.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.uid = uid;
const size = 256;
let index = size;
let buffer;
function uid(length = 11) {
    if (!buffer || index + length > size * 2) {
        buffer = '';
        index = 0;
        for (let i = 0; i < size; i++) {
            buffer += ((256 + Math.random() * 256) | 0).toString(16).substring(1);
        }
    }
    return buffer.substring(index, index++ + length);
}
//# sourceMappingURL=uid.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/utils/unit/formatEther.js":
/*!**********************************************************!*\
  !*** ./node_modules/viem/_cjs/utils/unit/formatEther.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.formatEther = formatEther;
const unit_js_1 = __webpack_require__(/*! ../../constants/unit.js */ "./node_modules/viem/_cjs/constants/unit.js");
const formatUnits_js_1 = __webpack_require__(/*! ./formatUnits.js */ "./node_modules/viem/_cjs/utils/unit/formatUnits.js");
function formatEther(wei, unit = 'wei') {
    return (0, formatUnits_js_1.formatUnits)(wei, unit_js_1.etherUnits[unit]);
}
//# sourceMappingURL=formatEther.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/utils/unit/formatGwei.js":
/*!*********************************************************!*\
  !*** ./node_modules/viem/_cjs/utils/unit/formatGwei.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.formatGwei = formatGwei;
const unit_js_1 = __webpack_require__(/*! ../../constants/unit.js */ "./node_modules/viem/_cjs/constants/unit.js");
const formatUnits_js_1 = __webpack_require__(/*! ./formatUnits.js */ "./node_modules/viem/_cjs/utils/unit/formatUnits.js");
function formatGwei(wei, unit = 'wei') {
    return (0, formatUnits_js_1.formatUnits)(wei, unit_js_1.gweiUnits[unit]);
}
//# sourceMappingURL=formatGwei.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/utils/unit/formatUnits.js":
/*!**********************************************************!*\
  !*** ./node_modules/viem/_cjs/utils/unit/formatUnits.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.formatUnits = formatUnits;
function formatUnits(value, decimals) {
    let display = value.toString();
    const negative = display.startsWith('-');
    if (negative)
        display = display.slice(1);
    display = display.padStart(decimals, '0');
    let [integer, fraction] = [
        display.slice(0, display.length - decimals),
        display.slice(display.length - decimals),
    ];
    fraction = fraction.replace(/(0+)$/, '');
    return `${negative ? '-' : ''}${integer || '0'}${fraction ? `.${fraction}` : ''}`;
}
//# sourceMappingURL=formatUnits.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/utils/unit/parseEther.js":
/*!*********************************************************!*\
  !*** ./node_modules/viem/_cjs/utils/unit/parseEther.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.parseEther = parseEther;
const unit_js_1 = __webpack_require__(/*! ../../constants/unit.js */ "./node_modules/viem/_cjs/constants/unit.js");
const parseUnits_js_1 = __webpack_require__(/*! ./parseUnits.js */ "./node_modules/viem/_cjs/utils/unit/parseUnits.js");
function parseEther(ether, unit = 'wei') {
    return (0, parseUnits_js_1.parseUnits)(ether, unit_js_1.etherUnits[unit]);
}
//# sourceMappingURL=parseEther.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/utils/unit/parseGwei.js":
/*!********************************************************!*\
  !*** ./node_modules/viem/_cjs/utils/unit/parseGwei.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.parseGwei = parseGwei;
const unit_js_1 = __webpack_require__(/*! ../../constants/unit.js */ "./node_modules/viem/_cjs/constants/unit.js");
const parseUnits_js_1 = __webpack_require__(/*! ./parseUnits.js */ "./node_modules/viem/_cjs/utils/unit/parseUnits.js");
function parseGwei(ether, unit = 'wei') {
    return (0, parseUnits_js_1.parseUnits)(ether, unit_js_1.gweiUnits[unit]);
}
//# sourceMappingURL=parseGwei.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/utils/unit/parseUnits.js":
/*!*********************************************************!*\
  !*** ./node_modules/viem/_cjs/utils/unit/parseUnits.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.parseUnits = parseUnits;
const unit_js_1 = __webpack_require__(/*! ../../errors/unit.js */ "./node_modules/viem/_cjs/errors/unit.js");
function parseUnits(value, decimals) {
    if (!/^(-?)([0-9]*)\.?([0-9]*)$/.test(value))
        throw new unit_js_1.InvalidDecimalNumberError({ value });
    let [integer, fraction = '0'] = value.split('.');
    const negative = integer.startsWith('-');
    if (negative)
        integer = integer.slice(1);
    fraction = fraction.replace(/(0+)$/, '');
    if (decimals === 0) {
        if (Math.round(Number(`.${fraction}`)) === 1)
            integer = `${BigInt(integer) + 1n}`;
        fraction = '';
    }
    else if (fraction.length > decimals) {
        const [left, unit, right] = [
            fraction.slice(0, decimals - 1),
            fraction.slice(decimals - 1, decimals),
            fraction.slice(decimals),
        ];
        const rounded = Math.round(Number(`${unit}.${right}`));
        if (rounded > 9)
            fraction = `${BigInt(left) + BigInt(1)}0`.padStart(left.length + 1, '0');
        else
            fraction = `${left}${rounded}`;
        if (fraction.length > decimals) {
            fraction = fraction.slice(1);
            integer = `${BigInt(integer) + 1n}`;
        }
        fraction = fraction.slice(0, decimals);
    }
    else {
        fraction = fraction.padEnd(decimals, '0');
    }
    return BigInt(`${negative ? '-' : ''}${integer}${fraction}`);
}
//# sourceMappingURL=parseUnits.js.map

/***/ }),

/***/ "./node_modules/viem/_cjs/utils/wait.js":
/*!**********************************************!*\
  !*** ./node_modules/viem/_cjs/utils/wait.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.wait = wait;
async function wait(time) {
    return new Promise((res) => setTimeout(res, time));
}
//# sourceMappingURL=wait.js.map

/***/ }),

/***/ "./node_modules/viem/node_modules/@noble/curves/_shortw_utils.js":
/*!***********************************************************************!*\
  !*** ./node_modules/viem/node_modules/@noble/curves/_shortw_utils.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getHash = getHash;
exports.createCurve = createCurve;
/**
 * Utilities for short weierstrass curves, combined with noble-hashes.
 * @module
 */
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const weierstrass_ts_1 = __webpack_require__(/*! ./abstract/weierstrass.js */ "./node_modules/viem/node_modules/@noble/curves/abstract/weierstrass.js");
/** connects noble-curves to noble-hashes */
function getHash(hash) {
    return { hash };
}
/** @deprecated use new `weierstrass()` and `ecdsa()` methods */
function createCurve(curveDef, defHash) {
    const create = (hash) => (0, weierstrass_ts_1.weierstrass)({ ...curveDef, hash: hash });
    return { ...create(defHash), create };
}
//# sourceMappingURL=_shortw_utils.js.map

/***/ }),

/***/ "./node_modules/viem/node_modules/@noble/curves/abstract/curve.js":
/*!************************************************************************!*\
  !*** ./node_modules/viem/node_modules/@noble/curves/abstract/curve.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.wNAF = void 0;
exports.negateCt = negateCt;
exports.normalizeZ = normalizeZ;
exports.mulEndoUnsafe = mulEndoUnsafe;
exports.pippenger = pippenger;
exports.precomputeMSMUnsafe = precomputeMSMUnsafe;
exports.validateBasic = validateBasic;
exports._createCurveFields = _createCurveFields;
/**
 * Methods for elliptic curve multiplication by scalars.
 * Contains wNAF, pippenger.
 * @module
 */
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const utils_ts_1 = __webpack_require__(/*! ../utils.js */ "./node_modules/viem/node_modules/@noble/curves/utils.js");
const modular_ts_1 = __webpack_require__(/*! ./modular.js */ "./node_modules/viem/node_modules/@noble/curves/abstract/modular.js");
const _0n = BigInt(0);
const _1n = BigInt(1);
function negateCt(condition, item) {
    const neg = item.negate();
    return condition ? neg : item;
}
/**
 * Takes a bunch of Projective Points but executes only one
 * inversion on all of them. Inversion is very slow operation,
 * so this improves performance massively.
 * Optimization: converts a list of projective points to a list of identical points with Z=1.
 */
function normalizeZ(c, points) {
    const invertedZs = (0, modular_ts_1.FpInvertBatch)(c.Fp, points.map((p) => p.Z));
    return points.map((p, i) => c.fromAffine(p.toAffine(invertedZs[i])));
}
function validateW(W, bits) {
    if (!Number.isSafeInteger(W) || W <= 0 || W > bits)
        throw new Error('invalid window size, expected [1..' + bits + '], got W=' + W);
}
function calcWOpts(W, scalarBits) {
    validateW(W, scalarBits);
    const windows = Math.ceil(scalarBits / W) + 1; // W=8 33. Not 32, because we skip zero
    const windowSize = 2 ** (W - 1); // W=8 128. Not 256, because we skip zero
    const maxNumber = 2 ** W; // W=8 256
    const mask = (0, utils_ts_1.bitMask)(W); // W=8 255 == mask 0b11111111
    const shiftBy = BigInt(W); // W=8 8
    return { windows, windowSize, mask, maxNumber, shiftBy };
}
function calcOffsets(n, window, wOpts) {
    const { windowSize, mask, maxNumber, shiftBy } = wOpts;
    let wbits = Number(n & mask); // extract W bits.
    let nextN = n >> shiftBy; // shift number by W bits.
    // What actually happens here:
    // const highestBit = Number(mask ^ (mask >> 1n));
    // let wbits2 = wbits - 1; // skip zero
    // if (wbits2 & highestBit) { wbits2 ^= Number(mask); // (~);
    // split if bits > max: +224 => 256-32
    if (wbits > windowSize) {
        // we skip zero, which means instead of `>= size-1`, we do `> size`
        wbits -= maxNumber; // -32, can be maxNumber - wbits, but then we need to set isNeg here.
        nextN += _1n; // +256 (carry)
    }
    const offsetStart = window * windowSize;
    const offset = offsetStart + Math.abs(wbits) - 1; // -1 because we skip zero
    const isZero = wbits === 0; // is current window slice a 0?
    const isNeg = wbits < 0; // is current window slice negative?
    const isNegF = window % 2 !== 0; // fake random statement for noise
    const offsetF = offsetStart; // fake offset for noise
    return { nextN, offset, isZero, isNeg, isNegF, offsetF };
}
function validateMSMPoints(points, c) {
    if (!Array.isArray(points))
        throw new Error('array expected');
    points.forEach((p, i) => {
        if (!(p instanceof c))
            throw new Error('invalid point at index ' + i);
    });
}
function validateMSMScalars(scalars, field) {
    if (!Array.isArray(scalars))
        throw new Error('array of scalars expected');
    scalars.forEach((s, i) => {
        if (!field.isValid(s))
            throw new Error('invalid scalar at index ' + i);
    });
}
// Since points in different groups cannot be equal (different object constructor),
// we can have single place to store precomputes.
// Allows to make points frozen / immutable.
const pointPrecomputes = new WeakMap();
const pointWindowSizes = new WeakMap();
function getW(P) {
    // To disable precomputes:
    // return 1;
    return pointWindowSizes.get(P) || 1;
}
function assert0(n) {
    if (n !== _0n)
        throw new Error('invalid wNAF');
}
/**
 * Elliptic curve multiplication of Point by scalar. Fragile.
 * Table generation takes **30MB of ram and 10ms on high-end CPU**,
 * but may take much longer on slow devices. Actual generation will happen on
 * first call of `multiply()`. By default, `BASE` point is precomputed.
 *
 * Scalars should always be less than curve order: this should be checked inside of a curve itself.
 * Creates precomputation tables for fast multiplication:
 * - private scalar is split by fixed size windows of W bits
 * - every window point is collected from window's table & added to accumulator
 * - since windows are different, same point inside tables won't be accessed more than once per calc
 * - each multiplication is 'Math.ceil(CURVE_ORDER / 𝑊) + 1' point additions (fixed for any scalar)
 * - +1 window is neccessary for wNAF
 * - wNAF reduces table size: 2x less memory + 2x faster generation, but 10% slower multiplication
 *
 * @todo Research returning 2d JS array of windows, instead of a single window.
 * This would allow windows to be in different memory locations
 */
class wNAF {
    // Parametrized with a given Point class (not individual point)
    constructor(Point, bits) {
        this.BASE = Point.BASE;
        this.ZERO = Point.ZERO;
        this.Fn = Point.Fn;
        this.bits = bits;
    }
    // non-const time multiplication ladder
    _unsafeLadder(elm, n, p = this.ZERO) {
        let d = elm;
        while (n > _0n) {
            if (n & _1n)
                p = p.add(d);
            d = d.double();
            n >>= _1n;
        }
        return p;
    }
    /**
     * Creates a wNAF precomputation window. Used for caching.
     * Default window size is set by `utils.precompute()` and is equal to 8.
     * Number of precomputed points depends on the curve size:
     * 2^(𝑊−1) * (Math.ceil(𝑛 / 𝑊) + 1), where:
     * - 𝑊 is the window size
     * - 𝑛 is the bitlength of the curve order.
     * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
     * @param point Point instance
     * @param W window size
     * @returns precomputed point tables flattened to a single array
     */
    precomputeWindow(point, W) {
        const { windows, windowSize } = calcWOpts(W, this.bits);
        const points = [];
        let p = point;
        let base = p;
        for (let window = 0; window < windows; window++) {
            base = p;
            points.push(base);
            // i=1, bc we skip 0
            for (let i = 1; i < windowSize; i++) {
                base = base.add(p);
                points.push(base);
            }
            p = base.double();
        }
        return points;
    }
    /**
     * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
     * More compact implementation:
     * https://github.com/paulmillr/noble-secp256k1/blob/47cb1669b6e506ad66b35fe7d76132ae97465da2/index.ts#L502-L541
     * @returns real and fake (for const-time) points
     */
    wNAF(W, precomputes, n) {
        // Scalar should be smaller than field order
        if (!this.Fn.isValid(n))
            throw new Error('invalid scalar');
        // Accumulators
        let p = this.ZERO;
        let f = this.BASE;
        // This code was first written with assumption that 'f' and 'p' will never be infinity point:
        // since each addition is multiplied by 2 ** W, it cannot cancel each other. However,
        // there is negate now: it is possible that negated element from low value
        // would be the same as high element, which will create carry into next window.
        // It's not obvious how this can fail, but still worth investigating later.
        const wo = calcWOpts(W, this.bits);
        for (let window = 0; window < wo.windows; window++) {
            // (n === _0n) is handled and not early-exited. isEven and offsetF are used for noise
            const { nextN, offset, isZero, isNeg, isNegF, offsetF } = calcOffsets(n, window, wo);
            n = nextN;
            if (isZero) {
                // bits are 0: add garbage to fake point
                // Important part for const-time getPublicKey: add random "noise" point to f.
                f = f.add(negateCt(isNegF, precomputes[offsetF]));
            }
            else {
                // bits are 1: add to result point
                p = p.add(negateCt(isNeg, precomputes[offset]));
            }
        }
        assert0(n);
        // Return both real and fake points: JIT won't eliminate f.
        // At this point there is a way to F be infinity-point even if p is not,
        // which makes it less const-time: around 1 bigint multiply.
        return { p, f };
    }
    /**
     * Implements ec unsafe (non const-time) multiplication using precomputed tables and w-ary non-adjacent form.
     * @param acc accumulator point to add result of multiplication
     * @returns point
     */
    wNAFUnsafe(W, precomputes, n, acc = this.ZERO) {
        const wo = calcWOpts(W, this.bits);
        for (let window = 0; window < wo.windows; window++) {
            if (n === _0n)
                break; // Early-exit, skip 0 value
            const { nextN, offset, isZero, isNeg } = calcOffsets(n, window, wo);
            n = nextN;
            if (isZero) {
                // Window bits are 0: skip processing.
                // Move to next window.
                continue;
            }
            else {
                const item = precomputes[offset];
                acc = acc.add(isNeg ? item.negate() : item); // Re-using acc allows to save adds in MSM
            }
        }
        assert0(n);
        return acc;
    }
    getPrecomputes(W, point, transform) {
        // Calculate precomputes on a first run, reuse them after
        let comp = pointPrecomputes.get(point);
        if (!comp) {
            comp = this.precomputeWindow(point, W);
            if (W !== 1) {
                // Doing transform outside of if brings 15% perf hit
                if (typeof transform === 'function')
                    comp = transform(comp);
                pointPrecomputes.set(point, comp);
            }
        }
        return comp;
    }
    cached(point, scalar, transform) {
        const W = getW(point);
        return this.wNAF(W, this.getPrecomputes(W, point, transform), scalar);
    }
    unsafe(point, scalar, transform, prev) {
        const W = getW(point);
        if (W === 1)
            return this._unsafeLadder(point, scalar, prev); // For W=1 ladder is ~x2 faster
        return this.wNAFUnsafe(W, this.getPrecomputes(W, point, transform), scalar, prev);
    }
    // We calculate precomputes for elliptic curve point multiplication
    // using windowed method. This specifies window size and
    // stores precomputed values. Usually only base point would be precomputed.
    createCache(P, W) {
        validateW(W, this.bits);
        pointWindowSizes.set(P, W);
        pointPrecomputes.delete(P);
    }
    hasCache(elm) {
        return getW(elm) !== 1;
    }
}
exports.wNAF = wNAF;
/**
 * Endomorphism-specific multiplication for Koblitz curves.
 * Cost: 128 dbl, 0-256 adds.
 */
function mulEndoUnsafe(Point, point, k1, k2) {
    let acc = point;
    let p1 = Point.ZERO;
    let p2 = Point.ZERO;
    while (k1 > _0n || k2 > _0n) {
        if (k1 & _1n)
            p1 = p1.add(acc);
        if (k2 & _1n)
            p2 = p2.add(acc);
        acc = acc.double();
        k1 >>= _1n;
        k2 >>= _1n;
    }
    return { p1, p2 };
}
/**
 * Pippenger algorithm for multi-scalar multiplication (MSM, Pa + Qb + Rc + ...).
 * 30x faster vs naive addition on L=4096, 10x faster than precomputes.
 * For N=254bit, L=1, it does: 1024 ADD + 254 DBL. For L=5: 1536 ADD + 254 DBL.
 * Algorithmically constant-time (for same L), even when 1 point + scalar, or when scalar = 0.
 * @param c Curve Point constructor
 * @param fieldN field over CURVE.N - important that it's not over CURVE.P
 * @param points array of L curve points
 * @param scalars array of L scalars (aka secret keys / bigints)
 */
function pippenger(c, fieldN, points, scalars) {
    // If we split scalars by some window (let's say 8 bits), every chunk will only
    // take 256 buckets even if there are 4096 scalars, also re-uses double.
    // TODO:
    // - https://eprint.iacr.org/2024/750.pdf
    // - https://tches.iacr.org/index.php/TCHES/article/view/10287
    // 0 is accepted in scalars
    validateMSMPoints(points, c);
    validateMSMScalars(scalars, fieldN);
    const plength = points.length;
    const slength = scalars.length;
    if (plength !== slength)
        throw new Error('arrays of points and scalars must have equal length');
    // if (plength === 0) throw new Error('array must be of length >= 2');
    const zero = c.ZERO;
    const wbits = (0, utils_ts_1.bitLen)(BigInt(plength));
    let windowSize = 1; // bits
    if (wbits > 12)
        windowSize = wbits - 3;
    else if (wbits > 4)
        windowSize = wbits - 2;
    else if (wbits > 0)
        windowSize = 2;
    const MASK = (0, utils_ts_1.bitMask)(windowSize);
    const buckets = new Array(Number(MASK) + 1).fill(zero); // +1 for zero array
    const lastBits = Math.floor((fieldN.BITS - 1) / windowSize) * windowSize;
    let sum = zero;
    for (let i = lastBits; i >= 0; i -= windowSize) {
        buckets.fill(zero);
        for (let j = 0; j < slength; j++) {
            const scalar = scalars[j];
            const wbits = Number((scalar >> BigInt(i)) & MASK);
            buckets[wbits] = buckets[wbits].add(points[j]);
        }
        let resI = zero; // not using this will do small speed-up, but will lose ct
        // Skip first bucket, because it is zero
        for (let j = buckets.length - 1, sumI = zero; j > 0; j--) {
            sumI = sumI.add(buckets[j]);
            resI = resI.add(sumI);
        }
        sum = sum.add(resI);
        if (i !== 0)
            for (let j = 0; j < windowSize; j++)
                sum = sum.double();
    }
    return sum;
}
/**
 * Precomputed multi-scalar multiplication (MSM, Pa + Qb + Rc + ...).
 * @param c Curve Point constructor
 * @param fieldN field over CURVE.N - important that it's not over CURVE.P
 * @param points array of L curve points
 * @returns function which multiplies points with scaars
 */
function precomputeMSMUnsafe(c, fieldN, points, windowSize) {
    /**
     * Performance Analysis of Window-based Precomputation
     *
     * Base Case (256-bit scalar, 8-bit window):
     * - Standard precomputation requires:
     *   - 31 additions per scalar × 256 scalars = 7,936 ops
     *   - Plus 255 summary additions = 8,191 total ops
     *   Note: Summary additions can be optimized via accumulator
     *
     * Chunked Precomputation Analysis:
     * - Using 32 chunks requires:
     *   - 255 additions per chunk
     *   - 256 doublings
     *   - Total: (255 × 32) + 256 = 8,416 ops
     *
     * Memory Usage Comparison:
     * Window Size | Standard Points | Chunked Points
     * ------------|-----------------|---------------
     *     4-bit   |     520         |      15
     *     8-bit   |    4,224        |     255
     *    10-bit   |   13,824        |   1,023
     *    16-bit   |  557,056        |  65,535
     *
     * Key Advantages:
     * 1. Enables larger window sizes due to reduced memory overhead
     * 2. More efficient for smaller scalar counts:
     *    - 16 chunks: (16 × 255) + 256 = 4,336 ops
     *    - ~2x faster than standard 8,191 ops
     *
     * Limitations:
     * - Not suitable for plain precomputes (requires 256 constant doublings)
     * - Performance degrades with larger scalar counts:
     *   - Optimal for ~256 scalars
     *   - Less efficient for 4096+ scalars (Pippenger preferred)
     */
    validateW(windowSize, fieldN.BITS);
    validateMSMPoints(points, c);
    const zero = c.ZERO;
    const tableSize = 2 ** windowSize - 1; // table size (without zero)
    const chunks = Math.ceil(fieldN.BITS / windowSize); // chunks of item
    const MASK = (0, utils_ts_1.bitMask)(windowSize);
    const tables = points.map((p) => {
        const res = [];
        for (let i = 0, acc = p; i < tableSize; i++) {
            res.push(acc);
            acc = acc.add(p);
        }
        return res;
    });
    return (scalars) => {
        validateMSMScalars(scalars, fieldN);
        if (scalars.length > points.length)
            throw new Error('array of scalars must be smaller than array of points');
        let res = zero;
        for (let i = 0; i < chunks; i++) {
            // No need to double if accumulator is still zero.
            if (res !== zero)
                for (let j = 0; j < windowSize; j++)
                    res = res.double();
            const shiftBy = BigInt(chunks * windowSize - (i + 1) * windowSize);
            for (let j = 0; j < scalars.length; j++) {
                const n = scalars[j];
                const curr = Number((n >> shiftBy) & MASK);
                if (!curr)
                    continue; // skip zero scalars chunks
                res = res.add(tables[j][curr - 1]);
            }
        }
        return res;
    };
}
// TODO: remove
/** @deprecated */
function validateBasic(curve) {
    (0, modular_ts_1.validateField)(curve.Fp);
    (0, utils_ts_1.validateObject)(curve, {
        n: 'bigint',
        h: 'bigint',
        Gx: 'field',
        Gy: 'field',
    }, {
        nBitLength: 'isSafeInteger',
        nByteLength: 'isSafeInteger',
    });
    // Set defaults
    return Object.freeze({
        ...(0, modular_ts_1.nLength)(curve.n, curve.nBitLength),
        ...curve,
        ...{ p: curve.Fp.ORDER },
    });
}
function createField(order, field, isLE) {
    if (field) {
        if (field.ORDER !== order)
            throw new Error('Field.ORDER must match order: Fp == p, Fn == n');
        (0, modular_ts_1.validateField)(field);
        return field;
    }
    else {
        return (0, modular_ts_1.Field)(order, { isLE });
    }
}
/** Validates CURVE opts and creates fields */
function _createCurveFields(type, CURVE, curveOpts = {}, FpFnLE) {
    if (FpFnLE === undefined)
        FpFnLE = type === 'edwards';
    if (!CURVE || typeof CURVE !== 'object')
        throw new Error(`expected valid ${type} CURVE object`);
    for (const p of ['p', 'n', 'h']) {
        const val = CURVE[p];
        if (!(typeof val === 'bigint' && val > _0n))
            throw new Error(`CURVE.${p} must be positive bigint`);
    }
    const Fp = createField(CURVE.p, curveOpts.Fp, FpFnLE);
    const Fn = createField(CURVE.n, curveOpts.Fn, FpFnLE);
    const _b = type === 'weierstrass' ? 'b' : 'd';
    const params = ['Gx', 'Gy', 'a', _b];
    for (const p of params) {
        // @ts-ignore
        if (!Fp.isValid(CURVE[p]))
            throw new Error(`CURVE.${p} must be valid field element of CURVE.Fp`);
    }
    CURVE = Object.freeze(Object.assign({}, CURVE));
    return { CURVE, Fp, Fn };
}
//# sourceMappingURL=curve.js.map

/***/ }),

/***/ "./node_modules/viem/node_modules/@noble/curves/abstract/hash-to-curve.js":
/*!********************************************************************************!*\
  !*** ./node_modules/viem/node_modules/@noble/curves/abstract/hash-to-curve.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports._DST_scalar = void 0;
exports.expand_message_xmd = expand_message_xmd;
exports.expand_message_xof = expand_message_xof;
exports.hash_to_field = hash_to_field;
exports.isogenyMap = isogenyMap;
exports.createHasher = createHasher;
const utils_ts_1 = __webpack_require__(/*! ../utils.js */ "./node_modules/viem/node_modules/@noble/curves/utils.js");
const modular_ts_1 = __webpack_require__(/*! ./modular.js */ "./node_modules/viem/node_modules/@noble/curves/abstract/modular.js");
// Octet Stream to Integer. "spec" implementation of os2ip is 2.5x slower vs bytesToNumberBE.
const os2ip = utils_ts_1.bytesToNumberBE;
// Integer to Octet Stream (numberToBytesBE)
function i2osp(value, length) {
    anum(value);
    anum(length);
    if (value < 0 || value >= 1 << (8 * length))
        throw new Error('invalid I2OSP input: ' + value);
    const res = Array.from({ length }).fill(0);
    for (let i = length - 1; i >= 0; i--) {
        res[i] = value & 0xff;
        value >>>= 8;
    }
    return new Uint8Array(res);
}
function strxor(a, b) {
    const arr = new Uint8Array(a.length);
    for (let i = 0; i < a.length; i++) {
        arr[i] = a[i] ^ b[i];
    }
    return arr;
}
function anum(item) {
    if (!Number.isSafeInteger(item))
        throw new Error('number expected');
}
function normDST(DST) {
    if (!(0, utils_ts_1.isBytes)(DST) && typeof DST !== 'string')
        throw new Error('DST must be Uint8Array or string');
    return typeof DST === 'string' ? (0, utils_ts_1.utf8ToBytes)(DST) : DST;
}
/**
 * Produces a uniformly random byte string using a cryptographic hash function H that outputs b bits.
 * [RFC 9380 5.3.1](https://www.rfc-editor.org/rfc/rfc9380#section-5.3.1).
 */
function expand_message_xmd(msg, DST, lenInBytes, H) {
    (0, utils_ts_1.abytes)(msg);
    anum(lenInBytes);
    DST = normDST(DST);
    // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3
    if (DST.length > 255)
        DST = H((0, utils_ts_1.concatBytes)((0, utils_ts_1.utf8ToBytes)('H2C-OVERSIZE-DST-'), DST));
    const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H;
    const ell = Math.ceil(lenInBytes / b_in_bytes);
    if (lenInBytes > 65535 || ell > 255)
        throw new Error('expand_message_xmd: invalid lenInBytes');
    const DST_prime = (0, utils_ts_1.concatBytes)(DST, i2osp(DST.length, 1));
    const Z_pad = i2osp(0, r_in_bytes);
    const l_i_b_str = i2osp(lenInBytes, 2); // len_in_bytes_str
    const b = new Array(ell);
    const b_0 = H((0, utils_ts_1.concatBytes)(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));
    b[0] = H((0, utils_ts_1.concatBytes)(b_0, i2osp(1, 1), DST_prime));
    for (let i = 1; i <= ell; i++) {
        const args = [strxor(b_0, b[i - 1]), i2osp(i + 1, 1), DST_prime];
        b[i] = H((0, utils_ts_1.concatBytes)(...args));
    }
    const pseudo_random_bytes = (0, utils_ts_1.concatBytes)(...b);
    return pseudo_random_bytes.slice(0, lenInBytes);
}
/**
 * Produces a uniformly random byte string using an extendable-output function (XOF) H.
 * 1. The collision resistance of H MUST be at least k bits.
 * 2. H MUST be an XOF that has been proved indifferentiable from
 *    a random oracle under a reasonable cryptographic assumption.
 * [RFC 9380 5.3.2](https://www.rfc-editor.org/rfc/rfc9380#section-5.3.2).
 */
function expand_message_xof(msg, DST, lenInBytes, k, H) {
    (0, utils_ts_1.abytes)(msg);
    anum(lenInBytes);
    DST = normDST(DST);
    // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3
    // DST = H('H2C-OVERSIZE-DST-' || a_very_long_DST, Math.ceil((lenInBytes * k) / 8));
    if (DST.length > 255) {
        const dkLen = Math.ceil((2 * k) / 8);
        DST = H.create({ dkLen }).update((0, utils_ts_1.utf8ToBytes)('H2C-OVERSIZE-DST-')).update(DST).digest();
    }
    if (lenInBytes > 65535 || DST.length > 255)
        throw new Error('expand_message_xof: invalid lenInBytes');
    return (H.create({ dkLen: lenInBytes })
        .update(msg)
        .update(i2osp(lenInBytes, 2))
        // 2. DST_prime = DST || I2OSP(len(DST), 1)
        .update(DST)
        .update(i2osp(DST.length, 1))
        .digest());
}
/**
 * Hashes arbitrary-length byte strings to a list of one or more elements of a finite field F.
 * [RFC 9380 5.2](https://www.rfc-editor.org/rfc/rfc9380#section-5.2).
 * @param msg a byte string containing the message to hash
 * @param count the number of elements of F to output
 * @param options `{DST: string, p: bigint, m: number, k: number, expand: 'xmd' | 'xof', hash: H}`, see above
 * @returns [u_0, ..., u_(count - 1)], a list of field elements.
 */
function hash_to_field(msg, count, options) {
    (0, utils_ts_1._validateObject)(options, {
        p: 'bigint',
        m: 'number',
        k: 'number',
        hash: 'function',
    });
    const { p, k, m, hash, expand, DST } = options;
    if (!(0, utils_ts_1.isHash)(options.hash))
        throw new Error('expected valid hash');
    (0, utils_ts_1.abytes)(msg);
    anum(count);
    const log2p = p.toString(2).length;
    const L = Math.ceil((log2p + k) / 8); // section 5.1 of ietf draft link above
    const len_in_bytes = count * m * L;
    let prb; // pseudo_random_bytes
    if (expand === 'xmd') {
        prb = expand_message_xmd(msg, DST, len_in_bytes, hash);
    }
    else if (expand === 'xof') {
        prb = expand_message_xof(msg, DST, len_in_bytes, k, hash);
    }
    else if (expand === '_internal_pass') {
        // for internal tests only
        prb = msg;
    }
    else {
        throw new Error('expand must be "xmd" or "xof"');
    }
    const u = new Array(count);
    for (let i = 0; i < count; i++) {
        const e = new Array(m);
        for (let j = 0; j < m; j++) {
            const elm_offset = L * (j + i * m);
            const tv = prb.subarray(elm_offset, elm_offset + L);
            e[j] = (0, modular_ts_1.mod)(os2ip(tv), p);
        }
        u[i] = e;
    }
    return u;
}
function isogenyMap(field, map) {
    // Make same order as in spec
    const coeff = map.map((i) => Array.from(i).reverse());
    return (x, y) => {
        const [xn, xd, yn, yd] = coeff.map((val) => val.reduce((acc, i) => field.add(field.mul(acc, x), i)));
        // 6.6.3
        // Exceptional cases of iso_map are inputs that cause the denominator of
        // either rational function to evaluate to zero; such cases MUST return
        // the identity point on E.
        const [xd_inv, yd_inv] = (0, modular_ts_1.FpInvertBatch)(field, [xd, yd], true);
        x = field.mul(xn, xd_inv); // xNum / xDen
        y = field.mul(y, field.mul(yn, yd_inv)); // y * (yNum / yDev)
        return { x, y };
    };
}
exports._DST_scalar = (0, utils_ts_1.utf8ToBytes)('HashToScalar-');
/** Creates hash-to-curve methods from EC Point and mapToCurve function. See {@link H2CHasher}. */
function createHasher(Point, mapToCurve, defaults) {
    if (typeof mapToCurve !== 'function')
        throw new Error('mapToCurve() must be defined');
    function map(num) {
        return Point.fromAffine(mapToCurve(num));
    }
    function clear(initial) {
        const P = initial.clearCofactor();
        if (P.equals(Point.ZERO))
            return Point.ZERO; // zero will throw in assert
        P.assertValidity();
        return P;
    }
    return {
        defaults,
        hashToCurve(msg, options) {
            const opts = Object.assign({}, defaults, options);
            const u = hash_to_field(msg, 2, opts);
            const u0 = map(u[0]);
            const u1 = map(u[1]);
            return clear(u0.add(u1));
        },
        encodeToCurve(msg, options) {
            const optsDst = defaults.encodeDST ? { DST: defaults.encodeDST } : {};
            const opts = Object.assign({}, defaults, optsDst, options);
            const u = hash_to_field(msg, 1, opts);
            const u0 = map(u[0]);
            return clear(u0);
        },
        /** See {@link H2CHasher} */
        mapToCurve(scalars) {
            if (!Array.isArray(scalars))
                throw new Error('expected array of bigints');
            for (const i of scalars)
                if (typeof i !== 'bigint')
                    throw new Error('expected array of bigints');
            return clear(map(scalars));
        },
        // hash_to_scalar can produce 0: https://www.rfc-editor.org/errata/eid8393
        // RFC 9380, draft-irtf-cfrg-bbs-signatures-08
        hashToScalar(msg, options) {
            // @ts-ignore
            const N = Point.Fn.ORDER;
            const opts = Object.assign({}, defaults, { p: N, m: 1, DST: exports._DST_scalar }, options);
            return hash_to_field(msg, 1, opts)[0][0];
        },
    };
}
//# sourceMappingURL=hash-to-curve.js.map

/***/ }),

/***/ "./node_modules/viem/node_modules/@noble/curves/abstract/modular.js":
/*!**************************************************************************!*\
  !*** ./node_modules/viem/node_modules/@noble/curves/abstract/modular.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isNegativeLE = void 0;
exports.mod = mod;
exports.pow = pow;
exports.pow2 = pow2;
exports.invert = invert;
exports.tonelliShanks = tonelliShanks;
exports.FpSqrt = FpSqrt;
exports.validateField = validateField;
exports.FpPow = FpPow;
exports.FpInvertBatch = FpInvertBatch;
exports.FpDiv = FpDiv;
exports.FpLegendre = FpLegendre;
exports.FpIsSquare = FpIsSquare;
exports.nLength = nLength;
exports.Field = Field;
exports.FpSqrtOdd = FpSqrtOdd;
exports.FpSqrtEven = FpSqrtEven;
exports.hashToPrivateScalar = hashToPrivateScalar;
exports.getFieldBytesLength = getFieldBytesLength;
exports.getMinHashLength = getMinHashLength;
exports.mapHashToField = mapHashToField;
/**
 * Utils for modular division and fields.
 * Field over 11 is a finite (Galois) field is integer number operations `mod 11`.
 * There is no division: it is replaced by modular multiplicative inverse.
 * @module
 */
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const utils_ts_1 = __webpack_require__(/*! ../utils.js */ "./node_modules/viem/node_modules/@noble/curves/utils.js");
// prettier-ignore
const _0n = BigInt(0), _1n = BigInt(1), _2n = /* @__PURE__ */ BigInt(2), _3n = /* @__PURE__ */ BigInt(3);
// prettier-ignore
const _4n = /* @__PURE__ */ BigInt(4), _5n = /* @__PURE__ */ BigInt(5), _7n = /* @__PURE__ */ BigInt(7);
// prettier-ignore
const _8n = /* @__PURE__ */ BigInt(8), _9n = /* @__PURE__ */ BigInt(9), _16n = /* @__PURE__ */ BigInt(16);
// Calculates a modulo b
function mod(a, b) {
    const result = a % b;
    return result >= _0n ? result : b + result;
}
/**
 * Efficiently raise num to power and do modular division.
 * Unsafe in some contexts: uses ladder, so can expose bigint bits.
 * @example
 * pow(2n, 6n, 11n) // 64n % 11n == 9n
 */
function pow(num, power, modulo) {
    return FpPow(Field(modulo), num, power);
}
/** Does `x^(2^power)` mod p. `pow2(30, 4)` == `30^(2^4)` */
function pow2(x, power, modulo) {
    let res = x;
    while (power-- > _0n) {
        res *= res;
        res %= modulo;
    }
    return res;
}
/**
 * Inverses number over modulo.
 * Implemented using [Euclidean GCD](https://brilliant.org/wiki/extended-euclidean-algorithm/).
 */
function invert(number, modulo) {
    if (number === _0n)
        throw new Error('invert: expected non-zero number');
    if (modulo <= _0n)
        throw new Error('invert: expected positive modulus, got ' + modulo);
    // Fermat's little theorem "CT-like" version inv(n) = n^(m-2) mod m is 30x slower.
    let a = mod(number, modulo);
    let b = modulo;
    // prettier-ignore
    let x = _0n, y = _1n, u = _1n, v = _0n;
    while (a !== _0n) {
        // JIT applies optimization if those two lines follow each other
        const q = b / a;
        const r = b % a;
        const m = x - u * q;
        const n = y - v * q;
        // prettier-ignore
        b = a, a = r, x = u, y = v, u = m, v = n;
    }
    const gcd = b;
    if (gcd !== _1n)
        throw new Error('invert: does not exist');
    return mod(x, modulo);
}
function assertIsSquare(Fp, root, n) {
    if (!Fp.eql(Fp.sqr(root), n))
        throw new Error('Cannot find square root');
}
// Not all roots are possible! Example which will throw:
// const NUM =
// n = 72057594037927816n;
// Fp = Field(BigInt('0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab'));
function sqrt3mod4(Fp, n) {
    const p1div4 = (Fp.ORDER + _1n) / _4n;
    const root = Fp.pow(n, p1div4);
    assertIsSquare(Fp, root, n);
    return root;
}
function sqrt5mod8(Fp, n) {
    const p5div8 = (Fp.ORDER - _5n) / _8n;
    const n2 = Fp.mul(n, _2n);
    const v = Fp.pow(n2, p5div8);
    const nv = Fp.mul(n, v);
    const i = Fp.mul(Fp.mul(nv, _2n), v);
    const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));
    assertIsSquare(Fp, root, n);
    return root;
}
// Based on RFC9380, Kong algorithm
// prettier-ignore
function sqrt9mod16(P) {
    const Fp_ = Field(P);
    const tn = tonelliShanks(P);
    const c1 = tn(Fp_, Fp_.neg(Fp_.ONE)); //  1. c1 = sqrt(-1) in F, i.e., (c1^2) == -1 in F
    const c2 = tn(Fp_, c1); //  2. c2 = sqrt(c1) in F, i.e., (c2^2) == c1 in F
    const c3 = tn(Fp_, Fp_.neg(c1)); //  3. c3 = sqrt(-c1) in F, i.e., (c3^2) == -c1 in F
    const c4 = (P + _7n) / _16n; //  4. c4 = (q + 7) / 16        # Integer arithmetic
    return (Fp, n) => {
        let tv1 = Fp.pow(n, c4); //  1. tv1 = x^c4
        let tv2 = Fp.mul(tv1, c1); //  2. tv2 = c1 * tv1
        const tv3 = Fp.mul(tv1, c2); //  3. tv3 = c2 * tv1
        const tv4 = Fp.mul(tv1, c3); //  4. tv4 = c3 * tv1
        const e1 = Fp.eql(Fp.sqr(tv2), n); //  5.  e1 = (tv2^2) == x
        const e2 = Fp.eql(Fp.sqr(tv3), n); //  6.  e2 = (tv3^2) == x
        tv1 = Fp.cmov(tv1, tv2, e1); //  7. tv1 = CMOV(tv1, tv2, e1)  # Select tv2 if (tv2^2) == x
        tv2 = Fp.cmov(tv4, tv3, e2); //  8. tv2 = CMOV(tv4, tv3, e2)  # Select tv3 if (tv3^2) == x
        const e3 = Fp.eql(Fp.sqr(tv2), n); //  9.  e3 = (tv2^2) == x
        const root = Fp.cmov(tv1, tv2, e3); // 10.  z = CMOV(tv1, tv2, e3)   # Select sqrt from tv1 & tv2
        assertIsSquare(Fp, root, n);
        return root;
    };
}
/**
 * Tonelli-Shanks square root search algorithm.
 * 1. https://eprint.iacr.org/2012/685.pdf (page 12)
 * 2. Square Roots from 1; 24, 51, 10 to Dan Shanks
 * @param P field order
 * @returns function that takes field Fp (created from P) and number n
 */
function tonelliShanks(P) {
    // Initialization (precomputation).
    // Caching initialization could boost perf by 7%.
    if (P < _3n)
        throw new Error('sqrt is not defined for small field');
    // Factor P - 1 = Q * 2^S, where Q is odd
    let Q = P - _1n;
    let S = 0;
    while (Q % _2n === _0n) {
        Q /= _2n;
        S++;
    }
    // Find the first quadratic non-residue Z >= 2
    let Z = _2n;
    const _Fp = Field(P);
    while (FpLegendre(_Fp, Z) === 1) {
        // Basic primality test for P. After x iterations, chance of
        // not finding quadratic non-residue is 2^x, so 2^1000.
        if (Z++ > 1000)
            throw new Error('Cannot find square root: probably non-prime P');
    }
    // Fast-path; usually done before Z, but we do "primality test".
    if (S === 1)
        return sqrt3mod4;
    // Slow-path
    // TODO: test on Fp2 and others
    let cc = _Fp.pow(Z, Q); // c = z^Q
    const Q1div2 = (Q + _1n) / _2n;
    return function tonelliSlow(Fp, n) {
        if (Fp.is0(n))
            return n;
        // Check if n is a quadratic residue using Legendre symbol
        if (FpLegendre(Fp, n) !== 1)
            throw new Error('Cannot find square root');
        // Initialize variables for the main loop
        let M = S;
        let c = Fp.mul(Fp.ONE, cc); // c = z^Q, move cc from field _Fp into field Fp
        let t = Fp.pow(n, Q); // t = n^Q, first guess at the fudge factor
        let R = Fp.pow(n, Q1div2); // R = n^((Q+1)/2), first guess at the square root
        // Main loop
        // while t != 1
        while (!Fp.eql(t, Fp.ONE)) {
            if (Fp.is0(t))
                return Fp.ZERO; // if t=0 return R=0
            let i = 1;
            // Find the smallest i >= 1 such that t^(2^i) ≡ 1 (mod P)
            let t_tmp = Fp.sqr(t); // t^(2^1)
            while (!Fp.eql(t_tmp, Fp.ONE)) {
                i++;
                t_tmp = Fp.sqr(t_tmp); // t^(2^2)...
                if (i === M)
                    throw new Error('Cannot find square root');
            }
            // Calculate the exponent for b: 2^(M - i - 1)
            const exponent = _1n << BigInt(M - i - 1); // bigint is important
            const b = Fp.pow(c, exponent); // b = 2^(M - i - 1)
            // Update variables
            M = i;
            c = Fp.sqr(b); // c = b^2
            t = Fp.mul(t, c); // t = (t * b^2)
            R = Fp.mul(R, b); // R = R*b
        }
        return R;
    };
}
/**
 * Square root for a finite field. Will try optimized versions first:
 *
 * 1. P ≡ 3 (mod 4)
 * 2. P ≡ 5 (mod 8)
 * 3. P ≡ 9 (mod 16)
 * 4. Tonelli-Shanks algorithm
 *
 * Different algorithms can give different roots, it is up to user to decide which one they want.
 * For example there is FpSqrtOdd/FpSqrtEven to choice root based on oddness (used for hash-to-curve).
 */
function FpSqrt(P) {
    // P ≡ 3 (mod 4) => √n = n^((P+1)/4)
    if (P % _4n === _3n)
        return sqrt3mod4;
    // P ≡ 5 (mod 8) => Atkin algorithm, page 10 of https://eprint.iacr.org/2012/685.pdf
    if (P % _8n === _5n)
        return sqrt5mod8;
    // P ≡ 9 (mod 16) => Kong algorithm, page 11 of https://eprint.iacr.org/2012/685.pdf (algorithm 4)
    if (P % _16n === _9n)
        return sqrt9mod16(P);
    // Tonelli-Shanks algorithm
    return tonelliShanks(P);
}
// Little-endian check for first LE bit (last BE bit);
const isNegativeLE = (num, modulo) => (mod(num, modulo) & _1n) === _1n;
exports.isNegativeLE = isNegativeLE;
// prettier-ignore
const FIELD_FIELDS = [
    'create', 'isValid', 'is0', 'neg', 'inv', 'sqrt', 'sqr',
    'eql', 'add', 'sub', 'mul', 'pow', 'div',
    'addN', 'subN', 'mulN', 'sqrN'
];
function validateField(field) {
    const initial = {
        ORDER: 'bigint',
        MASK: 'bigint',
        BYTES: 'number',
        BITS: 'number',
    };
    const opts = FIELD_FIELDS.reduce((map, val) => {
        map[val] = 'function';
        return map;
    }, initial);
    (0, utils_ts_1._validateObject)(field, opts);
    // const max = 16384;
    // if (field.BYTES < 1 || field.BYTES > max) throw new Error('invalid field');
    // if (field.BITS < 1 || field.BITS > 8 * max) throw new Error('invalid field');
    return field;
}
// Generic field functions
/**
 * Same as `pow` but for Fp: non-constant-time.
 * Unsafe in some contexts: uses ladder, so can expose bigint bits.
 */
function FpPow(Fp, num, power) {
    if (power < _0n)
        throw new Error('invalid exponent, negatives unsupported');
    if (power === _0n)
        return Fp.ONE;
    if (power === _1n)
        return num;
    let p = Fp.ONE;
    let d = num;
    while (power > _0n) {
        if (power & _1n)
            p = Fp.mul(p, d);
        d = Fp.sqr(d);
        power >>= _1n;
    }
    return p;
}
/**
 * Efficiently invert an array of Field elements.
 * Exception-free. Will return `undefined` for 0 elements.
 * @param passZero map 0 to 0 (instead of undefined)
 */
function FpInvertBatch(Fp, nums, passZero = false) {
    const inverted = new Array(nums.length).fill(passZero ? Fp.ZERO : undefined);
    // Walk from first to last, multiply them by each other MOD p
    const multipliedAcc = nums.reduce((acc, num, i) => {
        if (Fp.is0(num))
            return acc;
        inverted[i] = acc;
        return Fp.mul(acc, num);
    }, Fp.ONE);
    // Invert last element
    const invertedAcc = Fp.inv(multipliedAcc);
    // Walk from last to first, multiply them by inverted each other MOD p
    nums.reduceRight((acc, num, i) => {
        if (Fp.is0(num))
            return acc;
        inverted[i] = Fp.mul(acc, inverted[i]);
        return Fp.mul(acc, num);
    }, invertedAcc);
    return inverted;
}
// TODO: remove
function FpDiv(Fp, lhs, rhs) {
    return Fp.mul(lhs, typeof rhs === 'bigint' ? invert(rhs, Fp.ORDER) : Fp.inv(rhs));
}
/**
 * Legendre symbol.
 * Legendre constant is used to calculate Legendre symbol (a | p)
 * which denotes the value of a^((p-1)/2) (mod p).
 *
 * * (a | p) ≡ 1    if a is a square (mod p), quadratic residue
 * * (a | p) ≡ -1   if a is not a square (mod p), quadratic non residue
 * * (a | p) ≡ 0    if a ≡ 0 (mod p)
 */
function FpLegendre(Fp, n) {
    // We can use 3rd argument as optional cache of this value
    // but seems unneeded for now. The operation is very fast.
    const p1mod2 = (Fp.ORDER - _1n) / _2n;
    const powered = Fp.pow(n, p1mod2);
    const yes = Fp.eql(powered, Fp.ONE);
    const zero = Fp.eql(powered, Fp.ZERO);
    const no = Fp.eql(powered, Fp.neg(Fp.ONE));
    if (!yes && !zero && !no)
        throw new Error('invalid Legendre symbol result');
    return yes ? 1 : zero ? 0 : -1;
}
// This function returns True whenever the value x is a square in the field F.
function FpIsSquare(Fp, n) {
    const l = FpLegendre(Fp, n);
    return l === 1;
}
// CURVE.n lengths
function nLength(n, nBitLength) {
    // Bit size, byte size of CURVE.n
    if (nBitLength !== undefined)
        (0, utils_ts_1.anumber)(nBitLength);
    const _nBitLength = nBitLength !== undefined ? nBitLength : n.toString(2).length;
    const nByteLength = Math.ceil(_nBitLength / 8);
    return { nBitLength: _nBitLength, nByteLength };
}
/**
 * Creates a finite field. Major performance optimizations:
 * * 1. Denormalized operations like mulN instead of mul.
 * * 2. Identical object shape: never add or remove keys.
 * * 3. `Object.freeze`.
 * Fragile: always run a benchmark on a change.
 * Security note: operations don't check 'isValid' for all elements for performance reasons,
 * it is caller responsibility to check this.
 * This is low-level code, please make sure you know what you're doing.
 *
 * Note about field properties:
 * * CHARACTERISTIC p = prime number, number of elements in main subgroup.
 * * ORDER q = similar to cofactor in curves, may be composite `q = p^m`.
 *
 * @param ORDER field order, probably prime, or could be composite
 * @param bitLen how many bits the field consumes
 * @param isLE (default: false) if encoding / decoding should be in little-endian
 * @param redef optional faster redefinitions of sqrt and other methods
 */
function Field(ORDER, bitLenOrOpts, // TODO: use opts only in v2?
isLE = false, opts = {}) {
    if (ORDER <= _0n)
        throw new Error('invalid field: expected ORDER > 0, got ' + ORDER);
    let _nbitLength = undefined;
    let _sqrt = undefined;
    let modFromBytes = false;
    let allowedLengths = undefined;
    if (typeof bitLenOrOpts === 'object' && bitLenOrOpts != null) {
        if (opts.sqrt || isLE)
            throw new Error('cannot specify opts in two arguments');
        const _opts = bitLenOrOpts;
        if (_opts.BITS)
            _nbitLength = _opts.BITS;
        if (_opts.sqrt)
            _sqrt = _opts.sqrt;
        if (typeof _opts.isLE === 'boolean')
            isLE = _opts.isLE;
        if (typeof _opts.modFromBytes === 'boolean')
            modFromBytes = _opts.modFromBytes;
        allowedLengths = _opts.allowedLengths;
    }
    else {
        if (typeof bitLenOrOpts === 'number')
            _nbitLength = bitLenOrOpts;
        if (opts.sqrt)
            _sqrt = opts.sqrt;
    }
    const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, _nbitLength);
    if (BYTES > 2048)
        throw new Error('invalid field: expected ORDER of <= 2048 bytes');
    let sqrtP; // cached sqrtP
    const f = Object.freeze({
        ORDER,
        isLE,
        BITS,
        BYTES,
        MASK: (0, utils_ts_1.bitMask)(BITS),
        ZERO: _0n,
        ONE: _1n,
        allowedLengths: allowedLengths,
        create: (num) => mod(num, ORDER),
        isValid: (num) => {
            if (typeof num !== 'bigint')
                throw new Error('invalid field element: expected bigint, got ' + typeof num);
            return _0n <= num && num < ORDER; // 0 is valid element, but it's not invertible
        },
        is0: (num) => num === _0n,
        // is valid and invertible
        isValidNot0: (num) => !f.is0(num) && f.isValid(num),
        isOdd: (num) => (num & _1n) === _1n,
        neg: (num) => mod(-num, ORDER),
        eql: (lhs, rhs) => lhs === rhs,
        sqr: (num) => mod(num * num, ORDER),
        add: (lhs, rhs) => mod(lhs + rhs, ORDER),
        sub: (lhs, rhs) => mod(lhs - rhs, ORDER),
        mul: (lhs, rhs) => mod(lhs * rhs, ORDER),
        pow: (num, power) => FpPow(f, num, power),
        div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),
        // Same as above, but doesn't normalize
        sqrN: (num) => num * num,
        addN: (lhs, rhs) => lhs + rhs,
        subN: (lhs, rhs) => lhs - rhs,
        mulN: (lhs, rhs) => lhs * rhs,
        inv: (num) => invert(num, ORDER),
        sqrt: _sqrt ||
            ((n) => {
                if (!sqrtP)
                    sqrtP = FpSqrt(ORDER);
                return sqrtP(f, n);
            }),
        toBytes: (num) => (isLE ? (0, utils_ts_1.numberToBytesLE)(num, BYTES) : (0, utils_ts_1.numberToBytesBE)(num, BYTES)),
        fromBytes: (bytes, skipValidation = true) => {
            if (allowedLengths) {
                if (!allowedLengths.includes(bytes.length) || bytes.length > BYTES) {
                    throw new Error('Field.fromBytes: expected ' + allowedLengths + ' bytes, got ' + bytes.length);
                }
                const padded = new Uint8Array(BYTES);
                // isLE add 0 to right, !isLE to the left.
                padded.set(bytes, isLE ? 0 : padded.length - bytes.length);
                bytes = padded;
            }
            if (bytes.length !== BYTES)
                throw new Error('Field.fromBytes: expected ' + BYTES + ' bytes, got ' + bytes.length);
            let scalar = isLE ? (0, utils_ts_1.bytesToNumberLE)(bytes) : (0, utils_ts_1.bytesToNumberBE)(bytes);
            if (modFromBytes)
                scalar = mod(scalar, ORDER);
            if (!skipValidation)
                if (!f.isValid(scalar))
                    throw new Error('invalid field element: outside of range 0..ORDER');
            // NOTE: we don't validate scalar here, please use isValid. This done such way because some
            // protocol may allow non-reduced scalar that reduced later or changed some other way.
            return scalar;
        },
        // TODO: we don't need it here, move out to separate fn
        invertBatch: (lst) => FpInvertBatch(f, lst),
        // We can't move this out because Fp6, Fp12 implement it
        // and it's unclear what to return in there.
        cmov: (a, b, c) => (c ? b : a),
    });
    return Object.freeze(f);
}
// Generic random scalar, we can do same for other fields if via Fp2.mul(Fp2.ONE, Fp2.random)?
// This allows unsafe methods like ignore bias or zero. These unsafe, but often used in different protocols (if deterministic RNG).
// which mean we cannot force this via opts.
// Not sure what to do with randomBytes, we can accept it inside opts if wanted.
// Probably need to export getMinHashLength somewhere?
// random(bytes?: Uint8Array, unsafeAllowZero = false, unsafeAllowBias = false) {
//   const LEN = !unsafeAllowBias ? getMinHashLength(ORDER) : BYTES;
//   if (bytes === undefined) bytes = randomBytes(LEN); // _opts.randomBytes?
//   const num = isLE ? bytesToNumberLE(bytes) : bytesToNumberBE(bytes);
//   // `mod(x, 11)` can sometimes produce 0. `mod(x, 10) + 1` is the same, but no 0
//   const reduced = unsafeAllowZero ? mod(num, ORDER) : mod(num, ORDER - _1n) + _1n;
//   return reduced;
// },
function FpSqrtOdd(Fp, elm) {
    if (!Fp.isOdd)
        throw new Error("Field doesn't have isOdd");
    const root = Fp.sqrt(elm);
    return Fp.isOdd(root) ? root : Fp.neg(root);
}
function FpSqrtEven(Fp, elm) {
    if (!Fp.isOdd)
        throw new Error("Field doesn't have isOdd");
    const root = Fp.sqrt(elm);
    return Fp.isOdd(root) ? Fp.neg(root) : root;
}
/**
 * "Constant-time" private key generation utility.
 * Same as mapKeyToField, but accepts less bytes (40 instead of 48 for 32-byte field).
 * Which makes it slightly more biased, less secure.
 * @deprecated use `mapKeyToField` instead
 */
function hashToPrivateScalar(hash, groupOrder, isLE = false) {
    hash = (0, utils_ts_1.ensureBytes)('privateHash', hash);
    const hashLen = hash.length;
    const minLen = nLength(groupOrder).nByteLength + 8;
    if (minLen < 24 || hashLen < minLen || hashLen > 1024)
        throw new Error('hashToPrivateScalar: expected ' + minLen + '-1024 bytes of input, got ' + hashLen);
    const num = isLE ? (0, utils_ts_1.bytesToNumberLE)(hash) : (0, utils_ts_1.bytesToNumberBE)(hash);
    return mod(num, groupOrder - _1n) + _1n;
}
/**
 * Returns total number of bytes consumed by the field element.
 * For example, 32 bytes for usual 256-bit weierstrass curve.
 * @param fieldOrder number of field elements, usually CURVE.n
 * @returns byte length of field
 */
function getFieldBytesLength(fieldOrder) {
    if (typeof fieldOrder !== 'bigint')
        throw new Error('field order must be bigint');
    const bitLength = fieldOrder.toString(2).length;
    return Math.ceil(bitLength / 8);
}
/**
 * Returns minimal amount of bytes that can be safely reduced
 * by field order.
 * Should be 2^-128 for 128-bit curve such as P256.
 * @param fieldOrder number of field elements, usually CURVE.n
 * @returns byte length of target hash
 */
function getMinHashLength(fieldOrder) {
    const length = getFieldBytesLength(fieldOrder);
    return length + Math.ceil(length / 2);
}
/**
 * "Constant-time" private key generation utility.
 * Can take (n + n/2) or more bytes of uniform input e.g. from CSPRNG or KDF
 * and convert them into private scalar, with the modulo bias being negligible.
 * Needs at least 48 bytes of input for 32-byte private key.
 * https://research.kudelskisecurity.com/2020/07/28/the-definitive-guide-to-modulo-bias-and-how-to-avoid-it/
 * FIPS 186-5, A.2 https://csrc.nist.gov/publications/detail/fips/186/5/final
 * RFC 9380, https://www.rfc-editor.org/rfc/rfc9380#section-5
 * @param hash hash output from SHA3 or a similar function
 * @param groupOrder size of subgroup - (e.g. secp256k1.CURVE.n)
 * @param isLE interpret hash bytes as LE num
 * @returns valid private scalar
 */
function mapHashToField(key, fieldOrder, isLE = false) {
    const len = key.length;
    const fieldLen = getFieldBytesLength(fieldOrder);
    const minLen = getMinHashLength(fieldOrder);
    // No small numbers: need to understand bias story. No huge numbers: easier to detect JS timings.
    if (len < 16 || len < minLen || len > 1024)
        throw new Error('expected ' + minLen + '-1024 bytes of input, got ' + len);
    const num = isLE ? (0, utils_ts_1.bytesToNumberLE)(key) : (0, utils_ts_1.bytesToNumberBE)(key);
    // `mod(x, 11)` can sometimes produce 0. `mod(x, 10) + 1` is the same, but no 0
    const reduced = mod(num, fieldOrder - _1n) + _1n;
    return isLE ? (0, utils_ts_1.numberToBytesLE)(reduced, fieldLen) : (0, utils_ts_1.numberToBytesBE)(reduced, fieldLen);
}
//# sourceMappingURL=modular.js.map

/***/ }),

/***/ "./node_modules/viem/node_modules/@noble/curves/abstract/weierstrass.js":
/*!******************************************************************************!*\
  !*** ./node_modules/viem/node_modules/@noble/curves/abstract/weierstrass.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DER = exports.DERErr = void 0;
exports._splitEndoScalar = _splitEndoScalar;
exports._normFnElement = _normFnElement;
exports.weierstrassN = weierstrassN;
exports.SWUFpSqrtRatio = SWUFpSqrtRatio;
exports.mapToCurveSimpleSWU = mapToCurveSimpleSWU;
exports.ecdh = ecdh;
exports.ecdsa = ecdsa;
exports.weierstrassPoints = weierstrassPoints;
exports._legacyHelperEquat = _legacyHelperEquat;
exports.weierstrass = weierstrass;
/**
 * Short Weierstrass curve methods. The formula is: y² = x³ + ax + b.
 *
 * ### Design rationale for types
 *
 * * Interaction between classes from different curves should fail:
 *   `k256.Point.BASE.add(p256.Point.BASE)`
 * * For this purpose we want to use `instanceof` operator, which is fast and works during runtime
 * * Different calls of `curve()` would return different classes -
 *   `curve(params) !== curve(params)`: if somebody decided to monkey-patch their curve,
 *   it won't affect others
 *
 * TypeScript can't infer types for classes created inside a function. Classes is one instance
 * of nominative types in TypeScript and interfaces only check for shape, so it's hard to create
 * unique type for every function call.
 *
 * We can use generic types via some param, like curve opts, but that would:
 *     1. Enable interaction between `curve(params)` and `curve(params)` (curves of same params)
 *     which is hard to debug.
 *     2. Params can be generic and we can't enforce them to be constant value:
 *     if somebody creates curve from non-constant params,
 *     it would be allowed to interact with other curves with non-constant params
 *
 * @todo https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-7.html#unique-symbol
 * @module
 */
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const hmac_js_1 = __webpack_require__(/*! @noble/hashes/hmac.js */ "./node_modules/@noble/hashes/hmac.js");
const utils_1 = __webpack_require__(/*! @noble/hashes/utils */ "./node_modules/@noble/hashes/utils.js");
const utils_ts_1 = __webpack_require__(/*! ../utils.js */ "./node_modules/viem/node_modules/@noble/curves/utils.js");
const curve_ts_1 = __webpack_require__(/*! ./curve.js */ "./node_modules/viem/node_modules/@noble/curves/abstract/curve.js");
const modular_ts_1 = __webpack_require__(/*! ./modular.js */ "./node_modules/viem/node_modules/@noble/curves/abstract/modular.js");
// We construct basis in such way that den is always positive and equals n, but num sign depends on basis (not on secret value)
const divNearest = (num, den) => (num + (num >= 0 ? den : -den) / _2n) / den;
/**
 * Splits scalar for GLV endomorphism.
 */
function _splitEndoScalar(k, basis, n) {
    // Split scalar into two such that part is ~half bits: `abs(part) < sqrt(N)`
    // Since part can be negative, we need to do this on point.
    // TODO: verifyScalar function which consumes lambda
    const [[a1, b1], [a2, b2]] = basis;
    const c1 = divNearest(b2 * k, n);
    const c2 = divNearest(-b1 * k, n);
    // |k1|/|k2| is < sqrt(N), but can be negative.
    // If we do `k1 mod N`, we'll get big scalar (`> sqrt(N)`): so, we do cheaper negation instead.
    let k1 = k - c1 * a1 - c2 * a2;
    let k2 = -c1 * b1 - c2 * b2;
    const k1neg = k1 < _0n;
    const k2neg = k2 < _0n;
    if (k1neg)
        k1 = -k1;
    if (k2neg)
        k2 = -k2;
    // Double check that resulting scalar less than half bits of N: otherwise wNAF will fail.
    // This should only happen on wrong basises. Also, math inside is too complex and I don't trust it.
    const MAX_NUM = (0, utils_ts_1.bitMask)(Math.ceil((0, utils_ts_1.bitLen)(n) / 2)) + _1n; // Half bits of N
    if (k1 < _0n || k1 >= MAX_NUM || k2 < _0n || k2 >= MAX_NUM) {
        throw new Error('splitScalar (endomorphism): failed, k=' + k);
    }
    return { k1neg, k1, k2neg, k2 };
}
function validateSigFormat(format) {
    if (!['compact', 'recovered', 'der'].includes(format))
        throw new Error('Signature format must be "compact", "recovered", or "der"');
    return format;
}
function validateSigOpts(opts, def) {
    const optsn = {};
    for (let optName of Object.keys(def)) {
        // @ts-ignore
        optsn[optName] = opts[optName] === undefined ? def[optName] : opts[optName];
    }
    (0, utils_ts_1._abool2)(optsn.lowS, 'lowS');
    (0, utils_ts_1._abool2)(optsn.prehash, 'prehash');
    if (optsn.format !== undefined)
        validateSigFormat(optsn.format);
    return optsn;
}
class DERErr extends Error {
    constructor(m = '') {
        super(m);
    }
}
exports.DERErr = DERErr;
/**
 * ASN.1 DER encoding utilities. ASN is very complex & fragile. Format:
 *
 *     [0x30 (SEQUENCE), bytelength, 0x02 (INTEGER), intLength, R, 0x02 (INTEGER), intLength, S]
 *
 * Docs: https://letsencrypt.org/docs/a-warm-welcome-to-asn1-and-der/, https://luca.ntop.org/Teaching/Appunti/asn1.html
 */
exports.DER = {
    // asn.1 DER encoding utils
    Err: DERErr,
    // Basic building block is TLV (Tag-Length-Value)
    _tlv: {
        encode: (tag, data) => {
            const { Err: E } = exports.DER;
            if (tag < 0 || tag > 256)
                throw new E('tlv.encode: wrong tag');
            if (data.length & 1)
                throw new E('tlv.encode: unpadded data');
            const dataLen = data.length / 2;
            const len = (0, utils_ts_1.numberToHexUnpadded)(dataLen);
            if ((len.length / 2) & 128)
                throw new E('tlv.encode: long form length too big');
            // length of length with long form flag
            const lenLen = dataLen > 127 ? (0, utils_ts_1.numberToHexUnpadded)((len.length / 2) | 128) : '';
            const t = (0, utils_ts_1.numberToHexUnpadded)(tag);
            return t + lenLen + len + data;
        },
        // v - value, l - left bytes (unparsed)
        decode(tag, data) {
            const { Err: E } = exports.DER;
            let pos = 0;
            if (tag < 0 || tag > 256)
                throw new E('tlv.encode: wrong tag');
            if (data.length < 2 || data[pos++] !== tag)
                throw new E('tlv.decode: wrong tlv');
            const first = data[pos++];
            const isLong = !!(first & 128); // First bit of first length byte is flag for short/long form
            let length = 0;
            if (!isLong)
                length = first;
            else {
                // Long form: [longFlag(1bit), lengthLength(7bit), length (BE)]
                const lenLen = first & 127;
                if (!lenLen)
                    throw new E('tlv.decode(long): indefinite length not supported');
                if (lenLen > 4)
                    throw new E('tlv.decode(long): byte length is too big'); // this will overflow u32 in js
                const lengthBytes = data.subarray(pos, pos + lenLen);
                if (lengthBytes.length !== lenLen)
                    throw new E('tlv.decode: length bytes not complete');
                if (lengthBytes[0] === 0)
                    throw new E('tlv.decode(long): zero leftmost byte');
                for (const b of lengthBytes)
                    length = (length << 8) | b;
                pos += lenLen;
                if (length < 128)
                    throw new E('tlv.decode(long): not minimal encoding');
            }
            const v = data.subarray(pos, pos + length);
            if (v.length !== length)
                throw new E('tlv.decode: wrong value length');
            return { v, l: data.subarray(pos + length) };
        },
    },
    // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,
    // since we always use positive integers here. It must always be empty:
    // - add zero byte if exists
    // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)
    _int: {
        encode(num) {
            const { Err: E } = exports.DER;
            if (num < _0n)
                throw new E('integer: negative integers are not allowed');
            let hex = (0, utils_ts_1.numberToHexUnpadded)(num);
            // Pad with zero byte if negative flag is present
            if (Number.parseInt(hex[0], 16) & 0b1000)
                hex = '00' + hex;
            if (hex.length & 1)
                throw new E('unexpected DER parsing assertion: unpadded hex');
            return hex;
        },
        decode(data) {
            const { Err: E } = exports.DER;
            if (data[0] & 128)
                throw new E('invalid signature integer: negative');
            if (data[0] === 0x00 && !(data[1] & 128))
                throw new E('invalid signature integer: unnecessary leading zero');
            return (0, utils_ts_1.bytesToNumberBE)(data);
        },
    },
    toSig(hex) {
        // parse DER signature
        const { Err: E, _int: int, _tlv: tlv } = exports.DER;
        const data = (0, utils_ts_1.ensureBytes)('signature', hex);
        const { v: seqBytes, l: seqLeftBytes } = tlv.decode(0x30, data);
        if (seqLeftBytes.length)
            throw new E('invalid signature: left bytes after parsing');
        const { v: rBytes, l: rLeftBytes } = tlv.decode(0x02, seqBytes);
        const { v: sBytes, l: sLeftBytes } = tlv.decode(0x02, rLeftBytes);
        if (sLeftBytes.length)
            throw new E('invalid signature: left bytes after parsing');
        return { r: int.decode(rBytes), s: int.decode(sBytes) };
    },
    hexFromSig(sig) {
        const { _tlv: tlv, _int: int } = exports.DER;
        const rs = tlv.encode(0x02, int.encode(sig.r));
        const ss = tlv.encode(0x02, int.encode(sig.s));
        const seq = rs + ss;
        return tlv.encode(0x30, seq);
    },
};
// Be friendly to bad ECMAScript parsers by not using bigint literals
// prettier-ignore
const _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3), _4n = BigInt(4);
function _normFnElement(Fn, key) {
    const { BYTES: expected } = Fn;
    let num;
    if (typeof key === 'bigint') {
        num = key;
    }
    else {
        let bytes = (0, utils_ts_1.ensureBytes)('private key', key);
        try {
            num = Fn.fromBytes(bytes);
        }
        catch (error) {
            throw new Error(`invalid private key: expected ui8a of size ${expected}, got ${typeof key}`);
        }
    }
    if (!Fn.isValidNot0(num))
        throw new Error('invalid private key: out of range [1..N-1]');
    return num;
}
/**
 * Creates weierstrass Point constructor, based on specified curve options.
 *
 * @example
```js
const opts = {
  p: BigInt('0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff'),
  n: BigInt('0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551'),
  h: BigInt(1),
  a: BigInt('0xffffffff00000001000000000000000000000000fffffffffffffffffffffffc'),
  b: BigInt('0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b'),
  Gx: BigInt('0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296'),
  Gy: BigInt('0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5'),
};
const p256_Point = weierstrass(opts);
```
 */
function weierstrassN(params, extraOpts = {}) {
    const validated = (0, curve_ts_1._createCurveFields)('weierstrass', params, extraOpts);
    const { Fp, Fn } = validated;
    let CURVE = validated.CURVE;
    const { h: cofactor, n: CURVE_ORDER } = CURVE;
    (0, utils_ts_1._validateObject)(extraOpts, {}, {
        allowInfinityPoint: 'boolean',
        clearCofactor: 'function',
        isTorsionFree: 'function',
        fromBytes: 'function',
        toBytes: 'function',
        endo: 'object',
        wrapPrivateKey: 'boolean',
    });
    const { endo } = extraOpts;
    if (endo) {
        // validateObject(endo, { beta: 'bigint', splitScalar: 'function' });
        if (!Fp.is0(CURVE.a) || typeof endo.beta !== 'bigint' || !Array.isArray(endo.basises)) {
            throw new Error('invalid endo: expected "beta": bigint and "basises": array');
        }
    }
    const lengths = getWLengths(Fp, Fn);
    function assertCompressionIsSupported() {
        if (!Fp.isOdd)
            throw new Error('compression is not supported: Field does not have .isOdd()');
    }
    // Implements IEEE P1363 point encoding
    function pointToBytes(_c, point, isCompressed) {
        const { x, y } = point.toAffine();
        const bx = Fp.toBytes(x);
        (0, utils_ts_1._abool2)(isCompressed, 'isCompressed');
        if (isCompressed) {
            assertCompressionIsSupported();
            const hasEvenY = !Fp.isOdd(y);
            return (0, utils_ts_1.concatBytes)(pprefix(hasEvenY), bx);
        }
        else {
            return (0, utils_ts_1.concatBytes)(Uint8Array.of(0x04), bx, Fp.toBytes(y));
        }
    }
    function pointFromBytes(bytes) {
        (0, utils_ts_1._abytes2)(bytes, undefined, 'Point');
        const { publicKey: comp, publicKeyUncompressed: uncomp } = lengths; // e.g. for 32-byte: 33, 65
        const length = bytes.length;
        const head = bytes[0];
        const tail = bytes.subarray(1);
        // No actual validation is done here: use .assertValidity()
        if (length === comp && (head === 0x02 || head === 0x03)) {
            const x = Fp.fromBytes(tail);
            if (!Fp.isValid(x))
                throw new Error('bad point: is not on curve, wrong x');
            const y2 = weierstrassEquation(x); // y² = x³ + ax + b
            let y;
            try {
                y = Fp.sqrt(y2); // y = y² ^ (p+1)/4
            }
            catch (sqrtError) {
                const err = sqrtError instanceof Error ? ': ' + sqrtError.message : '';
                throw new Error('bad point: is not on curve, sqrt error' + err);
            }
            assertCompressionIsSupported();
            const isYOdd = Fp.isOdd(y); // (y & _1n) === _1n;
            const isHeadOdd = (head & 1) === 1; // ECDSA-specific
            if (isHeadOdd !== isYOdd)
                y = Fp.neg(y);
            return { x, y };
        }
        else if (length === uncomp && head === 0x04) {
            // TODO: more checks
            const L = Fp.BYTES;
            const x = Fp.fromBytes(tail.subarray(0, L));
            const y = Fp.fromBytes(tail.subarray(L, L * 2));
            if (!isValidXY(x, y))
                throw new Error('bad point: is not on curve');
            return { x, y };
        }
        else {
            throw new Error(`bad point: got length ${length}, expected compressed=${comp} or uncompressed=${uncomp}`);
        }
    }
    const encodePoint = extraOpts.toBytes || pointToBytes;
    const decodePoint = extraOpts.fromBytes || pointFromBytes;
    function weierstrassEquation(x) {
        const x2 = Fp.sqr(x); // x * x
        const x3 = Fp.mul(x2, x); // x² * x
        return Fp.add(Fp.add(x3, Fp.mul(x, CURVE.a)), CURVE.b); // x³ + a * x + b
    }
    // TODO: move top-level
    /** Checks whether equation holds for given x, y: y² == x³ + ax + b */
    function isValidXY(x, y) {
        const left = Fp.sqr(y); // y²
        const right = weierstrassEquation(x); // x³ + ax + b
        return Fp.eql(left, right);
    }
    // Validate whether the passed curve params are valid.
    // Test 1: equation y² = x³ + ax + b should work for generator point.
    if (!isValidXY(CURVE.Gx, CURVE.Gy))
        throw new Error('bad curve params: generator point');
    // Test 2: discriminant Δ part should be non-zero: 4a³ + 27b² != 0.
    // Guarantees curve is genus-1, smooth (non-singular).
    const _4a3 = Fp.mul(Fp.pow(CURVE.a, _3n), _4n);
    const _27b2 = Fp.mul(Fp.sqr(CURVE.b), BigInt(27));
    if (Fp.is0(Fp.add(_4a3, _27b2)))
        throw new Error('bad curve params: a or b');
    /** Asserts coordinate is valid: 0 <= n < Fp.ORDER. */
    function acoord(title, n, banZero = false) {
        if (!Fp.isValid(n) || (banZero && Fp.is0(n)))
            throw new Error(`bad point coordinate ${title}`);
        return n;
    }
    function aprjpoint(other) {
        if (!(other instanceof Point))
            throw new Error('ProjectivePoint expected');
    }
    function splitEndoScalarN(k) {
        if (!endo || !endo.basises)
            throw new Error('no endo');
        return _splitEndoScalar(k, endo.basises, Fn.ORDER);
    }
    // Memoized toAffine / validity check. They are heavy. Points are immutable.
    // Converts Projective point to affine (x, y) coordinates.
    // Can accept precomputed Z^-1 - for example, from invertBatch.
    // (X, Y, Z) ∋ (x=X/Z, y=Y/Z)
    const toAffineMemo = (0, utils_ts_1.memoized)((p, iz) => {
        const { X, Y, Z } = p;
        // Fast-path for normalized points
        if (Fp.eql(Z, Fp.ONE))
            return { x: X, y: Y };
        const is0 = p.is0();
        // If invZ was 0, we return zero point. However we still want to execute
        // all operations, so we replace invZ with a random number, 1.
        if (iz == null)
            iz = is0 ? Fp.ONE : Fp.inv(Z);
        const x = Fp.mul(X, iz);
        const y = Fp.mul(Y, iz);
        const zz = Fp.mul(Z, iz);
        if (is0)
            return { x: Fp.ZERO, y: Fp.ZERO };
        if (!Fp.eql(zz, Fp.ONE))
            throw new Error('invZ was invalid');
        return { x, y };
    });
    // NOTE: on exception this will crash 'cached' and no value will be set.
    // Otherwise true will be return
    const assertValidMemo = (0, utils_ts_1.memoized)((p) => {
        if (p.is0()) {
            // (0, 1, 0) aka ZERO is invalid in most contexts.
            // In BLS, ZERO can be serialized, so we allow it.
            // (0, 0, 0) is invalid representation of ZERO.
            if (extraOpts.allowInfinityPoint && !Fp.is0(p.Y))
                return;
            throw new Error('bad point: ZERO');
        }
        // Some 3rd-party test vectors require different wording between here & `fromCompressedHex`
        const { x, y } = p.toAffine();
        if (!Fp.isValid(x) || !Fp.isValid(y))
            throw new Error('bad point: x or y not field elements');
        if (!isValidXY(x, y))
            throw new Error('bad point: equation left != right');
        if (!p.isTorsionFree())
            throw new Error('bad point: not in prime-order subgroup');
        return true;
    });
    function finishEndo(endoBeta, k1p, k2p, k1neg, k2neg) {
        k2p = new Point(Fp.mul(k2p.X, endoBeta), k2p.Y, k2p.Z);
        k1p = (0, curve_ts_1.negateCt)(k1neg, k1p);
        k2p = (0, curve_ts_1.negateCt)(k2neg, k2p);
        return k1p.add(k2p);
    }
    /**
     * Projective Point works in 3d / projective (homogeneous) coordinates:(X, Y, Z) ∋ (x=X/Z, y=Y/Z).
     * Default Point works in 2d / affine coordinates: (x, y).
     * We're doing calculations in projective, because its operations don't require costly inversion.
     */
    class Point {
        /** Does NOT validate if the point is valid. Use `.assertValidity()`. */
        constructor(X, Y, Z) {
            this.X = acoord('x', X);
            this.Y = acoord('y', Y, true);
            this.Z = acoord('z', Z);
            Object.freeze(this);
        }
        static CURVE() {
            return CURVE;
        }
        /** Does NOT validate if the point is valid. Use `.assertValidity()`. */
        static fromAffine(p) {
            const { x, y } = p || {};
            if (!p || !Fp.isValid(x) || !Fp.isValid(y))
                throw new Error('invalid affine point');
            if (p instanceof Point)
                throw new Error('projective point not allowed');
            // (0, 0) would've produced (0, 0, 1) - instead, we need (0, 1, 0)
            if (Fp.is0(x) && Fp.is0(y))
                return Point.ZERO;
            return new Point(x, y, Fp.ONE);
        }
        static fromBytes(bytes) {
            const P = Point.fromAffine(decodePoint((0, utils_ts_1._abytes2)(bytes, undefined, 'point')));
            P.assertValidity();
            return P;
        }
        static fromHex(hex) {
            return Point.fromBytes((0, utils_ts_1.ensureBytes)('pointHex', hex));
        }
        get x() {
            return this.toAffine().x;
        }
        get y() {
            return this.toAffine().y;
        }
        /**
         *
         * @param windowSize
         * @param isLazy true will defer table computation until the first multiplication
         * @returns
         */
        precompute(windowSize = 8, isLazy = true) {
            wnaf.createCache(this, windowSize);
            if (!isLazy)
                this.multiply(_3n); // random number
            return this;
        }
        // TODO: return `this`
        /** A point on curve is valid if it conforms to equation. */
        assertValidity() {
            assertValidMemo(this);
        }
        hasEvenY() {
            const { y } = this.toAffine();
            if (!Fp.isOdd)
                throw new Error("Field doesn't support isOdd");
            return !Fp.isOdd(y);
        }
        /** Compare one point to another. */
        equals(other) {
            aprjpoint(other);
            const { X: X1, Y: Y1, Z: Z1 } = this;
            const { X: X2, Y: Y2, Z: Z2 } = other;
            const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));
            const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));
            return U1 && U2;
        }
        /** Flips point to one corresponding to (x, -y) in Affine coordinates. */
        negate() {
            return new Point(this.X, Fp.neg(this.Y), this.Z);
        }
        // Renes-Costello-Batina exception-free doubling formula.
        // There is 30% faster Jacobian formula, but it is not complete.
        // https://eprint.iacr.org/2015/1060, algorithm 3
        // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
        double() {
            const { a, b } = CURVE;
            const b3 = Fp.mul(b, _3n);
            const { X: X1, Y: Y1, Z: Z1 } = this;
            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore
            let t0 = Fp.mul(X1, X1); // step 1
            let t1 = Fp.mul(Y1, Y1);
            let t2 = Fp.mul(Z1, Z1);
            let t3 = Fp.mul(X1, Y1);
            t3 = Fp.add(t3, t3); // step 5
            Z3 = Fp.mul(X1, Z1);
            Z3 = Fp.add(Z3, Z3);
            X3 = Fp.mul(a, Z3);
            Y3 = Fp.mul(b3, t2);
            Y3 = Fp.add(X3, Y3); // step 10
            X3 = Fp.sub(t1, Y3);
            Y3 = Fp.add(t1, Y3);
            Y3 = Fp.mul(X3, Y3);
            X3 = Fp.mul(t3, X3);
            Z3 = Fp.mul(b3, Z3); // step 15
            t2 = Fp.mul(a, t2);
            t3 = Fp.sub(t0, t2);
            t3 = Fp.mul(a, t3);
            t3 = Fp.add(t3, Z3);
            Z3 = Fp.add(t0, t0); // step 20
            t0 = Fp.add(Z3, t0);
            t0 = Fp.add(t0, t2);
            t0 = Fp.mul(t0, t3);
            Y3 = Fp.add(Y3, t0);
            t2 = Fp.mul(Y1, Z1); // step 25
            t2 = Fp.add(t2, t2);
            t0 = Fp.mul(t2, t3);
            X3 = Fp.sub(X3, t0);
            Z3 = Fp.mul(t2, t1);
            Z3 = Fp.add(Z3, Z3); // step 30
            Z3 = Fp.add(Z3, Z3);
            return new Point(X3, Y3, Z3);
        }
        // Renes-Costello-Batina exception-free addition formula.
        // There is 30% faster Jacobian formula, but it is not complete.
        // https://eprint.iacr.org/2015/1060, algorithm 1
        // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
        add(other) {
            aprjpoint(other);
            const { X: X1, Y: Y1, Z: Z1 } = this;
            const { X: X2, Y: Y2, Z: Z2 } = other;
            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore
            const a = CURVE.a;
            const b3 = Fp.mul(CURVE.b, _3n);
            let t0 = Fp.mul(X1, X2); // step 1
            let t1 = Fp.mul(Y1, Y2);
            let t2 = Fp.mul(Z1, Z2);
            let t3 = Fp.add(X1, Y1);
            let t4 = Fp.add(X2, Y2); // step 5
            t3 = Fp.mul(t3, t4);
            t4 = Fp.add(t0, t1);
            t3 = Fp.sub(t3, t4);
            t4 = Fp.add(X1, Z1);
            let t5 = Fp.add(X2, Z2); // step 10
            t4 = Fp.mul(t4, t5);
            t5 = Fp.add(t0, t2);
            t4 = Fp.sub(t4, t5);
            t5 = Fp.add(Y1, Z1);
            X3 = Fp.add(Y2, Z2); // step 15
            t5 = Fp.mul(t5, X3);
            X3 = Fp.add(t1, t2);
            t5 = Fp.sub(t5, X3);
            Z3 = Fp.mul(a, t4);
            X3 = Fp.mul(b3, t2); // step 20
            Z3 = Fp.add(X3, Z3);
            X3 = Fp.sub(t1, Z3);
            Z3 = Fp.add(t1, Z3);
            Y3 = Fp.mul(X3, Z3);
            t1 = Fp.add(t0, t0); // step 25
            t1 = Fp.add(t1, t0);
            t2 = Fp.mul(a, t2);
            t4 = Fp.mul(b3, t4);
            t1 = Fp.add(t1, t2);
            t2 = Fp.sub(t0, t2); // step 30
            t2 = Fp.mul(a, t2);
            t4 = Fp.add(t4, t2);
            t0 = Fp.mul(t1, t4);
            Y3 = Fp.add(Y3, t0);
            t0 = Fp.mul(t5, t4); // step 35
            X3 = Fp.mul(t3, X3);
            X3 = Fp.sub(X3, t0);
            t0 = Fp.mul(t3, t1);
            Z3 = Fp.mul(t5, Z3);
            Z3 = Fp.add(Z3, t0); // step 40
            return new Point(X3, Y3, Z3);
        }
        subtract(other) {
            return this.add(other.negate());
        }
        is0() {
            return this.equals(Point.ZERO);
        }
        /**
         * Constant time multiplication.
         * Uses wNAF method. Windowed method may be 10% faster,
         * but takes 2x longer to generate and consumes 2x memory.
         * Uses precomputes when available.
         * Uses endomorphism for Koblitz curves.
         * @param scalar by which the point would be multiplied
         * @returns New point
         */
        multiply(scalar) {
            const { endo } = extraOpts;
            if (!Fn.isValidNot0(scalar))
                throw new Error('invalid scalar: out of range'); // 0 is invalid
            let point, fake; // Fake point is used to const-time mult
            const mul = (n) => wnaf.cached(this, n, (p) => (0, curve_ts_1.normalizeZ)(Point, p));
            /** See docs for {@link EndomorphismOpts} */
            if (endo) {
                const { k1neg, k1, k2neg, k2 } = splitEndoScalarN(scalar);
                const { p: k1p, f: k1f } = mul(k1);
                const { p: k2p, f: k2f } = mul(k2);
                fake = k1f.add(k2f);
                point = finishEndo(endo.beta, k1p, k2p, k1neg, k2neg);
            }
            else {
                const { p, f } = mul(scalar);
                point = p;
                fake = f;
            }
            // Normalize `z` for both points, but return only real one
            return (0, curve_ts_1.normalizeZ)(Point, [point, fake])[0];
        }
        /**
         * Non-constant-time multiplication. Uses double-and-add algorithm.
         * It's faster, but should only be used when you don't care about
         * an exposed secret key e.g. sig verification, which works over *public* keys.
         */
        multiplyUnsafe(sc) {
            const { endo } = extraOpts;
            const p = this;
            if (!Fn.isValid(sc))
                throw new Error('invalid scalar: out of range'); // 0 is valid
            if (sc === _0n || p.is0())
                return Point.ZERO;
            if (sc === _1n)
                return p; // fast-path
            if (wnaf.hasCache(this))
                return this.multiply(sc);
            if (endo) {
                const { k1neg, k1, k2neg, k2 } = splitEndoScalarN(sc);
                const { p1, p2 } = (0, curve_ts_1.mulEndoUnsafe)(Point, p, k1, k2); // 30% faster vs wnaf.unsafe
                return finishEndo(endo.beta, p1, p2, k1neg, k2neg);
            }
            else {
                return wnaf.unsafe(p, sc);
            }
        }
        multiplyAndAddUnsafe(Q, a, b) {
            const sum = this.multiplyUnsafe(a).add(Q.multiplyUnsafe(b));
            return sum.is0() ? undefined : sum;
        }
        /**
         * Converts Projective point to affine (x, y) coordinates.
         * @param invertedZ Z^-1 (inverted zero) - optional, precomputation is useful for invertBatch
         */
        toAffine(invertedZ) {
            return toAffineMemo(this, invertedZ);
        }
        /**
         * Checks whether Point is free of torsion elements (is in prime subgroup).
         * Always torsion-free for cofactor=1 curves.
         */
        isTorsionFree() {
            const { isTorsionFree } = extraOpts;
            if (cofactor === _1n)
                return true;
            if (isTorsionFree)
                return isTorsionFree(Point, this);
            return wnaf.unsafe(this, CURVE_ORDER).is0();
        }
        clearCofactor() {
            const { clearCofactor } = extraOpts;
            if (cofactor === _1n)
                return this; // Fast-path
            if (clearCofactor)
                return clearCofactor(Point, this);
            return this.multiplyUnsafe(cofactor);
        }
        isSmallOrder() {
            // can we use this.clearCofactor()?
            return this.multiplyUnsafe(cofactor).is0();
        }
        toBytes(isCompressed = true) {
            (0, utils_ts_1._abool2)(isCompressed, 'isCompressed');
            this.assertValidity();
            return encodePoint(Point, this, isCompressed);
        }
        toHex(isCompressed = true) {
            return (0, utils_ts_1.bytesToHex)(this.toBytes(isCompressed));
        }
        toString() {
            return `<Point ${this.is0() ? 'ZERO' : this.toHex()}>`;
        }
        // TODO: remove
        get px() {
            return this.X;
        }
        get py() {
            return this.X;
        }
        get pz() {
            return this.Z;
        }
        toRawBytes(isCompressed = true) {
            return this.toBytes(isCompressed);
        }
        _setWindowSize(windowSize) {
            this.precompute(windowSize);
        }
        static normalizeZ(points) {
            return (0, curve_ts_1.normalizeZ)(Point, points);
        }
        static msm(points, scalars) {
            return (0, curve_ts_1.pippenger)(Point, Fn, points, scalars);
        }
        static fromPrivateKey(privateKey) {
            return Point.BASE.multiply(_normFnElement(Fn, privateKey));
        }
    }
    // base / generator point
    Point.BASE = new Point(CURVE.Gx, CURVE.Gy, Fp.ONE);
    // zero / infinity / identity point
    Point.ZERO = new Point(Fp.ZERO, Fp.ONE, Fp.ZERO); // 0, 1, 0
    // math field
    Point.Fp = Fp;
    // scalar field
    Point.Fn = Fn;
    const bits = Fn.BITS;
    const wnaf = new curve_ts_1.wNAF(Point, extraOpts.endo ? Math.ceil(bits / 2) : bits);
    Point.BASE.precompute(8); // Enable precomputes. Slows down first publicKey computation by 20ms.
    return Point;
}
// Points start with byte 0x02 when y is even; otherwise 0x03
function pprefix(hasEvenY) {
    return Uint8Array.of(hasEvenY ? 0x02 : 0x03);
}
/**
 * Implementation of the Shallue and van de Woestijne method for any weierstrass curve.
 * TODO: check if there is a way to merge this with uvRatio in Edwards; move to modular.
 * b = True and y = sqrt(u / v) if (u / v) is square in F, and
 * b = False and y = sqrt(Z * (u / v)) otherwise.
 * @param Fp
 * @param Z
 * @returns
 */
function SWUFpSqrtRatio(Fp, Z) {
    // Generic implementation
    const q = Fp.ORDER;
    let l = _0n;
    for (let o = q - _1n; o % _2n === _0n; o /= _2n)
        l += _1n;
    const c1 = l; // 1. c1, the largest integer such that 2^c1 divides q - 1.
    // We need 2n ** c1 and 2n ** (c1-1). We can't use **; but we can use <<.
    // 2n ** c1 == 2n << (c1-1)
    const _2n_pow_c1_1 = _2n << (c1 - _1n - _1n);
    const _2n_pow_c1 = _2n_pow_c1_1 * _2n;
    const c2 = (q - _1n) / _2n_pow_c1; // 2. c2 = (q - 1) / (2^c1)  # Integer arithmetic
    const c3 = (c2 - _1n) / _2n; // 3. c3 = (c2 - 1) / 2            # Integer arithmetic
    const c4 = _2n_pow_c1 - _1n; // 4. c4 = 2^c1 - 1                # Integer arithmetic
    const c5 = _2n_pow_c1_1; // 5. c5 = 2^(c1 - 1)                  # Integer arithmetic
    const c6 = Fp.pow(Z, c2); // 6. c6 = Z^c2
    const c7 = Fp.pow(Z, (c2 + _1n) / _2n); // 7. c7 = Z^((c2 + 1) / 2)
    let sqrtRatio = (u, v) => {
        let tv1 = c6; // 1. tv1 = c6
        let tv2 = Fp.pow(v, c4); // 2. tv2 = v^c4
        let tv3 = Fp.sqr(tv2); // 3. tv3 = tv2^2
        tv3 = Fp.mul(tv3, v); // 4. tv3 = tv3 * v
        let tv5 = Fp.mul(u, tv3); // 5. tv5 = u * tv3
        tv5 = Fp.pow(tv5, c3); // 6. tv5 = tv5^c3
        tv5 = Fp.mul(tv5, tv2); // 7. tv5 = tv5 * tv2
        tv2 = Fp.mul(tv5, v); // 8. tv2 = tv5 * v
        tv3 = Fp.mul(tv5, u); // 9. tv3 = tv5 * u
        let tv4 = Fp.mul(tv3, tv2); // 10. tv4 = tv3 * tv2
        tv5 = Fp.pow(tv4, c5); // 11. tv5 = tv4^c5
        let isQR = Fp.eql(tv5, Fp.ONE); // 12. isQR = tv5 == 1
        tv2 = Fp.mul(tv3, c7); // 13. tv2 = tv3 * c7
        tv5 = Fp.mul(tv4, tv1); // 14. tv5 = tv4 * tv1
        tv3 = Fp.cmov(tv2, tv3, isQR); // 15. tv3 = CMOV(tv2, tv3, isQR)
        tv4 = Fp.cmov(tv5, tv4, isQR); // 16. tv4 = CMOV(tv5, tv4, isQR)
        // 17. for i in (c1, c1 - 1, ..., 2):
        for (let i = c1; i > _1n; i--) {
            let tv5 = i - _2n; // 18.    tv5 = i - 2
            tv5 = _2n << (tv5 - _1n); // 19.    tv5 = 2^tv5
            let tvv5 = Fp.pow(tv4, tv5); // 20.    tv5 = tv4^tv5
            const e1 = Fp.eql(tvv5, Fp.ONE); // 21.    e1 = tv5 == 1
            tv2 = Fp.mul(tv3, tv1); // 22.    tv2 = tv3 * tv1
            tv1 = Fp.mul(tv1, tv1); // 23.    tv1 = tv1 * tv1
            tvv5 = Fp.mul(tv4, tv1); // 24.    tv5 = tv4 * tv1
            tv3 = Fp.cmov(tv2, tv3, e1); // 25.    tv3 = CMOV(tv2, tv3, e1)
            tv4 = Fp.cmov(tvv5, tv4, e1); // 26.    tv4 = CMOV(tv5, tv4, e1)
        }
        return { isValid: isQR, value: tv3 };
    };
    if (Fp.ORDER % _4n === _3n) {
        // sqrt_ratio_3mod4(u, v)
        const c1 = (Fp.ORDER - _3n) / _4n; // 1. c1 = (q - 3) / 4     # Integer arithmetic
        const c2 = Fp.sqrt(Fp.neg(Z)); // 2. c2 = sqrt(-Z)
        sqrtRatio = (u, v) => {
            let tv1 = Fp.sqr(v); // 1. tv1 = v^2
            const tv2 = Fp.mul(u, v); // 2. tv2 = u * v
            tv1 = Fp.mul(tv1, tv2); // 3. tv1 = tv1 * tv2
            let y1 = Fp.pow(tv1, c1); // 4. y1 = tv1^c1
            y1 = Fp.mul(y1, tv2); // 5. y1 = y1 * tv2
            const y2 = Fp.mul(y1, c2); // 6. y2 = y1 * c2
            const tv3 = Fp.mul(Fp.sqr(y1), v); // 7. tv3 = y1^2; 8. tv3 = tv3 * v
            const isQR = Fp.eql(tv3, u); // 9. isQR = tv3 == u
            let y = Fp.cmov(y2, y1, isQR); // 10. y = CMOV(y2, y1, isQR)
            return { isValid: isQR, value: y }; // 11. return (isQR, y) isQR ? y : y*c2
        };
    }
    // No curves uses that
    // if (Fp.ORDER % _8n === _5n) // sqrt_ratio_5mod8
    return sqrtRatio;
}
/**
 * Simplified Shallue-van de Woestijne-Ulas Method
 * https://www.rfc-editor.org/rfc/rfc9380#section-6.6.2
 */
function mapToCurveSimpleSWU(Fp, opts) {
    (0, modular_ts_1.validateField)(Fp);
    const { A, B, Z } = opts;
    if (!Fp.isValid(A) || !Fp.isValid(B) || !Fp.isValid(Z))
        throw new Error('mapToCurveSimpleSWU: invalid opts');
    const sqrtRatio = SWUFpSqrtRatio(Fp, Z);
    if (!Fp.isOdd)
        throw new Error('Field does not have .isOdd()');
    // Input: u, an element of F.
    // Output: (x, y), a point on E.
    return (u) => {
        // prettier-ignore
        let tv1, tv2, tv3, tv4, tv5, tv6, x, y;
        tv1 = Fp.sqr(u); // 1.  tv1 = u^2
        tv1 = Fp.mul(tv1, Z); // 2.  tv1 = Z * tv1
        tv2 = Fp.sqr(tv1); // 3.  tv2 = tv1^2
        tv2 = Fp.add(tv2, tv1); // 4.  tv2 = tv2 + tv1
        tv3 = Fp.add(tv2, Fp.ONE); // 5.  tv3 = tv2 + 1
        tv3 = Fp.mul(tv3, B); // 6.  tv3 = B * tv3
        tv4 = Fp.cmov(Z, Fp.neg(tv2), !Fp.eql(tv2, Fp.ZERO)); // 7.  tv4 = CMOV(Z, -tv2, tv2 != 0)
        tv4 = Fp.mul(tv4, A); // 8.  tv4 = A * tv4
        tv2 = Fp.sqr(tv3); // 9.  tv2 = tv3^2
        tv6 = Fp.sqr(tv4); // 10. tv6 = tv4^2
        tv5 = Fp.mul(tv6, A); // 11. tv5 = A * tv6
        tv2 = Fp.add(tv2, tv5); // 12. tv2 = tv2 + tv5
        tv2 = Fp.mul(tv2, tv3); // 13. tv2 = tv2 * tv3
        tv6 = Fp.mul(tv6, tv4); // 14. tv6 = tv6 * tv4
        tv5 = Fp.mul(tv6, B); // 15. tv5 = B * tv6
        tv2 = Fp.add(tv2, tv5); // 16. tv2 = tv2 + tv5
        x = Fp.mul(tv1, tv3); // 17.   x = tv1 * tv3
        const { isValid, value } = sqrtRatio(tv2, tv6); // 18. (is_gx1_square, y1) = sqrt_ratio(tv2, tv6)
        y = Fp.mul(tv1, u); // 19.   y = tv1 * u  -> Z * u^3 * y1
        y = Fp.mul(y, value); // 20.   y = y * y1
        x = Fp.cmov(x, tv3, isValid); // 21.   x = CMOV(x, tv3, is_gx1_square)
        y = Fp.cmov(y, value, isValid); // 22.   y = CMOV(y, y1, is_gx1_square)
        const e1 = Fp.isOdd(u) === Fp.isOdd(y); // 23.  e1 = sgn0(u) == sgn0(y)
        y = Fp.cmov(Fp.neg(y), y, e1); // 24.   y = CMOV(-y, y, e1)
        const tv4_inv = (0, modular_ts_1.FpInvertBatch)(Fp, [tv4], true)[0];
        x = Fp.mul(x, tv4_inv); // 25.   x = x / tv4
        return { x, y };
    };
}
function getWLengths(Fp, Fn) {
    return {
        secretKey: Fn.BYTES,
        publicKey: 1 + Fp.BYTES,
        publicKeyUncompressed: 1 + 2 * Fp.BYTES,
        publicKeyHasPrefix: true,
        signature: 2 * Fn.BYTES,
    };
}
/**
 * Sometimes users only need getPublicKey, getSharedSecret, and secret key handling.
 * This helper ensures no signature functionality is present. Less code, smaller bundle size.
 */
function ecdh(Point, ecdhOpts = {}) {
    const { Fn } = Point;
    const randomBytes_ = ecdhOpts.randomBytes || utils_ts_1.randomBytes;
    const lengths = Object.assign(getWLengths(Point.Fp, Fn), { seed: (0, modular_ts_1.getMinHashLength)(Fn.ORDER) });
    function isValidSecretKey(secretKey) {
        try {
            return !!_normFnElement(Fn, secretKey);
        }
        catch (error) {
            return false;
        }
    }
    function isValidPublicKey(publicKey, isCompressed) {
        const { publicKey: comp, publicKeyUncompressed } = lengths;
        try {
            const l = publicKey.length;
            if (isCompressed === true && l !== comp)
                return false;
            if (isCompressed === false && l !== publicKeyUncompressed)
                return false;
            return !!Point.fromBytes(publicKey);
        }
        catch (error) {
            return false;
        }
    }
    /**
     * Produces cryptographically secure secret key from random of size
     * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.
     */
    function randomSecretKey(seed = randomBytes_(lengths.seed)) {
        return (0, modular_ts_1.mapHashToField)((0, utils_ts_1._abytes2)(seed, lengths.seed, 'seed'), Fn.ORDER);
    }
    /**
     * Computes public key for a secret key. Checks for validity of the secret key.
     * @param isCompressed whether to return compact (default), or full key
     * @returns Public key, full when isCompressed=false; short when isCompressed=true
     */
    function getPublicKey(secretKey, isCompressed = true) {
        return Point.BASE.multiply(_normFnElement(Fn, secretKey)).toBytes(isCompressed);
    }
    function keygen(seed) {
        const secretKey = randomSecretKey(seed);
        return { secretKey, publicKey: getPublicKey(secretKey) };
    }
    /**
     * Quick and dirty check for item being public key. Does not validate hex, or being on-curve.
     */
    function isProbPub(item) {
        if (typeof item === 'bigint')
            return false;
        if (item instanceof Point)
            return true;
        const { secretKey, publicKey, publicKeyUncompressed } = lengths;
        if (Fn.allowedLengths || secretKey === publicKey)
            return undefined;
        const l = (0, utils_ts_1.ensureBytes)('key', item).length;
        return l === publicKey || l === publicKeyUncompressed;
    }
    /**
     * ECDH (Elliptic Curve Diffie Hellman).
     * Computes shared public key from secret key A and public key B.
     * Checks: 1) secret key validity 2) shared key is on-curve.
     * Does NOT hash the result.
     * @param isCompressed whether to return compact (default), or full key
     * @returns shared public key
     */
    function getSharedSecret(secretKeyA, publicKeyB, isCompressed = true) {
        if (isProbPub(secretKeyA) === true)
            throw new Error('first arg must be private key');
        if (isProbPub(publicKeyB) === false)
            throw new Error('second arg must be public key');
        const s = _normFnElement(Fn, secretKeyA);
        const b = Point.fromHex(publicKeyB); // checks for being on-curve
        return b.multiply(s).toBytes(isCompressed);
    }
    const utils = {
        isValidSecretKey,
        isValidPublicKey,
        randomSecretKey,
        // TODO: remove
        isValidPrivateKey: isValidSecretKey,
        randomPrivateKey: randomSecretKey,
        normPrivateKeyToScalar: (key) => _normFnElement(Fn, key),
        precompute(windowSize = 8, point = Point.BASE) {
            return point.precompute(windowSize, false);
        },
    };
    return Object.freeze({ getPublicKey, getSharedSecret, keygen, Point, utils, lengths });
}
/**
 * Creates ECDSA signing interface for given elliptic curve `Point` and `hash` function.
 * We need `hash` for 2 features:
 * 1. Message prehash-ing. NOT used if `sign` / `verify` are called with `prehash: false`
 * 2. k generation in `sign`, using HMAC-drbg(hash)
 *
 * ECDSAOpts are only rarely needed.
 *
 * @example
 * ```js
 * const p256_Point = weierstrass(...);
 * const p256_sha256 = ecdsa(p256_Point, sha256);
 * const p256_sha224 = ecdsa(p256_Point, sha224);
 * const p256_sha224_r = ecdsa(p256_Point, sha224, { randomBytes: (length) => { ... } });
 * ```
 */
function ecdsa(Point, hash, ecdsaOpts = {}) {
    (0, utils_1.ahash)(hash);
    (0, utils_ts_1._validateObject)(ecdsaOpts, {}, {
        hmac: 'function',
        lowS: 'boolean',
        randomBytes: 'function',
        bits2int: 'function',
        bits2int_modN: 'function',
    });
    const randomBytes = ecdsaOpts.randomBytes || utils_ts_1.randomBytes;
    const hmac = ecdsaOpts.hmac ||
        ((key, ...msgs) => (0, hmac_js_1.hmac)(hash, key, (0, utils_ts_1.concatBytes)(...msgs)));
    const { Fp, Fn } = Point;
    const { ORDER: CURVE_ORDER, BITS: fnBits } = Fn;
    const { keygen, getPublicKey, getSharedSecret, utils, lengths } = ecdh(Point, ecdsaOpts);
    const defaultSigOpts = {
        prehash: false,
        lowS: typeof ecdsaOpts.lowS === 'boolean' ? ecdsaOpts.lowS : false,
        format: undefined, //'compact' as ECDSASigFormat,
        extraEntropy: false,
    };
    const defaultSigOpts_format = 'compact';
    function isBiggerThanHalfOrder(number) {
        const HALF = CURVE_ORDER >> _1n;
        return number > HALF;
    }
    function validateRS(title, num) {
        if (!Fn.isValidNot0(num))
            throw new Error(`invalid signature ${title}: out of range 1..Point.Fn.ORDER`);
        return num;
    }
    function validateSigLength(bytes, format) {
        validateSigFormat(format);
        const size = lengths.signature;
        const sizer = format === 'compact' ? size : format === 'recovered' ? size + 1 : undefined;
        return (0, utils_ts_1._abytes2)(bytes, sizer, `${format} signature`);
    }
    /**
     * ECDSA signature with its (r, s) properties. Supports compact, recovered & DER representations.
     */
    class Signature {
        constructor(r, s, recovery) {
            this.r = validateRS('r', r); // r in [1..N-1];
            this.s = validateRS('s', s); // s in [1..N-1];
            if (recovery != null)
                this.recovery = recovery;
            Object.freeze(this);
        }
        static fromBytes(bytes, format = defaultSigOpts_format) {
            validateSigLength(bytes, format);
            let recid;
            if (format === 'der') {
                const { r, s } = exports.DER.toSig((0, utils_ts_1._abytes2)(bytes));
                return new Signature(r, s);
            }
            if (format === 'recovered') {
                recid = bytes[0];
                format = 'compact';
                bytes = bytes.subarray(1);
            }
            const L = Fn.BYTES;
            const r = bytes.subarray(0, L);
            const s = bytes.subarray(L, L * 2);
            return new Signature(Fn.fromBytes(r), Fn.fromBytes(s), recid);
        }
        static fromHex(hex, format) {
            return this.fromBytes((0, utils_ts_1.hexToBytes)(hex), format);
        }
        addRecoveryBit(recovery) {
            return new Signature(this.r, this.s, recovery);
        }
        recoverPublicKey(messageHash) {
            const FIELD_ORDER = Fp.ORDER;
            const { r, s, recovery: rec } = this;
            if (rec == null || ![0, 1, 2, 3].includes(rec))
                throw new Error('recovery id invalid');
            // ECDSA recovery is hard for cofactor > 1 curves.
            // In sign, `r = q.x mod n`, and here we recover q.x from r.
            // While recovering q.x >= n, we need to add r+n for cofactor=1 curves.
            // However, for cofactor>1, r+n may not get q.x:
            // r+n*i would need to be done instead where i is unknown.
            // To easily get i, we either need to:
            // a. increase amount of valid recid values (4, 5...); OR
            // b. prohibit non-prime-order signatures (recid > 1).
            const hasCofactor = CURVE_ORDER * _2n < FIELD_ORDER;
            if (hasCofactor && rec > 1)
                throw new Error('recovery id is ambiguous for h>1 curve');
            const radj = rec === 2 || rec === 3 ? r + CURVE_ORDER : r;
            if (!Fp.isValid(radj))
                throw new Error('recovery id 2 or 3 invalid');
            const x = Fp.toBytes(radj);
            const R = Point.fromBytes((0, utils_ts_1.concatBytes)(pprefix((rec & 1) === 0), x));
            const ir = Fn.inv(radj); // r^-1
            const h = bits2int_modN((0, utils_ts_1.ensureBytes)('msgHash', messageHash)); // Truncate hash
            const u1 = Fn.create(-h * ir); // -hr^-1
            const u2 = Fn.create(s * ir); // sr^-1
            // (sr^-1)R-(hr^-1)G = -(hr^-1)G + (sr^-1). unsafe is fine: there is no private data.
            const Q = Point.BASE.multiplyUnsafe(u1).add(R.multiplyUnsafe(u2));
            if (Q.is0())
                throw new Error('point at infinify');
            Q.assertValidity();
            return Q;
        }
        // Signatures should be low-s, to prevent malleability.
        hasHighS() {
            return isBiggerThanHalfOrder(this.s);
        }
        toBytes(format = defaultSigOpts_format) {
            validateSigFormat(format);
            if (format === 'der')
                return (0, utils_ts_1.hexToBytes)(exports.DER.hexFromSig(this));
            const r = Fn.toBytes(this.r);
            const s = Fn.toBytes(this.s);
            if (format === 'recovered') {
                if (this.recovery == null)
                    throw new Error('recovery bit must be present');
                return (0, utils_ts_1.concatBytes)(Uint8Array.of(this.recovery), r, s);
            }
            return (0, utils_ts_1.concatBytes)(r, s);
        }
        toHex(format) {
            return (0, utils_ts_1.bytesToHex)(this.toBytes(format));
        }
        // TODO: remove
        assertValidity() { }
        static fromCompact(hex) {
            return Signature.fromBytes((0, utils_ts_1.ensureBytes)('sig', hex), 'compact');
        }
        static fromDER(hex) {
            return Signature.fromBytes((0, utils_ts_1.ensureBytes)('sig', hex), 'der');
        }
        normalizeS() {
            return this.hasHighS() ? new Signature(this.r, Fn.neg(this.s), this.recovery) : this;
        }
        toDERRawBytes() {
            return this.toBytes('der');
        }
        toDERHex() {
            return (0, utils_ts_1.bytesToHex)(this.toBytes('der'));
        }
        toCompactRawBytes() {
            return this.toBytes('compact');
        }
        toCompactHex() {
            return (0, utils_ts_1.bytesToHex)(this.toBytes('compact'));
        }
    }
    // RFC6979: ensure ECDSA msg is X bytes and < N. RFC suggests optional truncating via bits2octets.
    // FIPS 186-4 4.6 suggests the leftmost min(nBitLen, outLen) bits, which matches bits2int.
    // bits2int can produce res>N, we can do mod(res, N) since the bitLen is the same.
    // int2octets can't be used; pads small msgs with 0: unacceptatble for trunc as per RFC vectors
    const bits2int = ecdsaOpts.bits2int ||
        function bits2int_def(bytes) {
            // Our custom check "just in case", for protection against DoS
            if (bytes.length > 8192)
                throw new Error('input is too large');
            // For curves with nBitLength % 8 !== 0: bits2octets(bits2octets(m)) !== bits2octets(m)
            // for some cases, since bytes.length * 8 is not actual bitLength.
            const num = (0, utils_ts_1.bytesToNumberBE)(bytes); // check for == u8 done here
            const delta = bytes.length * 8 - fnBits; // truncate to nBitLength leftmost bits
            return delta > 0 ? num >> BigInt(delta) : num;
        };
    const bits2int_modN = ecdsaOpts.bits2int_modN ||
        function bits2int_modN_def(bytes) {
            return Fn.create(bits2int(bytes)); // can't use bytesToNumberBE here
        };
    // Pads output with zero as per spec
    const ORDER_MASK = (0, utils_ts_1.bitMask)(fnBits);
    /** Converts to bytes. Checks if num in `[0..ORDER_MASK-1]` e.g.: `[0..2^256-1]`. */
    function int2octets(num) {
        // IMPORTANT: the check ensures working for case `Fn.BYTES != Fn.BITS * 8`
        (0, utils_ts_1.aInRange)('num < 2^' + fnBits, num, _0n, ORDER_MASK);
        return Fn.toBytes(num);
    }
    function validateMsgAndHash(message, prehash) {
        (0, utils_ts_1._abytes2)(message, undefined, 'message');
        return prehash ? (0, utils_ts_1._abytes2)(hash(message), undefined, 'prehashed message') : message;
    }
    /**
     * Steps A, D of RFC6979 3.2.
     * Creates RFC6979 seed; converts msg/privKey to numbers.
     * Used only in sign, not in verify.
     *
     * Warning: we cannot assume here that message has same amount of bytes as curve order,
     * this will be invalid at least for P521. Also it can be bigger for P224 + SHA256.
     */
    function prepSig(message, privateKey, opts) {
        if (['recovered', 'canonical'].some((k) => k in opts))
            throw new Error('sign() legacy options not supported');
        const { lowS, prehash, extraEntropy } = validateSigOpts(opts, defaultSigOpts);
        message = validateMsgAndHash(message, prehash); // RFC6979 3.2 A: h1 = H(m)
        // We can't later call bits2octets, since nested bits2int is broken for curves
        // with fnBits % 8 !== 0. Because of that, we unwrap it here as int2octets call.
        // const bits2octets = (bits) => int2octets(bits2int_modN(bits))
        const h1int = bits2int_modN(message);
        const d = _normFnElement(Fn, privateKey); // validate secret key, convert to bigint
        const seedArgs = [int2octets(d), int2octets(h1int)];
        // extraEntropy. RFC6979 3.6: additional k' (optional).
        if (extraEntropy != null && extraEntropy !== false) {
            // K = HMAC_K(V || 0x00 || int2octets(x) || bits2octets(h1) || k')
            // gen random bytes OR pass as-is
            const e = extraEntropy === true ? randomBytes(lengths.secretKey) : extraEntropy;
            seedArgs.push((0, utils_ts_1.ensureBytes)('extraEntropy', e)); // check for being bytes
        }
        const seed = (0, utils_ts_1.concatBytes)(...seedArgs); // Step D of RFC6979 3.2
        const m = h1int; // NOTE: no need to call bits2int second time here, it is inside truncateHash!
        // Converts signature params into point w r/s, checks result for validity.
        // To transform k => Signature:
        // q = k⋅G
        // r = q.x mod n
        // s = k^-1(m + rd) mod n
        // Can use scalar blinding b^-1(bm + bdr) where b ∈ [1,q−1] according to
        // https://tches.iacr.org/index.php/TCHES/article/view/7337/6509. We've decided against it:
        // a) dependency on CSPRNG b) 15% slowdown c) doesn't really help since bigints are not CT
        function k2sig(kBytes) {
            // RFC 6979 Section 3.2, step 3: k = bits2int(T)
            // Important: all mod() calls here must be done over N
            const k = bits2int(kBytes); // mod n, not mod p
            if (!Fn.isValidNot0(k))
                return; // Valid scalars (including k) must be in 1..N-1
            const ik = Fn.inv(k); // k^-1 mod n
            const q = Point.BASE.multiply(k).toAffine(); // q = k⋅G
            const r = Fn.create(q.x); // r = q.x mod n
            if (r === _0n)
                return;
            const s = Fn.create(ik * Fn.create(m + r * d)); // Not using blinding here, see comment above
            if (s === _0n)
                return;
            let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n); // recovery bit (2 or 3, when q.x > n)
            let normS = s;
            if (lowS && isBiggerThanHalfOrder(s)) {
                normS = Fn.neg(s); // if lowS was passed, ensure s is always
                recovery ^= 1; // // in the bottom half of N
            }
            return new Signature(r, normS, recovery); // use normS, not s
        }
        return { seed, k2sig };
    }
    /**
     * Signs message hash with a secret key.
     *
     * ```
     * sign(m, d) where
     *   k = rfc6979_hmac_drbg(m, d)
     *   (x, y) = G × k
     *   r = x mod n
     *   s = (m + dr) / k mod n
     * ```
     */
    function sign(message, secretKey, opts = {}) {
        message = (0, utils_ts_1.ensureBytes)('message', message);
        const { seed, k2sig } = prepSig(message, secretKey, opts); // Steps A, D of RFC6979 3.2.
        const drbg = (0, utils_ts_1.createHmacDrbg)(hash.outputLen, Fn.BYTES, hmac);
        const sig = drbg(seed, k2sig); // Steps B, C, D, E, F, G
        return sig;
    }
    function tryParsingSig(sg) {
        // Try to deduce format
        let sig = undefined;
        const isHex = typeof sg === 'string' || (0, utils_ts_1.isBytes)(sg);
        const isObj = !isHex &&
            sg !== null &&
            typeof sg === 'object' &&
            typeof sg.r === 'bigint' &&
            typeof sg.s === 'bigint';
        if (!isHex && !isObj)
            throw new Error('invalid signature, expected Uint8Array, hex string or Signature instance');
        if (isObj) {
            sig = new Signature(sg.r, sg.s);
        }
        else if (isHex) {
            try {
                sig = Signature.fromBytes((0, utils_ts_1.ensureBytes)('sig', sg), 'der');
            }
            catch (derError) {
                if (!(derError instanceof exports.DER.Err))
                    throw derError;
            }
            if (!sig) {
                try {
                    sig = Signature.fromBytes((0, utils_ts_1.ensureBytes)('sig', sg), 'compact');
                }
                catch (error) {
                    return false;
                }
            }
        }
        if (!sig)
            return false;
        return sig;
    }
    /**
     * Verifies a signature against message and public key.
     * Rejects lowS signatures by default: see {@link ECDSAVerifyOpts}.
     * Implements section 4.1.4 from https://www.secg.org/sec1-v2.pdf:
     *
     * ```
     * verify(r, s, h, P) where
     *   u1 = hs^-1 mod n
     *   u2 = rs^-1 mod n
     *   R = u1⋅G + u2⋅P
     *   mod(R.x, n) == r
     * ```
     */
    function verify(signature, message, publicKey, opts = {}) {
        const { lowS, prehash, format } = validateSigOpts(opts, defaultSigOpts);
        publicKey = (0, utils_ts_1.ensureBytes)('publicKey', publicKey);
        message = validateMsgAndHash((0, utils_ts_1.ensureBytes)('message', message), prehash);
        if ('strict' in opts)
            throw new Error('options.strict was renamed to lowS');
        const sig = format === undefined
            ? tryParsingSig(signature)
            : Signature.fromBytes((0, utils_ts_1.ensureBytes)('sig', signature), format);
        if (sig === false)
            return false;
        try {
            const P = Point.fromBytes(publicKey);
            if (lowS && sig.hasHighS())
                return false;
            const { r, s } = sig;
            const h = bits2int_modN(message); // mod n, not mod p
            const is = Fn.inv(s); // s^-1 mod n
            const u1 = Fn.create(h * is); // u1 = hs^-1 mod n
            const u2 = Fn.create(r * is); // u2 = rs^-1 mod n
            const R = Point.BASE.multiplyUnsafe(u1).add(P.multiplyUnsafe(u2)); // u1⋅G + u2⋅P
            if (R.is0())
                return false;
            const v = Fn.create(R.x); // v = r.x mod n
            return v === r;
        }
        catch (e) {
            return false;
        }
    }
    function recoverPublicKey(signature, message, opts = {}) {
        const { prehash } = validateSigOpts(opts, defaultSigOpts);
        message = validateMsgAndHash(message, prehash);
        return Signature.fromBytes(signature, 'recovered').recoverPublicKey(message).toBytes();
    }
    return Object.freeze({
        keygen,
        getPublicKey,
        getSharedSecret,
        utils,
        lengths,
        Point,
        sign,
        verify,
        recoverPublicKey,
        Signature,
        hash,
    });
}
/** @deprecated use `weierstrass` in newer releases */
function weierstrassPoints(c) {
    const { CURVE, curveOpts } = _weierstrass_legacy_opts_to_new(c);
    const Point = weierstrassN(CURVE, curveOpts);
    return _weierstrass_new_output_to_legacy(c, Point);
}
function _weierstrass_legacy_opts_to_new(c) {
    const CURVE = {
        a: c.a,
        b: c.b,
        p: c.Fp.ORDER,
        n: c.n,
        h: c.h,
        Gx: c.Gx,
        Gy: c.Gy,
    };
    const Fp = c.Fp;
    let allowedLengths = c.allowedPrivateKeyLengths
        ? Array.from(new Set(c.allowedPrivateKeyLengths.map((l) => Math.ceil(l / 2))))
        : undefined;
    const Fn = (0, modular_ts_1.Field)(CURVE.n, {
        BITS: c.nBitLength,
        allowedLengths: allowedLengths,
        modFromBytes: c.wrapPrivateKey,
    });
    const curveOpts = {
        Fp,
        Fn,
        allowInfinityPoint: c.allowInfinityPoint,
        endo: c.endo,
        isTorsionFree: c.isTorsionFree,
        clearCofactor: c.clearCofactor,
        fromBytes: c.fromBytes,
        toBytes: c.toBytes,
    };
    return { CURVE, curveOpts };
}
function _ecdsa_legacy_opts_to_new(c) {
    const { CURVE, curveOpts } = _weierstrass_legacy_opts_to_new(c);
    const ecdsaOpts = {
        hmac: c.hmac,
        randomBytes: c.randomBytes,
        lowS: c.lowS,
        bits2int: c.bits2int,
        bits2int_modN: c.bits2int_modN,
    };
    return { CURVE, curveOpts, hash: c.hash, ecdsaOpts };
}
function _legacyHelperEquat(Fp, a, b) {
    /**
     * y² = x³ + ax + b: Short weierstrass curve formula. Takes x, returns y².
     * @returns y²
     */
    function weierstrassEquation(x) {
        const x2 = Fp.sqr(x); // x * x
        const x3 = Fp.mul(x2, x); // x² * x
        return Fp.add(Fp.add(x3, Fp.mul(x, a)), b); // x³ + a * x + b
    }
    return weierstrassEquation;
}
function _weierstrass_new_output_to_legacy(c, Point) {
    const { Fp, Fn } = Point;
    function isWithinCurveOrder(num) {
        return (0, utils_ts_1.inRange)(num, _1n, Fn.ORDER);
    }
    const weierstrassEquation = _legacyHelperEquat(Fp, c.a, c.b);
    return Object.assign({}, {
        CURVE: c,
        Point: Point,
        ProjectivePoint: Point,
        normPrivateKeyToScalar: (key) => _normFnElement(Fn, key),
        weierstrassEquation,
        isWithinCurveOrder,
    });
}
function _ecdsa_new_output_to_legacy(c, _ecdsa) {
    const Point = _ecdsa.Point;
    return Object.assign({}, _ecdsa, {
        ProjectivePoint: Point,
        CURVE: Object.assign({}, c, (0, modular_ts_1.nLength)(Point.Fn.ORDER, Point.Fn.BITS)),
    });
}
// _ecdsa_legacy
function weierstrass(c) {
    const { CURVE, curveOpts, hash, ecdsaOpts } = _ecdsa_legacy_opts_to_new(c);
    const Point = weierstrassN(CURVE, curveOpts);
    const signs = ecdsa(Point, hash, ecdsaOpts);
    return _ecdsa_new_output_to_legacy(c, signs);
}
//# sourceMappingURL=weierstrass.js.map

/***/ }),

/***/ "./node_modules/viem/node_modules/@noble/curves/secp256k1.js":
/*!*******************************************************************!*\
  !*** ./node_modules/viem/node_modules/@noble/curves/secp256k1.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.encodeToCurve = exports.hashToCurve = exports.secp256k1_hasher = exports.schnorr = exports.secp256k1 = void 0;
/**
 * SECG secp256k1. See [pdf](https://www.secg.org/sec2-v2.pdf).
 *
 * Belongs to Koblitz curves: it has efficiently-computable GLV endomorphism ψ,
 * check out {@link EndomorphismOpts}. Seems to be rigid (not backdoored).
 * @module
 */
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const sha2_js_1 = __webpack_require__(/*! @noble/hashes/sha2.js */ "./node_modules/@noble/hashes/sha2.js");
const utils_js_1 = __webpack_require__(/*! @noble/hashes/utils.js */ "./node_modules/@noble/hashes/utils.js");
const _shortw_utils_ts_1 = __webpack_require__(/*! ./_shortw_utils.js */ "./node_modules/viem/node_modules/@noble/curves/_shortw_utils.js");
const hash_to_curve_ts_1 = __webpack_require__(/*! ./abstract/hash-to-curve.js */ "./node_modules/viem/node_modules/@noble/curves/abstract/hash-to-curve.js");
const modular_ts_1 = __webpack_require__(/*! ./abstract/modular.js */ "./node_modules/viem/node_modules/@noble/curves/abstract/modular.js");
const weierstrass_ts_1 = __webpack_require__(/*! ./abstract/weierstrass.js */ "./node_modules/viem/node_modules/@noble/curves/abstract/weierstrass.js");
const utils_ts_1 = __webpack_require__(/*! ./utils.js */ "./node_modules/viem/node_modules/@noble/curves/utils.js");
// Seems like generator was produced from some seed:
// `Point.BASE.multiply(Point.Fn.inv(2n, N)).toAffine().x`
// // gives short x 0x3b78ce563f89a0ed9414f5aa28ad0d96d6795f9c63n
const secp256k1_CURVE = {
    p: BigInt('0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f'),
    n: BigInt('0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141'),
    h: BigInt(1),
    a: BigInt(0),
    b: BigInt(7),
    Gx: BigInt('0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798'),
    Gy: BigInt('0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8'),
};
const secp256k1_ENDO = {
    beta: BigInt('0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee'),
    basises: [
        [BigInt('0x3086d221a7d46bcde86c90e49284eb15'), -BigInt('0xe4437ed6010e88286f547fa90abfe4c3')],
        [BigInt('0x114ca50f7a8e2f3f657c1108d9d44cfd8'), BigInt('0x3086d221a7d46bcde86c90e49284eb15')],
    ],
};
const _0n = /* @__PURE__ */ BigInt(0);
const _1n = /* @__PURE__ */ BigInt(1);
const _2n = /* @__PURE__ */ BigInt(2);
/**
 * √n = n^((p+1)/4) for fields p = 3 mod 4. We unwrap the loop and multiply bit-by-bit.
 * (P+1n/4n).toString(2) would produce bits [223x 1, 0, 22x 1, 4x 0, 11, 00]
 */
function sqrtMod(y) {
    const P = secp256k1_CURVE.p;
    // prettier-ignore
    const _3n = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);
    // prettier-ignore
    const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);
    const b2 = (y * y * y) % P; // x^3, 11
    const b3 = (b2 * b2 * y) % P; // x^7
    const b6 = ((0, modular_ts_1.pow2)(b3, _3n, P) * b3) % P;
    const b9 = ((0, modular_ts_1.pow2)(b6, _3n, P) * b3) % P;
    const b11 = ((0, modular_ts_1.pow2)(b9, _2n, P) * b2) % P;
    const b22 = ((0, modular_ts_1.pow2)(b11, _11n, P) * b11) % P;
    const b44 = ((0, modular_ts_1.pow2)(b22, _22n, P) * b22) % P;
    const b88 = ((0, modular_ts_1.pow2)(b44, _44n, P) * b44) % P;
    const b176 = ((0, modular_ts_1.pow2)(b88, _88n, P) * b88) % P;
    const b220 = ((0, modular_ts_1.pow2)(b176, _44n, P) * b44) % P;
    const b223 = ((0, modular_ts_1.pow2)(b220, _3n, P) * b3) % P;
    const t1 = ((0, modular_ts_1.pow2)(b223, _23n, P) * b22) % P;
    const t2 = ((0, modular_ts_1.pow2)(t1, _6n, P) * b2) % P;
    const root = (0, modular_ts_1.pow2)(t2, _2n, P);
    if (!Fpk1.eql(Fpk1.sqr(root), y))
        throw new Error('Cannot find square root');
    return root;
}
const Fpk1 = (0, modular_ts_1.Field)(secp256k1_CURVE.p, { sqrt: sqrtMod });
/**
 * secp256k1 curve, ECDSA and ECDH methods.
 *
 * Field: `2n**256n - 2n**32n - 2n**9n - 2n**8n - 2n**7n - 2n**6n - 2n**4n - 1n`
 *
 * @example
 * ```js
 * import { secp256k1 } from '@noble/curves/secp256k1';
 * const { secretKey, publicKey } = secp256k1.keygen();
 * const msg = new TextEncoder().encode('hello');
 * const sig = secp256k1.sign(msg, secretKey);
 * const isValid = secp256k1.verify(sig, msg, publicKey) === true;
 * ```
 */
exports.secp256k1 = (0, _shortw_utils_ts_1.createCurve)({ ...secp256k1_CURVE, Fp: Fpk1, lowS: true, endo: secp256k1_ENDO }, sha2_js_1.sha256);
// Schnorr signatures are superior to ECDSA from above. Below is Schnorr-specific BIP0340 code.
// https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki
/** An object mapping tags to their tagged hash prefix of [SHA256(tag) | SHA256(tag)] */
const TAGGED_HASH_PREFIXES = {};
function taggedHash(tag, ...messages) {
    let tagP = TAGGED_HASH_PREFIXES[tag];
    if (tagP === undefined) {
        const tagH = (0, sha2_js_1.sha256)((0, utils_ts_1.utf8ToBytes)(tag));
        tagP = (0, utils_ts_1.concatBytes)(tagH, tagH);
        TAGGED_HASH_PREFIXES[tag] = tagP;
    }
    return (0, sha2_js_1.sha256)((0, utils_ts_1.concatBytes)(tagP, ...messages));
}
// ECDSA compact points are 33-byte. Schnorr is 32: we strip first byte 0x02 or 0x03
const pointToBytes = (point) => point.toBytes(true).slice(1);
const Pointk1 = /* @__PURE__ */ (() => exports.secp256k1.Point)();
const hasEven = (y) => y % _2n === _0n;
// Calculate point, scalar and bytes
function schnorrGetExtPubKey(priv) {
    const { Fn, BASE } = Pointk1;
    const d_ = (0, weierstrass_ts_1._normFnElement)(Fn, priv);
    const p = BASE.multiply(d_); // P = d'⋅G; 0 < d' < n check is done inside
    const scalar = hasEven(p.y) ? d_ : Fn.neg(d_);
    return { scalar, bytes: pointToBytes(p) };
}
/**
 * lift_x from BIP340. Convert 32-byte x coordinate to elliptic curve point.
 * @returns valid point checked for being on-curve
 */
function lift_x(x) {
    const Fp = Fpk1;
    if (!Fp.isValidNot0(x))
        throw new Error('invalid x: Fail if x ≥ p');
    const xx = Fp.create(x * x);
    const c = Fp.create(xx * x + BigInt(7)); // Let c = x³ + 7 mod p.
    let y = Fp.sqrt(c); // Let y = c^(p+1)/4 mod p. Same as sqrt().
    // Return the unique point P such that x(P) = x and
    // y(P) = y if y mod 2 = 0 or y(P) = p-y otherwise.
    if (!hasEven(y))
        y = Fp.neg(y);
    const p = Pointk1.fromAffine({ x, y });
    p.assertValidity();
    return p;
}
const num = utils_ts_1.bytesToNumberBE;
/**
 * Create tagged hash, convert it to bigint, reduce modulo-n.
 */
function challenge(...args) {
    return Pointk1.Fn.create(num(taggedHash('BIP0340/challenge', ...args)));
}
/**
 * Schnorr public key is just `x` coordinate of Point as per BIP340.
 */
function schnorrGetPublicKey(secretKey) {
    return schnorrGetExtPubKey(secretKey).bytes; // d'=int(sk). Fail if d'=0 or d'≥n. Ret bytes(d'⋅G)
}
/**
 * Creates Schnorr signature as per BIP340. Verifies itself before returning anything.
 * auxRand is optional and is not the sole source of k generation: bad CSPRNG won't be dangerous.
 */
function schnorrSign(message, secretKey, auxRand = (0, utils_js_1.randomBytes)(32)) {
    const { Fn } = Pointk1;
    const m = (0, utils_ts_1.ensureBytes)('message', message);
    const { bytes: px, scalar: d } = schnorrGetExtPubKey(secretKey); // checks for isWithinCurveOrder
    const a = (0, utils_ts_1.ensureBytes)('auxRand', auxRand, 32); // Auxiliary random data a: a 32-byte array
    const t = Fn.toBytes(d ^ num(taggedHash('BIP0340/aux', a))); // Let t be the byte-wise xor of bytes(d) and hash/aux(a)
    const rand = taggedHash('BIP0340/nonce', t, px, m); // Let rand = hash/nonce(t || bytes(P) || m)
    // Let k' = int(rand) mod n. Fail if k' = 0. Let R = k'⋅G
    const { bytes: rx, scalar: k } = schnorrGetExtPubKey(rand);
    const e = challenge(rx, px, m); // Let e = int(hash/challenge(bytes(R) || bytes(P) || m)) mod n.
    const sig = new Uint8Array(64); // Let sig = bytes(R) || bytes((k + ed) mod n).
    sig.set(rx, 0);
    sig.set(Fn.toBytes(Fn.create(k + e * d)), 32);
    // If Verify(bytes(P), m, sig) (see below) returns failure, abort
    if (!schnorrVerify(sig, m, px))
        throw new Error('sign: Invalid signature produced');
    return sig;
}
/**
 * Verifies Schnorr signature.
 * Will swallow errors & return false except for initial type validation of arguments.
 */
function schnorrVerify(signature, message, publicKey) {
    const { Fn, BASE } = Pointk1;
    const sig = (0, utils_ts_1.ensureBytes)('signature', signature, 64);
    const m = (0, utils_ts_1.ensureBytes)('message', message);
    const pub = (0, utils_ts_1.ensureBytes)('publicKey', publicKey, 32);
    try {
        const P = lift_x(num(pub)); // P = lift_x(int(pk)); fail if that fails
        const r = num(sig.subarray(0, 32)); // Let r = int(sig[0:32]); fail if r ≥ p.
        if (!(0, utils_ts_1.inRange)(r, _1n, secp256k1_CURVE.p))
            return false;
        const s = num(sig.subarray(32, 64)); // Let s = int(sig[32:64]); fail if s ≥ n.
        if (!(0, utils_ts_1.inRange)(s, _1n, secp256k1_CURVE.n))
            return false;
        // int(challenge(bytes(r)||bytes(P)||m))%n
        const e = challenge(Fn.toBytes(r), pointToBytes(P), m);
        // R = s⋅G - e⋅P, where -eP == (n-e)P
        const R = BASE.multiplyUnsafe(s).add(P.multiplyUnsafe(Fn.neg(e)));
        const { x, y } = R.toAffine();
        // Fail if is_infinite(R) / not has_even_y(R) / x(R) ≠ r.
        if (R.is0() || !hasEven(y) || x !== r)
            return false;
        return true;
    }
    catch (error) {
        return false;
    }
}
/**
 * Schnorr signatures over secp256k1.
 * https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki
 * @example
 * ```js
 * import { schnorr } from '@noble/curves/secp256k1';
 * const { secretKey, publicKey } = schnorr.keygen();
 * // const publicKey = schnorr.getPublicKey(secretKey);
 * const msg = new TextEncoder().encode('hello');
 * const sig = schnorr.sign(msg, secretKey);
 * const isValid = schnorr.verify(sig, msg, publicKey);
 * ```
 */
exports.schnorr = (() => {
    const size = 32;
    const seedLength = 48;
    const randomSecretKey = (seed = (0, utils_js_1.randomBytes)(seedLength)) => {
        return (0, modular_ts_1.mapHashToField)(seed, secp256k1_CURVE.n);
    };
    // TODO: remove
    exports.secp256k1.utils.randomSecretKey;
    function keygen(seed) {
        const secretKey = randomSecretKey(seed);
        return { secretKey, publicKey: schnorrGetPublicKey(secretKey) };
    }
    return {
        keygen,
        getPublicKey: schnorrGetPublicKey,
        sign: schnorrSign,
        verify: schnorrVerify,
        Point: Pointk1,
        utils: {
            randomSecretKey: randomSecretKey,
            randomPrivateKey: randomSecretKey,
            taggedHash,
            // TODO: remove
            lift_x,
            pointToBytes,
            numberToBytesBE: utils_ts_1.numberToBytesBE,
            bytesToNumberBE: utils_ts_1.bytesToNumberBE,
            mod: modular_ts_1.mod,
        },
        lengths: {
            secretKey: size,
            publicKey: size,
            publicKeyHasPrefix: false,
            signature: size * 2,
            seed: seedLength,
        },
    };
})();
const isoMap = /* @__PURE__ */ (() => (0, hash_to_curve_ts_1.isogenyMap)(Fpk1, [
    // xNum
    [
        '0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7',
        '0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581',
        '0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262',
        '0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c',
    ],
    // xDen
    [
        '0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b',
        '0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14',
        '0x0000000000000000000000000000000000000000000000000000000000000001', // LAST 1
    ],
    // yNum
    [
        '0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c',
        '0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3',
        '0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931',
        '0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84',
    ],
    // yDen
    [
        '0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b',
        '0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573',
        '0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f',
        '0x0000000000000000000000000000000000000000000000000000000000000001', // LAST 1
    ],
].map((i) => i.map((j) => BigInt(j)))))();
const mapSWU = /* @__PURE__ */ (() => (0, weierstrass_ts_1.mapToCurveSimpleSWU)(Fpk1, {
    A: BigInt('0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533'),
    B: BigInt('1771'),
    Z: Fpk1.create(BigInt('-11')),
}))();
/** Hashing / encoding to secp256k1 points / field. RFC 9380 methods. */
exports.secp256k1_hasher = (() => (0, hash_to_curve_ts_1.createHasher)(exports.secp256k1.Point, (scalars) => {
    const { x, y } = mapSWU(Fpk1.create(scalars[0]));
    return isoMap(x, y);
}, {
    DST: 'secp256k1_XMD:SHA-256_SSWU_RO_',
    encodeDST: 'secp256k1_XMD:SHA-256_SSWU_NU_',
    p: Fpk1.ORDER,
    m: 1,
    k: 128,
    expand: 'xmd',
    hash: sha2_js_1.sha256,
}))();
/** @deprecated use `import { secp256k1_hasher } from '@noble/curves/secp256k1.js';` */
exports.hashToCurve = (() => exports.secp256k1_hasher.hashToCurve)();
/** @deprecated use `import { secp256k1_hasher } from '@noble/curves/secp256k1.js';` */
exports.encodeToCurve = (() => exports.secp256k1_hasher.encodeToCurve)();
//# sourceMappingURL=secp256k1.js.map

/***/ }),

/***/ "./node_modules/viem/node_modules/@noble/curves/utils.js":
/*!***************************************************************!*\
  !*** ./node_modules/viem/node_modules/@noble/curves/utils.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.notImplemented = exports.bitMask = exports.utf8ToBytes = exports.randomBytes = exports.isBytes = exports.hexToBytes = exports.concatBytes = exports.bytesToUtf8 = exports.bytesToHex = exports.anumber = exports.abytes = void 0;
exports.abool = abool;
exports._abool2 = _abool2;
exports._abytes2 = _abytes2;
exports.numberToHexUnpadded = numberToHexUnpadded;
exports.hexToNumber = hexToNumber;
exports.bytesToNumberBE = bytesToNumberBE;
exports.bytesToNumberLE = bytesToNumberLE;
exports.numberToBytesBE = numberToBytesBE;
exports.numberToBytesLE = numberToBytesLE;
exports.numberToVarBytesBE = numberToVarBytesBE;
exports.ensureBytes = ensureBytes;
exports.equalBytes = equalBytes;
exports.copyBytes = copyBytes;
exports.asciiToBytes = asciiToBytes;
exports.inRange = inRange;
exports.aInRange = aInRange;
exports.bitLen = bitLen;
exports.bitGet = bitGet;
exports.bitSet = bitSet;
exports.createHmacDrbg = createHmacDrbg;
exports.validateObject = validateObject;
exports.isHash = isHash;
exports._validateObject = _validateObject;
exports.memoized = memoized;
/**
 * Hex, bytes and number utilities.
 * @module
 */
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const utils_js_1 = __webpack_require__(/*! @noble/hashes/utils.js */ "./node_modules/@noble/hashes/utils.js");
var utils_js_2 = __webpack_require__(/*! @noble/hashes/utils.js */ "./node_modules/@noble/hashes/utils.js");
Object.defineProperty(exports, "abytes", ({ enumerable: true, get: function () { return utils_js_2.abytes; } }));
Object.defineProperty(exports, "anumber", ({ enumerable: true, get: function () { return utils_js_2.anumber; } }));
Object.defineProperty(exports, "bytesToHex", ({ enumerable: true, get: function () { return utils_js_2.bytesToHex; } }));
Object.defineProperty(exports, "bytesToUtf8", ({ enumerable: true, get: function () { return utils_js_2.bytesToUtf8; } }));
Object.defineProperty(exports, "concatBytes", ({ enumerable: true, get: function () { return utils_js_2.concatBytes; } }));
Object.defineProperty(exports, "hexToBytes", ({ enumerable: true, get: function () { return utils_js_2.hexToBytes; } }));
Object.defineProperty(exports, "isBytes", ({ enumerable: true, get: function () { return utils_js_2.isBytes; } }));
Object.defineProperty(exports, "randomBytes", ({ enumerable: true, get: function () { return utils_js_2.randomBytes; } }));
Object.defineProperty(exports, "utf8ToBytes", ({ enumerable: true, get: function () { return utils_js_2.utf8ToBytes; } }));
const _0n = /* @__PURE__ */ BigInt(0);
const _1n = /* @__PURE__ */ BigInt(1);
function abool(title, value) {
    if (typeof value !== 'boolean')
        throw new Error(title + ' boolean expected, got ' + value);
}
// tmp name until v2
function _abool2(value, title = '') {
    if (typeof value !== 'boolean') {
        const prefix = title && `"${title}"`;
        throw new Error(prefix + 'expected boolean, got type=' + typeof value);
    }
    return value;
}
// tmp name until v2
/** Asserts something is Uint8Array. */
function _abytes2(value, length, title = '') {
    const bytes = (0, utils_js_1.isBytes)(value);
    const len = value?.length;
    const needsLen = length !== undefined;
    if (!bytes || (needsLen && len !== length)) {
        const prefix = title && `"${title}" `;
        const ofLen = needsLen ? ` of length ${length}` : '';
        const got = bytes ? `length=${len}` : `type=${typeof value}`;
        throw new Error(prefix + 'expected Uint8Array' + ofLen + ', got ' + got);
    }
    return value;
}
// Used in weierstrass, der
function numberToHexUnpadded(num) {
    const hex = num.toString(16);
    return hex.length & 1 ? '0' + hex : hex;
}
function hexToNumber(hex) {
    if (typeof hex !== 'string')
        throw new Error('hex string expected, got ' + typeof hex);
    return hex === '' ? _0n : BigInt('0x' + hex); // Big Endian
}
// BE: Big Endian, LE: Little Endian
function bytesToNumberBE(bytes) {
    return hexToNumber((0, utils_js_1.bytesToHex)(bytes));
}
function bytesToNumberLE(bytes) {
    (0, utils_js_1.abytes)(bytes);
    return hexToNumber((0, utils_js_1.bytesToHex)(Uint8Array.from(bytes).reverse()));
}
function numberToBytesBE(n, len) {
    return (0, utils_js_1.hexToBytes)(n.toString(16).padStart(len * 2, '0'));
}
function numberToBytesLE(n, len) {
    return numberToBytesBE(n, len).reverse();
}
// Unpadded, rarely used
function numberToVarBytesBE(n) {
    return (0, utils_js_1.hexToBytes)(numberToHexUnpadded(n));
}
/**
 * Takes hex string or Uint8Array, converts to Uint8Array.
 * Validates output length.
 * Will throw error for other types.
 * @param title descriptive title for an error e.g. 'secret key'
 * @param hex hex string or Uint8Array
 * @param expectedLength optional, will compare to result array's length
 * @returns
 */
function ensureBytes(title, hex, expectedLength) {
    let res;
    if (typeof hex === 'string') {
        try {
            res = (0, utils_js_1.hexToBytes)(hex);
        }
        catch (e) {
            throw new Error(title + ' must be hex string or Uint8Array, cause: ' + e);
        }
    }
    else if ((0, utils_js_1.isBytes)(hex)) {
        // Uint8Array.from() instead of hash.slice() because node.js Buffer
        // is instance of Uint8Array, and its slice() creates **mutable** copy
        res = Uint8Array.from(hex);
    }
    else {
        throw new Error(title + ' must be hex string or Uint8Array');
    }
    const len = res.length;
    if (typeof expectedLength === 'number' && len !== expectedLength)
        throw new Error(title + ' of length ' + expectedLength + ' expected, got ' + len);
    return res;
}
// Compares 2 u8a-s in kinda constant time
function equalBytes(a, b) {
    if (a.length !== b.length)
        return false;
    let diff = 0;
    for (let i = 0; i < a.length; i++)
        diff |= a[i] ^ b[i];
    return diff === 0;
}
/**
 * Copies Uint8Array. We can't use u8a.slice(), because u8a can be Buffer,
 * and Buffer#slice creates mutable copy. Never use Buffers!
 */
function copyBytes(bytes) {
    return Uint8Array.from(bytes);
}
/**
 * Decodes 7-bit ASCII string to Uint8Array, throws on non-ascii symbols
 * Should be safe to use for things expected to be ASCII.
 * Returns exact same result as utf8ToBytes for ASCII or throws.
 */
function asciiToBytes(ascii) {
    return Uint8Array.from(ascii, (c, i) => {
        const charCode = c.charCodeAt(0);
        if (c.length !== 1 || charCode > 127) {
            throw new Error(`string contains non-ASCII character "${ascii[i]}" with code ${charCode} at position ${i}`);
        }
        return charCode;
    });
}
/**
 * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])
 */
// export const utf8ToBytes: typeof utf8ToBytes_ = utf8ToBytes_;
/**
 * Converts bytes to string using UTF8 encoding.
 * @example bytesToUtf8(Uint8Array.from([97, 98, 99])) // 'abc'
 */
// export const bytesToUtf8: typeof bytesToUtf8_ = bytesToUtf8_;
// Is positive bigint
const isPosBig = (n) => typeof n === 'bigint' && _0n <= n;
function inRange(n, min, max) {
    return isPosBig(n) && isPosBig(min) && isPosBig(max) && min <= n && n < max;
}
/**
 * Asserts min <= n < max. NOTE: It's < max and not <= max.
 * @example
 * aInRange('x', x, 1n, 256n); // would assume x is in (1n..255n)
 */
function aInRange(title, n, min, max) {
    // Why min <= n < max and not a (min < n < max) OR b (min <= n <= max)?
    // consider P=256n, min=0n, max=P
    // - a for min=0 would require -1:          `inRange('x', x, -1n, P)`
    // - b would commonly require subtraction:  `inRange('x', x, 0n, P - 1n)`
    // - our way is the cleanest:               `inRange('x', x, 0n, P)
    if (!inRange(n, min, max))
        throw new Error('expected valid ' + title + ': ' + min + ' <= n < ' + max + ', got ' + n);
}
// Bit operations
/**
 * Calculates amount of bits in a bigint.
 * Same as `n.toString(2).length`
 * TODO: merge with nLength in modular
 */
function bitLen(n) {
    let len;
    for (len = 0; n > _0n; n >>= _1n, len += 1)
        ;
    return len;
}
/**
 * Gets single bit at position.
 * NOTE: first bit position is 0 (same as arrays)
 * Same as `!!+Array.from(n.toString(2)).reverse()[pos]`
 */
function bitGet(n, pos) {
    return (n >> BigInt(pos)) & _1n;
}
/**
 * Sets single bit at position.
 */
function bitSet(n, pos, value) {
    return n | ((value ? _1n : _0n) << BigInt(pos));
}
/**
 * Calculate mask for N bits. Not using ** operator with bigints because of old engines.
 * Same as BigInt(`0b${Array(i).fill('1').join('')}`)
 */
const bitMask = (n) => (_1n << BigInt(n)) - _1n;
exports.bitMask = bitMask;
/**
 * Minimal HMAC-DRBG from NIST 800-90 for RFC6979 sigs.
 * @returns function that will call DRBG until 2nd arg returns something meaningful
 * @example
 *   const drbg = createHmacDRBG<Key>(32, 32, hmac);
 *   drbg(seed, bytesToKey); // bytesToKey must return Key or undefined
 */
function createHmacDrbg(hashLen, qByteLen, hmacFn) {
    if (typeof hashLen !== 'number' || hashLen < 2)
        throw new Error('hashLen must be a number');
    if (typeof qByteLen !== 'number' || qByteLen < 2)
        throw new Error('qByteLen must be a number');
    if (typeof hmacFn !== 'function')
        throw new Error('hmacFn must be a function');
    // Step B, Step C: set hashLen to 8*ceil(hlen/8)
    const u8n = (len) => new Uint8Array(len); // creates Uint8Array
    const u8of = (byte) => Uint8Array.of(byte); // another shortcut
    let v = u8n(hashLen); // Minimal non-full-spec HMAC-DRBG from NIST 800-90 for RFC6979 sigs.
    let k = u8n(hashLen); // Steps B and C of RFC6979 3.2: set hashLen, in our case always same
    let i = 0; // Iterations counter, will throw when over 1000
    const reset = () => {
        v.fill(1);
        k.fill(0);
        i = 0;
    };
    const h = (...b) => hmacFn(k, v, ...b); // hmac(k)(v, ...values)
    const reseed = (seed = u8n(0)) => {
        // HMAC-DRBG reseed() function. Steps D-G
        k = h(u8of(0x00), seed); // k = hmac(k || v || 0x00 || seed)
        v = h(); // v = hmac(k || v)
        if (seed.length === 0)
            return;
        k = h(u8of(0x01), seed); // k = hmac(k || v || 0x01 || seed)
        v = h(); // v = hmac(k || v)
    };
    const gen = () => {
        // HMAC-DRBG generate() function
        if (i++ >= 1000)
            throw new Error('drbg: tried 1000 values');
        let len = 0;
        const out = [];
        while (len < qByteLen) {
            v = h();
            const sl = v.slice();
            out.push(sl);
            len += v.length;
        }
        return (0, utils_js_1.concatBytes)(...out);
    };
    const genUntil = (seed, pred) => {
        reset();
        reseed(seed); // Steps D-G
        let res = undefined; // Step H: grind until k is in [1..n-1]
        while (!(res = pred(gen())))
            reseed();
        reset();
        return res;
    };
    return genUntil;
}
// Validating curves and fields
const validatorFns = {
    bigint: (val) => typeof val === 'bigint',
    function: (val) => typeof val === 'function',
    boolean: (val) => typeof val === 'boolean',
    string: (val) => typeof val === 'string',
    stringOrUint8Array: (val) => typeof val === 'string' || (0, utils_js_1.isBytes)(val),
    isSafeInteger: (val) => Number.isSafeInteger(val),
    array: (val) => Array.isArray(val),
    field: (val, object) => object.Fp.isValid(val),
    hash: (val) => typeof val === 'function' && Number.isSafeInteger(val.outputLen),
};
// type Record<K extends string | number | symbol, T> = { [P in K]: T; }
function validateObject(object, validators, optValidators = {}) {
    const checkField = (fieldName, type, isOptional) => {
        const checkVal = validatorFns[type];
        if (typeof checkVal !== 'function')
            throw new Error('invalid validator function');
        const val = object[fieldName];
        if (isOptional && val === undefined)
            return;
        if (!checkVal(val, object)) {
            throw new Error('param ' + String(fieldName) + ' is invalid. Expected ' + type + ', got ' + val);
        }
    };
    for (const [fieldName, type] of Object.entries(validators))
        checkField(fieldName, type, false);
    for (const [fieldName, type] of Object.entries(optValidators))
        checkField(fieldName, type, true);
    return object;
}
// validate type tests
// const o: { a: number; b: number; c: number } = { a: 1, b: 5, c: 6 };
// const z0 = validateObject(o, { a: 'isSafeInteger' }, { c: 'bigint' }); // Ok!
// // Should fail type-check
// const z1 = validateObject(o, { a: 'tmp' }, { c: 'zz' });
// const z2 = validateObject(o, { a: 'isSafeInteger' }, { c: 'zz' });
// const z3 = validateObject(o, { test: 'boolean', z: 'bug' });
// const z4 = validateObject(o, { a: 'boolean', z: 'bug' });
function isHash(val) {
    return typeof val === 'function' && Number.isSafeInteger(val.outputLen);
}
function _validateObject(object, fields, optFields = {}) {
    if (!object || typeof object !== 'object')
        throw new Error('expected valid options object');
    function checkField(fieldName, expectedType, isOpt) {
        const val = object[fieldName];
        if (isOpt && val === undefined)
            return;
        const current = typeof val;
        if (current !== expectedType || val === null)
            throw new Error(`param "${fieldName}" is invalid: expected ${expectedType}, got ${current}`);
    }
    Object.entries(fields).forEach(([k, v]) => checkField(k, v, false));
    Object.entries(optFields).forEach(([k, v]) => checkField(k, v, true));
}
/**
 * throws not implemented error
 */
const notImplemented = () => {
    throw new Error('not implemented');
};
exports.notImplemented = notImplemented;
/**
 * Memoizes (caches) computation result.
 * Uses WeakMap: the value is going auto-cleaned by GC after last reference is removed.
 */
function memoized(fn) {
    const map = new WeakMap();
    return (arg, ...args) => {
        const val = map.get(arg);
        if (val !== undefined)
            return val;
        const computed = fn(arg, ...args);
        map.set(arg, computed);
        return computed;
    };
}
//# sourceMappingURL=utils.js.map

/***/ })

}]);